;; nyacc/lang/c99/c99-06.test		-*- scheme -*-
;;
;; Copyright (C) 2017,2019,2020 Matthew R. Wette
;; 
;; Copying and distribution of this file, with or without modification,
;; are permitted in any medium without royalty provided the copyright
;; notice and this notice are preserved.  This file is offered as-is,
;; without any warranty.

;; test C99 munge utilities

(define-module (c99-06)
  #:use-module (nyacc lang c99 parser)
  #:use-module (nyacc lang c99 util)
  #:use-module (nyacc lang c99 munge)
  #:use-module (nyacc lang c99 pprint)
  #:use-module (nyacc lang c99 cxeval)
  #:use-module (nyacc lang sx-util)
  #:use-module ((sxml xpath) #:select (sxpath))
  #:use-module (test-suite lib))
(use-modules (ice-9 pretty-print))
(define pp pretty-print)
(define (sf fmt . args) (apply simple-format #t fmt args))

(define (fold p s l)
  (let loop ((s s) (l l))
    (if (null? l) s (loop (p (car l) s) (cdr l)))))

(define incs '("exam.d"))

(define (parse-string str)
  (with-input-from-string str
    (lambda ()
      (parse-c99 #:inc-dirs incs #:mode 'decl #:inc-help c99-std-help))))

(define (parse-file file)
  (with-input-from-file file
    (lambda ()
      (parse-c99 #:inc-dirs incs #:mode 'decl))))

(define (c99pp sx)
  (with-output-to-string
    (lambda ()
      (pretty-print-c99 sx))))

(define (test-expand-typerefs code indx xcode)
  (let* ((tree (parse-string code))
	 (udict (c99-trans-unit->udict tree))
	 (decl (and=> ((sxpath `((decl ,indx))) tree) car))
	 (xdecl (expand-typerefs decl udict))
	 (ncode (c99pp xdecl)))
    ;;(newline) (display code) (display ncode)
    (string=? ncode xcode)))
      
;; parser test
(with-test-prefix "nyacc/c99-06, munging"

  (pass-if "expand-typerefs w/ function declarator"
    (test-expand-typerefs
     (string-append
      "typedef int *foo_t;\n"
      "typedef double hmm_t[3];\n"
      "int bar(foo_t (*baz)(hmm_t y));\n")
     3
     ;; =>
     "int bar(int *(*baz)(double y[3]));\n"))

  (pass-if "expand-typerefs w/ enum-ref"
    (test-expand-typerefs
     "enum foo x;\n"
     1
     ;; =>
     "int x;\n"))

  (pass-if "expand-typerefs w/ enum typedef"
    (test-expand-typerefs
     "typedef enum _foo foo_t;\nfoo_t x;\n"
     2
     ;; =>
     "int x;\n"))

  (pass-if "expand struct-ref w/ struct-def"
    (test-expand-typerefs
     (string-append
      "struct foo { int a; double b; };\n"
      "struct foo x;\n")
     2
     "struct foo {\n  int a;\n  double b;\n} x;\n"))

  (pass-if "knarly expand-typeref case"
    (test-expand-typerefs
     (string-append
      "typedef int *bla_t[2];\n"
      "bla_t foo(bla_t (*)(bla_t));\n")
     2
     "int *foo(int *(*)(int)[2])[2];\n"))

  (pass-if "misc expand-typerefs cases"
    (fold
     (lambda (pair status)
       (let* ((ltree (parse-string (car pair)))
	      (rtree (parse-string (cdr pair)))
	      (ldict (c99-trans-unit->udict ltree))
	      (ldecl (assoc-ref ldict "bar"))
	      (rdict (c99-trans-unit->udict rtree))
	      (rdecl (assoc-ref rdict "bar"))
	      (xdecl (expand-typerefs ldecl ldict)))
	 (and status (equal? rdecl xdecl))))
     #t
     '(("typedef int foo; foo bar;" . "int bar;")
       ("typedef int *foo; foo bar;" . "int *bar;")
       ("typedef int *foo; foo *bar;" . "int **bar;")
       ("typedef int *foo; int bar(foo*);" . "int bar(int **);")
       ("typedef int *foo[2]; foo bar;" . "int *bar[2];")
       ("typedef int *foo[2]; foo *bar;" . "int *(*bar)[2];")
       ("typedef int *foo[2]; int (*bar)(foo*x);" . "int (*bar)(int *(*x)[2]);")
       ("typedef int *foo[2]; int (*bar)(foo*);" . "int (*bar)(int *(*)[2]);")
       ("typedef const int foo_t; const foo_t x;" . "const int x;")
       )))

  (pass-if "udecl->mdecl/concrete"
    (fold
     (lambda (pair status)
       (let* ((tree (parse-string (car pair)))
	      (udict (c99-trans-unit->udict tree))
	      (udecl (assoc-ref udict "foo"))
	      (mdecl (udecl->mdecl udecl)))
	 (and status (equal? mdecl (cdr pair)))))
     #t
     '(("int foo;" . ("foo" (fixed-type "int")))
       ("int **foo;" . ("foo" (pointer-to) (pointer-to) (fixed-type "int")))
       ("int foo();" . ("foo" (function-returning (param-list))
			(fixed-type "int"))))))

  (pass-if "udecl->mdecl/abstract"
    (fold
     (lambda (spec status)
       (let* ((namer (lambda () "@"))
	      (tree (parse-string (car spec)))
	      (udict (c99-trans-unit->udict tree))
	      (udecl (assoc-ref udict "foo"))
	      (udecl (sx-ref* udecl 2 1 2 1))
	      (mdecl (udecl->mdecl udecl #:namer namer)))
	 (and status (equal? mdecl (cdr spec)))))
     #t
     `(("int foo(int);" . ("@" (fixed-type "int")))
       ("int foo(int*);" . ("@" (pointer-to) (fixed-type "int")))
       ("int foo(int**);" . ("@" (pointer-to) (pointer-to) (fixed-type "int")))
       ("int foo(int[]);" . ("@" (array-of) (fixed-type "int")))
       ("int foo(int*[]);" . ("@" (array-of) (pointer-to) (fixed-type "int")))
       ("int foo(int(*)()[]);" . ("@" (pointer-to)  ;; ???
				  (function-returning (param-list))
				  (array-of) (fixed-type "int"))))))

  #;(pass-if "evaluate sizeof(type)"
    (fold
     (lambda (case status)
       (let* ((code (string-append (car case) " int x = sizeof(foo_t);"))
	      (tree (parse-string code))
	      (udict (c99-trans-unit->udict tree))
	      (udecl (assoc-ref udict "x"))
	      (sotex (sx-ref* udecl 2 2 1))) ; (sizeof-type (type-name ...))
	 (call-with-values
	     (lambda () (eval-sizeof-type sotex udict))
	   (lambda (size align)
	     (and status (= size (cadr case)) (= align (cddr case)))))))
     #t
     '(("typedef int foo_t;" . (4 . 4))
       ("typedef long foo_t;" . (8 . 8))
       ("typedef int foo_t[5];" . (20 . 4))
       ("typedef struct { int x; } foo_t;" . (4 . 4))
       ("typedef struct { int x,y; } foo_t;" . (8 . 4))
       ("typedef struct { int x; double y; } foo_t;" . (16 . 8))
       ("typedef struct { double x; int y; } foo_t;" . (16 . 8))
       ("typedef struct { int x,y; double z; } foo_t;" . (16 . 8))
       ("typedef struct { int x; double z; void *p; } foo_t;" . (24 . 8))
       ("typedef union { double x; int y; } foo_t;" . (8 . 8))
       ("typedef union { double x; int y[3]; } foo_t;" . (16 . 8))
       ("typedef enum { FOO=1, BAR=2 } foo_t;" . (4 . 4))
       )) #f)

  (pass-if "canize-enum-def-list"
    (let* ((code "enum { FOO = 1, }; enum { BAR = 1 + FOO };")
	   (tree (parse-string code))
	   (udict (c99-trans-unit->udict tree))
	   (ddict (c99-trans-unit->ddict tree))
	   (ddict (udict-enums->ddict udict ddict)))
      (and (string= "1" (or (assoc-ref ddict "FOO") "X"))
	   (string= "2" (or (assoc-ref ddict "BAR") "X")))))

  )

;; --- last line ---
