;; auto-generated by ffi-help.scm

(define-module (ffi libgit2)
  #:use-module (system ffi-help-rt)
  #:use-module ((system foreign) #:prefix ffi:)
  #:use-module (bytestructures guile)
  )
(dynamic-link "libgit2")
(define void intptr_t)
(define echo-decls #f)

;; extern void git_libgit2_version(int *major, int *minor, int *rev);
(define ~git_libgit2_version #f)
(define (git_libgit2_version major minor rev)
  (unless
    ~git_libgit2_version
    (set! ~git_libgit2_version
      (fh-link-proc
        "git_libgit2_version"
        ffi:void
        (list '* '* '*))))
  (let ((~major (unwrap~pointer major))
        (~minor (unwrap~pointer minor))
        (~rev (unwrap~pointer rev)))
    (~git_libgit2_version ~major ~minor ~rev)))
(export git_libgit2_version)

;; typedef enum {
;;   GIT_FEATURE_THREADS = 1<<0,
;;   GIT_FEATURE_HTTPS = 1<<1,
;;   GIT_FEATURE_SSH = 1<<2,
;;   GIT_FEATURE_NSEC = 1<<3,
;; } git_feature_t;
(define-fh-enum git_feature_t
  '((GIT_FEATURE_THREADS . 1)
    (GIT_FEATURE_HTTPS . 2)
    (GIT_FEATURE_SSH . 4)
    (GIT_FEATURE_NSEC . 8))
  )

;; extern int git_libgit2_features(void);
(define ~git_libgit2_features #f)
(define (git_libgit2_features)
  (unless
    ~git_libgit2_features
    (set! ~git_libgit2_features
      (fh-link-proc
        "git_libgit2_features"
        ffi:int
        (list))))
  (let () (~git_libgit2_features)))
(export git_libgit2_features)

;; typedef enum {
;;   GIT_OPT_GET_MWINDOW_SIZE,
;;   GIT_OPT_SET_MWINDOW_SIZE,
;;   GIT_OPT_GET_MWINDOW_MAPPED_LIMIT,
;;   GIT_OPT_SET_MWINDOW_MAPPED_LIMIT,
;;   GIT_OPT_GET_SEARCH_PATH,
;;   GIT_OPT_SET_SEARCH_PATH,
;;   GIT_OPT_SET_CACHE_OBJECT_LIMIT,
;;   GIT_OPT_SET_CACHE_MAX_SIZE,
;;   GIT_OPT_ENABLE_CACHING,
;;   GIT_OPT_GET_CACHED_MEMORY,
;;   GIT_OPT_GET_TEMPLATE_PATH,
;;   GIT_OPT_SET_TEMPLATE_PATH,
;;   GIT_OPT_SET_SSL_CERT_LOCATIONS,
;;   GIT_OPT_SET_USER_AGENT,
;;   GIT_OPT_ENABLE_STRICT_OBJECT_CREATION,
;;   GIT_OPT_ENABLE_STRICT_SYMBOLIC_REF_CREATION,
;;   GIT_OPT_SET_SSL_CIPHERS,
;;   GIT_OPT_GET_USER_AGENT,
;;   GIT_OPT_ENABLE_OFS_DELTA,
;;   GIT_OPT_ENABLE_FSYNC_GITDIR,
;;   GIT_OPT_GET_WINDOWS_SHAREMODE,
;;   GIT_OPT_SET_WINDOWS_SHAREMODE,
;;   GIT_OPT_ENABLE_STRICT_HASH_VERIFICATION,
;; } git_libgit2_opt_t;
(define-fh-enum git_libgit2_opt_t
  '((GIT_OPT_GET_MWINDOW_SIZE . 0)
    (GIT_OPT_SET_MWINDOW_SIZE . 1)
    (GIT_OPT_GET_MWINDOW_MAPPED_LIMIT . 2)
    (GIT_OPT_SET_MWINDOW_MAPPED_LIMIT . 3)
    (GIT_OPT_GET_SEARCH_PATH . 4)
    (GIT_OPT_SET_SEARCH_PATH . 5)
    (GIT_OPT_SET_CACHE_OBJECT_LIMIT . 6)
    (GIT_OPT_SET_CACHE_MAX_SIZE . 7)
    (GIT_OPT_ENABLE_CACHING . 8)
    (GIT_OPT_GET_CACHED_MEMORY . 9)
    (GIT_OPT_GET_TEMPLATE_PATH . 10)
    (GIT_OPT_SET_TEMPLATE_PATH . 11)
    (GIT_OPT_SET_SSL_CERT_LOCATIONS . 12)
    (GIT_OPT_SET_USER_AGENT . 13)
    (GIT_OPT_ENABLE_STRICT_OBJECT_CREATION . 14)
    (GIT_OPT_ENABLE_STRICT_SYMBOLIC_REF_CREATION
      .
      15)
    (GIT_OPT_SET_SSL_CIPHERS . 16)
    (GIT_OPT_GET_USER_AGENT . 17)
    (GIT_OPT_ENABLE_OFS_DELTA . 18)
    (GIT_OPT_ENABLE_FSYNC_GITDIR . 19)
    (GIT_OPT_GET_WINDOWS_SHAREMODE . 20)
    (GIT_OPT_SET_WINDOWS_SHAREMODE . 21)
    (GIT_OPT_ENABLE_STRICT_HASH_VERIFICATION . 22))
  )

;; extern int git_libgit2_opts(int option, ...);
;; ... failed.

;; typedef int64_t git_off_t;
(define wrap-git_off_t identity)
(define unwrap-git_off_t unwrap~fixed) ;; FIX ME
(define git_off_t-desc int32)
;;(export wrap-git_off_t unwrap-git_off_t git_off_t-desc

;; typedef int64_t git_time_t;
(define wrap-git_time_t identity)
(define unwrap-git_time_t unwrap~fixed) ;; FIX ME
(define git_time_t-desc int32)
;;(export wrap-git_time_t unwrap-git_time_t git_time_t-desc

;; typedef enum {
;;   GIT_OBJ_ANY = -2,
;;   GIT_OBJ_BAD = -1,
;;   GIT_OBJ__EXT1 = 0,
;;   GIT_OBJ_COMMIT = 1,
;;   GIT_OBJ_TREE = 2,
;;   GIT_OBJ_BLOB = 3,
;;   GIT_OBJ_TAG = 4,
;;   GIT_OBJ__EXT2 = 5,
;;   GIT_OBJ_OFS_DELTA = 6,
;;   GIT_OBJ_REF_DELTA = 7,
;; } git_otype;
(define-fh-enum git_otype
  '((GIT_OBJ_ANY . -2)
    (GIT_OBJ_BAD . -1)
    (GIT_OBJ__EXT1 . 0)
    (GIT_OBJ_COMMIT . 1)
    (GIT_OBJ_TREE . 2)
    (GIT_OBJ_BLOB . 3)
    (GIT_OBJ_TAG . 4)
    (GIT_OBJ__EXT2 . 5)
    (GIT_OBJ_OFS_DELTA . 6)
    (GIT_OBJ_REF_DELTA . 7))
  )

;; typedef struct git_odb git_odb;
(define git_odb-desc void)
(export git_odb-desc)
(define git_odb*-desc (bs:pointer git_odb-desc))
(export git_odb*-desc)
(define-fh-pointer-type git_odb* git_odb*-desc)

;; typedef struct git_odb_backend git_odb_backend;
(define git_odb_backend-desc void)
(export git_odb_backend-desc)
(define git_odb_backend*-desc (bs:pointer git_odb_backend-desc))
(export git_odb_backend*-desc)
(define-fh-pointer-type git_odb_backend* git_odb_backend*-desc)

;; typedef struct git_odb_object git_odb_object;
(define git_odb_object-desc void)
(export git_odb_object-desc)
(define git_odb_object*-desc (bs:pointer git_odb_object-desc))
(export git_odb_object*-desc)
(define-fh-pointer-type git_odb_object* git_odb_object*-desc)

;; typedef struct git_odb_stream git_odb_stream;
(define git_odb_stream-desc void)
(export git_odb_stream-desc)
(define git_odb_stream*-desc (bs:pointer (delay git_odb_stream-desc)))
(export git_odb_stream*-desc)
(define-fh-pointer-type git_odb_stream* git_odb_stream*-desc)

;; typedef struct git_odb_writepack git_odb_writepack;
(define git_odb_writepack-desc void)
(export git_odb_writepack-desc)
(define git_odb_writepack*-desc (bs:pointer (delay git_odb_writepack-desc)))
(export git_odb_writepack*-desc)
(define-fh-pointer-type git_odb_writepack* git_odb_writepack*-desc)

;; typedef struct git_refdb git_refdb;
(define git_refdb-desc void)
(export git_refdb-desc)
(define git_refdb*-desc (bs:pointer git_refdb-desc))
(export git_refdb*-desc)
(define-fh-pointer-type git_refdb* git_refdb*-desc)

;; typedef struct git_refdb_backend git_refdb_backend;
(define git_refdb_backend-desc void)
(export git_refdb_backend-desc)
(define git_refdb_backend*-desc (bs:pointer git_refdb_backend-desc))
(export git_refdb_backend*-desc)
(define-fh-pointer-type git_refdb_backend* git_refdb_backend*-desc)

;; typedef struct git_repository git_repository;
(define git_repository-desc void)
(export git_repository-desc)
(define git_repository*-desc (bs:pointer git_repository-desc))
(export git_repository*-desc)
(define-fh-pointer-type git_repository* git_repository*-desc)

;; typedef struct git_worktree git_worktree;
(define git_worktree-desc void)
(export git_worktree-desc)
(define git_worktree*-desc (bs:pointer git_worktree-desc))
(export git_worktree*-desc)
(define-fh-pointer-type git_worktree* git_worktree*-desc)

;; typedef struct git_object git_object;
(define git_object-desc void)
(export git_object-desc)
(define git_object*-desc (bs:pointer git_object-desc))
(export git_object*-desc)
(define-fh-pointer-type git_object* git_object*-desc)

;; typedef struct git_revwalk git_revwalk;
(define git_revwalk-desc void)
(export git_revwalk-desc)
(define git_revwalk*-desc (bs:pointer git_revwalk-desc))
(export git_revwalk*-desc)
(define-fh-pointer-type git_revwalk* git_revwalk*-desc)

;; typedef struct git_tag git_tag;
(define git_tag-desc void)
(export git_tag-desc)
(define git_tag*-desc (bs:pointer git_tag-desc))
(export git_tag*-desc)
(define-fh-pointer-type git_tag* git_tag*-desc)

;; typedef struct git_blob git_blob;
(define git_blob-desc void)
(export git_blob-desc)
(define git_blob*-desc (bs:pointer git_blob-desc))
(export git_blob*-desc)
(define-fh-pointer-type git_blob* git_blob*-desc)

;; typedef struct git_commit git_commit;
(define git_commit-desc void)
(export git_commit-desc)
(define git_commit*-desc (bs:pointer git_commit-desc))
(export git_commit*-desc)
(define-fh-pointer-type git_commit* git_commit*-desc)

;; typedef struct git_tree_entry git_tree_entry;
(define git_tree_entry-desc void)
(export git_tree_entry-desc)
(define git_tree_entry*-desc (bs:pointer git_tree_entry-desc))
(export git_tree_entry*-desc)
(define-fh-pointer-type git_tree_entry* git_tree_entry*-desc)

;; typedef struct git_tree git_tree;
(define git_tree-desc void)
(export git_tree-desc)
(define git_tree*-desc (bs:pointer git_tree-desc))
(export git_tree*-desc)
(define-fh-pointer-type git_tree* git_tree*-desc)

;; typedef struct git_treebuilder git_treebuilder;
(define git_treebuilder-desc void)
(export git_treebuilder-desc)
(define git_treebuilder*-desc (bs:pointer git_treebuilder-desc))
(export git_treebuilder*-desc)
(define-fh-pointer-type git_treebuilder* git_treebuilder*-desc)

;; typedef struct git_index git_index;
(define git_index-desc void)
(export git_index-desc)
(define git_index*-desc (bs:pointer git_index-desc))
(export git_index*-desc)
(define-fh-pointer-type git_index* git_index*-desc)

;; typedef struct git_index_conflict_iterator git_index_conflict_iterator;
(define git_index_conflict_iterator-desc void)
(export git_index_conflict_iterator-desc)
(define git_index_conflict_iterator*-desc (bs:pointer git_index_conflict_iterator-desc))
(export git_index_conflict_iterator*-desc)
(define-fh-pointer-type git_index_conflict_iterator* git_index_conflict_iterator*-desc)

;; typedef struct git_config git_config;
(define git_config-desc void)
(export git_config-desc)
(define git_config*-desc (bs:pointer git_config-desc))
(export git_config*-desc)
(define-fh-pointer-type git_config* git_config*-desc)

;; typedef struct git_config_backend git_config_backend;
(define git_config_backend-desc void)
(export git_config_backend-desc)
(define git_config_backend*-desc (bs:pointer git_config_backend-desc))
(export git_config_backend*-desc)
(define-fh-pointer-type git_config_backend* git_config_backend*-desc)

;; typedef struct git_reflog_entry git_reflog_entry;
(define git_reflog_entry-desc void)
(export git_reflog_entry-desc)
(define git_reflog_entry*-desc (bs:pointer git_reflog_entry-desc))
(export git_reflog_entry*-desc)
(define-fh-pointer-type git_reflog_entry* git_reflog_entry*-desc)

;; typedef struct git_reflog git_reflog;
(define git_reflog-desc void)
(export git_reflog-desc)
(define git_reflog*-desc (bs:pointer git_reflog-desc))
(export git_reflog*-desc)
(define-fh-pointer-type git_reflog* git_reflog*-desc)

;; typedef struct git_note git_note;
(define git_note-desc void)
(export git_note-desc)
(define git_note*-desc (bs:pointer git_note-desc))
(export git_note*-desc)
(define-fh-pointer-type git_note* git_note*-desc)

;; typedef struct git_packbuilder git_packbuilder;
(define git_packbuilder-desc void)
(export git_packbuilder-desc)
(define git_packbuilder*-desc (bs:pointer git_packbuilder-desc))
(export git_packbuilder*-desc)
(define-fh-pointer-type git_packbuilder* git_packbuilder*-desc)

;; typedef struct git_time {
;;   git_time_t time; /**< time in seconds from epoch */
;;   int offset; /**< timezone offset, in minutes */
;; } git_time;
(define git_time-desc
  (bs:struct (list `(time ,int32) `(offset ,int))))
(export git_time-desc)
(define-fh-compound-type/p git_time git_time-desc)
(define struct-git_time git_time)

;; typedef struct git_signature {
;;   char *name; /**< full name of the author */
;;   char *email; /**< email of the author */
;;   git_time when; /**< time when the action happened */
;; } git_signature;
(define git_signature-desc
  (bs:struct
    (list `(name ,(bs:pointer int))
          `(email ,(bs:pointer int))
          `(when ,git_time-desc))))
(export git_signature-desc)
(define-fh-compound-type/p git_signature git_signature-desc)
(define struct-git_signature git_signature)

;; typedef struct git_reference git_reference;
(define git_reference-desc void)
(export git_reference-desc)
(define git_reference*-desc (bs:pointer git_reference-desc))
(export git_reference*-desc)
(define-fh-pointer-type git_reference* git_reference*-desc)

;; typedef struct git_reference_iterator git_reference_iterator;
(define git_reference_iterator-desc void)
(export git_reference_iterator-desc)
(define git_reference_iterator*-desc (bs:pointer git_reference_iterator-desc))
(export git_reference_iterator*-desc)
(define-fh-pointer-type git_reference_iterator* git_reference_iterator*-desc)

;; typedef struct git_transaction git_transaction;
(define git_transaction-desc void)
(export git_transaction-desc)
(define git_transaction*-desc (bs:pointer git_transaction-desc))
(export git_transaction*-desc)
(define-fh-pointer-type git_transaction* git_transaction*-desc)

;; typedef struct git_annotated_commit git_annotated_commit;
(define git_annotated_commit-desc void)
(export git_annotated_commit-desc)
(define git_annotated_commit*-desc (bs:pointer git_annotated_commit-desc))
(export git_annotated_commit*-desc)
(define-fh-pointer-type git_annotated_commit* git_annotated_commit*-desc)

;; typedef struct git_merge_result git_merge_result;
(define git_merge_result-desc void)
(export git_merge_result-desc)
(define git_merge_result*-desc (bs:pointer git_merge_result-desc))
(export git_merge_result*-desc)
(define-fh-pointer-type git_merge_result* git_merge_result*-desc)

;; typedef struct git_status_list git_status_list;
(define git_status_list-desc void)
(export git_status_list-desc)
(define git_status_list*-desc (bs:pointer git_status_list-desc))
(export git_status_list*-desc)
(define-fh-pointer-type git_status_list* git_status_list*-desc)

;; typedef struct git_rebase git_rebase;
(define git_rebase-desc void)
(export git_rebase-desc)
(define git_rebase*-desc (bs:pointer git_rebase-desc))
(export git_rebase*-desc)
(define-fh-pointer-type git_rebase* git_rebase*-desc)

;; typedef enum {
;;   GIT_REF_INVALID = 0,
;;   GIT_REF_OID = 1,
;;   GIT_REF_SYMBOLIC = 2,
;;   GIT_REF_LISTALL = GIT_REF_OID | GIT_REF_SYMBOLIC,
;; } git_ref_t;
(define-fh-enum git_ref_t
  '((GIT_REF_INVALID . 0)
    (GIT_REF_OID . 1)
    (GIT_REF_SYMBOLIC . 2)
    (GIT_REF_LISTALL . 3))
  )

;; typedef enum {
;;   GIT_BRANCH_LOCAL = 1,
;;   GIT_BRANCH_REMOTE = 2,
;;   GIT_BRANCH_ALL = GIT_BRANCH_LOCAL | GIT_BRANCH_REMOTE,
;; } git_branch_t;
(define-fh-enum git_branch_t
  '((GIT_BRANCH_LOCAL . 1)
    (GIT_BRANCH_REMOTE . 2)
    (GIT_BRANCH_ALL . 3))
  )

;; typedef enum {
;;   GIT_FILEMODE_UNREADABLE = 0000000,
;;   GIT_FILEMODE_TREE = 0040000,
;;   GIT_FILEMODE_BLOB = 0100644,
;;   GIT_FILEMODE_BLOB_EXECUTABLE = 0100755,
;;   GIT_FILEMODE_LINK = 0120000,
;;   GIT_FILEMODE_COMMIT = 0160000,
;; } git_filemode_t;
(define-fh-enum git_filemode_t
  '((GIT_FILEMODE_UNREADABLE . 0)
    (GIT_FILEMODE_TREE . 16384)
    (GIT_FILEMODE_BLOB . 33188)
    (GIT_FILEMODE_BLOB_EXECUTABLE . 33261)
    (GIT_FILEMODE_LINK . 40960)
    (GIT_FILEMODE_COMMIT . 57344))
  )

;; typedef struct git_refspec git_refspec;
(define git_refspec-desc void)
(export git_refspec-desc)
(define git_refspec*-desc (bs:pointer git_refspec-desc))
(export git_refspec*-desc)
(define-fh-pointer-type git_refspec* git_refspec*-desc)

;; typedef struct git_remote git_remote;
(define git_remote-desc void)
(export git_remote-desc)
(define git_remote*-desc (bs:pointer git_remote-desc))
(export git_remote*-desc)
(define-fh-pointer-type git_remote* git_remote*-desc)

;; typedef struct git_transport git_transport;
(define git_transport-desc void)
(export git_transport-desc)
(define git_transport*-desc (bs:pointer git_transport-desc))
(export git_transport*-desc)
(define-fh-pointer-type git_transport* git_transport*-desc)

;; typedef struct git_push git_push;
(define git_push-desc void)
(export git_push-desc)
(define git_push*-desc (bs:pointer git_push-desc))
(export git_push*-desc)
(define-fh-pointer-type git_push* git_push*-desc)

;; typedef struct git_remote_head git_remote_head;
(define git_remote_head-desc void)
(export git_remote_head-desc)
(define git_remote_head*-desc (bs:pointer (delay git_remote_head-desc)))
(export git_remote_head*-desc)
(define-fh-pointer-type git_remote_head* git_remote_head*-desc)

;; typedef struct git_remote_callbacks git_remote_callbacks;
(define git_remote_callbacks-desc void)
(export git_remote_callbacks-desc)
(define git_remote_callbacks*-desc (bs:pointer (delay git_remote_callbacks-desc)))
(export git_remote_callbacks*-desc)
(define-fh-pointer-type git_remote_callbacks* git_remote_callbacks*-desc)

;; typedef struct git_transfer_progress {
;;   unsigned int total_objects;
;;   unsigned int indexed_objects;
;;   unsigned int received_objects;
;;   unsigned int local_objects;
;;   unsigned int total_deltas;
;;   unsigned int indexed_deltas;
;;   size_t received_bytes;
;; } git_transfer_progress;
(define git_transfer_progress-desc
  (bs:struct
    (list `(total_objects ,unsigned-int)
          `(indexed_objects ,unsigned-int)
          `(received_objects ,unsigned-int)
          `(local_objects ,unsigned-int)
          `(total_deltas ,unsigned-int)
          `(indexed_deltas ,unsigned-int)
          `(received_bytes ,size_t))))
(export git_transfer_progress-desc)
(define-fh-compound-type/p git_transfer_progress git_transfer_progress-desc)
(define struct-git_transfer_progress git_transfer_progress)

;; typedef int (*git_transfer_progress_cb)(const git_transfer_progress *stats, 
;;     void *payload);
(define-fh-function/p git_transfer_progress_cb
  ffi:int (list (quote *) (quote *)))

;; typedef int (*git_transport_message_cb)(const char *str, int len, void *
;;     payload);
(define-fh-function/p git_transport_message_cb
  ffi:int (list (quote *) ffi:int (quote *)))

;; typedef enum git_cert_t {
;;   GIT_CERT_NONE,
;;   GIT_CERT_X509,
;;   GIT_CERT_HOSTKEY_LIBSSH2,
;;   GIT_CERT_STRARRAY,
;; } git_cert_t;
(define-fh-enum git_cert_t
  '((GIT_CERT_NONE . 0)
    (GIT_CERT_X509 . 1)
    (GIT_CERT_HOSTKEY_LIBSSH2 . 2)
    (GIT_CERT_STRARRAY . 3))
  )
(define unwrap-enum-git_cert_t unwrap-git_cert_t)
(define wrap-enum-git_cert_t wrap-git_cert_t)

;; typedef struct {
;;   /**
;;    * Type of certificate. A `GIT_CERT_` value.
;;    */
;;   git_cert_t cert_type;
;; } git_cert;
(define git_cert-desc
  (bs:struct (list `(cert_type ,int))))
(export git_cert-desc)
(define-fh-compound-type/p git_cert git_cert-desc)

;; typedef int (*git_transport_certificate_check_cb)(git_cert *cert, int valid
;;     , const char *host, void *payload);
(define-fh-function/p git_transport_certificate_check_cb
  ffi:int (list (quote *) ffi:int (quote *) (quote *)))

;; typedef struct git_submodule git_submodule;
(define git_submodule-desc void)
(export git_submodule-desc)
(define git_submodule*-desc (bs:pointer git_submodule-desc))
(export git_submodule*-desc)
(define-fh-pointer-type git_submodule* git_submodule*-desc)

;; typedef enum {
;;   GIT_SUBMODULE_UPDATE_CHECKOUT = 1,
;;   GIT_SUBMODULE_UPDATE_REBASE = 2,
;;   GIT_SUBMODULE_UPDATE_MERGE = 3,
;;   GIT_SUBMODULE_UPDATE_NONE = 4,
;;   GIT_SUBMODULE_UPDATE_DEFAULT = 0,
;; } git_submodule_update_t;
(define-fh-enum git_submodule_update_t
  '((GIT_SUBMODULE_UPDATE_CHECKOUT . 1)
    (GIT_SUBMODULE_UPDATE_REBASE . 2)
    (GIT_SUBMODULE_UPDATE_MERGE . 3)
    (GIT_SUBMODULE_UPDATE_NONE . 4)
    (GIT_SUBMODULE_UPDATE_DEFAULT . 0))
  )

;; typedef enum {
;;   GIT_SUBMODULE_IGNORE_UNSPECIFIED = -1,
;;   GIT_SUBMODULE_IGNORE_NONE = 1,
;;   GIT_SUBMODULE_IGNORE_UNTRACKED = 2,
;;   GIT_SUBMODULE_IGNORE_DIRTY = 3,
;;   GIT_SUBMODULE_IGNORE_ALL = 4,
;; } git_submodule_ignore_t;
(define-fh-enum git_submodule_ignore_t
  '((GIT_SUBMODULE_IGNORE_UNSPECIFIED . -1)
    (GIT_SUBMODULE_IGNORE_NONE . 1)
    (GIT_SUBMODULE_IGNORE_UNTRACKED . 2)
    (GIT_SUBMODULE_IGNORE_DIRTY . 3)
    (GIT_SUBMODULE_IGNORE_ALL . 4))
  )

;; typedef enum {
;;   GIT_SUBMODULE_RECURSE_NO = 0,
;;   GIT_SUBMODULE_RECURSE_YES = 1,
;;   GIT_SUBMODULE_RECURSE_ONDEMAND = 2,
;; } git_submodule_recurse_t;
(define-fh-enum git_submodule_recurse_t
  '((GIT_SUBMODULE_RECURSE_NO . 0)
    (GIT_SUBMODULE_RECURSE_YES . 1)
    (GIT_SUBMODULE_RECURSE_ONDEMAND . 2))
  )

;; typedef struct git_writestream git_writestream;
(define git_writestream-desc void)
(export git_writestream-desc)
(define git_writestream*-desc (bs:pointer (delay git_writestream-desc)))
(export git_writestream*-desc)
(define-fh-pointer-type git_writestream* git_writestream*-desc)

;; struct git_writestream {
;;   int (*write)(git_writestream *stream, const char *buffer, size_t len);
;;   int (*close)(git_writestream *stream);
;;   void (*free)(git_writestream *stream);
;; };
(define struct-git_writestream-desc
  (bs:struct
    (list `(write ,(bs:pointer void))
          `(close ,(bs:pointer void))
          `(free ,(bs:pointer void)))))
(export struct-git_writestream-desc)
(define-fh-compound-type/p struct-git_writestream struct-git_writestream-desc)
(set! git_writestream-desc struct-git_writestream-desc)
(define-fh-compound-type git_writestream git_writestream-desc)

;; typedef struct git_oid {
;;   /** raw binary formatted id */
;;   unsigned char id[20];
;; } git_oid;
(define git_oid-desc
  (bs:struct (list `(id ,(bs:vector 20 uint8)))))
(export git_oid-desc)
(define-fh-compound-type/p git_oid git_oid-desc)
(define struct-git_oid git_oid)

;; extern int git_oid_fromstr(git_oid *out, const char *str);
(define ~git_oid_fromstr #f)
(define (git_oid_fromstr out str)
  (unless
    ~git_oid_fromstr
    (set! ~git_oid_fromstr
      (fh-link-proc
        "git_oid_fromstr"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap-git_oid* out))
        (~str (unwrap~pointer str)))
    (~git_oid_fromstr ~out ~str)))
(export git_oid_fromstr)

;; extern int git_oid_fromstrp(git_oid *out, const char *str);
(define ~git_oid_fromstrp #f)
(define (git_oid_fromstrp out str)
  (unless
    ~git_oid_fromstrp
    (set! ~git_oid_fromstrp
      (fh-link-proc
        "git_oid_fromstrp"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap-git_oid* out))
        (~str (unwrap~pointer str)))
    (~git_oid_fromstrp ~out ~str)))
(export git_oid_fromstrp)

;; extern int git_oid_fromstrn(git_oid *out, const char *str, size_t length);
(define ~git_oid_fromstrn #f)
(define (git_oid_fromstrn out str length)
  (unless
    ~git_oid_fromstrn
    (set! ~git_oid_fromstrn
      (fh-link-proc
        "git_oid_fromstrn"
        ffi:int
        (list '* '* ffi:size_t))))
  (let ((~out (unwrap-git_oid* out))
        (~str (unwrap~pointer str))
        (~length (unwrap~fixed length)))
    (~git_oid_fromstrn ~out ~str ~length)))
(export git_oid_fromstrn)

;; extern void git_oid_fromraw(git_oid *out, const unsigned char *raw);
(define ~git_oid_fromraw #f)
(define (git_oid_fromraw out raw)
  (unless
    ~git_oid_fromraw
    (set! ~git_oid_fromraw
      (fh-link-proc
        "git_oid_fromraw"
        ffi:void
        (list '* '*))))
  (let ((~out (unwrap-git_oid* out))
        (~raw (unwrap~pointer raw)))
    (~git_oid_fromraw ~out ~raw)))
(export git_oid_fromraw)

;; extern void git_oid_fmt(char *out, const git_oid *id);
(define ~git_oid_fmt #f)
(define (git_oid_fmt out id)
  (unless
    ~git_oid_fmt
    (set! ~git_oid_fmt
      (fh-link-proc
        "git_oid_fmt"
        ffi:void
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~id (unwrap-git_oid* id)))
    (~git_oid_fmt ~out ~id)))
(export git_oid_fmt)

;; extern void git_oid_nfmt(char *out, size_t n, const git_oid *id);
(define ~git_oid_nfmt #f)
(define (git_oid_nfmt out n id)
  (unless
    ~git_oid_nfmt
    (set! ~git_oid_nfmt
      (fh-link-proc
        "git_oid_nfmt"
        ffi:void
        (list '* ffi:size_t '*))))
  (let ((~out (unwrap~pointer out))
        (~n (unwrap~fixed n))
        (~id (unwrap-git_oid* id)))
    (~git_oid_nfmt ~out ~n ~id)))
(export git_oid_nfmt)

;; extern void git_oid_pathfmt(char *out, const git_oid *id);
(define ~git_oid_pathfmt #f)
(define (git_oid_pathfmt out id)
  (unless
    ~git_oid_pathfmt
    (set! ~git_oid_pathfmt
      (fh-link-proc
        "git_oid_pathfmt"
        ffi:void
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~id (unwrap-git_oid* id)))
    (~git_oid_pathfmt ~out ~id)))
(export git_oid_pathfmt)

;; extern char *git_oid_tostr_s(const git_oid *oid);
(define ~git_oid_tostr_s #f)
(define (git_oid_tostr_s oid)
  (unless
    ~git_oid_tostr_s
    (set! ~git_oid_tostr_s
      (fh-link-proc "git_oid_tostr_s" '* (list '*))))
  (let ((~oid (unwrap-git_oid* oid)))
    (~git_oid_tostr_s ~oid)))
(export git_oid_tostr_s)

;; extern char *git_oid_tostr(char *out, size_t n, const git_oid *id);
(define ~git_oid_tostr #f)
(define (git_oid_tostr out n id)
  (unless
    ~git_oid_tostr
    (set! ~git_oid_tostr
      (fh-link-proc
        "git_oid_tostr"
        '*
        (list '* ffi:size_t '*))))
  (let ((~out (unwrap~pointer out))
        (~n (unwrap~fixed n))
        (~id (unwrap-git_oid* id)))
    (~git_oid_tostr ~out ~n ~id)))
(export git_oid_tostr)

;; extern void git_oid_cpy(git_oid *out, const git_oid *src);
(define ~git_oid_cpy #f)
(define (git_oid_cpy out src)
  (unless
    ~git_oid_cpy
    (set! ~git_oid_cpy
      (fh-link-proc
        "git_oid_cpy"
        ffi:void
        (list '* '*))))
  (let ((~out (unwrap-git_oid* out))
        (~src (unwrap-git_oid* src)))
    (~git_oid_cpy ~out ~src)))
(export git_oid_cpy)

;; extern int git_oid_cmp(const git_oid *a, const git_oid *b);
(define ~git_oid_cmp #f)
(define (git_oid_cmp a b)
  (unless
    ~git_oid_cmp
    (set! ~git_oid_cmp
      (fh-link-proc "git_oid_cmp" ffi:int (list '* '*))))
  (let ((~a (unwrap-git_oid* a))
        (~b (unwrap-git_oid* b)))
    (~git_oid_cmp ~a ~b)))
(export git_oid_cmp)

;; extern int git_oid_equal(const git_oid *a, const git_oid *b);
(define ~git_oid_equal #f)
(define (git_oid_equal a b)
  (unless
    ~git_oid_equal
    (set! ~git_oid_equal
      (fh-link-proc
        "git_oid_equal"
        ffi:int
        (list '* '*))))
  (let ((~a (unwrap-git_oid* a))
        (~b (unwrap-git_oid* b)))
    (~git_oid_equal ~a ~b)))
(export git_oid_equal)

;; extern int git_oid_ncmp(const git_oid *a, const git_oid *b, size_t len);
(define ~git_oid_ncmp #f)
(define (git_oid_ncmp a b len)
  (unless
    ~git_oid_ncmp
    (set! ~git_oid_ncmp
      (fh-link-proc
        "git_oid_ncmp"
        ffi:int
        (list '* '* ffi:size_t))))
  (let ((~a (unwrap-git_oid* a))
        (~b (unwrap-git_oid* b))
        (~len (unwrap~fixed len)))
    (~git_oid_ncmp ~a ~b ~len)))
(export git_oid_ncmp)

;; extern int git_oid_streq(const git_oid *id, const char *str);
(define ~git_oid_streq #f)
(define (git_oid_streq id str)
  (unless
    ~git_oid_streq
    (set! ~git_oid_streq
      (fh-link-proc
        "git_oid_streq"
        ffi:int
        (list '* '*))))
  (let ((~id (unwrap-git_oid* id))
        (~str (unwrap~pointer str)))
    (~git_oid_streq ~id ~str)))
(export git_oid_streq)

;; extern int git_oid_strcmp(const git_oid *id, const char *str);
(define ~git_oid_strcmp #f)
(define (git_oid_strcmp id str)
  (unless
    ~git_oid_strcmp
    (set! ~git_oid_strcmp
      (fh-link-proc
        "git_oid_strcmp"
        ffi:int
        (list '* '*))))
  (let ((~id (unwrap-git_oid* id))
        (~str (unwrap~pointer str)))
    (~git_oid_strcmp ~id ~str)))
(export git_oid_strcmp)

;; extern int git_oid_iszero(const git_oid *id);
(define ~git_oid_iszero #f)
(define (git_oid_iszero id)
  (unless
    ~git_oid_iszero
    (set! ~git_oid_iszero
      (fh-link-proc "git_oid_iszero" ffi:int (list '*))))
  (let ((~id (unwrap-git_oid* id)))
    (~git_oid_iszero ~id)))
(export git_oid_iszero)

;; typedef struct git_oid_shorten git_oid_shorten;
(define git_oid_shorten-desc void)
(export git_oid_shorten-desc)
(define git_oid_shorten*-desc (bs:pointer git_oid_shorten-desc))
(export git_oid_shorten*-desc)
(define-fh-pointer-type git_oid_shorten* git_oid_shorten*-desc)

;; extern git_oid_shorten *git_oid_shorten_new(size_t min_length);
(define ~git_oid_shorten_new #f)
(define (git_oid_shorten_new min_length)
  (unless
    ~git_oid_shorten_new
    (set! ~git_oid_shorten_new
      (fh-link-proc
        "git_oid_shorten_new"
        '*
        (list ffi:size_t))))
  (let ((~min_length (unwrap~fixed min_length)))
    (wrap-git_oid_shorten*
      (~git_oid_shorten_new ~min_length))))
(export git_oid_shorten_new)

;; extern int git_oid_shorten_add(git_oid_shorten *os, const char *text_id);
(define ~git_oid_shorten_add #f)
(define (git_oid_shorten_add os text_id)
  (unless
    ~git_oid_shorten_add
    (set! ~git_oid_shorten_add
      (fh-link-proc
        "git_oid_shorten_add"
        ffi:int
        (list '* '*))))
  (let ((~os (unwrap-git_oid_shorten* os))
        (~text_id (unwrap~pointer text_id)))
    (~git_oid_shorten_add ~os ~text_id)))
(export git_oid_shorten_add)

;; extern void git_oid_shorten_free(git_oid_shorten *os);
(define ~git_oid_shorten_free #f)
(define (git_oid_shorten_free os)
  (unless
    ~git_oid_shorten_free
    (set! ~git_oid_shorten_free
      (fh-link-proc
        "git_oid_shorten_free"
        ffi:void
        (list '*))))
  (let ((~os (unwrap-git_oid_shorten* os)))
    (~git_oid_shorten_free ~os)))
(export git_oid_shorten_free)

;; typedef struct {
;;   char *ptr;
;;   size_t asize, size;
;; } git_buf;
(define git_buf-desc
  (bs:struct
    (list `(ptr ,(bs:pointer int))
          `(size ,size_t)
          `(asize ,size_t))))
(export git_buf-desc)
(define-fh-compound-type/p git_buf git_buf-desc)

;; extern void git_buf_free(git_buf *buffer);
(define ~git_buf_free #f)
(define (git_buf_free buffer)
  (unless
    ~git_buf_free
    (set! ~git_buf_free
      (fh-link-proc "git_buf_free" ffi:void (list '*))))
  (let ((~buffer (unwrap-git_buf* buffer)))
    (~git_buf_free ~buffer)))
(export git_buf_free)

;; extern int git_buf_grow(git_buf *buffer, size_t target_size);
(define ~git_buf_grow #f)
(define (git_buf_grow buffer target_size)
  (unless
    ~git_buf_grow
    (set! ~git_buf_grow
      (fh-link-proc
        "git_buf_grow"
        ffi:int
        (list '* ffi:size_t))))
  (let ((~buffer (unwrap-git_buf* buffer))
        (~target_size (unwrap~fixed target_size)))
    (~git_buf_grow ~buffer ~target_size)))
(export git_buf_grow)

;; extern int git_buf_set(git_buf *buffer, const void *data, size_t datalen);
(define ~git_buf_set #f)
(define (git_buf_set buffer data datalen)
  (unless
    ~git_buf_set
    (set! ~git_buf_set
      (fh-link-proc
        "git_buf_set"
        ffi:int
        (list '* '* ffi:size_t))))
  (let ((~buffer (unwrap-git_buf* buffer))
        (~data (unwrap~pointer data))
        (~datalen (unwrap~fixed datalen)))
    (~git_buf_set ~buffer ~data ~datalen)))
(export git_buf_set)

;; extern int git_buf_is_binary(const git_buf *buf);
(define ~git_buf_is_binary #f)
(define (git_buf_is_binary buf)
  (unless
    ~git_buf_is_binary
    (set! ~git_buf_is_binary
      (fh-link-proc
        "git_buf_is_binary"
        ffi:int
        (list '*))))
  (let ((~buf (unwrap-git_buf* buf)))
    (~git_buf_is_binary ~buf)))
(export git_buf_is_binary)

;; extern int git_buf_contains_nul(const git_buf *buf);
(define ~git_buf_contains_nul #f)
(define (git_buf_contains_nul buf)
  (unless
    ~git_buf_contains_nul
    (set! ~git_buf_contains_nul
      (fh-link-proc
        "git_buf_contains_nul"
        ffi:int
        (list '*))))
  (let ((~buf (unwrap-git_buf* buf)))
    (~git_buf_contains_nul ~buf)))
(export git_buf_contains_nul)

;; extern int git_repository_open(git_repository **out, const char *path);
(define ~git_repository_open #f)
(define (git_repository_open out path)
  (unless
    ~git_repository_open
    (set! ~git_repository_open
      (fh-link-proc
        "git_repository_open"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~path (unwrap~pointer path)))
    (~git_repository_open ~out ~path)))
(export git_repository_open)

;; extern int git_repository_open_from_worktree(git_repository **out, 
;;     git_worktree *wt);
(define ~git_repository_open_from_worktree #f)
(define (git_repository_open_from_worktree out wt)
  (unless
    ~git_repository_open_from_worktree
    (set! ~git_repository_open_from_worktree
      (fh-link-proc
        "git_repository_open_from_worktree"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~wt (unwrap-git_worktree* wt)))
    (~git_repository_open_from_worktree ~out ~wt)))
(export git_repository_open_from_worktree)

;; extern int git_repository_wrap_odb(git_repository **out, git_odb *odb);
(define ~git_repository_wrap_odb #f)
(define (git_repository_wrap_odb out odb)
  (unless
    ~git_repository_wrap_odb
    (set! ~git_repository_wrap_odb
      (fh-link-proc
        "git_repository_wrap_odb"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~odb (unwrap-git_odb* odb)))
    (~git_repository_wrap_odb ~out ~odb)))
(export git_repository_wrap_odb)

;; extern int git_repository_discover(git_buf *out, const char *start_path, int
;;      across_fs, const char *ceiling_dirs);
(define ~git_repository_discover #f)
(define (git_repository_discover
         out
         start_path
         across_fs
         ceiling_dirs)
  (unless
    ~git_repository_discover
    (set! ~git_repository_discover
      (fh-link-proc
        "git_repository_discover"
        ffi:int
        (list '* '* ffi:int '*))))
  (let ((~out (unwrap-git_buf* out))
        (~start_path (unwrap~pointer start_path))
        (~across_fs (unwrap~fixed across_fs))
        (~ceiling_dirs (unwrap~pointer ceiling_dirs)))
    (~git_repository_discover
      ~out
      ~start_path
      ~across_fs
      ~ceiling_dirs)))
(export git_repository_discover)

;; typedef enum {
;;   GIT_REPOSITORY_OPEN_NO_SEARCH = 1<<0,
;;   GIT_REPOSITORY_OPEN_CROSS_FS = 1<<1,
;;   GIT_REPOSITORY_OPEN_BARE = 1<<2,
;;   GIT_REPOSITORY_OPEN_NO_DOTGIT = 1<<3,
;;   GIT_REPOSITORY_OPEN_FROM_ENV = 1<<4,
;; } git_repository_open_flag_t;
(define-fh-enum git_repository_open_flag_t
  '((GIT_REPOSITORY_OPEN_NO_SEARCH . 1)
    (GIT_REPOSITORY_OPEN_CROSS_FS . 2)
    (GIT_REPOSITORY_OPEN_BARE . 4)
    (GIT_REPOSITORY_OPEN_NO_DOTGIT . 8)
    (GIT_REPOSITORY_OPEN_FROM_ENV . 16))
  )

;; extern int git_repository_open_ext(git_repository **out, const char *path, 
;;     unsigned int flags, const char *ceiling_dirs);
(define ~git_repository_open_ext #f)
(define (git_repository_open_ext
         out
         path
         flags
         ceiling_dirs)
  (unless
    ~git_repository_open_ext
    (set! ~git_repository_open_ext
      (fh-link-proc
        "git_repository_open_ext"
        ffi:int
        (list '* '* ffi:unsigned-int '*))))
  (let ((~out (unwrap~pointer out))
        (~path (unwrap~pointer path))
        (~flags (unwrap~fixed flags))
        (~ceiling_dirs (unwrap~pointer ceiling_dirs)))
    (~git_repository_open_ext
      ~out
      ~path
      ~flags
      ~ceiling_dirs)))
(export git_repository_open_ext)

;; extern int git_repository_open_bare(git_repository **out, const char *
;;     bare_path);
(define ~git_repository_open_bare #f)
(define (git_repository_open_bare out bare_path)
  (unless
    ~git_repository_open_bare
    (set! ~git_repository_open_bare
      (fh-link-proc
        "git_repository_open_bare"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~bare_path (unwrap~pointer bare_path)))
    (~git_repository_open_bare ~out ~bare_path)))
(export git_repository_open_bare)

;; extern void git_repository_free(git_repository *repo);
(define ~git_repository_free #f)
(define (git_repository_free repo)
  (unless
    ~git_repository_free
    (set! ~git_repository_free
      (fh-link-proc
        "git_repository_free"
        ffi:void
        (list '*))))
  (let ((~repo (unwrap-git_repository* repo)))
    (~git_repository_free ~repo)))
(export git_repository_free)

;; extern int git_repository_init(git_repository **out, const char *path, 
;;     unsigned is_bare);
(define ~git_repository_init #f)
(define (git_repository_init out path is_bare)
  (unless
    ~git_repository_init
    (set! ~git_repository_init
      (fh-link-proc
        "git_repository_init"
        ffi:int
        (list '* '* ffi:unsigned-int))))
  (let ((~out (unwrap~pointer out))
        (~path (unwrap~pointer path))
        (~is_bare (unwrap~fixed is_bare)))
    (~git_repository_init ~out ~path ~is_bare)))
(export git_repository_init)

;; typedef enum {
;;   GIT_REPOSITORY_INIT_BARE = 1u<<0,
;;   GIT_REPOSITORY_INIT_NO_REINIT = 1u<<1,
;;   GIT_REPOSITORY_INIT_NO_DOTGIT_DIR = 1u<<2,
;;   GIT_REPOSITORY_INIT_MKDIR = 1u<<3,
;;   GIT_REPOSITORY_INIT_MKPATH = 1u<<4,
;;   GIT_REPOSITORY_INIT_EXTERNAL_TEMPLATE = 1u<<5,
;;   GIT_REPOSITORY_INIT_RELATIVE_GITLINK = 1u<<6,
;; } git_repository_init_flag_t;
(define-fh-enum git_repository_init_flag_t
  '((GIT_REPOSITORY_INIT_BARE . 1)
    (GIT_REPOSITORY_INIT_NO_REINIT . 2)
    (GIT_REPOSITORY_INIT_NO_DOTGIT_DIR . 4)
    (GIT_REPOSITORY_INIT_MKDIR . 8)
    (GIT_REPOSITORY_INIT_MKPATH . 16)
    (GIT_REPOSITORY_INIT_EXTERNAL_TEMPLATE . 32)
    (GIT_REPOSITORY_INIT_RELATIVE_GITLINK . 64))
  )

;; typedef enum {
;;   GIT_REPOSITORY_INIT_SHARED_UMASK = 0,
;;   GIT_REPOSITORY_INIT_SHARED_GROUP = 0002775,
;;   GIT_REPOSITORY_INIT_SHARED_ALL = 0002777,
;; } git_repository_init_mode_t;
(define-fh-enum git_repository_init_mode_t
  '((GIT_REPOSITORY_INIT_SHARED_UMASK . 0)
    (GIT_REPOSITORY_INIT_SHARED_GROUP . 1533)
    (GIT_REPOSITORY_INIT_SHARED_ALL . 1535))
  )

;; typedef struct {
;;   unsigned int version;
;;   uint32_t flags;
;;   uint32_t mode;
;;   const char *workdir_path;
;;   const char *description;
;;   const char *template_path;
;;   const char *initial_head;
;;   const char *origin_url;
;; } git_repository_init_options;
(define git_repository_init_options-desc
  (bs:struct
    (list `(version ,unsigned-int)
          `(flags ,uint64)
          `(mode ,uint64)
          `(workdir_path ,(bs:pointer int))
          `(description ,(bs:pointer int))
          `(template_path ,(bs:pointer int))
          `(initial_head ,(bs:pointer int))
          `(origin_url ,(bs:pointer int)))))
(export git_repository_init_options-desc)
(define-fh-compound-type/p git_repository_init_options git_repository_init_options-desc)

;; extern int git_repository_init_init_options(git_repository_init_options *
;;     opts, unsigned int version);
(define ~git_repository_init_init_options #f)
(define (git_repository_init_init_options opts version)
  (unless
    ~git_repository_init_init_options
    (set! ~git_repository_init_init_options
      (fh-link-proc
        "git_repository_init_init_options"
        ffi:int
        (list '* ffi:unsigned-int))))
  (let ((~opts (unwrap-git_repository_init_options* opts))
        (~version (unwrap~fixed version)))
    (~git_repository_init_init_options
      ~opts
      ~version)))
(export git_repository_init_init_options)

;; extern int git_repository_init_ext(git_repository **out, const char *
;;     repo_path, git_repository_init_options *opts);
(define ~git_repository_init_ext #f)
(define (git_repository_init_ext out repo_path opts)
  (unless
    ~git_repository_init_ext
    (set! ~git_repository_init_ext
      (fh-link-proc
        "git_repository_init_ext"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo_path (unwrap~pointer repo_path))
        (~opts (unwrap-git_repository_init_options* opts)))
    (~git_repository_init_ext ~out ~repo_path ~opts)))
(export git_repository_init_ext)

;; extern int git_repository_head(git_reference **out, git_repository *repo);
(define ~git_repository_head #f)
(define (git_repository_head out repo)
  (unless
    ~git_repository_head
    (set! ~git_repository_head
      (fh-link-proc
        "git_repository_head"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo)))
    (~git_repository_head ~out ~repo)))
(export git_repository_head)

;; extern int git_repository_head_for_worktree(git_reference **out, 
;;     git_repository *repo, const char *name);
(define ~git_repository_head_for_worktree #f)
(define (git_repository_head_for_worktree out repo name)
  (unless
    ~git_repository_head_for_worktree
    (set! ~git_repository_head_for_worktree
      (fh-link-proc
        "git_repository_head_for_worktree"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo))
        (~name (unwrap~pointer name)))
    (~git_repository_head_for_worktree
      ~out
      ~repo
      ~name)))
(export git_repository_head_for_worktree)

;; extern int git_repository_head_detached(git_repository *repo);
(define ~git_repository_head_detached #f)
(define (git_repository_head_detached repo)
  (unless
    ~git_repository_head_detached
    (set! ~git_repository_head_detached
      (fh-link-proc
        "git_repository_head_detached"
        ffi:int
        (list '*))))
  (let ((~repo (unwrap-git_repository* repo)))
    (~git_repository_head_detached ~repo)))
(export git_repository_head_detached)

;; extern int git_repository_head_detached_for_worktree(git_repository *repo, 
;;     const char *name);
(define ~git_repository_head_detached_for_worktree #f)
(define (git_repository_head_detached_for_worktree
         repo
         name)
  (unless
    ~git_repository_head_detached_for_worktree
    (set! ~git_repository_head_detached_for_worktree
      (fh-link-proc
        "git_repository_head_detached_for_worktree"
        ffi:int
        (list '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~name (unwrap~pointer name)))
    (~git_repository_head_detached_for_worktree
      ~repo
      ~name)))
(export git_repository_head_detached_for_worktree)

;; extern int git_repository_head_unborn(git_repository *repo);
(define ~git_repository_head_unborn #f)
(define (git_repository_head_unborn repo)
  (unless
    ~git_repository_head_unborn
    (set! ~git_repository_head_unborn
      (fh-link-proc
        "git_repository_head_unborn"
        ffi:int
        (list '*))))
  (let ((~repo (unwrap-git_repository* repo)))
    (~git_repository_head_unborn ~repo)))
(export git_repository_head_unborn)

;; extern int git_repository_is_empty(git_repository *repo);
(define ~git_repository_is_empty #f)
(define (git_repository_is_empty repo)
  (unless
    ~git_repository_is_empty
    (set! ~git_repository_is_empty
      (fh-link-proc
        "git_repository_is_empty"
        ffi:int
        (list '*))))
  (let ((~repo (unwrap-git_repository* repo)))
    (~git_repository_is_empty ~repo)))
(export git_repository_is_empty)

;; typedef enum {
;;   GIT_REPOSITORY_ITEM_GITDIR,
;;   GIT_REPOSITORY_ITEM_WORKDIR,
;;   GIT_REPOSITORY_ITEM_COMMONDIR,
;;   GIT_REPOSITORY_ITEM_INDEX,
;;   GIT_REPOSITORY_ITEM_OBJECTS,
;;   GIT_REPOSITORY_ITEM_REFS,
;;   GIT_REPOSITORY_ITEM_PACKED_REFS,
;;   GIT_REPOSITORY_ITEM_REMOTES,
;;   GIT_REPOSITORY_ITEM_CONFIG,
;;   GIT_REPOSITORY_ITEM_INFO,
;;   GIT_REPOSITORY_ITEM_HOOKS,
;;   GIT_REPOSITORY_ITEM_LOGS,
;;   GIT_REPOSITORY_ITEM_MODULES,
;;   GIT_REPOSITORY_ITEM_WORKTREES,
;; } git_repository_item_t;
(define-fh-enum git_repository_item_t
  '((GIT_REPOSITORY_ITEM_GITDIR . 0)
    (GIT_REPOSITORY_ITEM_WORKDIR . 1)
    (GIT_REPOSITORY_ITEM_COMMONDIR . 2)
    (GIT_REPOSITORY_ITEM_INDEX . 3)
    (GIT_REPOSITORY_ITEM_OBJECTS . 4)
    (GIT_REPOSITORY_ITEM_REFS . 5)
    (GIT_REPOSITORY_ITEM_PACKED_REFS . 6)
    (GIT_REPOSITORY_ITEM_REMOTES . 7)
    (GIT_REPOSITORY_ITEM_CONFIG . 8)
    (GIT_REPOSITORY_ITEM_INFO . 9)
    (GIT_REPOSITORY_ITEM_HOOKS . 10)
    (GIT_REPOSITORY_ITEM_LOGS . 11)
    (GIT_REPOSITORY_ITEM_MODULES . 12)
    (GIT_REPOSITORY_ITEM_WORKTREES . 13))
  )

;; extern int git_repository_item_path(git_buf *out, git_repository *repo, 
;;     git_repository_item_t item);
(define ~git_repository_item_path #f)
(define (git_repository_item_path out repo item)
  (unless
    ~git_repository_item_path
    (set! ~git_repository_item_path
      (fh-link-proc
        "git_repository_item_path"
        ffi:int
        (list '* '* ffi:int))))
  (let ((~out (unwrap-git_buf* out))
        (~repo (unwrap-git_repository* repo))
        (~item (unwrap~fixed item)))
    (~git_repository_item_path ~out ~repo ~item)))
(export git_repository_item_path)

;; extern const char *git_repository_path(git_repository *repo);
(define ~git_repository_path #f)
(define (git_repository_path repo)
  (unless
    ~git_repository_path
    (set! ~git_repository_path
      (fh-link-proc "git_repository_path" '* (list '*))))
  (let ((~repo (unwrap-git_repository* repo)))
    (~git_repository_path ~repo)))
(export git_repository_path)

;; extern const char *git_repository_workdir(git_repository *repo);
(define ~git_repository_workdir #f)
(define (git_repository_workdir repo)
  (unless
    ~git_repository_workdir
    (set! ~git_repository_workdir
      (fh-link-proc
        "git_repository_workdir"
        '*
        (list '*))))
  (let ((~repo (unwrap-git_repository* repo)))
    (~git_repository_workdir ~repo)))
(export git_repository_workdir)

;; extern const char *git_repository_commondir(git_repository *repo);
(define ~git_repository_commondir #f)
(define (git_repository_commondir repo)
  (unless
    ~git_repository_commondir
    (set! ~git_repository_commondir
      (fh-link-proc
        "git_repository_commondir"
        '*
        (list '*))))
  (let ((~repo (unwrap-git_repository* repo)))
    (~git_repository_commondir ~repo)))
(export git_repository_commondir)

;; extern int git_repository_set_workdir(git_repository *repo, const char *
;;     workdir, int update_gitlink);
(define ~git_repository_set_workdir #f)
(define (git_repository_set_workdir
         repo
         workdir
         update_gitlink)
  (unless
    ~git_repository_set_workdir
    (set! ~git_repository_set_workdir
      (fh-link-proc
        "git_repository_set_workdir"
        ffi:int
        (list '* '* ffi:int))))
  (let ((~repo (unwrap-git_repository* repo))
        (~workdir (unwrap~pointer workdir))
        (~update_gitlink (unwrap~fixed update_gitlink)))
    (~git_repository_set_workdir
      ~repo
      ~workdir
      ~update_gitlink)))
(export git_repository_set_workdir)

;; extern int git_repository_is_bare(git_repository *repo);
(define ~git_repository_is_bare #f)
(define (git_repository_is_bare repo)
  (unless
    ~git_repository_is_bare
    (set! ~git_repository_is_bare
      (fh-link-proc
        "git_repository_is_bare"
        ffi:int
        (list '*))))
  (let ((~repo (unwrap-git_repository* repo)))
    (~git_repository_is_bare ~repo)))
(export git_repository_is_bare)

;; extern int git_repository_is_worktree(git_repository *repo);
(define ~git_repository_is_worktree #f)
(define (git_repository_is_worktree repo)
  (unless
    ~git_repository_is_worktree
    (set! ~git_repository_is_worktree
      (fh-link-proc
        "git_repository_is_worktree"
        ffi:int
        (list '*))))
  (let ((~repo (unwrap-git_repository* repo)))
    (~git_repository_is_worktree ~repo)))
(export git_repository_is_worktree)

;; extern int git_repository_config(git_config **out, git_repository *repo);
(define ~git_repository_config #f)
(define (git_repository_config out repo)
  (unless
    ~git_repository_config
    (set! ~git_repository_config
      (fh-link-proc
        "git_repository_config"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo)))
    (~git_repository_config ~out ~repo)))
(export git_repository_config)

;; extern int git_repository_config_snapshot(git_config **out, git_repository *
;;     repo);
(define ~git_repository_config_snapshot #f)
(define (git_repository_config_snapshot out repo)
  (unless
    ~git_repository_config_snapshot
    (set! ~git_repository_config_snapshot
      (fh-link-proc
        "git_repository_config_snapshot"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo)))
    (~git_repository_config_snapshot ~out ~repo)))
(export git_repository_config_snapshot)

;; extern int git_repository_odb(git_odb **out, git_repository *repo);
(define ~git_repository_odb #f)
(define (git_repository_odb out repo)
  (unless
    ~git_repository_odb
    (set! ~git_repository_odb
      (fh-link-proc
        "git_repository_odb"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo)))
    (~git_repository_odb ~out ~repo)))
(export git_repository_odb)

;; extern int git_repository_refdb(git_refdb **out, git_repository *repo);
(define ~git_repository_refdb #f)
(define (git_repository_refdb out repo)
  (unless
    ~git_repository_refdb
    (set! ~git_repository_refdb
      (fh-link-proc
        "git_repository_refdb"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo)))
    (~git_repository_refdb ~out ~repo)))
(export git_repository_refdb)

;; extern int git_repository_index(git_index **out, git_repository *repo);
(define ~git_repository_index #f)
(define (git_repository_index out repo)
  (unless
    ~git_repository_index
    (set! ~git_repository_index
      (fh-link-proc
        "git_repository_index"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo)))
    (~git_repository_index ~out ~repo)))
(export git_repository_index)

;; extern int git_repository_message(git_buf *out, git_repository *repo);
(define ~git_repository_message #f)
(define (git_repository_message out repo)
  (unless
    ~git_repository_message
    (set! ~git_repository_message
      (fh-link-proc
        "git_repository_message"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap-git_buf* out))
        (~repo (unwrap-git_repository* repo)))
    (~git_repository_message ~out ~repo)))
(export git_repository_message)

;; extern int git_repository_message_remove(git_repository *repo);
(define ~git_repository_message_remove #f)
(define (git_repository_message_remove repo)
  (unless
    ~git_repository_message_remove
    (set! ~git_repository_message_remove
      (fh-link-proc
        "git_repository_message_remove"
        ffi:int
        (list '*))))
  (let ((~repo (unwrap-git_repository* repo)))
    (~git_repository_message_remove ~repo)))
(export git_repository_message_remove)

;; extern int git_repository_state_cleanup(git_repository *repo);
(define ~git_repository_state_cleanup #f)
(define (git_repository_state_cleanup repo)
  (unless
    ~git_repository_state_cleanup
    (set! ~git_repository_state_cleanup
      (fh-link-proc
        "git_repository_state_cleanup"
        ffi:int
        (list '*))))
  (let ((~repo (unwrap-git_repository* repo)))
    (~git_repository_state_cleanup ~repo)))
(export git_repository_state_cleanup)

;; typedef int (*git_repository_fetchhead_foreach_cb)(const char *ref_name, 
;;     const char *remote_url, const git_oid *oid, unsigned int is_merge, void 
;;     *payload);
(define-fh-function/p git_repository_fetchhead_foreach_cb
  ffi:int (list (quote *) (quote *) (quote *) ffi:unsigned-int (quote *)))

;; extern int git_repository_fetchhead_foreach(git_repository *repo, 
;;     git_repository_fetchhead_foreach_cb callback, void *payload);
(define ~git_repository_fetchhead_foreach #f)
(define (git_repository_fetchhead_foreach
         repo
         callback
         payload)
  (unless
    ~git_repository_fetchhead_foreach
    (set! ~git_repository_fetchhead_foreach
      (fh-link-proc
        "git_repository_fetchhead_foreach"
        ffi:int
        (list '* '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~callback
          ((make-ftn-arg-unwrapper
             ffi:int
             (list '* '* '* ffi:unsigned-int '*))
           callback))
        (~payload (unwrap~pointer payload)))
    (~git_repository_fetchhead_foreach
      ~repo
      ~callback
      ~payload)))
(export git_repository_fetchhead_foreach)

;; typedef int (*git_repository_mergehead_foreach_cb)(const git_oid *oid, void 
;;     *payload);
(define-fh-function/p git_repository_mergehead_foreach_cb
  ffi:int (list (quote *) (quote *)))

;; extern int git_repository_mergehead_foreach(git_repository *repo, 
;;     git_repository_mergehead_foreach_cb callback, void *payload);
(define ~git_repository_mergehead_foreach #f)
(define (git_repository_mergehead_foreach
         repo
         callback
         payload)
  (unless
    ~git_repository_mergehead_foreach
    (set! ~git_repository_mergehead_foreach
      (fh-link-proc
        "git_repository_mergehead_foreach"
        ffi:int
        (list '* '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~callback
          ((make-ftn-arg-unwrapper ffi:int (list '* '*))
           callback))
        (~payload (unwrap~pointer payload)))
    (~git_repository_mergehead_foreach
      ~repo
      ~callback
      ~payload)))
(export git_repository_mergehead_foreach)

;; extern int git_repository_hashfile(git_oid *out, git_repository *repo, const
;;      char *path, git_otype type, const char *as_path);
(define ~git_repository_hashfile #f)
(define (git_repository_hashfile
         out
         repo
         path
         type
         as_path)
  (unless
    ~git_repository_hashfile
    (set! ~git_repository_hashfile
      (fh-link-proc
        "git_repository_hashfile"
        ffi:int
        (list '* '* '* ffi:int '*))))
  (let ((~out (unwrap-git_oid* out))
        (~repo (unwrap-git_repository* repo))
        (~path (unwrap~pointer path))
        (~type (unwrap~fixed type))
        (~as_path (unwrap~pointer as_path)))
    (~git_repository_hashfile
      ~out
      ~repo
      ~path
      ~type
      ~as_path)))
(export git_repository_hashfile)

;; extern int git_repository_set_head(git_repository *repo, const char *refname
;;     );
(define ~git_repository_set_head #f)
(define (git_repository_set_head repo refname)
  (unless
    ~git_repository_set_head
    (set! ~git_repository_set_head
      (fh-link-proc
        "git_repository_set_head"
        ffi:int
        (list '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~refname (unwrap~pointer refname)))
    (~git_repository_set_head ~repo ~refname)))
(export git_repository_set_head)

;; extern int git_repository_set_head_detached(git_repository *repo, const 
;;     git_oid *commitish);
(define ~git_repository_set_head_detached #f)
(define (git_repository_set_head_detached repo commitish)
  (unless
    ~git_repository_set_head_detached
    (set! ~git_repository_set_head_detached
      (fh-link-proc
        "git_repository_set_head_detached"
        ffi:int
        (list '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~commitish (unwrap-git_oid* commitish)))
    (~git_repository_set_head_detached
      ~repo
      ~commitish)))
(export git_repository_set_head_detached)

;; extern int git_repository_set_head_detached_from_annotated(git_repository *
;;     repo, const git_annotated_commit *commitish);
(define ~git_repository_set_head_detached_from_annotated #f)
(define (git_repository_set_head_detached_from_annotated
         repo
         commitish)
  (unless
    ~git_repository_set_head_detached_from_annotated
    (set! ~git_repository_set_head_detached_from_annotated
      (fh-link-proc
        "git_repository_set_head_detached_from_annotated"
        ffi:int
        (list '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~commitish
          (unwrap-git_annotated_commit* commitish)))
    (~git_repository_set_head_detached_from_annotated
      ~repo
      ~commitish)))
(export git_repository_set_head_detached_from_annotated)

;; extern int git_repository_detach_head(git_repository *repo);
(define ~git_repository_detach_head #f)
(define (git_repository_detach_head repo)
  (unless
    ~git_repository_detach_head
    (set! ~git_repository_detach_head
      (fh-link-proc
        "git_repository_detach_head"
        ffi:int
        (list '*))))
  (let ((~repo (unwrap-git_repository* repo)))
    (~git_repository_detach_head ~repo)))
(export git_repository_detach_head)

;; typedef enum {
;;   GIT_REPOSITORY_STATE_NONE,
;;   GIT_REPOSITORY_STATE_MERGE,
;;   GIT_REPOSITORY_STATE_REVERT,
;;   GIT_REPOSITORY_STATE_REVERT_SEQUENCE,
;;   GIT_REPOSITORY_STATE_CHERRYPICK,
;;   GIT_REPOSITORY_STATE_CHERRYPICK_SEQUENCE,
;;   GIT_REPOSITORY_STATE_BISECT,
;;   GIT_REPOSITORY_STATE_REBASE,
;;   GIT_REPOSITORY_STATE_REBASE_INTERACTIVE,
;;   GIT_REPOSITORY_STATE_REBASE_MERGE,
;;   GIT_REPOSITORY_STATE_APPLY_MAILBOX,
;;   GIT_REPOSITORY_STATE_APPLY_MAILBOX_OR_REBASE,
;; } git_repository_state_t;
(define-fh-enum git_repository_state_t
  '((GIT_REPOSITORY_STATE_NONE . 0)
    (GIT_REPOSITORY_STATE_MERGE . 1)
    (GIT_REPOSITORY_STATE_REVERT . 2)
    (GIT_REPOSITORY_STATE_REVERT_SEQUENCE . 3)
    (GIT_REPOSITORY_STATE_CHERRYPICK . 4)
    (GIT_REPOSITORY_STATE_CHERRYPICK_SEQUENCE . 5)
    (GIT_REPOSITORY_STATE_BISECT . 6)
    (GIT_REPOSITORY_STATE_REBASE . 7)
    (GIT_REPOSITORY_STATE_REBASE_INTERACTIVE . 8)
    (GIT_REPOSITORY_STATE_REBASE_MERGE . 9)
    (GIT_REPOSITORY_STATE_APPLY_MAILBOX . 10)
    (GIT_REPOSITORY_STATE_APPLY_MAILBOX_OR_REBASE
      .
      11))
  )

;; extern int git_repository_state(git_repository *repo);
(define ~git_repository_state #f)
(define (git_repository_state repo)
  (unless
    ~git_repository_state
    (set! ~git_repository_state
      (fh-link-proc
        "git_repository_state"
        ffi:int
        (list '*))))
  (let ((~repo (unwrap-git_repository* repo)))
    (~git_repository_state ~repo)))
(export git_repository_state)

;; extern int git_repository_set_namespace(git_repository *repo, const char *
;;     nmspace);
(define ~git_repository_set_namespace #f)
(define (git_repository_set_namespace repo nmspace)
  (unless
    ~git_repository_set_namespace
    (set! ~git_repository_set_namespace
      (fh-link-proc
        "git_repository_set_namespace"
        ffi:int
        (list '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~nmspace (unwrap~pointer nmspace)))
    (~git_repository_set_namespace ~repo ~nmspace)))
(export git_repository_set_namespace)

;; extern const char *git_repository_get_namespace(git_repository *repo);
(define ~git_repository_get_namespace #f)
(define (git_repository_get_namespace repo)
  (unless
    ~git_repository_get_namespace
    (set! ~git_repository_get_namespace
      (fh-link-proc
        "git_repository_get_namespace"
        '*
        (list '*))))
  (let ((~repo (unwrap-git_repository* repo)))
    (~git_repository_get_namespace ~repo)))
(export git_repository_get_namespace)

;; extern int git_repository_is_shallow(git_repository *repo);
(define ~git_repository_is_shallow #f)
(define (git_repository_is_shallow repo)
  (unless
    ~git_repository_is_shallow
    (set! ~git_repository_is_shallow
      (fh-link-proc
        "git_repository_is_shallow"
        ffi:int
        (list '*))))
  (let ((~repo (unwrap-git_repository* repo)))
    (~git_repository_is_shallow ~repo)))
(export git_repository_is_shallow)

;; extern int git_repository_ident(const char **name, const char **email, const
;;      git_repository *repo);
(define ~git_repository_ident #f)
(define (git_repository_ident name email repo)
  (unless
    ~git_repository_ident
    (set! ~git_repository_ident
      (fh-link-proc
        "git_repository_ident"
        ffi:int
        (list '* '* '*))))
  (let ((~name (unwrap~pointer name))
        (~email (unwrap~pointer email))
        (~repo (unwrap-git_repository* repo)))
    (~git_repository_ident ~name ~email ~repo)))
(export git_repository_ident)

;; extern int git_repository_set_ident(git_repository *repo, const char *name, 
;;     const char *email);
(define ~git_repository_set_ident #f)
(define (git_repository_set_ident repo name email)
  (unless
    ~git_repository_set_ident
    (set! ~git_repository_set_ident
      (fh-link-proc
        "git_repository_set_ident"
        ffi:int
        (list '* '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~name (unwrap~pointer name))
        (~email (unwrap~pointer email)))
    (~git_repository_set_ident ~repo ~name ~email)))
(export git_repository_set_ident)

;; extern int git_annotated_commit_from_ref(git_annotated_commit **out, 
;;     git_repository *repo, const git_reference *ref);
(define ~git_annotated_commit_from_ref #f)
(define (git_annotated_commit_from_ref out repo ref)
  (unless
    ~git_annotated_commit_from_ref
    (set! ~git_annotated_commit_from_ref
      (fh-link-proc
        "git_annotated_commit_from_ref"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo))
        (~ref (unwrap-git_reference* ref)))
    (~git_annotated_commit_from_ref ~out ~repo ~ref)))
(export git_annotated_commit_from_ref)

;; extern int git_annotated_commit_from_fetchhead(git_annotated_commit **out, 
;;     git_repository *repo, const char *branch_name, const char *remote_url, 
;;     const git_oid *id);
(define ~git_annotated_commit_from_fetchhead #f)
(define (git_annotated_commit_from_fetchhead
         out
         repo
         branch_name
         remote_url
         id)
  (unless
    ~git_annotated_commit_from_fetchhead
    (set! ~git_annotated_commit_from_fetchhead
      (fh-link-proc
        "git_annotated_commit_from_fetchhead"
        ffi:int
        (list '* '* '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo))
        (~branch_name (unwrap~pointer branch_name))
        (~remote_url (unwrap~pointer remote_url))
        (~id (unwrap-git_oid* id)))
    (~git_annotated_commit_from_fetchhead
      ~out
      ~repo
      ~branch_name
      ~remote_url
      ~id)))
(export git_annotated_commit_from_fetchhead)

;; extern int git_annotated_commit_lookup(git_annotated_commit **out, 
;;     git_repository *repo, const git_oid *id);
(define ~git_annotated_commit_lookup #f)
(define (git_annotated_commit_lookup out repo id)
  (unless
    ~git_annotated_commit_lookup
    (set! ~git_annotated_commit_lookup
      (fh-link-proc
        "git_annotated_commit_lookup"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo))
        (~id (unwrap-git_oid* id)))
    (~git_annotated_commit_lookup ~out ~repo ~id)))
(export git_annotated_commit_lookup)

;; extern int git_annotated_commit_from_revspec(git_annotated_commit **out, 
;;     git_repository *repo, const char *revspec);
(define ~git_annotated_commit_from_revspec #f)
(define (git_annotated_commit_from_revspec
         out
         repo
         revspec)
  (unless
    ~git_annotated_commit_from_revspec
    (set! ~git_annotated_commit_from_revspec
      (fh-link-proc
        "git_annotated_commit_from_revspec"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo))
        (~revspec (unwrap~pointer revspec)))
    (~git_annotated_commit_from_revspec
      ~out
      ~repo
      ~revspec)))
(export git_annotated_commit_from_revspec)

;; extern const git_oid *git_annotated_commit_id(const git_annotated_commit *
;;     commit);
(define ~git_annotated_commit_id #f)
(define (git_annotated_commit_id commit)
  (unless
    ~git_annotated_commit_id
    (set! ~git_annotated_commit_id
      (fh-link-proc
        "git_annotated_commit_id"
        '*
        (list '*))))
  (let ((~commit (unwrap-git_annotated_commit* commit)))
    (wrap-git_oid*
      (~git_annotated_commit_id ~commit))))
(export git_annotated_commit_id)

;; extern void git_annotated_commit_free(git_annotated_commit *commit);
(define ~git_annotated_commit_free #f)
(define (git_annotated_commit_free commit)
  (unless
    ~git_annotated_commit_free
    (set! ~git_annotated_commit_free
      (fh-link-proc
        "git_annotated_commit_free"
        ffi:void
        (list '*))))
  (let ((~commit (unwrap-git_annotated_commit* commit)))
    (~git_annotated_commit_free ~commit)))
(export git_annotated_commit_free)

;; typedef enum {
;;   GIT_ATTR_UNSPECIFIED_T = 0,
;;   GIT_ATTR_TRUE_T,
;;   GIT_ATTR_FALSE_T,
;;   GIT_ATTR_VALUE_T,
;; } git_attr_t;
(define-fh-enum git_attr_t
  '((GIT_ATTR_UNSPECIFIED_T . 0)
    (GIT_ATTR_TRUE_T . 1)
    (GIT_ATTR_FALSE_T . 2)
    (GIT_ATTR_VALUE_T . 3))
  )

;; extern git_attr_t git_attr_value(const char *attr);
(define ~git_attr_value #f)
(define (git_attr_value attr)
  (unless
    ~git_attr_value
    (set! ~git_attr_value
      (fh-link-proc "git_attr_value" ffi:int (list '*))))
  (let ((~attr (unwrap~pointer attr)))
    (~git_attr_value ~attr)))
(export git_attr_value)

;; extern int git_attr_get(const char **value_out, git_repository *repo, 
;;     uint32_t flags, const char *path, const char *name);
(define ~git_attr_get #f)
(define (git_attr_get value_out repo flags path name)
  (unless
    ~git_attr_get
    (set! ~git_attr_get
      (fh-link-proc
        "git_attr_get"
        ffi:int
        (list '* '* ffi:uint32 '* '*))))
  (let ((~value_out (unwrap~pointer value_out))
        (~repo (unwrap-git_repository* repo))
        (~flags (unwrap~fixed flags))
        (~path (unwrap~pointer path))
        (~name (unwrap~pointer name)))
    (~git_attr_get
      ~value_out
      ~repo
      ~flags
      ~path
      ~name)))
(export git_attr_get)

;; extern int git_attr_get_many(const char **values_out, git_repository *repo, 
;;     uint32_t flags, const char *path, size_t num_attr, const char **names);
(define ~git_attr_get_many #f)
(define (git_attr_get_many
         values_out
         repo
         flags
         path
         num_attr
         names)
  (unless
    ~git_attr_get_many
    (set! ~git_attr_get_many
      (fh-link-proc
        "git_attr_get_many"
        ffi:int
        (list '* '* ffi:uint32 '* ffi:size_t '*))))
  (let ((~values_out (unwrap~pointer values_out))
        (~repo (unwrap-git_repository* repo))
        (~flags (unwrap~fixed flags))
        (~path (unwrap~pointer path))
        (~num_attr (unwrap~fixed num_attr))
        (~names (unwrap~pointer names)))
    (~git_attr_get_many
      ~values_out
      ~repo
      ~flags
      ~path
      ~num_attr
      ~names)))
(export git_attr_get_many)

;; typedef int (*git_attr_foreach_cb)(const char *name, const char *value, void
;;      *payload);
(define-fh-function/p git_attr_foreach_cb
  ffi:int (list (quote *) (quote *) (quote *)))

;; extern int git_attr_foreach(git_repository *repo, uint32_t flags, const char
;;      *path, git_attr_foreach_cb callback, void *payload);
(define ~git_attr_foreach #f)
(define (git_attr_foreach
         repo
         flags
         path
         callback
         payload)
  (unless
    ~git_attr_foreach
    (set! ~git_attr_foreach
      (fh-link-proc
        "git_attr_foreach"
        ffi:int
        (list '* ffi:uint32 '* '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~flags (unwrap~fixed flags))
        (~path (unwrap~pointer path))
        (~callback
          ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
           callback))
        (~payload (unwrap~pointer payload)))
    (~git_attr_foreach
      ~repo
      ~flags
      ~path
      ~callback
      ~payload)))
(export git_attr_foreach)

;; extern void git_attr_cache_flush(git_repository *repo);
(define ~git_attr_cache_flush #f)
(define (git_attr_cache_flush repo)
  (unless
    ~git_attr_cache_flush
    (set! ~git_attr_cache_flush
      (fh-link-proc
        "git_attr_cache_flush"
        ffi:void
        (list '*))))
  (let ((~repo (unwrap-git_repository* repo)))
    (~git_attr_cache_flush ~repo)))
(export git_attr_cache_flush)

;; extern int git_attr_add_macro(git_repository *repo, const char *name, const 
;;     char *values);
(define ~git_attr_add_macro #f)
(define (git_attr_add_macro repo name values)
  (unless
    ~git_attr_add_macro
    (set! ~git_attr_add_macro
      (fh-link-proc
        "git_attr_add_macro"
        ffi:int
        (list '* '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~name (unwrap~pointer name))
        (~values (unwrap~pointer values)))
    (~git_attr_add_macro ~repo ~name ~values)))
(export git_attr_add_macro)

;; extern int git_object_lookup(git_object **object, git_repository *repo, 
;;     const git_oid *id, git_otype type);
(define ~git_object_lookup #f)
(define (git_object_lookup object repo id type)
  (unless
    ~git_object_lookup
    (set! ~git_object_lookup
      (fh-link-proc
        "git_object_lookup"
        ffi:int
        (list '* '* '* ffi:int))))
  (let ((~object (unwrap~pointer object))
        (~repo (unwrap-git_repository* repo))
        (~id (unwrap-git_oid* id))
        (~type (unwrap~fixed type)))
    (~git_object_lookup ~object ~repo ~id ~type)))
(export git_object_lookup)

;; extern int git_object_lookup_prefix(git_object **object_out, git_repository 
;;     *repo, const git_oid *id, size_t len, git_otype type);
(define ~git_object_lookup_prefix #f)
(define (git_object_lookup_prefix
         object_out
         repo
         id
         len
         type)
  (unless
    ~git_object_lookup_prefix
    (set! ~git_object_lookup_prefix
      (fh-link-proc
        "git_object_lookup_prefix"
        ffi:int
        (list '* '* '* ffi:size_t ffi:int))))
  (let ((~object_out (unwrap~pointer object_out))
        (~repo (unwrap-git_repository* repo))
        (~id (unwrap-git_oid* id))
        (~len (unwrap~fixed len))
        (~type (unwrap~fixed type)))
    (~git_object_lookup_prefix
      ~object_out
      ~repo
      ~id
      ~len
      ~type)))
(export git_object_lookup_prefix)

;; extern int git_object_lookup_bypath(git_object **out, const git_object *
;;     treeish, const char *path, git_otype type);
(define ~git_object_lookup_bypath #f)
(define (git_object_lookup_bypath out treeish path type)
  (unless
    ~git_object_lookup_bypath
    (set! ~git_object_lookup_bypath
      (fh-link-proc
        "git_object_lookup_bypath"
        ffi:int
        (list '* '* '* ffi:int))))
  (let ((~out (unwrap~pointer out))
        (~treeish (unwrap-git_object* treeish))
        (~path (unwrap~pointer path))
        (~type (unwrap~fixed type)))
    (~git_object_lookup_bypath
      ~out
      ~treeish
      ~path
      ~type)))
(export git_object_lookup_bypath)

;; extern const git_oid *git_object_id(const git_object *obj);
(define ~git_object_id #f)
(define (git_object_id obj)
  (unless
    ~git_object_id
    (set! ~git_object_id
      (fh-link-proc "git_object_id" '* (list '*))))
  (let ((~obj (unwrap-git_object* obj)))
    (wrap-git_oid* (~git_object_id ~obj))))
(export git_object_id)

;; extern int git_object_short_id(git_buf *out, const git_object *obj);
(define ~git_object_short_id #f)
(define (git_object_short_id out obj)
  (unless
    ~git_object_short_id
    (set! ~git_object_short_id
      (fh-link-proc
        "git_object_short_id"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap-git_buf* out))
        (~obj (unwrap-git_object* obj)))
    (~git_object_short_id ~out ~obj)))
(export git_object_short_id)

;; extern git_otype git_object_type(const git_object *obj);
(define ~git_object_type #f)
(define (git_object_type obj)
  (unless
    ~git_object_type
    (set! ~git_object_type
      (fh-link-proc
        "git_object_type"
        ffi:int
        (list '*))))
  (let ((~obj (unwrap-git_object* obj)))
    (~git_object_type ~obj)))
(export git_object_type)

;; extern git_repository *git_object_owner(const git_object *obj);
(define ~git_object_owner #f)
(define (git_object_owner obj)
  (unless
    ~git_object_owner
    (set! ~git_object_owner
      (fh-link-proc "git_object_owner" '* (list '*))))
  (let ((~obj (unwrap-git_object* obj)))
    (wrap-git_repository* (~git_object_owner ~obj))))
(export git_object_owner)

;; extern void git_object_free(git_object *object);
(define ~git_object_free #f)
(define (git_object_free object)
  (unless
    ~git_object_free
    (set! ~git_object_free
      (fh-link-proc
        "git_object_free"
        ffi:void
        (list '*))))
  (let ((~object (unwrap-git_object* object)))
    (~git_object_free ~object)))
(export git_object_free)

;; extern const char *git_object_type2string(git_otype type);
(define ~git_object_type2string #f)
(define (git_object_type2string type)
  (unless
    ~git_object_type2string
    (set! ~git_object_type2string
      (fh-link-proc
        "git_object_type2string"
        '*
        (list ffi:int))))
  (let ((~type (unwrap~fixed type)))
    (~git_object_type2string ~type)))
(export git_object_type2string)

;; extern git_otype git_object_string2type(const char *str);
(define ~git_object_string2type #f)
(define (git_object_string2type str)
  (unless
    ~git_object_string2type
    (set! ~git_object_string2type
      (fh-link-proc
        "git_object_string2type"
        ffi:int
        (list '*))))
  (let ((~str (unwrap~pointer str)))
    (~git_object_string2type ~str)))
(export git_object_string2type)

;; extern int git_object_typeisloose(git_otype type);
(define ~git_object_typeisloose #f)
(define (git_object_typeisloose type)
  (unless
    ~git_object_typeisloose
    (set! ~git_object_typeisloose
      (fh-link-proc
        "git_object_typeisloose"
        ffi:int
        (list ffi:int))))
  (let ((~type (unwrap~fixed type)))
    (~git_object_typeisloose ~type)))
(export git_object_typeisloose)

;; extern size_t git_object__size(git_otype type);
(define ~git_object__size #f)
(define (git_object__size type)
  (unless
    ~git_object__size
    (set! ~git_object__size
      (fh-link-proc
        "git_object__size"
        ffi:size_t
        (list ffi:int))))
  (let ((~type (unwrap~fixed type)))
    (~git_object__size ~type)))
(export git_object__size)

;; extern int git_object_peel(git_object **peeled, const git_object *object, 
;;     git_otype target_type);
(define ~git_object_peel #f)
(define (git_object_peel peeled object target_type)
  (unless
    ~git_object_peel
    (set! ~git_object_peel
      (fh-link-proc
        "git_object_peel"
        ffi:int
        (list '* '* ffi:int))))
  (let ((~peeled (unwrap~pointer peeled))
        (~object (unwrap-git_object* object))
        (~target_type (unwrap~fixed target_type)))
    (~git_object_peel ~peeled ~object ~target_type)))
(export git_object_peel)

;; extern int git_object_dup(git_object **dest, git_object *source);
(define ~git_object_dup #f)
(define (git_object_dup dest source)
  (unless
    ~git_object_dup
    (set! ~git_object_dup
      (fh-link-proc
        "git_object_dup"
        ffi:int
        (list '* '*))))
  (let ((~dest (unwrap~pointer dest))
        (~source (unwrap-git_object* source)))
    (~git_object_dup ~dest ~source)))
(export git_object_dup)

;; extern int git_blob_lookup(git_blob **blob, git_repository *repo, const 
;;     git_oid *id);
(define ~git_blob_lookup #f)
(define (git_blob_lookup blob repo id)
  (unless
    ~git_blob_lookup
    (set! ~git_blob_lookup
      (fh-link-proc
        "git_blob_lookup"
        ffi:int
        (list '* '* '*))))
  (let ((~blob (unwrap~pointer blob))
        (~repo (unwrap-git_repository* repo))
        (~id (unwrap-git_oid* id)))
    (~git_blob_lookup ~blob ~repo ~id)))
(export git_blob_lookup)

;; extern int git_blob_lookup_prefix(git_blob **blob, git_repository *repo, 
;;     const git_oid *id, size_t len);
(define ~git_blob_lookup_prefix #f)
(define (git_blob_lookup_prefix blob repo id len)
  (unless
    ~git_blob_lookup_prefix
    (set! ~git_blob_lookup_prefix
      (fh-link-proc
        "git_blob_lookup_prefix"
        ffi:int
        (list '* '* '* ffi:size_t))))
  (let ((~blob (unwrap~pointer blob))
        (~repo (unwrap-git_repository* repo))
        (~id (unwrap-git_oid* id))
        (~len (unwrap~fixed len)))
    (~git_blob_lookup_prefix ~blob ~repo ~id ~len)))
(export git_blob_lookup_prefix)

;; extern void git_blob_free(git_blob *blob);
(define ~git_blob_free #f)
(define (git_blob_free blob)
  (unless
    ~git_blob_free
    (set! ~git_blob_free
      (fh-link-proc "git_blob_free" ffi:void (list '*))))
  (let ((~blob (unwrap-git_blob* blob)))
    (~git_blob_free ~blob)))
(export git_blob_free)

;; extern const git_oid *git_blob_id(const git_blob *blob);
(define ~git_blob_id #f)
(define (git_blob_id blob)
  (unless
    ~git_blob_id
    (set! ~git_blob_id
      (fh-link-proc "git_blob_id" '* (list '*))))
  (let ((~blob (unwrap-git_blob* blob)))
    (wrap-git_oid* (~git_blob_id ~blob))))
(export git_blob_id)

;; extern git_repository *git_blob_owner(const git_blob *blob);
(define ~git_blob_owner #f)
(define (git_blob_owner blob)
  (unless
    ~git_blob_owner
    (set! ~git_blob_owner
      (fh-link-proc "git_blob_owner" '* (list '*))))
  (let ((~blob (unwrap-git_blob* blob)))
    (wrap-git_repository* (~git_blob_owner ~blob))))
(export git_blob_owner)

;; extern const void *git_blob_rawcontent(const git_blob *blob);
(define ~git_blob_rawcontent #f)
(define (git_blob_rawcontent blob)
  (unless
    ~git_blob_rawcontent
    (set! ~git_blob_rawcontent
      (fh-link-proc "git_blob_rawcontent" '* (list '*))))
  (let ((~blob (unwrap-git_blob* blob)))
    (~git_blob_rawcontent ~blob)))
(export git_blob_rawcontent)

;; extern git_off_t git_blob_rawsize(const git_blob *blob);
(define ~git_blob_rawsize #f)
(define (git_blob_rawsize blob)
  (unless
    ~git_blob_rawsize
    (set! ~git_blob_rawsize
      (fh-link-proc
        "git_blob_rawsize"
        ffi:int64
        (list '*))))
  (let ((~blob (unwrap-git_blob* blob)))
    (~git_blob_rawsize ~blob)))
(export git_blob_rawsize)

;; extern int git_blob_filtered_content(git_buf *out, git_blob *blob, const 
;;     char *as_path, int check_for_binary_data);
(define ~git_blob_filtered_content #f)
(define (git_blob_filtered_content
         out
         blob
         as_path
         check_for_binary_data)
  (unless
    ~git_blob_filtered_content
    (set! ~git_blob_filtered_content
      (fh-link-proc
        "git_blob_filtered_content"
        ffi:int
        (list '* '* '* ffi:int))))
  (let ((~out (unwrap-git_buf* out))
        (~blob (unwrap-git_blob* blob))
        (~as_path (unwrap~pointer as_path))
        (~check_for_binary_data
          (unwrap~fixed check_for_binary_data)))
    (~git_blob_filtered_content
      ~out
      ~blob
      ~as_path
      ~check_for_binary_data)))
(export git_blob_filtered_content)

;; extern int git_blob_create_fromworkdir(git_oid *id, git_repository *repo, 
;;     const char *relative_path);
(define ~git_blob_create_fromworkdir #f)
(define (git_blob_create_fromworkdir
         id
         repo
         relative_path)
  (unless
    ~git_blob_create_fromworkdir
    (set! ~git_blob_create_fromworkdir
      (fh-link-proc
        "git_blob_create_fromworkdir"
        ffi:int
        (list '* '* '*))))
  (let ((~id (unwrap-git_oid* id))
        (~repo (unwrap-git_repository* repo))
        (~relative_path (unwrap~pointer relative_path)))
    (~git_blob_create_fromworkdir
      ~id
      ~repo
      ~relative_path)))
(export git_blob_create_fromworkdir)

;; extern int git_blob_create_fromdisk(git_oid *id, git_repository *repo, const
;;      char *path);
(define ~git_blob_create_fromdisk #f)
(define (git_blob_create_fromdisk id repo path)
  (unless
    ~git_blob_create_fromdisk
    (set! ~git_blob_create_fromdisk
      (fh-link-proc
        "git_blob_create_fromdisk"
        ffi:int
        (list '* '* '*))))
  (let ((~id (unwrap-git_oid* id))
        (~repo (unwrap-git_repository* repo))
        (~path (unwrap~pointer path)))
    (~git_blob_create_fromdisk ~id ~repo ~path)))
(export git_blob_create_fromdisk)

;; extern int git_blob_create_fromstream(git_writestream **out, git_repository 
;;     *repo, const char *hintpath);
(define ~git_blob_create_fromstream #f)
(define (git_blob_create_fromstream out repo hintpath)
  (unless
    ~git_blob_create_fromstream
    (set! ~git_blob_create_fromstream
      (fh-link-proc
        "git_blob_create_fromstream"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo))
        (~hintpath (unwrap~pointer hintpath)))
    (~git_blob_create_fromstream
      ~out
      ~repo
      ~hintpath)))
(export git_blob_create_fromstream)

;; extern int git_blob_create_fromstream_commit(git_oid *out, git_writestream *
;;     stream);
(define ~git_blob_create_fromstream_commit #f)
(define (git_blob_create_fromstream_commit out stream)
  (unless
    ~git_blob_create_fromstream_commit
    (set! ~git_blob_create_fromstream_commit
      (fh-link-proc
        "git_blob_create_fromstream_commit"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap-git_oid* out))
        (~stream (unwrap-git_writestream* stream)))
    (~git_blob_create_fromstream_commit ~out ~stream)))
(export git_blob_create_fromstream_commit)

;; extern int git_blob_create_frombuffer(git_oid *id, git_repository *repo, 
;;     const void *buffer, size_t len);
(define ~git_blob_create_frombuffer #f)
(define (git_blob_create_frombuffer id repo buffer len)
  (unless
    ~git_blob_create_frombuffer
    (set! ~git_blob_create_frombuffer
      (fh-link-proc
        "git_blob_create_frombuffer"
        ffi:int
        (list '* '* '* ffi:size_t))))
  (let ((~id (unwrap-git_oid* id))
        (~repo (unwrap-git_repository* repo))
        (~buffer (unwrap~pointer buffer))
        (~len (unwrap~fixed len)))
    (~git_blob_create_frombuffer
      ~id
      ~repo
      ~buffer
      ~len)))
(export git_blob_create_frombuffer)

;; extern int git_blob_is_binary(const git_blob *blob);
(define ~git_blob_is_binary #f)
(define (git_blob_is_binary blob)
  (unless
    ~git_blob_is_binary
    (set! ~git_blob_is_binary
      (fh-link-proc
        "git_blob_is_binary"
        ffi:int
        (list '*))))
  (let ((~blob (unwrap-git_blob* blob)))
    (~git_blob_is_binary ~blob)))
(export git_blob_is_binary)

;; extern int git_blob_dup(git_blob **out, git_blob *source);
(define ~git_blob_dup #f)
(define (git_blob_dup out source)
  (unless
    ~git_blob_dup
    (set! ~git_blob_dup
      (fh-link-proc
        "git_blob_dup"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~source (unwrap-git_blob* source)))
    (~git_blob_dup ~out ~source)))
(export git_blob_dup)

;; typedef enum {
;;   GIT_BLAME_NORMAL = 0,
;;   GIT_BLAME_TRACK_COPIES_SAME_FILE = 1<<0,
;;   GIT_BLAME_TRACK_COPIES_SAME_COMMIT_MOVES = 1<<1,
;;   GIT_BLAME_TRACK_COPIES_SAME_COMMIT_COPIES = 1<<2,
;;   GIT_BLAME_TRACK_COPIES_ANY_COMMIT_COPIES = 1<<3,
;;   GIT_BLAME_FIRST_PARENT = 1<<4,
;; } git_blame_flag_t;
(define-fh-enum git_blame_flag_t
  '((GIT_BLAME_NORMAL . 0)
    (GIT_BLAME_TRACK_COPIES_SAME_FILE . 1)
    (GIT_BLAME_TRACK_COPIES_SAME_COMMIT_MOVES . 2)
    (GIT_BLAME_TRACK_COPIES_SAME_COMMIT_COPIES . 4)
    (GIT_BLAME_TRACK_COPIES_ANY_COMMIT_COPIES . 8)
    (GIT_BLAME_FIRST_PARENT . 16))
  )

;; typedef struct git_blame_options {
;;   unsigned int version;
;;   uint32_t flags;
;;   uint16_t min_match_characters;
;;   git_oid newest_commit;
;;   git_oid oldest_commit;
;;   size_t min_line;
;;   size_t max_line;
;; } git_blame_options;
(define git_blame_options-desc
  (bs:struct
    (list `(version ,unsigned-int)
          `(flags ,uint64)
          `(min_match_characters ,uint16)
          `(newest_commit ,git_oid-desc)
          `(oldest_commit ,git_oid-desc)
          `(min_line ,size_t)
          `(max_line ,size_t))))
(export git_blame_options-desc)
(define-fh-compound-type/p git_blame_options git_blame_options-desc)
(define struct-git_blame_options git_blame_options)

;; extern int git_blame_init_options(git_blame_options *opts, unsigned int 
;;     version);
(define ~git_blame_init_options #f)
(define (git_blame_init_options opts version)
  (unless
    ~git_blame_init_options
    (set! ~git_blame_init_options
      (fh-link-proc
        "git_blame_init_options"
        ffi:int
        (list '* ffi:unsigned-int))))
  (let ((~opts (unwrap-git_blame_options* opts))
        (~version (unwrap~fixed version)))
    (~git_blame_init_options ~opts ~version)))
(export git_blame_init_options)

;; typedef struct git_blame_hunk {
;;   size_t lines_in_hunk;
;;   git_oid final_commit_id;
;;   size_t final_start_line_number;
;;   git_signature *final_signature;
;;   git_oid orig_commit_id;
;;   const char *orig_path;
;;   size_t orig_start_line_number;
;;   git_signature *orig_signature;
;;   char boundary;
;; } git_blame_hunk;
(define git_blame_hunk-desc
  (bs:struct
    (list `(lines_in_hunk ,size_t)
          `(final_commit_id ,git_oid-desc)
          `(final_start_line_number ,size_t)
          `(final_signature
             ,(bs:pointer (delay git_signature*-desc)))
          `(orig_commit_id ,git_oid-desc)
          `(orig_path ,(bs:pointer int))
          `(orig_start_line_number ,size_t)
          `(orig_signature
             ,(bs:pointer (delay git_signature*-desc)))
          `(boundary ,int))))
(export git_blame_hunk-desc)
(define-fh-compound-type/p git_blame_hunk git_blame_hunk-desc)
(define struct-git_blame_hunk git_blame_hunk)

;; typedef struct git_blame git_blame;
(define git_blame-desc void)
(export git_blame-desc)
(define git_blame*-desc (bs:pointer git_blame-desc))
(export git_blame*-desc)
(define-fh-pointer-type git_blame* git_blame*-desc)

;; extern uint32_t git_blame_get_hunk_count(git_blame *blame);
(define ~git_blame_get_hunk_count #f)
(define (git_blame_get_hunk_count blame)
  (unless
    ~git_blame_get_hunk_count
    (set! ~git_blame_get_hunk_count
      (fh-link-proc
        "git_blame_get_hunk_count"
        ffi:uint32
        (list '*))))
  (let ((~blame (unwrap-git_blame* blame)))
    (~git_blame_get_hunk_count ~blame)))
(export git_blame_get_hunk_count)

;; extern const git_blame_hunk *git_blame_get_hunk_byindex(git_blame *blame, 
;;     uint32_t index);
(define ~git_blame_get_hunk_byindex #f)
(define (git_blame_get_hunk_byindex blame index)
  (unless
    ~git_blame_get_hunk_byindex
    (set! ~git_blame_get_hunk_byindex
      (fh-link-proc
        "git_blame_get_hunk_byindex"
        '*
        (list '* ffi:uint32))))
  (let ((~blame (unwrap-git_blame* blame))
        (~index (unwrap~fixed index)))
    (wrap-git_blame_hunk*
      (~git_blame_get_hunk_byindex ~blame ~index))))
(export git_blame_get_hunk_byindex)

;; extern const git_blame_hunk *git_blame_get_hunk_byline(git_blame *blame, 
;;     size_t lineno);
(define ~git_blame_get_hunk_byline #f)
(define (git_blame_get_hunk_byline blame lineno)
  (unless
    ~git_blame_get_hunk_byline
    (set! ~git_blame_get_hunk_byline
      (fh-link-proc
        "git_blame_get_hunk_byline"
        '*
        (list '* ffi:size_t))))
  (let ((~blame (unwrap-git_blame* blame))
        (~lineno (unwrap~fixed lineno)))
    (wrap-git_blame_hunk*
      (~git_blame_get_hunk_byline ~blame ~lineno))))
(export git_blame_get_hunk_byline)

;; extern int git_blame_file(git_blame **out, git_repository *repo, const char 
;;     *path, git_blame_options *options);
(define ~git_blame_file #f)
(define (git_blame_file out repo path options)
  (unless
    ~git_blame_file
    (set! ~git_blame_file
      (fh-link-proc
        "git_blame_file"
        ffi:int
        (list '* '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo))
        (~path (unwrap~pointer path))
        (~options (unwrap-git_blame_options* options)))
    (~git_blame_file ~out ~repo ~path ~options)))
(export git_blame_file)

;; extern int git_blame_buffer(git_blame **out, git_blame *reference, const 
;;     char *buffer, size_t buffer_len);
(define ~git_blame_buffer #f)
(define (git_blame_buffer
         out
         reference
         buffer
         buffer_len)
  (unless
    ~git_blame_buffer
    (set! ~git_blame_buffer
      (fh-link-proc
        "git_blame_buffer"
        ffi:int
        (list '* '* '* ffi:size_t))))
  (let ((~out (unwrap~pointer out))
        (~reference (unwrap-git_blame* reference))
        (~buffer (unwrap~pointer buffer))
        (~buffer_len (unwrap~fixed buffer_len)))
    (~git_blame_buffer
      ~out
      ~reference
      ~buffer
      ~buffer_len)))
(export git_blame_buffer)

;; extern void git_blame_free(git_blame *blame);
(define ~git_blame_free #f)
(define (git_blame_free blame)
  (unless
    ~git_blame_free
    (set! ~git_blame_free
      (fh-link-proc
        "git_blame_free"
        ffi:void
        (list '*))))
  (let ((~blame (unwrap-git_blame* blame)))
    (~git_blame_free ~blame)))
(export git_blame_free)

;; extern int git_branch_create(git_reference **out, git_repository *repo, 
;;     const char *branch_name, const git_commit *target, int force);
(define ~git_branch_create #f)
(define (git_branch_create
         out
         repo
         branch_name
         target
         force)
  (unless
    ~git_branch_create
    (set! ~git_branch_create
      (fh-link-proc
        "git_branch_create"
        ffi:int
        (list '* '* '* '* ffi:int))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo))
        (~branch_name (unwrap~pointer branch_name))
        (~target (unwrap-git_commit* target))
        (~force (unwrap~fixed force)))
    (~git_branch_create
      ~out
      ~repo
      ~branch_name
      ~target
      ~force)))
(export git_branch_create)

;; extern int git_branch_create_from_annotated(git_reference **ref_out, 
;;     git_repository *repository, const char *branch_name, const 
;;     git_annotated_commit *commit, int force);
(define ~git_branch_create_from_annotated #f)
(define (git_branch_create_from_annotated
         ref_out
         repository
         branch_name
         commit
         force)
  (unless
    ~git_branch_create_from_annotated
    (set! ~git_branch_create_from_annotated
      (fh-link-proc
        "git_branch_create_from_annotated"
        ffi:int
        (list '* '* '* '* ffi:int))))
  (let ((~ref_out (unwrap~pointer ref_out))
        (~repository (unwrap-git_repository* repository))
        (~branch_name (unwrap~pointer branch_name))
        (~commit (unwrap-git_annotated_commit* commit))
        (~force (unwrap~fixed force)))
    (~git_branch_create_from_annotated
      ~ref_out
      ~repository
      ~branch_name
      ~commit
      ~force)))
(export git_branch_create_from_annotated)

;; extern int git_branch_delete(git_reference *branch);
(define ~git_branch_delete #f)
(define (git_branch_delete branch)
  (unless
    ~git_branch_delete
    (set! ~git_branch_delete
      (fh-link-proc
        "git_branch_delete"
        ffi:int
        (list '*))))
  (let ((~branch (unwrap-git_reference* branch)))
    (~git_branch_delete ~branch)))
(export git_branch_delete)

;; typedef struct git_branch_iterator git_branch_iterator;
(define git_branch_iterator-desc void)
(export git_branch_iterator-desc)
(define git_branch_iterator*-desc (bs:pointer git_branch_iterator-desc))
(export git_branch_iterator*-desc)
(define-fh-pointer-type git_branch_iterator* git_branch_iterator*-desc)

;; extern int git_branch_iterator_new(git_branch_iterator **out, git_repository
;;      *repo, git_branch_t list_flags);
(define ~git_branch_iterator_new #f)
(define (git_branch_iterator_new out repo list_flags)
  (unless
    ~git_branch_iterator_new
    (set! ~git_branch_iterator_new
      (fh-link-proc
        "git_branch_iterator_new"
        ffi:int
        (list '* '* ffi:int))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo))
        (~list_flags (unwrap~fixed list_flags)))
    (~git_branch_iterator_new ~out ~repo ~list_flags)))
(export git_branch_iterator_new)

;; extern int git_branch_next(git_reference **out, git_branch_t *out_type, 
;;     git_branch_iterator *iter);
(define ~git_branch_next #f)
(define (git_branch_next out out_type iter)
  (unless
    ~git_branch_next
    (set! ~git_branch_next
      (fh-link-proc
        "git_branch_next"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~out_type (unwrap~pointer out_type))
        (~iter (unwrap-git_branch_iterator* iter)))
    (~git_branch_next ~out ~out_type ~iter)))
(export git_branch_next)

;; extern void git_branch_iterator_free(git_branch_iterator *iter);
(define ~git_branch_iterator_free #f)
(define (git_branch_iterator_free iter)
  (unless
    ~git_branch_iterator_free
    (set! ~git_branch_iterator_free
      (fh-link-proc
        "git_branch_iterator_free"
        ffi:void
        (list '*))))
  (let ((~iter (unwrap-git_branch_iterator* iter)))
    (~git_branch_iterator_free ~iter)))
(export git_branch_iterator_free)

;; extern int git_branch_move(git_reference **out, git_reference *branch, const
;;      char *new_branch_name, int force);
(define ~git_branch_move #f)
(define (git_branch_move
         out
         branch
         new_branch_name
         force)
  (unless
    ~git_branch_move
    (set! ~git_branch_move
      (fh-link-proc
        "git_branch_move"
        ffi:int
        (list '* '* '* ffi:int))))
  (let ((~out (unwrap~pointer out))
        (~branch (unwrap-git_reference* branch))
        (~new_branch_name
          (unwrap~pointer new_branch_name))
        (~force (unwrap~fixed force)))
    (~git_branch_move
      ~out
      ~branch
      ~new_branch_name
      ~force)))
(export git_branch_move)

;; extern int git_branch_lookup(git_reference **out, git_repository *repo, 
;;     const char *branch_name, git_branch_t branch_type);
(define ~git_branch_lookup #f)
(define (git_branch_lookup
         out
         repo
         branch_name
         branch_type)
  (unless
    ~git_branch_lookup
    (set! ~git_branch_lookup
      (fh-link-proc
        "git_branch_lookup"
        ffi:int
        (list '* '* '* ffi:int))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo))
        (~branch_name (unwrap~pointer branch_name))
        (~branch_type (unwrap~fixed branch_type)))
    (~git_branch_lookup
      ~out
      ~repo
      ~branch_name
      ~branch_type)))
(export git_branch_lookup)

;; extern int git_branch_name(const char **out, const git_reference *ref);
(define ~git_branch_name #f)
(define (git_branch_name out ref)
  (unless
    ~git_branch_name
    (set! ~git_branch_name
      (fh-link-proc
        "git_branch_name"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~ref (unwrap-git_reference* ref)))
    (~git_branch_name ~out ~ref)))
(export git_branch_name)

;; extern int git_branch_upstream(git_reference **out, const git_reference *
;;     branch);
(define ~git_branch_upstream #f)
(define (git_branch_upstream out branch)
  (unless
    ~git_branch_upstream
    (set! ~git_branch_upstream
      (fh-link-proc
        "git_branch_upstream"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~branch (unwrap-git_reference* branch)))
    (~git_branch_upstream ~out ~branch)))
(export git_branch_upstream)

;; extern int git_branch_set_upstream(git_reference *branch, const char *
;;     upstream_name);
(define ~git_branch_set_upstream #f)
(define (git_branch_set_upstream branch upstream_name)
  (unless
    ~git_branch_set_upstream
    (set! ~git_branch_set_upstream
      (fh-link-proc
        "git_branch_set_upstream"
        ffi:int
        (list '* '*))))
  (let ((~branch (unwrap-git_reference* branch))
        (~upstream_name (unwrap~pointer upstream_name)))
    (~git_branch_set_upstream ~branch ~upstream_name)))
(export git_branch_set_upstream)

;; extern int git_branch_upstream_name(git_buf *out, git_repository *repo, 
;;     const char *refname);
(define ~git_branch_upstream_name #f)
(define (git_branch_upstream_name out repo refname)
  (unless
    ~git_branch_upstream_name
    (set! ~git_branch_upstream_name
      (fh-link-proc
        "git_branch_upstream_name"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap-git_buf* out))
        (~repo (unwrap-git_repository* repo))
        (~refname (unwrap~pointer refname)))
    (~git_branch_upstream_name ~out ~repo ~refname)))
(export git_branch_upstream_name)

;; extern int git_branch_is_head(const git_reference *branch);
(define ~git_branch_is_head #f)
(define (git_branch_is_head branch)
  (unless
    ~git_branch_is_head
    (set! ~git_branch_is_head
      (fh-link-proc
        "git_branch_is_head"
        ffi:int
        (list '*))))
  (let ((~branch (unwrap-git_reference* branch)))
    (~git_branch_is_head ~branch)))
(export git_branch_is_head)

;; extern int git_branch_is_checked_out(const git_reference *branch);
(define ~git_branch_is_checked_out #f)
(define (git_branch_is_checked_out branch)
  (unless
    ~git_branch_is_checked_out
    (set! ~git_branch_is_checked_out
      (fh-link-proc
        "git_branch_is_checked_out"
        ffi:int
        (list '*))))
  (let ((~branch (unwrap-git_reference* branch)))
    (~git_branch_is_checked_out ~branch)))
(export git_branch_is_checked_out)

;; extern int git_branch_remote_name(git_buf *out, git_repository *repo, const 
;;     char *canonical_branch_name);
(define ~git_branch_remote_name #f)
(define (git_branch_remote_name
         out
         repo
         canonical_branch_name)
  (unless
    ~git_branch_remote_name
    (set! ~git_branch_remote_name
      (fh-link-proc
        "git_branch_remote_name"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap-git_buf* out))
        (~repo (unwrap-git_repository* repo))
        (~canonical_branch_name
          (unwrap~pointer canonical_branch_name)))
    (~git_branch_remote_name
      ~out
      ~repo
      ~canonical_branch_name)))
(export git_branch_remote_name)

;; extern int git_branch_upstream_remote(git_buf *buf, git_repository *repo, 
;;     const char *refname);
(define ~git_branch_upstream_remote #f)
(define (git_branch_upstream_remote buf repo refname)
  (unless
    ~git_branch_upstream_remote
    (set! ~git_branch_upstream_remote
      (fh-link-proc
        "git_branch_upstream_remote"
        ffi:int
        (list '* '* '*))))
  (let ((~buf (unwrap-git_buf* buf))
        (~repo (unwrap-git_repository* repo))
        (~refname (unwrap~pointer refname)))
    (~git_branch_upstream_remote ~buf ~repo ~refname)))
(export git_branch_upstream_remote)

;; extern int git_tree_lookup(git_tree **out, git_repository *repo, const 
;;     git_oid *id);
(define ~git_tree_lookup #f)
(define (git_tree_lookup out repo id)
  (unless
    ~git_tree_lookup
    (set! ~git_tree_lookup
      (fh-link-proc
        "git_tree_lookup"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo))
        (~id (unwrap-git_oid* id)))
    (~git_tree_lookup ~out ~repo ~id)))
(export git_tree_lookup)

;; extern int git_tree_lookup_prefix(git_tree **out, git_repository *repo, 
;;     const git_oid *id, size_t len);
(define ~git_tree_lookup_prefix #f)
(define (git_tree_lookup_prefix out repo id len)
  (unless
    ~git_tree_lookup_prefix
    (set! ~git_tree_lookup_prefix
      (fh-link-proc
        "git_tree_lookup_prefix"
        ffi:int
        (list '* '* '* ffi:size_t))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo))
        (~id (unwrap-git_oid* id))
        (~len (unwrap~fixed len)))
    (~git_tree_lookup_prefix ~out ~repo ~id ~len)))
(export git_tree_lookup_prefix)

;; extern void git_tree_free(git_tree *tree);
(define ~git_tree_free #f)
(define (git_tree_free tree)
  (unless
    ~git_tree_free
    (set! ~git_tree_free
      (fh-link-proc "git_tree_free" ffi:void (list '*))))
  (let ((~tree (unwrap-git_tree* tree)))
    (~git_tree_free ~tree)))
(export git_tree_free)

;; extern const git_oid *git_tree_id(const git_tree *tree);
(define ~git_tree_id #f)
(define (git_tree_id tree)
  (unless
    ~git_tree_id
    (set! ~git_tree_id
      (fh-link-proc "git_tree_id" '* (list '*))))
  (let ((~tree (unwrap-git_tree* tree)))
    (wrap-git_oid* (~git_tree_id ~tree))))
(export git_tree_id)

;; extern git_repository *git_tree_owner(const git_tree *tree);
(define ~git_tree_owner #f)
(define (git_tree_owner tree)
  (unless
    ~git_tree_owner
    (set! ~git_tree_owner
      (fh-link-proc "git_tree_owner" '* (list '*))))
  (let ((~tree (unwrap-git_tree* tree)))
    (wrap-git_repository* (~git_tree_owner ~tree))))
(export git_tree_owner)

;; extern size_t git_tree_entrycount(const git_tree *tree);
(define ~git_tree_entrycount #f)
(define (git_tree_entrycount tree)
  (unless
    ~git_tree_entrycount
    (set! ~git_tree_entrycount
      (fh-link-proc
        "git_tree_entrycount"
        ffi:size_t
        (list '*))))
  (let ((~tree (unwrap-git_tree* tree)))
    (~git_tree_entrycount ~tree)))
(export git_tree_entrycount)

;; extern const git_tree_entry *git_tree_entry_byname(const git_tree *tree, 
;;     const char *filename);
(define ~git_tree_entry_byname #f)
(define (git_tree_entry_byname tree filename)
  (unless
    ~git_tree_entry_byname
    (set! ~git_tree_entry_byname
      (fh-link-proc
        "git_tree_entry_byname"
        '*
        (list '* '*))))
  (let ((~tree (unwrap-git_tree* tree))
        (~filename (unwrap~pointer filename)))
    (wrap-git_tree_entry*
      (~git_tree_entry_byname ~tree ~filename))))
(export git_tree_entry_byname)

;; extern const git_tree_entry *git_tree_entry_byindex(const git_tree *tree, 
;;     size_t idx);
(define ~git_tree_entry_byindex #f)
(define (git_tree_entry_byindex tree idx)
  (unless
    ~git_tree_entry_byindex
    (set! ~git_tree_entry_byindex
      (fh-link-proc
        "git_tree_entry_byindex"
        '*
        (list '* ffi:size_t))))
  (let ((~tree (unwrap-git_tree* tree))
        (~idx (unwrap~fixed idx)))
    (wrap-git_tree_entry*
      (~git_tree_entry_byindex ~tree ~idx))))
(export git_tree_entry_byindex)

;; extern const git_tree_entry *git_tree_entry_byid(const git_tree *tree, const
;;      git_oid *id);
(define ~git_tree_entry_byid #f)
(define (git_tree_entry_byid tree id)
  (unless
    ~git_tree_entry_byid
    (set! ~git_tree_entry_byid
      (fh-link-proc
        "git_tree_entry_byid"
        '*
        (list '* '*))))
  (let ((~tree (unwrap-git_tree* tree))
        (~id (unwrap-git_oid* id)))
    (wrap-git_tree_entry*
      (~git_tree_entry_byid ~tree ~id))))
(export git_tree_entry_byid)

;; extern int git_tree_entry_bypath(git_tree_entry **out, const git_tree *root
;;     , const char *path);
(define ~git_tree_entry_bypath #f)
(define (git_tree_entry_bypath out root path)
  (unless
    ~git_tree_entry_bypath
    (set! ~git_tree_entry_bypath
      (fh-link-proc
        "git_tree_entry_bypath"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~root (unwrap-git_tree* root))
        (~path (unwrap~pointer path)))
    (~git_tree_entry_bypath ~out ~root ~path)))
(export git_tree_entry_bypath)

;; extern int git_tree_entry_dup(git_tree_entry **dest, const git_tree_entry *
;;     source);
(define ~git_tree_entry_dup #f)
(define (git_tree_entry_dup dest source)
  (unless
    ~git_tree_entry_dup
    (set! ~git_tree_entry_dup
      (fh-link-proc
        "git_tree_entry_dup"
        ffi:int
        (list '* '*))))
  (let ((~dest (unwrap~pointer dest))
        (~source (unwrap-git_tree_entry* source)))
    (~git_tree_entry_dup ~dest ~source)))
(export git_tree_entry_dup)

;; extern void git_tree_entry_free(git_tree_entry *entry);
(define ~git_tree_entry_free #f)
(define (git_tree_entry_free entry)
  (unless
    ~git_tree_entry_free
    (set! ~git_tree_entry_free
      (fh-link-proc
        "git_tree_entry_free"
        ffi:void
        (list '*))))
  (let ((~entry (unwrap-git_tree_entry* entry)))
    (~git_tree_entry_free ~entry)))
(export git_tree_entry_free)

;; extern const char *git_tree_entry_name(const git_tree_entry *entry);
(define ~git_tree_entry_name #f)
(define (git_tree_entry_name entry)
  (unless
    ~git_tree_entry_name
    (set! ~git_tree_entry_name
      (fh-link-proc "git_tree_entry_name" '* (list '*))))
  (let ((~entry (unwrap-git_tree_entry* entry)))
    (~git_tree_entry_name ~entry)))
(export git_tree_entry_name)

;; extern const git_oid *git_tree_entry_id(const git_tree_entry *entry);
(define ~git_tree_entry_id #f)
(define (git_tree_entry_id entry)
  (unless
    ~git_tree_entry_id
    (set! ~git_tree_entry_id
      (fh-link-proc "git_tree_entry_id" '* (list '*))))
  (let ((~entry (unwrap-git_tree_entry* entry)))
    (wrap-git_oid* (~git_tree_entry_id ~entry))))
(export git_tree_entry_id)

;; extern git_otype git_tree_entry_type(const git_tree_entry *entry);
(define ~git_tree_entry_type #f)
(define (git_tree_entry_type entry)
  (unless
    ~git_tree_entry_type
    (set! ~git_tree_entry_type
      (fh-link-proc
        "git_tree_entry_type"
        ffi:int
        (list '*))))
  (let ((~entry (unwrap-git_tree_entry* entry)))
    (~git_tree_entry_type ~entry)))
(export git_tree_entry_type)

;; extern git_filemode_t git_tree_entry_filemode(const git_tree_entry *entry);
(define ~git_tree_entry_filemode #f)
(define (git_tree_entry_filemode entry)
  (unless
    ~git_tree_entry_filemode
    (set! ~git_tree_entry_filemode
      (fh-link-proc
        "git_tree_entry_filemode"
        ffi:int
        (list '*))))
  (let ((~entry (unwrap-git_tree_entry* entry)))
    (~git_tree_entry_filemode ~entry)))
(export git_tree_entry_filemode)

;; extern git_filemode_t git_tree_entry_filemode_raw(const git_tree_entry *
;;     entry);
(define ~git_tree_entry_filemode_raw #f)
(define (git_tree_entry_filemode_raw entry)
  (unless
    ~git_tree_entry_filemode_raw
    (set! ~git_tree_entry_filemode_raw
      (fh-link-proc
        "git_tree_entry_filemode_raw"
        ffi:int
        (list '*))))
  (let ((~entry (unwrap-git_tree_entry* entry)))
    (~git_tree_entry_filemode_raw ~entry)))
(export git_tree_entry_filemode_raw)

;; extern int git_tree_entry_cmp(const git_tree_entry *e1, const git_tree_entry
;;      *e2);
(define ~git_tree_entry_cmp #f)
(define (git_tree_entry_cmp e1 e2)
  (unless
    ~git_tree_entry_cmp
    (set! ~git_tree_entry_cmp
      (fh-link-proc
        "git_tree_entry_cmp"
        ffi:int
        (list '* '*))))
  (let ((~e1 (unwrap-git_tree_entry* e1))
        (~e2 (unwrap-git_tree_entry* e2)))
    (~git_tree_entry_cmp ~e1 ~e2)))
(export git_tree_entry_cmp)

;; extern int git_tree_entry_to_object(git_object **object_out, git_repository 
;;     *repo, const git_tree_entry *entry);
(define ~git_tree_entry_to_object #f)
(define (git_tree_entry_to_object object_out repo entry)
  (unless
    ~git_tree_entry_to_object
    (set! ~git_tree_entry_to_object
      (fh-link-proc
        "git_tree_entry_to_object"
        ffi:int
        (list '* '* '*))))
  (let ((~object_out (unwrap~pointer object_out))
        (~repo (unwrap-git_repository* repo))
        (~entry (unwrap-git_tree_entry* entry)))
    (~git_tree_entry_to_object
      ~object_out
      ~repo
      ~entry)))
(export git_tree_entry_to_object)

;; extern int git_treebuilder_new(git_treebuilder **out, git_repository *repo, 
;;     const git_tree *source);
(define ~git_treebuilder_new #f)
(define (git_treebuilder_new out repo source)
  (unless
    ~git_treebuilder_new
    (set! ~git_treebuilder_new
      (fh-link-proc
        "git_treebuilder_new"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo))
        (~source (unwrap-git_tree* source)))
    (~git_treebuilder_new ~out ~repo ~source)))
(export git_treebuilder_new)

;; extern void git_treebuilder_clear(git_treebuilder *bld);
(define ~git_treebuilder_clear #f)
(define (git_treebuilder_clear bld)
  (unless
    ~git_treebuilder_clear
    (set! ~git_treebuilder_clear
      (fh-link-proc
        "git_treebuilder_clear"
        ffi:void
        (list '*))))
  (let ((~bld (unwrap-git_treebuilder* bld)))
    (~git_treebuilder_clear ~bld)))
(export git_treebuilder_clear)

;; extern unsigned int git_treebuilder_entrycount(git_treebuilder *bld);
(define ~git_treebuilder_entrycount #f)
(define (git_treebuilder_entrycount bld)
  (unless
    ~git_treebuilder_entrycount
    (set! ~git_treebuilder_entrycount
      (fh-link-proc
        "git_treebuilder_entrycount"
        ffi:unsigned-int
        (list '*))))
  (let ((~bld (unwrap-git_treebuilder* bld)))
    (~git_treebuilder_entrycount ~bld)))
(export git_treebuilder_entrycount)

;; extern void git_treebuilder_free(git_treebuilder *bld);
(define ~git_treebuilder_free #f)
(define (git_treebuilder_free bld)
  (unless
    ~git_treebuilder_free
    (set! ~git_treebuilder_free
      (fh-link-proc
        "git_treebuilder_free"
        ffi:void
        (list '*))))
  (let ((~bld (unwrap-git_treebuilder* bld)))
    (~git_treebuilder_free ~bld)))
(export git_treebuilder_free)

;; extern const git_tree_entry *git_treebuilder_get(git_treebuilder *bld, const
;;      char *filename);
(define ~git_treebuilder_get #f)
(define (git_treebuilder_get bld filename)
  (unless
    ~git_treebuilder_get
    (set! ~git_treebuilder_get
      (fh-link-proc
        "git_treebuilder_get"
        '*
        (list '* '*))))
  (let ((~bld (unwrap-git_treebuilder* bld))
        (~filename (unwrap~pointer filename)))
    (wrap-git_tree_entry*
      (~git_treebuilder_get ~bld ~filename))))
(export git_treebuilder_get)

;; extern int git_treebuilder_insert(const git_tree_entry **out, 
;;     git_treebuilder *bld, const char *filename, const git_oid *id, 
;;     git_filemode_t filemode);
(define ~git_treebuilder_insert #f)
(define (git_treebuilder_insert
         out
         bld
         filename
         id
         filemode)
  (unless
    ~git_treebuilder_insert
    (set! ~git_treebuilder_insert
      (fh-link-proc
        "git_treebuilder_insert"
        ffi:int
        (list '* '* '* '* ffi:int))))
  (let ((~out (unwrap~pointer out))
        (~bld (unwrap-git_treebuilder* bld))
        (~filename (unwrap~pointer filename))
        (~id (unwrap-git_oid* id))
        (~filemode (unwrap~fixed filemode)))
    (~git_treebuilder_insert
      ~out
      ~bld
      ~filename
      ~id
      ~filemode)))
(export git_treebuilder_insert)

;; extern int git_treebuilder_remove(git_treebuilder *bld, const char *filename
;;     );
(define ~git_treebuilder_remove #f)
(define (git_treebuilder_remove bld filename)
  (unless
    ~git_treebuilder_remove
    (set! ~git_treebuilder_remove
      (fh-link-proc
        "git_treebuilder_remove"
        ffi:int
        (list '* '*))))
  (let ((~bld (unwrap-git_treebuilder* bld))
        (~filename (unwrap~pointer filename)))
    (~git_treebuilder_remove ~bld ~filename)))
(export git_treebuilder_remove)

;; typedef int (*git_treebuilder_filter_cb)(const git_tree_entry *entry, void *
;;     payload);
(define-fh-function/p git_treebuilder_filter_cb
  ffi:int (list (quote *) (quote *)))

;; extern void git_treebuilder_filter(git_treebuilder *bld, 
;;     git_treebuilder_filter_cb filter, void *payload);
(define ~git_treebuilder_filter #f)
(define (git_treebuilder_filter bld filter payload)
  (unless
    ~git_treebuilder_filter
    (set! ~git_treebuilder_filter
      (fh-link-proc
        "git_treebuilder_filter"
        ffi:void
        (list '* '* '*))))
  (let ((~bld (unwrap-git_treebuilder* bld))
        (~filter
          ((make-ftn-arg-unwrapper ffi:int (list '* '*))
           filter))
        (~payload (unwrap~pointer payload)))
    (~git_treebuilder_filter ~bld ~filter ~payload)))
(export git_treebuilder_filter)

;; extern int git_treebuilder_write(git_oid *id, git_treebuilder *bld);
(define ~git_treebuilder_write #f)
(define (git_treebuilder_write id bld)
  (unless
    ~git_treebuilder_write
    (set! ~git_treebuilder_write
      (fh-link-proc
        "git_treebuilder_write"
        ffi:int
        (list '* '*))))
  (let ((~id (unwrap-git_oid* id))
        (~bld (unwrap-git_treebuilder* bld)))
    (~git_treebuilder_write ~id ~bld)))
(export git_treebuilder_write)

;; extern int git_treebuilder_write_with_buffer(git_oid *oid, git_treebuilder *
;;     bld, git_buf *tree);
(define ~git_treebuilder_write_with_buffer #f)
(define (git_treebuilder_write_with_buffer oid bld tree)
  (unless
    ~git_treebuilder_write_with_buffer
    (set! ~git_treebuilder_write_with_buffer
      (fh-link-proc
        "git_treebuilder_write_with_buffer"
        ffi:int
        (list '* '* '*))))
  (let ((~oid (unwrap-git_oid* oid))
        (~bld (unwrap-git_treebuilder* bld))
        (~tree (unwrap-git_buf* tree)))
    (~git_treebuilder_write_with_buffer
      ~oid
      ~bld
      ~tree)))
(export git_treebuilder_write_with_buffer)

;; typedef int (*git_treewalk_cb)(const char *root, const git_tree_entry *entry
;;     , void *payload);
(define-fh-function/p git_treewalk_cb
  ffi:int (list (quote *) (quote *) (quote *)))

;; typedef enum {
;;   GIT_TREEWALK_PRE = 0,
;;   GIT_TREEWALK_POST = 1,
;; } git_treewalk_mode;
(define-fh-enum git_treewalk_mode
  '((GIT_TREEWALK_PRE . 0) (GIT_TREEWALK_POST . 1))
  )

;; extern int git_tree_walk(const git_tree *tree, git_treewalk_mode mode, 
;;     git_treewalk_cb callback, void *payload);
(define ~git_tree_walk #f)
(define (git_tree_walk tree mode callback payload)
  (unless
    ~git_tree_walk
    (set! ~git_tree_walk
      (fh-link-proc
        "git_tree_walk"
        ffi:int
        (list '* ffi:int '* '*))))
  (let ((~tree (unwrap-git_tree* tree))
        (~mode (unwrap~fixed mode))
        (~callback
          ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
           callback))
        (~payload (unwrap~pointer payload)))
    (~git_tree_walk ~tree ~mode ~callback ~payload)))
(export git_tree_walk)

;; extern int git_tree_dup(git_tree **out, git_tree *source);
(define ~git_tree_dup #f)
(define (git_tree_dup out source)
  (unless
    ~git_tree_dup
    (set! ~git_tree_dup
      (fh-link-proc
        "git_tree_dup"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~source (unwrap-git_tree* source)))
    (~git_tree_dup ~out ~source)))
(export git_tree_dup)

;; typedef enum {
;;   GIT_TREE_UPDATE_UPSERT,
;;   GIT_TREE_UPDATE_REMOVE,
;; } git_tree_update_t;
(define-fh-enum git_tree_update_t
  '((GIT_TREE_UPDATE_UPSERT . 0)
    (GIT_TREE_UPDATE_REMOVE . 1))
  )

;; typedef struct {
;;   /** Update action. If it's an removal, only the path is looked at */
;;   git_tree_update_t action;
;;   /** The entry's id */
;;   git_oid id;
;;   /** The filemode/kind of object */
;;   git_filemode_t filemode;
;;   /** The full path from the root tree */
;;   const char *path;
;; } git_tree_update;
(define git_tree_update-desc
  (bs:struct
    (list `(action ,int)
          `(id ,git_oid-desc)
          `(filemode ,int)
          `(path ,(bs:pointer int)))))
(export git_tree_update-desc)
(define-fh-compound-type/p git_tree_update git_tree_update-desc)

;; extern int git_tree_create_updated(git_oid *out, git_repository *repo, 
;;     git_tree *baseline, size_t nupdates, const git_tree_update *updates);
(define ~git_tree_create_updated #f)
(define (git_tree_create_updated
         out
         repo
         baseline
         nupdates
         updates)
  (unless
    ~git_tree_create_updated
    (set! ~git_tree_create_updated
      (fh-link-proc
        "git_tree_create_updated"
        ffi:int
        (list '* '* '* ffi:size_t '*))))
  (let ((~out (unwrap-git_oid* out))
        (~repo (unwrap-git_repository* repo))
        (~baseline (unwrap-git_tree* baseline))
        (~nupdates (unwrap~fixed nupdates))
        (~updates (unwrap-git_tree_update* updates)))
    (~git_tree_create_updated
      ~out
      ~repo
      ~baseline
      ~nupdates
      ~updates)))
(export git_tree_create_updated)

;; typedef struct git_strarray {
;;   char **strings;
;;   size_t count;
;; } git_strarray;
(define git_strarray-desc
  (bs:struct
    (list `(strings ,(bs:pointer (bs:pointer int)))
          `(count ,size_t))))
(export git_strarray-desc)
(define-fh-compound-type/p git_strarray git_strarray-desc)
(define struct-git_strarray git_strarray)

;; extern void git_strarray_free(git_strarray *array);
(define ~git_strarray_free #f)
(define (git_strarray_free array)
  (unless
    ~git_strarray_free
    (set! ~git_strarray_free
      (fh-link-proc
        "git_strarray_free"
        ffi:void
        (list '*))))
  (let ((~array (unwrap-git_strarray* array)))
    (~git_strarray_free ~array)))
(export git_strarray_free)

;; extern int git_strarray_copy(git_strarray *tgt, const git_strarray *src);
(define ~git_strarray_copy #f)
(define (git_strarray_copy tgt src)
  (unless
    ~git_strarray_copy
    (set! ~git_strarray_copy
      (fh-link-proc
        "git_strarray_copy"
        ffi:int
        (list '* '*))))
  (let ((~tgt (unwrap-git_strarray* tgt))
        (~src (unwrap-git_strarray* src)))
    (~git_strarray_copy ~tgt ~src)))
(export git_strarray_copy)

;; extern int git_reference_lookup(git_reference **out, git_repository *repo, 
;;     const char *name);
(define ~git_reference_lookup #f)
(define (git_reference_lookup out repo name)
  (unless
    ~git_reference_lookup
    (set! ~git_reference_lookup
      (fh-link-proc
        "git_reference_lookup"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo))
        (~name (unwrap~pointer name)))
    (~git_reference_lookup ~out ~repo ~name)))
(export git_reference_lookup)

;; extern int git_reference_name_to_id(git_oid *out, git_repository *repo, 
;;     const char *name);
(define ~git_reference_name_to_id #f)
(define (git_reference_name_to_id out repo name)
  (unless
    ~git_reference_name_to_id
    (set! ~git_reference_name_to_id
      (fh-link-proc
        "git_reference_name_to_id"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap-git_oid* out))
        (~repo (unwrap-git_repository* repo))
        (~name (unwrap~pointer name)))
    (~git_reference_name_to_id ~out ~repo ~name)))
(export git_reference_name_to_id)

;; extern int git_reference_dwim(git_reference **out, git_repository *repo, 
;;     const char *shorthand);
(define ~git_reference_dwim #f)
(define (git_reference_dwim out repo shorthand)
  (unless
    ~git_reference_dwim
    (set! ~git_reference_dwim
      (fh-link-proc
        "git_reference_dwim"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo))
        (~shorthand (unwrap~pointer shorthand)))
    (~git_reference_dwim ~out ~repo ~shorthand)))
(export git_reference_dwim)

;; extern int git_reference_symbolic_create_matching(git_reference **out, 
;;     git_repository *repo, const char *name, const char *target, int force, 
;;     const char *current_value, const char *log_message);
(define ~git_reference_symbolic_create_matching #f)
(define (git_reference_symbolic_create_matching
         out
         repo
         name
         target
         force
         current_value
         log_message)
  (unless
    ~git_reference_symbolic_create_matching
    (set! ~git_reference_symbolic_create_matching
      (fh-link-proc
        "git_reference_symbolic_create_matching"
        ffi:int
        (list '* '* '* '* ffi:int '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo))
        (~name (unwrap~pointer name))
        (~target (unwrap~pointer target))
        (~force (unwrap~fixed force))
        (~current_value (unwrap~pointer current_value))
        (~log_message (unwrap~pointer log_message)))
    (~git_reference_symbolic_create_matching
      ~out
      ~repo
      ~name
      ~target
      ~force
      ~current_value
      ~log_message)))
(export git_reference_symbolic_create_matching)

;; extern int git_reference_symbolic_create(git_reference **out, git_repository
;;      *repo, const char *name, const char *target, int force, const char *
;;     log_message);
(define ~git_reference_symbolic_create #f)
(define (git_reference_symbolic_create
         out
         repo
         name
         target
         force
         log_message)
  (unless
    ~git_reference_symbolic_create
    (set! ~git_reference_symbolic_create
      (fh-link-proc
        "git_reference_symbolic_create"
        ffi:int
        (list '* '* '* '* ffi:int '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo))
        (~name (unwrap~pointer name))
        (~target (unwrap~pointer target))
        (~force (unwrap~fixed force))
        (~log_message (unwrap~pointer log_message)))
    (~git_reference_symbolic_create
      ~out
      ~repo
      ~name
      ~target
      ~force
      ~log_message)))
(export git_reference_symbolic_create)

;; extern int git_reference_create(git_reference **out, git_repository *repo, 
;;     const char *name, const git_oid *id, int force, const char *log_message)
;;     ;
(define ~git_reference_create #f)
(define (git_reference_create
         out
         repo
         name
         id
         force
         log_message)
  (unless
    ~git_reference_create
    (set! ~git_reference_create
      (fh-link-proc
        "git_reference_create"
        ffi:int
        (list '* '* '* '* ffi:int '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo))
        (~name (unwrap~pointer name))
        (~id (unwrap-git_oid* id))
        (~force (unwrap~fixed force))
        (~log_message (unwrap~pointer log_message)))
    (~git_reference_create
      ~out
      ~repo
      ~name
      ~id
      ~force
      ~log_message)))
(export git_reference_create)

;; extern int git_reference_create_matching(git_reference **out, git_repository
;;      *repo, const char *name, const git_oid *id, int force, const git_oid *
;;     current_id, const char *log_message);
(define ~git_reference_create_matching #f)
(define (git_reference_create_matching
         out
         repo
         name
         id
         force
         current_id
         log_message)
  (unless
    ~git_reference_create_matching
    (set! ~git_reference_create_matching
      (fh-link-proc
        "git_reference_create_matching"
        ffi:int
        (list '* '* '* '* ffi:int '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo))
        (~name (unwrap~pointer name))
        (~id (unwrap-git_oid* id))
        (~force (unwrap~fixed force))
        (~current_id (unwrap-git_oid* current_id))
        (~log_message (unwrap~pointer log_message)))
    (~git_reference_create_matching
      ~out
      ~repo
      ~name
      ~id
      ~force
      ~current_id
      ~log_message)))
(export git_reference_create_matching)

;; extern const git_oid *git_reference_target(const git_reference *ref);
(define ~git_reference_target #f)
(define (git_reference_target ref)
  (unless
    ~git_reference_target
    (set! ~git_reference_target
      (fh-link-proc
        "git_reference_target"
        '*
        (list '*))))
  (let ((~ref (unwrap-git_reference* ref)))
    (wrap-git_oid* (~git_reference_target ~ref))))
(export git_reference_target)

;; extern const git_oid *git_reference_target_peel(const git_reference *ref);
(define ~git_reference_target_peel #f)
(define (git_reference_target_peel ref)
  (unless
    ~git_reference_target_peel
    (set! ~git_reference_target_peel
      (fh-link-proc
        "git_reference_target_peel"
        '*
        (list '*))))
  (let ((~ref (unwrap-git_reference* ref)))
    (wrap-git_oid* (~git_reference_target_peel ~ref))))
(export git_reference_target_peel)

;; extern const char *git_reference_symbolic_target(const git_reference *ref);
(define ~git_reference_symbolic_target #f)
(define (git_reference_symbolic_target ref)
  (unless
    ~git_reference_symbolic_target
    (set! ~git_reference_symbolic_target
      (fh-link-proc
        "git_reference_symbolic_target"
        '*
        (list '*))))
  (let ((~ref (unwrap-git_reference* ref)))
    (~git_reference_symbolic_target ~ref)))
(export git_reference_symbolic_target)

;; extern git_ref_t git_reference_type(const git_reference *ref);
(define ~git_reference_type #f)
(define (git_reference_type ref)
  (unless
    ~git_reference_type
    (set! ~git_reference_type
      (fh-link-proc
        "git_reference_type"
        ffi:int
        (list '*))))
  (let ((~ref (unwrap-git_reference* ref)))
    (~git_reference_type ~ref)))
(export git_reference_type)

;; extern const char *git_reference_name(const git_reference *ref);
(define ~git_reference_name #f)
(define (git_reference_name ref)
  (unless
    ~git_reference_name
    (set! ~git_reference_name
      (fh-link-proc "git_reference_name" '* (list '*))))
  (let ((~ref (unwrap-git_reference* ref)))
    (~git_reference_name ~ref)))
(export git_reference_name)

;; extern int git_reference_resolve(git_reference **out, const git_reference *
;;     ref);
(define ~git_reference_resolve #f)
(define (git_reference_resolve out ref)
  (unless
    ~git_reference_resolve
    (set! ~git_reference_resolve
      (fh-link-proc
        "git_reference_resolve"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~ref (unwrap-git_reference* ref)))
    (~git_reference_resolve ~out ~ref)))
(export git_reference_resolve)

;; extern git_repository *git_reference_owner(const git_reference *ref);
(define ~git_reference_owner #f)
(define (git_reference_owner ref)
  (unless
    ~git_reference_owner
    (set! ~git_reference_owner
      (fh-link-proc "git_reference_owner" '* (list '*))))
  (let ((~ref (unwrap-git_reference* ref)))
    (wrap-git_repository*
      (~git_reference_owner ~ref))))
(export git_reference_owner)

;; extern int git_reference_symbolic_set_target(git_reference **out, 
;;     git_reference *ref, const char *target, const char *log_message);
(define ~git_reference_symbolic_set_target #f)
(define (git_reference_symbolic_set_target
         out
         ref
         target
         log_message)
  (unless
    ~git_reference_symbolic_set_target
    (set! ~git_reference_symbolic_set_target
      (fh-link-proc
        "git_reference_symbolic_set_target"
        ffi:int
        (list '* '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~ref (unwrap-git_reference* ref))
        (~target (unwrap~pointer target))
        (~log_message (unwrap~pointer log_message)))
    (~git_reference_symbolic_set_target
      ~out
      ~ref
      ~target
      ~log_message)))
(export git_reference_symbolic_set_target)

;; extern int git_reference_set_target(git_reference **out, git_reference *ref
;;     , const git_oid *id, const char *log_message);
(define ~git_reference_set_target #f)
(define (git_reference_set_target out ref id log_message)
  (unless
    ~git_reference_set_target
    (set! ~git_reference_set_target
      (fh-link-proc
        "git_reference_set_target"
        ffi:int
        (list '* '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~ref (unwrap-git_reference* ref))
        (~id (unwrap-git_oid* id))
        (~log_message (unwrap~pointer log_message)))
    (~git_reference_set_target
      ~out
      ~ref
      ~id
      ~log_message)))
(export git_reference_set_target)

;; extern int git_reference_rename(git_reference **new_ref, git_reference *ref
;;     , const char *new_name, int force, const char *log_message);
(define ~git_reference_rename #f)
(define (git_reference_rename
         new_ref
         ref
         new_name
         force
         log_message)
  (unless
    ~git_reference_rename
    (set! ~git_reference_rename
      (fh-link-proc
        "git_reference_rename"
        ffi:int
        (list '* '* '* ffi:int '*))))
  (let ((~new_ref (unwrap~pointer new_ref))
        (~ref (unwrap-git_reference* ref))
        (~new_name (unwrap~pointer new_name))
        (~force (unwrap~fixed force))
        (~log_message (unwrap~pointer log_message)))
    (~git_reference_rename
      ~new_ref
      ~ref
      ~new_name
      ~force
      ~log_message)))
(export git_reference_rename)

;; extern int git_reference_delete(git_reference *ref);
(define ~git_reference_delete #f)
(define (git_reference_delete ref)
  (unless
    ~git_reference_delete
    (set! ~git_reference_delete
      (fh-link-proc
        "git_reference_delete"
        ffi:int
        (list '*))))
  (let ((~ref (unwrap-git_reference* ref)))
    (~git_reference_delete ~ref)))
(export git_reference_delete)

;; extern int git_reference_remove(git_repository *repo, const char *name);
(define ~git_reference_remove #f)
(define (git_reference_remove repo name)
  (unless
    ~git_reference_remove
    (set! ~git_reference_remove
      (fh-link-proc
        "git_reference_remove"
        ffi:int
        (list '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~name (unwrap~pointer name)))
    (~git_reference_remove ~repo ~name)))
(export git_reference_remove)

;; extern int git_reference_list(git_strarray *array, git_repository *repo);
(define ~git_reference_list #f)
(define (git_reference_list array repo)
  (unless
    ~git_reference_list
    (set! ~git_reference_list
      (fh-link-proc
        "git_reference_list"
        ffi:int
        (list '* '*))))
  (let ((~array (unwrap-git_strarray* array))
        (~repo (unwrap-git_repository* repo)))
    (~git_reference_list ~array ~repo)))
(export git_reference_list)

;; typedef int (*git_reference_foreach_cb)(git_reference *reference, void *
;;     payload);
(define-fh-function/p git_reference_foreach_cb
  ffi:int (list (quote *) (quote *)))

;; typedef int (*git_reference_foreach_name_cb)(const char *name, void *payload
;;     );
(define-fh-function/p git_reference_foreach_name_cb
  ffi:int (list (quote *) (quote *)))

;; extern int git_reference_foreach(git_repository *repo, 
;;     git_reference_foreach_cb callback, void *payload);
(define ~git_reference_foreach #f)
(define (git_reference_foreach repo callback payload)
  (unless
    ~git_reference_foreach
    (set! ~git_reference_foreach
      (fh-link-proc
        "git_reference_foreach"
        ffi:int
        (list '* '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~callback
          ((make-ftn-arg-unwrapper ffi:int (list '* '*))
           callback))
        (~payload (unwrap~pointer payload)))
    (~git_reference_foreach ~repo ~callback ~payload)))
(export git_reference_foreach)

;; extern int git_reference_foreach_name(git_repository *repo, 
;;     git_reference_foreach_name_cb callback, void *payload);
(define ~git_reference_foreach_name #f)
(define (git_reference_foreach_name
         repo
         callback
         payload)
  (unless
    ~git_reference_foreach_name
    (set! ~git_reference_foreach_name
      (fh-link-proc
        "git_reference_foreach_name"
        ffi:int
        (list '* '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~callback
          ((make-ftn-arg-unwrapper ffi:int (list '* '*))
           callback))
        (~payload (unwrap~pointer payload)))
    (~git_reference_foreach_name
      ~repo
      ~callback
      ~payload)))
(export git_reference_foreach_name)

;; extern int git_reference_dup(git_reference **dest, git_reference *source);
(define ~git_reference_dup #f)
(define (git_reference_dup dest source)
  (unless
    ~git_reference_dup
    (set! ~git_reference_dup
      (fh-link-proc
        "git_reference_dup"
        ffi:int
        (list '* '*))))
  (let ((~dest (unwrap~pointer dest))
        (~source (unwrap-git_reference* source)))
    (~git_reference_dup ~dest ~source)))
(export git_reference_dup)

;; extern void git_reference_free(git_reference *ref);
(define ~git_reference_free #f)
(define (git_reference_free ref)
  (unless
    ~git_reference_free
    (set! ~git_reference_free
      (fh-link-proc
        "git_reference_free"
        ffi:void
        (list '*))))
  (let ((~ref (unwrap-git_reference* ref)))
    (~git_reference_free ~ref)))
(export git_reference_free)

;; extern int git_reference_cmp(const git_reference *ref1, const git_reference 
;;     *ref2);
(define ~git_reference_cmp #f)
(define (git_reference_cmp ref1 ref2)
  (unless
    ~git_reference_cmp
    (set! ~git_reference_cmp
      (fh-link-proc
        "git_reference_cmp"
        ffi:int
        (list '* '*))))
  (let ((~ref1 (unwrap-git_reference* ref1))
        (~ref2 (unwrap-git_reference* ref2)))
    (~git_reference_cmp ~ref1 ~ref2)))
(export git_reference_cmp)

;; extern int git_reference_iterator_new(git_reference_iterator **out, 
;;     git_repository *repo);
(define ~git_reference_iterator_new #f)
(define (git_reference_iterator_new out repo)
  (unless
    ~git_reference_iterator_new
    (set! ~git_reference_iterator_new
      (fh-link-proc
        "git_reference_iterator_new"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo)))
    (~git_reference_iterator_new ~out ~repo)))
(export git_reference_iterator_new)

;; extern int git_reference_iterator_glob_new(git_reference_iterator **out, 
;;     git_repository *repo, const char *glob);
(define ~git_reference_iterator_glob_new #f)
(define (git_reference_iterator_glob_new out repo glob)
  (unless
    ~git_reference_iterator_glob_new
    (set! ~git_reference_iterator_glob_new
      (fh-link-proc
        "git_reference_iterator_glob_new"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo))
        (~glob (unwrap~pointer glob)))
    (~git_reference_iterator_glob_new
      ~out
      ~repo
      ~glob)))
(export git_reference_iterator_glob_new)

;; extern int git_reference_next(git_reference **out, git_reference_iterator *
;;     iter);
(define ~git_reference_next #f)
(define (git_reference_next out iter)
  (unless
    ~git_reference_next
    (set! ~git_reference_next
      (fh-link-proc
        "git_reference_next"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~iter (unwrap-git_reference_iterator* iter)))
    (~git_reference_next ~out ~iter)))
(export git_reference_next)

;; extern int git_reference_next_name(const char **out, git_reference_iterator 
;;     *iter);
(define ~git_reference_next_name #f)
(define (git_reference_next_name out iter)
  (unless
    ~git_reference_next_name
    (set! ~git_reference_next_name
      (fh-link-proc
        "git_reference_next_name"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~iter (unwrap-git_reference_iterator* iter)))
    (~git_reference_next_name ~out ~iter)))
(export git_reference_next_name)

;; extern void git_reference_iterator_free(git_reference_iterator *iter);
(define ~git_reference_iterator_free #f)
(define (git_reference_iterator_free iter)
  (unless
    ~git_reference_iterator_free
    (set! ~git_reference_iterator_free
      (fh-link-proc
        "git_reference_iterator_free"
        ffi:void
        (list '*))))
  (let ((~iter (unwrap-git_reference_iterator* iter)))
    (~git_reference_iterator_free ~iter)))
(export git_reference_iterator_free)

;; extern int git_reference_foreach_glob(git_repository *repo, const char *glob
;;     , git_reference_foreach_name_cb callback, void *payload);
(define ~git_reference_foreach_glob #f)
(define (git_reference_foreach_glob
         repo
         glob
         callback
         payload)
  (unless
    ~git_reference_foreach_glob
    (set! ~git_reference_foreach_glob
      (fh-link-proc
        "git_reference_foreach_glob"
        ffi:int
        (list '* '* '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~glob (unwrap~pointer glob))
        (~callback
          ((make-ftn-arg-unwrapper ffi:int (list '* '*))
           callback))
        (~payload (unwrap~pointer payload)))
    (~git_reference_foreach_glob
      ~repo
      ~glob
      ~callback
      ~payload)))
(export git_reference_foreach_glob)

;; extern int git_reference_has_log(git_repository *repo, const char *refname)
;;     ;
(define ~git_reference_has_log #f)
(define (git_reference_has_log repo refname)
  (unless
    ~git_reference_has_log
    (set! ~git_reference_has_log
      (fh-link-proc
        "git_reference_has_log"
        ffi:int
        (list '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~refname (unwrap~pointer refname)))
    (~git_reference_has_log ~repo ~refname)))
(export git_reference_has_log)

;; extern int git_reference_ensure_log(git_repository *repo, const char *
;;     refname);
(define ~git_reference_ensure_log #f)
(define (git_reference_ensure_log repo refname)
  (unless
    ~git_reference_ensure_log
    (set! ~git_reference_ensure_log
      (fh-link-proc
        "git_reference_ensure_log"
        ffi:int
        (list '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~refname (unwrap~pointer refname)))
    (~git_reference_ensure_log ~repo ~refname)))
(export git_reference_ensure_log)

;; extern int git_reference_is_branch(const git_reference *ref);
(define ~git_reference_is_branch #f)
(define (git_reference_is_branch ref)
  (unless
    ~git_reference_is_branch
    (set! ~git_reference_is_branch
      (fh-link-proc
        "git_reference_is_branch"
        ffi:int
        (list '*))))
  (let ((~ref (unwrap-git_reference* ref)))
    (~git_reference_is_branch ~ref)))
(export git_reference_is_branch)

;; extern int git_reference_is_remote(const git_reference *ref);
(define ~git_reference_is_remote #f)
(define (git_reference_is_remote ref)
  (unless
    ~git_reference_is_remote
    (set! ~git_reference_is_remote
      (fh-link-proc
        "git_reference_is_remote"
        ffi:int
        (list '*))))
  (let ((~ref (unwrap-git_reference* ref)))
    (~git_reference_is_remote ~ref)))
(export git_reference_is_remote)

;; extern int git_reference_is_tag(const git_reference *ref);
(define ~git_reference_is_tag #f)
(define (git_reference_is_tag ref)
  (unless
    ~git_reference_is_tag
    (set! ~git_reference_is_tag
      (fh-link-proc
        "git_reference_is_tag"
        ffi:int
        (list '*))))
  (let ((~ref (unwrap-git_reference* ref)))
    (~git_reference_is_tag ~ref)))
(export git_reference_is_tag)

;; extern int git_reference_is_note(const git_reference *ref);
(define ~git_reference_is_note #f)
(define (git_reference_is_note ref)
  (unless
    ~git_reference_is_note
    (set! ~git_reference_is_note
      (fh-link-proc
        "git_reference_is_note"
        ffi:int
        (list '*))))
  (let ((~ref (unwrap-git_reference* ref)))
    (~git_reference_is_note ~ref)))
(export git_reference_is_note)

;; typedef enum {
;;   GIT_REF_FORMAT_NORMAL = 0u,
;;   GIT_REF_FORMAT_ALLOW_ONELEVEL = 1u<<0,
;;   GIT_REF_FORMAT_REFSPEC_PATTERN = 1u<<1,
;;   GIT_REF_FORMAT_REFSPEC_SHORTHAND = 1u<<2,
;; } git_reference_normalize_t;
(define-fh-enum git_reference_normalize_t
  '((GIT_REF_FORMAT_NORMAL . 0)
    (GIT_REF_FORMAT_ALLOW_ONELEVEL . 1)
    (GIT_REF_FORMAT_REFSPEC_PATTERN . 2)
    (GIT_REF_FORMAT_REFSPEC_SHORTHAND . 4))
  )

;; extern int git_reference_normalize_name(char *buffer_out, size_t buffer_size
;;     , const char *name, unsigned int flags);
(define ~git_reference_normalize_name #f)
(define (git_reference_normalize_name
         buffer_out
         buffer_size
         name
         flags)
  (unless
    ~git_reference_normalize_name
    (set! ~git_reference_normalize_name
      (fh-link-proc
        "git_reference_normalize_name"
        ffi:int
        (list '* ffi:size_t '* ffi:unsigned-int))))
  (let ((~buffer_out (unwrap~pointer buffer_out))
        (~buffer_size (unwrap~fixed buffer_size))
        (~name (unwrap~pointer name))
        (~flags (unwrap~fixed flags)))
    (~git_reference_normalize_name
      ~buffer_out
      ~buffer_size
      ~name
      ~flags)))
(export git_reference_normalize_name)

;; extern int git_reference_peel(git_object **out, git_reference *ref, 
;;     git_otype type);
(define ~git_reference_peel #f)
(define (git_reference_peel out ref type)
  (unless
    ~git_reference_peel
    (set! ~git_reference_peel
      (fh-link-proc
        "git_reference_peel"
        ffi:int
        (list '* '* ffi:int))))
  (let ((~out (unwrap~pointer out))
        (~ref (unwrap-git_reference* ref))
        (~type (unwrap~fixed type)))
    (~git_reference_peel ~out ~ref ~type)))
(export git_reference_peel)

;; extern int git_reference_is_valid_name(const char *refname);
(define ~git_reference_is_valid_name #f)
(define (git_reference_is_valid_name refname)
  (unless
    ~git_reference_is_valid_name
    (set! ~git_reference_is_valid_name
      (fh-link-proc
        "git_reference_is_valid_name"
        ffi:int
        (list '*))))
  (let ((~refname (unwrap~pointer refname)))
    (~git_reference_is_valid_name ~refname)))
(export git_reference_is_valid_name)

;; extern const char *git_reference_shorthand(const git_reference *ref);
(define ~git_reference_shorthand #f)
(define (git_reference_shorthand ref)
  (unless
    ~git_reference_shorthand
    (set! ~git_reference_shorthand
      (fh-link-proc
        "git_reference_shorthand"
        '*
        (list '*))))
  (let ((~ref (unwrap-git_reference* ref)))
    (~git_reference_shorthand ~ref)))
(export git_reference_shorthand)

;; typedef enum {
;;   GIT_DIFF_NORMAL = 0,
;;   GIT_DIFF_REVERSE = 1u<<0,
;;   GIT_DIFF_INCLUDE_IGNORED = 1u<<1,
;;   GIT_DIFF_RECURSE_IGNORED_DIRS = 1u<<2,
;;   GIT_DIFF_INCLUDE_UNTRACKED = 1u<<3,
;;   GIT_DIFF_RECURSE_UNTRACKED_DIRS = 1u<<4,
;;   GIT_DIFF_INCLUDE_UNMODIFIED = 1u<<5,
;;   GIT_DIFF_INCLUDE_TYPECHANGE = 1u<<6,
;;   GIT_DIFF_INCLUDE_TYPECHANGE_TREES = 1u<<7,
;;   GIT_DIFF_IGNORE_FILEMODE = 1u<<8,
;;   GIT_DIFF_IGNORE_SUBMODULES = 1u<<9,
;;   GIT_DIFF_IGNORE_CASE = 1u<<10,
;;   GIT_DIFF_INCLUDE_CASECHANGE = 1u<<11,
;;   GIT_DIFF_DISABLE_PATHSPEC_MATCH = 1u<<12,
;;   GIT_DIFF_SKIP_BINARY_CHECK = 1u<<13,
;;   GIT_DIFF_ENABLE_FAST_UNTRACKED_DIRS = 1u<<14,
;;   GIT_DIFF_UPDATE_INDEX = 1u<<15,
;;   GIT_DIFF_INCLUDE_UNREADABLE = 1u<<16,
;;   GIT_DIFF_INCLUDE_UNREADABLE_AS_UNTRACKED = 1u<<17,
;;   GIT_DIFF_FORCE_TEXT = 1u<<20,
;;   GIT_DIFF_FORCE_BINARY = 1u<<21,
;;   GIT_DIFF_IGNORE_WHITESPACE = 1u<<22,
;;   GIT_DIFF_IGNORE_WHITESPACE_CHANGE = 1u<<23,
;;   GIT_DIFF_IGNORE_WHITESPACE_EOL = 1u<<24,
;;   GIT_DIFF_SHOW_UNTRACKED_CONTENT = 1u<<25,
;;   GIT_DIFF_SHOW_UNMODIFIED = 1u<<26,
;;   GIT_DIFF_PATIENCE = 1u<<28,
;;   GIT_DIFF_MINIMAL = 1<<29,
;;   GIT_DIFF_SHOW_BINARY = 1<<30,
;; } git_diff_option_t;
(define-fh-enum git_diff_option_t
  '((GIT_DIFF_NORMAL . 0)
    (GIT_DIFF_REVERSE . 1)
    (GIT_DIFF_INCLUDE_IGNORED . 2)
    (GIT_DIFF_RECURSE_IGNORED_DIRS . 4)
    (GIT_DIFF_INCLUDE_UNTRACKED . 8)
    (GIT_DIFF_RECURSE_UNTRACKED_DIRS . 16)
    (GIT_DIFF_INCLUDE_UNMODIFIED . 32)
    (GIT_DIFF_INCLUDE_TYPECHANGE . 64)
    (GIT_DIFF_INCLUDE_TYPECHANGE_TREES . 128)
    (GIT_DIFF_IGNORE_FILEMODE . 256)
    (GIT_DIFF_IGNORE_SUBMODULES . 512)
    (GIT_DIFF_IGNORE_CASE . 1024)
    (GIT_DIFF_INCLUDE_CASECHANGE . 2048)
    (GIT_DIFF_DISABLE_PATHSPEC_MATCH . 4096)
    (GIT_DIFF_SKIP_BINARY_CHECK . 8192)
    (GIT_DIFF_ENABLE_FAST_UNTRACKED_DIRS . 16384)
    (GIT_DIFF_UPDATE_INDEX . 32768)
    (GIT_DIFF_INCLUDE_UNREADABLE . 65536)
    (GIT_DIFF_INCLUDE_UNREADABLE_AS_UNTRACKED
      .
      131072)
    (GIT_DIFF_FORCE_TEXT . 1048576)
    (GIT_DIFF_FORCE_BINARY . 2097152)
    (GIT_DIFF_IGNORE_WHITESPACE . 4194304)
    (GIT_DIFF_IGNORE_WHITESPACE_CHANGE . 8388608)
    (GIT_DIFF_IGNORE_WHITESPACE_EOL . 16777216)
    (GIT_DIFF_SHOW_UNTRACKED_CONTENT . 33554432)
    (GIT_DIFF_SHOW_UNMODIFIED . 67108864)
    (GIT_DIFF_PATIENCE . 268435456)
    (GIT_DIFF_MINIMAL . 536870912)
    (GIT_DIFF_SHOW_BINARY . 1073741824))
  )

;; typedef struct git_diff git_diff;
(define git_diff-desc void)
(export git_diff-desc)
(define git_diff*-desc (bs:pointer git_diff-desc))
(export git_diff*-desc)
(define-fh-pointer-type git_diff* git_diff*-desc)

;; typedef enum {
;;   GIT_DIFF_FLAG_BINARY = 1u<<0,
;;   GIT_DIFF_FLAG_NOT_BINARY = 1u<<1,
;;   GIT_DIFF_FLAG_VALID_ID = 1u<<2,
;;   GIT_DIFF_FLAG_EXISTS = 1u<<3,
;; } git_diff_flag_t;
(define-fh-enum git_diff_flag_t
  '((GIT_DIFF_FLAG_BINARY . 1)
    (GIT_DIFF_FLAG_NOT_BINARY . 2)
    (GIT_DIFF_FLAG_VALID_ID . 4)
    (GIT_DIFF_FLAG_EXISTS . 8))
  )

;; typedef enum {
;;   GIT_DELTA_UNMODIFIED = 0,
;;   GIT_DELTA_ADDED = 1,
;;   GIT_DELTA_DELETED = 2,
;;   GIT_DELTA_MODIFIED = 3,
;;   GIT_DELTA_RENAMED = 4,
;;   GIT_DELTA_COPIED = 5,
;;   GIT_DELTA_IGNORED = 6,
;;   GIT_DELTA_UNTRACKED = 7,
;;   GIT_DELTA_TYPECHANGE = 8,
;;   GIT_DELTA_UNREADABLE = 9,
;;   GIT_DELTA_CONFLICTED = 10,
;; } git_delta_t;
(define-fh-enum git_delta_t
  '((GIT_DELTA_UNMODIFIED . 0)
    (GIT_DELTA_ADDED . 1)
    (GIT_DELTA_DELETED . 2)
    (GIT_DELTA_MODIFIED . 3)
    (GIT_DELTA_RENAMED . 4)
    (GIT_DELTA_COPIED . 5)
    (GIT_DELTA_IGNORED . 6)
    (GIT_DELTA_UNTRACKED . 7)
    (GIT_DELTA_TYPECHANGE . 8)
    (GIT_DELTA_UNREADABLE . 9)
    (GIT_DELTA_CONFLICTED . 10))
  )

;; typedef struct {
;;   git_oid id;
;;   const char *path;
;;   git_off_t size;
;;   uint32_t flags;
;;   uint16_t mode;
;;   uint16_t id_abbrev;
;; } git_diff_file;
(define git_diff_file-desc
  (bs:struct
    (list `(id ,git_oid-desc)
          `(path ,(bs:pointer int))
          `(size ,int32)
          `(flags ,uint64)
          `(mode ,uint16)
          `(id_abbrev ,uint16))))
(export git_diff_file-desc)
(define-fh-compound-type/p git_diff_file git_diff_file-desc)

;; typedef struct {
;;   git_delta_t status;
;;   uint32_t flags; /**< git_diff_flag_t values */
;;   uint16_t similarity; /**< for RENAMED and COPIED, value 0-100 */
;;   uint16_t nfiles; /**< number of files in this delta */
;;   git_diff_file old_file;
;;   git_diff_file new_file;
;; } git_diff_delta;
(define git_diff_delta-desc
  (bs:struct
    (list `(status ,int)
          `(flags ,uint64)
          `(similarity ,uint16)
          `(nfiles ,uint16)
          `(old_file ,git_diff_file-desc)
          `(new_file ,git_diff_file-desc))))
(export git_diff_delta-desc)
(define-fh-compound-type/p git_diff_delta git_diff_delta-desc)

;; typedef int (*git_diff_notify_cb)(const git_diff *diff_so_far, const 
;;     git_diff_delta *delta_to_add, const char *matched_pathspec, void *
;;     payload);
(define-fh-function/p git_diff_notify_cb
  ffi:int (list (quote *) (quote *) (quote *) (quote *)))

;; typedef int (*git_diff_progress_cb)(const git_diff *diff_so_far, const char 
;;     *old_path, const char *new_path, void *payload);
(define-fh-function/p git_diff_progress_cb
  ffi:int (list (quote *) (quote *) (quote *) (quote *)))

;; typedef struct {
;;   unsigned int version; /**< version for the struct */
;;   uint32_t flags; /**< defaults to GIT_DIFF_NORMAL */
;;   /* options controlling which files are in the diff */
;;   git_submodule_ignore_t ignore_submodules; /**< submodule ignore rule */
;;   git_strarray pathspec; /**< defaults to include all paths */
;;   git_diff_notify_cb notify_cb;
;;   git_diff_progress_cb progress_cb;
;;   void *payload;
;;   /* options controlling how to diff text is generated */
;;   uint32_t context_lines; /**< defaults to 3 */
;;   uint32_t interhunk_lines; /**< defaults to 0 */
;;   uint16_t id_abbrev; /**< default 'core.abbrev' or 7 if unset */
;;   git_off_t max_size; /**< defaults to 512MB */
;;   const char *old_prefix; /**< defaults to "a" */
;;   const char *new_prefix; /**< defaults to "b" */
;; } git_diff_options;
(define git_diff_options-desc
  (bs:struct
    (list `(version ,unsigned-int)
          `(flags ,uint64)
          `(ignore_submodules ,int)
          `(pathspec ,git_strarray-desc)
          `(notify_cb ,(bs:pointer void))
          `(progress_cb ,(bs:pointer void))
          `(payload ,(bs:pointer void))
          `(context_lines ,uint64)
          `(interhunk_lines ,uint64)
          `(id_abbrev ,uint16)
          `(max_size ,int32)
          `(old_prefix ,(bs:pointer int))
          `(new_prefix ,(bs:pointer int)))))
(export git_diff_options-desc)
(define-fh-compound-type/p git_diff_options git_diff_options-desc)

;; extern int git_diff_init_options(git_diff_options *opts, unsigned int 
;;     version);
(define ~git_diff_init_options #f)
(define (git_diff_init_options opts version)
  (unless
    ~git_diff_init_options
    (set! ~git_diff_init_options
      (fh-link-proc
        "git_diff_init_options"
        ffi:int
        (list '* ffi:unsigned-int))))
  (let ((~opts (unwrap-git_diff_options* opts))
        (~version (unwrap~fixed version)))
    (~git_diff_init_options ~opts ~version)))
(export git_diff_init_options)

;; typedef int (*git_diff_file_cb)(const git_diff_delta *delta, float progress
;;     , void *payload);
(define-fh-function/p git_diff_file_cb
  ffi:int (list (quote *) ffi:float (quote *)))

;; typedef enum {
;;   GIT_DIFF_BINARY_NONE,
;;   GIT_DIFF_BINARY_LITERAL,
;;   GIT_DIFF_BINARY_DELTA,
;; } git_diff_binary_t;
(define-fh-enum git_diff_binary_t
  '((GIT_DIFF_BINARY_NONE . 0)
    (GIT_DIFF_BINARY_LITERAL . 1)
    (GIT_DIFF_BINARY_DELTA . 2))
  )

;; typedef struct {
;;   /** The type of binary data for this file. */
;;   git_diff_binary_t type;
;;   /** The binary data, deflated. */
;;   const char *data;
;;   /** The length of the binary data. */
;;   size_t datalen;
;;   /** The length of the binary data after inflation. */
;;   size_t inflatedlen;
;; } git_diff_binary_file;
(define git_diff_binary_file-desc
  (bs:struct
    (list `(type ,int)
          `(data ,(bs:pointer int))
          `(datalen ,size_t)
          `(inflatedlen ,size_t))))
(export git_diff_binary_file-desc)
(define-fh-compound-type/p git_diff_binary_file git_diff_binary_file-desc)

;; typedef struct {
;;   /**
;;    * Whether there is data in this binary structure or not.  If this
;;    * is `1`, then this was produced and included binary content.  If
;;    * this is `0` then this was generated knowing only that a binary
;;    * file changed but without providing the data, probably from a patch
;;    * that said `Binary files a/file.txt and b/file.txt differ`.
;;    */
;;   unsigned int contains_data;
;;   git_diff_binary_file old_file; /**< The contents of the old file. */
;;   git_diff_binary_file new_file; /**< The contents of the new file. */
;; } git_diff_binary;
(define git_diff_binary-desc
  (bs:struct
    (list `(contains_data ,unsigned-int)
          `(old_file ,git_diff_binary_file-desc)
          `(new_file ,git_diff_binary_file-desc))))
(export git_diff_binary-desc)
(define-fh-compound-type/p git_diff_binary git_diff_binary-desc)

;; typedef int (*git_diff_binary_cb)(const git_diff_delta *delta, const 
;;     git_diff_binary *binary, void *payload);
(define-fh-function/p git_diff_binary_cb
  ffi:int (list (quote *) (quote *) (quote *)))

;; typedef struct {
;;   int old_start; /** Starting line number in old_file */
;;   int old_lines; /** Number of lines in old_file */
;;   int new_start; /** Starting line number in new_file */
;;   int new_lines; /** Number of lines in new_file */
;;   size_t header_len; /** Number of bytes in header text */
;;   char header[128]; /** Header text, NUL-byte terminated */
;; } git_diff_hunk;
(define git_diff_hunk-desc
  (bs:struct
    (list `(old_start ,int)
          `(old_lines ,int)
          `(new_start ,int)
          `(new_lines ,int)
          `(header_len ,size_t)
          `(header ,(bs:vector 128 int8)))))
(export git_diff_hunk-desc)
(define-fh-compound-type/p git_diff_hunk git_diff_hunk-desc)

;; typedef int (*git_diff_hunk_cb)(const git_diff_delta *delta, const 
;;     git_diff_hunk *hunk, void *payload);
(define-fh-function/p git_diff_hunk_cb
  ffi:int (list (quote *) (quote *) (quote *)))

;; typedef enum {
;;   GIT_DIFF_LINE_CONTEXT = ' ',
;;   GIT_DIFF_LINE_ADDITION = '+',
;;   GIT_DIFF_LINE_DELETION = '-',
;;   GIT_DIFF_LINE_CONTEXT_EOFNL = '=',
;;   GIT_DIFF_LINE_ADD_EOFNL = '>',
;;   GIT_DIFF_LINE_DEL_EOFNL = '<',
;;   GIT_DIFF_LINE_FILE_HDR = 'F',
;;   GIT_DIFF_LINE_HUNK_HDR = 'H',
;;   GIT_DIFF_LINE_BINARY = 'B',
;; } git_diff_line_t;
(define-fh-enum git_diff_line_t
  '((GIT_DIFF_LINE_CONTEXT . 32)
    (GIT_DIFF_LINE_ADDITION . 43)
    (GIT_DIFF_LINE_DELETION . 45)
    (GIT_DIFF_LINE_CONTEXT_EOFNL . 61)
    (GIT_DIFF_LINE_ADD_EOFNL . 62)
    (GIT_DIFF_LINE_DEL_EOFNL . 60)
    (GIT_DIFF_LINE_FILE_HDR . 70)
    (GIT_DIFF_LINE_HUNK_HDR . 72)
    (GIT_DIFF_LINE_BINARY . 66))
  )

;; typedef struct {
;;   char origin; /**< A git_diff_line_t value */
;;   int old_lineno; /**< Line number in old file or -1 for added line */
;;   int new_lineno; /**< Line number in new file or -1 for deleted line */
;;   int num_lines; /**< Number of newline characters in content */
;;   size_t content_len; /**< Number of bytes of data */
;;   git_off_t content_offset; 
;;       /**< Offset in the original file to the content */
;;   const char *content; /**< Pointer to diff text, not NUL-byte terminated */
;;       
;; } git_diff_line;
(define git_diff_line-desc
  (bs:struct
    (list `(origin ,int)
          `(old_lineno ,int)
          `(new_lineno ,int)
          `(num_lines ,int)
          `(content_len ,size_t)
          `(content_offset ,int32)
          `(content ,(bs:pointer int)))))
(export git_diff_line-desc)
(define-fh-compound-type/p git_diff_line git_diff_line-desc)

;; typedef int (*git_diff_line_cb)(const git_diff_delta *delta, const 
;;     git_diff_hunk *hunk, const git_diff_line *line, void *payload); 
;;     /**< user reference data */
(define-fh-function/p git_diff_line_cb
  ffi:int (list (quote *) (quote *) (quote *) (quote *)))

;; typedef enum {
;;   GIT_DIFF_FIND_BY_CONFIG = 0,
;;   GIT_DIFF_FIND_RENAMES = 1u<<0,
;;   GIT_DIFF_FIND_RENAMES_FROM_REWRITES = 1u<<1,
;;   GIT_DIFF_FIND_COPIES = 1u<<2,
;;   GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED = 1u<<3,
;;   GIT_DIFF_FIND_REWRITES = 1u<<4,
;;   GIT_DIFF_BREAK_REWRITES = 1u<<5,
;;   GIT_DIFF_FIND_AND_BREAK_REWRITES = GIT_DIFF_FIND_REWRITES | 
;;       GIT_DIFF_BREAK_REWRITES,
;;   GIT_DIFF_FIND_FOR_UNTRACKED = 1u<<6,
;;   GIT_DIFF_FIND_ALL = 0x0ff,
;;   GIT_DIFF_FIND_IGNORE_LEADING_WHITESPACE = 0,
;;   GIT_DIFF_FIND_IGNORE_WHITESPACE = 1u<<12,
;;   GIT_DIFF_FIND_DONT_IGNORE_WHITESPACE = 1u<<13,
;;   GIT_DIFF_FIND_EXACT_MATCH_ONLY = 1u<<14,
;;   GIT_DIFF_BREAK_REWRITES_FOR_RENAMES_ONLY = 1u<<15,
;;   GIT_DIFF_FIND_REMOVE_UNMODIFIED = 1u<<16,
;; } git_diff_find_t;
(define-fh-enum git_diff_find_t
  '((GIT_DIFF_FIND_BY_CONFIG . 0)
    (GIT_DIFF_FIND_RENAMES . 1)
    (GIT_DIFF_FIND_RENAMES_FROM_REWRITES . 2)
    (GIT_DIFF_FIND_COPIES . 4)
    (GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED . 8)
    (GIT_DIFF_FIND_REWRITES . 16)
    (GIT_DIFF_BREAK_REWRITES . 32)
    (GIT_DIFF_FIND_AND_BREAK_REWRITES . 48)
    (GIT_DIFF_FIND_FOR_UNTRACKED . 64)
    (GIT_DIFF_FIND_ALL . 255)
    (GIT_DIFF_FIND_IGNORE_LEADING_WHITESPACE . 0)
    (GIT_DIFF_FIND_IGNORE_WHITESPACE . 4096)
    (GIT_DIFF_FIND_DONT_IGNORE_WHITESPACE . 8192)
    (GIT_DIFF_FIND_EXACT_MATCH_ONLY . 16384)
    (GIT_DIFF_BREAK_REWRITES_FOR_RENAMES_ONLY
      .
      32768)
    (GIT_DIFF_FIND_REMOVE_UNMODIFIED . 65536))
  )

;; typedef struct {
;;   int (*file_signature)(void **out, const git_diff_file *file, const char *
;;       fullpath, void *payload);
;;   int (*buffer_signature)(void **out, const git_diff_file *file, const char 
;;       *buf, size_t buflen, void *payload);
;;   void (*free_signature)(void *sig, void *payload);
;;   int (*similarity)(int *score, void *siga, void *sigb, void *payload);
;;   void *payload;
;; } git_diff_similarity_metric;
(define git_diff_similarity_metric-desc
  (bs:struct
    (list `(file_signature ,(bs:pointer void))
          `(buffer_signature ,(bs:pointer void))
          `(free_signature ,(bs:pointer void))
          `(similarity ,(bs:pointer void))
          `(payload ,(bs:pointer void)))))
(export git_diff_similarity_metric-desc)
(define-fh-compound-type/p git_diff_similarity_metric git_diff_similarity_metric-desc)

;; typedef struct {
;;   unsigned int version;
;;   /**
;;    * Combination of git_diff_find_t values (default GIT_DIFF_FIND_BY_CONFIG).
;;       
;;    * NOTE: if you don't explicitly set this, `diff.renames` could be set
;;    * to false, resulting in `git_diff_find_similar` doing nothing.
;;    */
;;   uint32_t flags;
;;   /** Similarity to consider a file renamed (default 50) */
;;   uint16_t rename_threshold;
;;   /** Similarity of modified to be eligible rename source (default 50) */
;;   uint16_t rename_from_rewrite_threshold;
;;   /** Similarity to consider a file a copy (default 50) */
;;   uint16_t copy_threshold;
;;   /** Similarity to split modify into delete/add pair (default 60) */
;;   uint16_t break_rewrite_threshold;
;;   /** Maximum similarity sources to examine for a file (somewhat like
;;    *  git-diff's `-l` option or `diff.renameLimit` config) (default 200)
;;    */
;;   size_t rename_limit;
;;   /** Pluggable similarity metric; pass NULL to use internal metric */
;;   git_diff_similarity_metric *metric;
;; } git_diff_find_options;
(define git_diff_find_options-desc
  (bs:struct
    (list `(version ,unsigned-int)
          `(flags ,uint64)
          `(rename_threshold ,uint16)
          `(rename_from_rewrite_threshold ,uint16)
          `(copy_threshold ,uint16)
          `(break_rewrite_threshold ,uint16)
          `(rename_limit ,size_t)
          `(metric
             ,(bs:pointer
                (delay git_diff_similarity_metric*-desc))))))
(export git_diff_find_options-desc)
(define-fh-compound-type/p git_diff_find_options git_diff_find_options-desc)

;; extern int git_diff_find_init_options(git_diff_find_options *opts, 
;;     unsigned int version);
(define ~git_diff_find_init_options #f)
(define (git_diff_find_init_options opts version)
  (unless
    ~git_diff_find_init_options
    (set! ~git_diff_find_init_options
      (fh-link-proc
        "git_diff_find_init_options"
        ffi:int
        (list '* ffi:unsigned-int))))
  (let ((~opts (unwrap-git_diff_find_options* opts))
        (~version (unwrap~fixed version)))
    (~git_diff_find_init_options ~opts ~version)))
(export git_diff_find_init_options)

;; extern void git_diff_free(git_diff *diff);
(define ~git_diff_free #f)
(define (git_diff_free diff)
  (unless
    ~git_diff_free
    (set! ~git_diff_free
      (fh-link-proc "git_diff_free" ffi:void (list '*))))
  (let ((~diff (unwrap-git_diff* diff)))
    (~git_diff_free ~diff)))
(export git_diff_free)

;; extern int git_diff_tree_to_tree(git_diff **diff, git_repository *repo, 
;;     git_tree *old_tree, git_tree *new_tree, const git_diff_options *opts); 
;;     /**< can be NULL for defaults */
(define ~git_diff_tree_to_tree #f)
(define (git_diff_tree_to_tree
         diff
         repo
         old_tree
         new_tree
         opts)
  (unless
    ~git_diff_tree_to_tree
    (set! ~git_diff_tree_to_tree
      (fh-link-proc
        "git_diff_tree_to_tree"
        ffi:int
        (list '* '* '* '* '*))))
  (let ((~diff (unwrap~pointer diff))
        (~repo (unwrap-git_repository* repo))
        (~old_tree (unwrap-git_tree* old_tree))
        (~new_tree (unwrap-git_tree* new_tree))
        (~opts (unwrap-git_diff_options* opts)))
    (~git_diff_tree_to_tree
      ~diff
      ~repo
      ~old_tree
      ~new_tree
      ~opts)))
(export git_diff_tree_to_tree)

;; extern int git_diff_tree_to_index(git_diff **diff, git_repository *repo, 
;;     git_tree *old_tree, git_index *index, const git_diff_options *opts); 
;;     /**< can be NULL for defaults */
(define ~git_diff_tree_to_index #f)
(define (git_diff_tree_to_index
         diff
         repo
         old_tree
         index
         opts)
  (unless
    ~git_diff_tree_to_index
    (set! ~git_diff_tree_to_index
      (fh-link-proc
        "git_diff_tree_to_index"
        ffi:int
        (list '* '* '* '* '*))))
  (let ((~diff (unwrap~pointer diff))
        (~repo (unwrap-git_repository* repo))
        (~old_tree (unwrap-git_tree* old_tree))
        (~index (unwrap-git_index* index))
        (~opts (unwrap-git_diff_options* opts)))
    (~git_diff_tree_to_index
      ~diff
      ~repo
      ~old_tree
      ~index
      ~opts)))
(export git_diff_tree_to_index)

;; extern int git_diff_index_to_workdir(git_diff **diff, git_repository *repo, 
;;     git_index *index, const git_diff_options *opts); 
;;     /**< can be NULL for defaults */
(define ~git_diff_index_to_workdir #f)
(define (git_diff_index_to_workdir diff repo index opts)
  (unless
    ~git_diff_index_to_workdir
    (set! ~git_diff_index_to_workdir
      (fh-link-proc
        "git_diff_index_to_workdir"
        ffi:int
        (list '* '* '* '*))))
  (let ((~diff (unwrap~pointer diff))
        (~repo (unwrap-git_repository* repo))
        (~index (unwrap-git_index* index))
        (~opts (unwrap-git_diff_options* opts)))
    (~git_diff_index_to_workdir
      ~diff
      ~repo
      ~index
      ~opts)))
(export git_diff_index_to_workdir)

;; extern int git_diff_tree_to_workdir(git_diff **diff, git_repository *repo, 
;;     git_tree *old_tree, const git_diff_options *opts); 
;;     /**< can be NULL for defaults */
(define ~git_diff_tree_to_workdir #f)
(define (git_diff_tree_to_workdir
         diff
         repo
         old_tree
         opts)
  (unless
    ~git_diff_tree_to_workdir
    (set! ~git_diff_tree_to_workdir
      (fh-link-proc
        "git_diff_tree_to_workdir"
        ffi:int
        (list '* '* '* '*))))
  (let ((~diff (unwrap~pointer diff))
        (~repo (unwrap-git_repository* repo))
        (~old_tree (unwrap-git_tree* old_tree))
        (~opts (unwrap-git_diff_options* opts)))
    (~git_diff_tree_to_workdir
      ~diff
      ~repo
      ~old_tree
      ~opts)))
(export git_diff_tree_to_workdir)

;; extern int git_diff_tree_to_workdir_with_index(git_diff **diff, 
;;     git_repository *repo, git_tree *old_tree, const git_diff_options *opts)
;;     ; /**< can be NULL for defaults */
(define ~git_diff_tree_to_workdir_with_index #f)
(define (git_diff_tree_to_workdir_with_index
         diff
         repo
         old_tree
         opts)
  (unless
    ~git_diff_tree_to_workdir_with_index
    (set! ~git_diff_tree_to_workdir_with_index
      (fh-link-proc
        "git_diff_tree_to_workdir_with_index"
        ffi:int
        (list '* '* '* '*))))
  (let ((~diff (unwrap~pointer diff))
        (~repo (unwrap-git_repository* repo))
        (~old_tree (unwrap-git_tree* old_tree))
        (~opts (unwrap-git_diff_options* opts)))
    (~git_diff_tree_to_workdir_with_index
      ~diff
      ~repo
      ~old_tree
      ~opts)))
(export git_diff_tree_to_workdir_with_index)

;; extern int git_diff_index_to_index(git_diff **diff, git_repository *repo, 
;;     git_index *old_index, git_index *new_index, const git_diff_options *opts
;;     ); /**< can be NULL for defaults */
(define ~git_diff_index_to_index #f)
(define (git_diff_index_to_index
         diff
         repo
         old_index
         new_index
         opts)
  (unless
    ~git_diff_index_to_index
    (set! ~git_diff_index_to_index
      (fh-link-proc
        "git_diff_index_to_index"
        ffi:int
        (list '* '* '* '* '*))))
  (let ((~diff (unwrap~pointer diff))
        (~repo (unwrap-git_repository* repo))
        (~old_index (unwrap-git_index* old_index))
        (~new_index (unwrap-git_index* new_index))
        (~opts (unwrap-git_diff_options* opts)))
    (~git_diff_index_to_index
      ~diff
      ~repo
      ~old_index
      ~new_index
      ~opts)))
(export git_diff_index_to_index)

;; extern int git_diff_merge(git_diff *onto, const git_diff *from);
(define ~git_diff_merge #f)
(define (git_diff_merge onto from)
  (unless
    ~git_diff_merge
    (set! ~git_diff_merge
      (fh-link-proc
        "git_diff_merge"
        ffi:int
        (list '* '*))))
  (let ((~onto (unwrap-git_diff* onto))
        (~from (unwrap-git_diff* from)))
    (~git_diff_merge ~onto ~from)))
(export git_diff_merge)

;; extern int git_diff_find_similar(git_diff *diff, const git_diff_find_options
;;      *options);
(define ~git_diff_find_similar #f)
(define (git_diff_find_similar diff options)
  (unless
    ~git_diff_find_similar
    (set! ~git_diff_find_similar
      (fh-link-proc
        "git_diff_find_similar"
        ffi:int
        (list '* '*))))
  (let ((~diff (unwrap-git_diff* diff))
        (~options
          (unwrap-git_diff_find_options* options)))
    (~git_diff_find_similar ~diff ~options)))
(export git_diff_find_similar)

;; extern size_t git_diff_num_deltas(const git_diff *diff);
(define ~git_diff_num_deltas #f)
(define (git_diff_num_deltas diff)
  (unless
    ~git_diff_num_deltas
    (set! ~git_diff_num_deltas
      (fh-link-proc
        "git_diff_num_deltas"
        ffi:size_t
        (list '*))))
  (let ((~diff (unwrap-git_diff* diff)))
    (~git_diff_num_deltas ~diff)))
(export git_diff_num_deltas)

;; extern size_t git_diff_num_deltas_of_type(const git_diff *diff, git_delta_t 
;;     type);
(define ~git_diff_num_deltas_of_type #f)
(define (git_diff_num_deltas_of_type diff type)
  (unless
    ~git_diff_num_deltas_of_type
    (set! ~git_diff_num_deltas_of_type
      (fh-link-proc
        "git_diff_num_deltas_of_type"
        ffi:size_t
        (list '* ffi:int))))
  (let ((~diff (unwrap-git_diff* diff))
        (~type (unwrap~fixed type)))
    (~git_diff_num_deltas_of_type ~diff ~type)))
(export git_diff_num_deltas_of_type)

;; extern const git_diff_delta *git_diff_get_delta(const git_diff *diff, size_t
;;      idx);
(define ~git_diff_get_delta #f)
(define (git_diff_get_delta diff idx)
  (unless
    ~git_diff_get_delta
    (set! ~git_diff_get_delta
      (fh-link-proc
        "git_diff_get_delta"
        '*
        (list '* ffi:size_t))))
  (let ((~diff (unwrap-git_diff* diff))
        (~idx (unwrap~fixed idx)))
    (wrap-git_diff_delta*
      (~git_diff_get_delta ~diff ~idx))))
(export git_diff_get_delta)

;; extern int git_diff_is_sorted_icase(const git_diff *diff);
(define ~git_diff_is_sorted_icase #f)
(define (git_diff_is_sorted_icase diff)
  (unless
    ~git_diff_is_sorted_icase
    (set! ~git_diff_is_sorted_icase
      (fh-link-proc
        "git_diff_is_sorted_icase"
        ffi:int
        (list '*))))
  (let ((~diff (unwrap-git_diff* diff)))
    (~git_diff_is_sorted_icase ~diff)))
(export git_diff_is_sorted_icase)

;; extern int git_diff_foreach(git_diff *diff, git_diff_file_cb file_cb, 
;;     git_diff_binary_cb binary_cb, git_diff_hunk_cb hunk_cb, git_diff_line_cb
;;      line_cb, void *payload);
(define ~git_diff_foreach #f)
(define (git_diff_foreach
         diff
         file_cb
         binary_cb
         hunk_cb
         line_cb
         payload)
  (unless
    ~git_diff_foreach
    (set! ~git_diff_foreach
      (fh-link-proc
        "git_diff_foreach"
        ffi:int
        (list '* '* '* '* '* '*))))
  (let ((~diff (unwrap-git_diff* diff))
        (~file_cb
          ((make-ftn-arg-unwrapper
             ffi:int
             (list '* ffi:float '*))
           file_cb))
        (~binary_cb
          ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
           binary_cb))
        (~hunk_cb
          ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
           hunk_cb))
        (~line_cb
          ((make-ftn-arg-unwrapper
             ffi:int
             (list '* '* '* '*))
           line_cb))
        (~payload (unwrap~pointer payload)))
    (~git_diff_foreach
      ~diff
      ~file_cb
      ~binary_cb
      ~hunk_cb
      ~line_cb
      ~payload)))
(export git_diff_foreach)

;; extern char git_diff_status_char(git_delta_t status);
(define ~git_diff_status_char #f)
(define (git_diff_status_char status)
  (unless
    ~git_diff_status_char
    (set! ~git_diff_status_char
      (fh-link-proc
        "git_diff_status_char"
        ffi:int
        (list ffi:int))))
  (let ((~status (unwrap~fixed status)))
    (~git_diff_status_char ~status)))
(export git_diff_status_char)

;; typedef enum {
;;   GIT_DIFF_FORMAT_PATCH = 1u,
;;   GIT_DIFF_FORMAT_PATCH_HEADER = 2u,
;;   GIT_DIFF_FORMAT_RAW = 3u,
;;   GIT_DIFF_FORMAT_NAME_ONLY = 4u,
;;   GIT_DIFF_FORMAT_NAME_STATUS = 5u,
;; } git_diff_format_t;
(define-fh-enum git_diff_format_t
  '((GIT_DIFF_FORMAT_PATCH . 1)
    (GIT_DIFF_FORMAT_PATCH_HEADER . 2)
    (GIT_DIFF_FORMAT_RAW . 3)
    (GIT_DIFF_FORMAT_NAME_ONLY . 4)
    (GIT_DIFF_FORMAT_NAME_STATUS . 5))
  )

;; extern int git_diff_print(git_diff *diff, git_diff_format_t format, 
;;     git_diff_line_cb print_cb, void *payload);
(define ~git_diff_print #f)
(define (git_diff_print diff format print_cb payload)
  (unless
    ~git_diff_print
    (set! ~git_diff_print
      (fh-link-proc
        "git_diff_print"
        ffi:int
        (list '* ffi:int '* '*))))
  (let ((~diff (unwrap-git_diff* diff))
        (~format (unwrap~fixed format))
        (~print_cb
          ((make-ftn-arg-unwrapper
             ffi:int
             (list '* '* '* '*))
           print_cb))
        (~payload (unwrap~pointer payload)))
    (~git_diff_print
      ~diff
      ~format
      ~print_cb
      ~payload)))
(export git_diff_print)

;; extern int git_diff_to_buf(git_buf *out, git_diff *diff, git_diff_format_t 
;;     format);
(define ~git_diff_to_buf #f)
(define (git_diff_to_buf out diff format)
  (unless
    ~git_diff_to_buf
    (set! ~git_diff_to_buf
      (fh-link-proc
        "git_diff_to_buf"
        ffi:int
        (list '* '* ffi:int))))
  (let ((~out (unwrap-git_buf* out))
        (~diff (unwrap-git_diff* diff))
        (~format (unwrap~fixed format)))
    (~git_diff_to_buf ~out ~diff ~format)))
(export git_diff_to_buf)

;; extern int git_diff_blobs(const git_blob *old_blob, const char *old_as_path
;;     , const git_blob *new_blob, const char *new_as_path, const 
;;     git_diff_options *options, git_diff_file_cb file_cb, git_diff_binary_cb 
;;     binary_cb, git_diff_hunk_cb hunk_cb, git_diff_line_cb line_cb, void *
;;     payload);
(define ~git_diff_blobs #f)
(define (git_diff_blobs
         old_blob
         old_as_path
         new_blob
         new_as_path
         options
         file_cb
         binary_cb
         hunk_cb
         line_cb
         payload)
  (unless
    ~git_diff_blobs
    (set! ~git_diff_blobs
      (fh-link-proc
        "git_diff_blobs"
        ffi:int
        (list '* '* '* '* '* '* '* '* '* '*))))
  (let ((~old_blob (unwrap-git_blob* old_blob))
        (~old_as_path (unwrap~pointer old_as_path))
        (~new_blob (unwrap-git_blob* new_blob))
        (~new_as_path (unwrap~pointer new_as_path))
        (~options (unwrap-git_diff_options* options))
        (~file_cb
          ((make-ftn-arg-unwrapper
             ffi:int
             (list '* ffi:float '*))
           file_cb))
        (~binary_cb
          ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
           binary_cb))
        (~hunk_cb
          ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
           hunk_cb))
        (~line_cb
          ((make-ftn-arg-unwrapper
             ffi:int
             (list '* '* '* '*))
           line_cb))
        (~payload (unwrap~pointer payload)))
    (~git_diff_blobs
      ~old_blob
      ~old_as_path
      ~new_blob
      ~new_as_path
      ~options
      ~file_cb
      ~binary_cb
      ~hunk_cb
      ~line_cb
      ~payload)))
(export git_diff_blobs)

;; extern int git_diff_blob_to_buffer(const git_blob *old_blob, const char *
;;     old_as_path, const char *buffer, size_t buffer_len, const char *
;;     buffer_as_path, const git_diff_options *options, git_diff_file_cb 
;;     file_cb, git_diff_binary_cb binary_cb, git_diff_hunk_cb hunk_cb, 
;;     git_diff_line_cb line_cb, void *payload);
(define ~git_diff_blob_to_buffer #f)
(define (git_diff_blob_to_buffer
         old_blob
         old_as_path
         buffer
         buffer_len
         buffer_as_path
         options
         file_cb
         binary_cb
         hunk_cb
         line_cb
         payload)
  (unless
    ~git_diff_blob_to_buffer
    (set! ~git_diff_blob_to_buffer
      (fh-link-proc
        "git_diff_blob_to_buffer"
        ffi:int
        (list '* '* '* ffi:size_t '* '* '* '* '* '* '*))))
  (let ((~old_blob (unwrap-git_blob* old_blob))
        (~old_as_path (unwrap~pointer old_as_path))
        (~buffer (unwrap~pointer buffer))
        (~buffer_len (unwrap~fixed buffer_len))
        (~buffer_as_path (unwrap~pointer buffer_as_path))
        (~options (unwrap-git_diff_options* options))
        (~file_cb
          ((make-ftn-arg-unwrapper
             ffi:int
             (list '* ffi:float '*))
           file_cb))
        (~binary_cb
          ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
           binary_cb))
        (~hunk_cb
          ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
           hunk_cb))
        (~line_cb
          ((make-ftn-arg-unwrapper
             ffi:int
             (list '* '* '* '*))
           line_cb))
        (~payload (unwrap~pointer payload)))
    (~git_diff_blob_to_buffer
      ~old_blob
      ~old_as_path
      ~buffer
      ~buffer_len
      ~buffer_as_path
      ~options
      ~file_cb
      ~binary_cb
      ~hunk_cb
      ~line_cb
      ~payload)))
(export git_diff_blob_to_buffer)

;; extern int git_diff_buffers(const void *old_buffer, size_t old_len, const 
;;     char *old_as_path, const void *new_buffer, size_t new_len, const char *
;;     new_as_path, const git_diff_options *options, git_diff_file_cb file_cb, 
;;     git_diff_binary_cb binary_cb, git_diff_hunk_cb hunk_cb, git_diff_line_cb
;;      line_cb, void *payload);
(define ~git_diff_buffers #f)
(define (git_diff_buffers
         old_buffer
         old_len
         old_as_path
         new_buffer
         new_len
         new_as_path
         options
         file_cb
         binary_cb
         hunk_cb
         line_cb
         payload)
  (unless
    ~git_diff_buffers
    (set! ~git_diff_buffers
      (fh-link-proc
        "git_diff_buffers"
        ffi:int
        (list '*
              ffi:size_t
              '*
              '*
              ffi:size_t
              '*
              '*
              '*
              '*
              '*
              '*
              '*))))
  (let ((~old_buffer (unwrap~pointer old_buffer))
        (~old_len (unwrap~fixed old_len))
        (~old_as_path (unwrap~pointer old_as_path))
        (~new_buffer (unwrap~pointer new_buffer))
        (~new_len (unwrap~fixed new_len))
        (~new_as_path (unwrap~pointer new_as_path))
        (~options (unwrap-git_diff_options* options))
        (~file_cb
          ((make-ftn-arg-unwrapper
             ffi:int
             (list '* ffi:float '*))
           file_cb))
        (~binary_cb
          ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
           binary_cb))
        (~hunk_cb
          ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
           hunk_cb))
        (~line_cb
          ((make-ftn-arg-unwrapper
             ffi:int
             (list '* '* '* '*))
           line_cb))
        (~payload (unwrap~pointer payload)))
    (~git_diff_buffers
      ~old_buffer
      ~old_len
      ~old_as_path
      ~new_buffer
      ~new_len
      ~new_as_path
      ~options
      ~file_cb
      ~binary_cb
      ~hunk_cb
      ~line_cb
      ~payload)))
(export git_diff_buffers)

;; extern int git_diff_from_buffer(git_diff **out, const char *content, size_t 
;;     content_len);
(define ~git_diff_from_buffer #f)
(define (git_diff_from_buffer out content content_len)
  (unless
    ~git_diff_from_buffer
    (set! ~git_diff_from_buffer
      (fh-link-proc
        "git_diff_from_buffer"
        ffi:int
        (list '* '* ffi:size_t))))
  (let ((~out (unwrap~pointer out))
        (~content (unwrap~pointer content))
        (~content_len (unwrap~fixed content_len)))
    (~git_diff_from_buffer
      ~out
      ~content
      ~content_len)))
(export git_diff_from_buffer)

;; typedef struct git_diff_stats git_diff_stats;
(define git_diff_stats-desc void)
(export git_diff_stats-desc)
(define git_diff_stats*-desc (bs:pointer git_diff_stats-desc))
(export git_diff_stats*-desc)
(define-fh-pointer-type git_diff_stats* git_diff_stats*-desc)

;; typedef enum {
;;   GIT_DIFF_STATS_NONE = 0,
;;   GIT_DIFF_STATS_FULL = 1u<<0,
;;   GIT_DIFF_STATS_SHORT = 1u<<1,
;;   GIT_DIFF_STATS_NUMBER = 1u<<2,
;;   GIT_DIFF_STATS_INCLUDE_SUMMARY = 1u<<3,
;; } git_diff_stats_format_t;
(define-fh-enum git_diff_stats_format_t
  '((GIT_DIFF_STATS_NONE . 0)
    (GIT_DIFF_STATS_FULL . 1)
    (GIT_DIFF_STATS_SHORT . 2)
    (GIT_DIFF_STATS_NUMBER . 4)
    (GIT_DIFF_STATS_INCLUDE_SUMMARY . 8))
  )

;; extern int git_diff_get_stats(git_diff_stats **out, git_diff *diff);
(define ~git_diff_get_stats #f)
(define (git_diff_get_stats out diff)
  (unless
    ~git_diff_get_stats
    (set! ~git_diff_get_stats
      (fh-link-proc
        "git_diff_get_stats"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~diff (unwrap-git_diff* diff)))
    (~git_diff_get_stats ~out ~diff)))
(export git_diff_get_stats)

;; extern size_t git_diff_stats_files_changed(const git_diff_stats *stats);
(define ~git_diff_stats_files_changed #f)
(define (git_diff_stats_files_changed stats)
  (unless
    ~git_diff_stats_files_changed
    (set! ~git_diff_stats_files_changed
      (fh-link-proc
        "git_diff_stats_files_changed"
        ffi:size_t
        (list '*))))
  (let ((~stats (unwrap-git_diff_stats* stats)))
    (~git_diff_stats_files_changed ~stats)))
(export git_diff_stats_files_changed)

;; extern size_t git_diff_stats_insertions(const git_diff_stats *stats);
(define ~git_diff_stats_insertions #f)
(define (git_diff_stats_insertions stats)
  (unless
    ~git_diff_stats_insertions
    (set! ~git_diff_stats_insertions
      (fh-link-proc
        "git_diff_stats_insertions"
        ffi:size_t
        (list '*))))
  (let ((~stats (unwrap-git_diff_stats* stats)))
    (~git_diff_stats_insertions ~stats)))
(export git_diff_stats_insertions)

;; extern size_t git_diff_stats_deletions(const git_diff_stats *stats);
(define ~git_diff_stats_deletions #f)
(define (git_diff_stats_deletions stats)
  (unless
    ~git_diff_stats_deletions
    (set! ~git_diff_stats_deletions
      (fh-link-proc
        "git_diff_stats_deletions"
        ffi:size_t
        (list '*))))
  (let ((~stats (unwrap-git_diff_stats* stats)))
    (~git_diff_stats_deletions ~stats)))
(export git_diff_stats_deletions)

;; extern int git_diff_stats_to_buf(git_buf *out, const git_diff_stats *stats, 
;;     git_diff_stats_format_t format, size_t width);
(define ~git_diff_stats_to_buf #f)
(define (git_diff_stats_to_buf out stats format width)
  (unless
    ~git_diff_stats_to_buf
    (set! ~git_diff_stats_to_buf
      (fh-link-proc
        "git_diff_stats_to_buf"
        ffi:int
        (list '* '* ffi:int ffi:size_t))))
  (let ((~out (unwrap-git_buf* out))
        (~stats (unwrap-git_diff_stats* stats))
        (~format (unwrap~fixed format))
        (~width (unwrap~fixed width)))
    (~git_diff_stats_to_buf
      ~out
      ~stats
      ~format
      ~width)))
(export git_diff_stats_to_buf)

;; extern void git_diff_stats_free(git_diff_stats *stats);
(define ~git_diff_stats_free #f)
(define (git_diff_stats_free stats)
  (unless
    ~git_diff_stats_free
    (set! ~git_diff_stats_free
      (fh-link-proc
        "git_diff_stats_free"
        ffi:void
        (list '*))))
  (let ((~stats (unwrap-git_diff_stats* stats)))
    (~git_diff_stats_free ~stats)))
(export git_diff_stats_free)

;; typedef enum {
;;   GIT_DIFF_FORMAT_EMAIL_NONE = 0,
;;   GIT_DIFF_FORMAT_EMAIL_EXCLUDE_SUBJECT_PATCH_MARKER = 1<<0,
;; } git_diff_format_email_flags_t;
(define-fh-enum git_diff_format_email_flags_t
  '((GIT_DIFF_FORMAT_EMAIL_NONE . 0)
    (GIT_DIFF_FORMAT_EMAIL_EXCLUDE_SUBJECT_PATCH_MARKER
      .
      1))
  )

;; typedef struct {
;;   unsigned int version;
;;   git_diff_format_email_flags_t flags;
;;   /** This patch number */
;;   size_t patch_no;
;;   /** Total number of patches in this series */
;;   size_t total_patches;
;;   /** id to use for the commit */
;;   const git_oid *id;
;;   /** Summary of the change */
;;   const char *summary;
;;   /** Commit message's body */
;;   const char *body;
;;   /** Author of the change */
;;   const git_signature *author;
;; } git_diff_format_email_options;
(define git_diff_format_email_options-desc
  (bs:struct
    (list `(version ,unsigned-int)
          `(flags ,int)
          `(patch_no ,size_t)
          `(total_patches ,size_t)
          `(id ,(bs:pointer (delay git_oid*-desc)))
          `(summary ,(bs:pointer int))
          `(body ,(bs:pointer int))
          `(author
             ,(bs:pointer (delay git_signature*-desc))))))
(export git_diff_format_email_options-desc)
(define-fh-compound-type/p git_diff_format_email_options git_diff_format_email_options-desc)

;; extern int git_diff_format_email(git_buf *out, git_diff *diff, const 
;;     git_diff_format_email_options *opts);
(define ~git_diff_format_email #f)
(define (git_diff_format_email out diff opts)
  (unless
    ~git_diff_format_email
    (set! ~git_diff_format_email
      (fh-link-proc
        "git_diff_format_email"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap-git_buf* out))
        (~diff (unwrap-git_diff* diff))
        (~opts (unwrap-git_diff_format_email_options* opts)))
    (~git_diff_format_email ~out ~diff ~opts)))
(export git_diff_format_email)

;; extern int git_diff_commit_as_email(git_buf *out, git_repository *repo, 
;;     git_commit *commit, size_t patch_no, size_t total_patches, 
;;     git_diff_format_email_flags_t flags, const git_diff_options *diff_opts)
;;     ;
(define ~git_diff_commit_as_email #f)
(define (git_diff_commit_as_email
         out
         repo
         commit
         patch_no
         total_patches
         flags
         diff_opts)
  (unless
    ~git_diff_commit_as_email
    (set! ~git_diff_commit_as_email
      (fh-link-proc
        "git_diff_commit_as_email"
        ffi:int
        (list '* '* '* ffi:size_t ffi:size_t ffi:int '*))))
  (let ((~out (unwrap-git_buf* out))
        (~repo (unwrap-git_repository* repo))
        (~commit (unwrap-git_commit* commit))
        (~patch_no (unwrap~fixed patch_no))
        (~total_patches (unwrap~fixed total_patches))
        (~flags (unwrap~fixed flags))
        (~diff_opts (unwrap-git_diff_options* diff_opts)))
    (~git_diff_commit_as_email
      ~out
      ~repo
      ~commit
      ~patch_no
      ~total_patches
      ~flags
      ~diff_opts)))
(export git_diff_commit_as_email)

;; extern int git_diff_format_email_init_options(git_diff_format_email_options 
;;     *opts, unsigned int version);
(define ~git_diff_format_email_init_options #f)
(define (git_diff_format_email_init_options opts version)
  (unless
    ~git_diff_format_email_init_options
    (set! ~git_diff_format_email_init_options
      (fh-link-proc
        "git_diff_format_email_init_options"
        ffi:int
        (list '* ffi:unsigned-int))))
  (let ((~opts (unwrap-git_diff_format_email_options* opts))
        (~version (unwrap~fixed version)))
    (~git_diff_format_email_init_options
      ~opts
      ~version)))
(export git_diff_format_email_init_options)

;; typedef enum {
;;   GIT_CHECKOUT_NONE = 0,
;;   GIT_CHECKOUT_SAFE = 1u<<0,
;;   GIT_CHECKOUT_FORCE = 1u<<1,
;;   GIT_CHECKOUT_RECREATE_MISSING = 1u<<2,
;;   GIT_CHECKOUT_ALLOW_CONFLICTS = 1u<<4,
;;   GIT_CHECKOUT_REMOVE_UNTRACKED = 1u<<5,
;;   GIT_CHECKOUT_REMOVE_IGNORED = 1u<<6,
;;   GIT_CHECKOUT_UPDATE_ONLY = 1u<<7,
;;   GIT_CHECKOUT_DONT_UPDATE_INDEX = 1u<<8,
;;   GIT_CHECKOUT_NO_REFRESH = 1u<<9,
;;   GIT_CHECKOUT_SKIP_UNMERGED = 1u<<10,
;;   GIT_CHECKOUT_USE_OURS = 1u<<11,
;;   GIT_CHECKOUT_USE_THEIRS = 1u<<12,
;;   GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH = 1u<<13,
;;   GIT_CHECKOUT_SKIP_LOCKED_DIRECTORIES = 1u<<18,
;;   GIT_CHECKOUT_DONT_OVERWRITE_IGNORED = 1u<<19,
;;   GIT_CHECKOUT_CONFLICT_STYLE_MERGE = 1u<<20,
;;   GIT_CHECKOUT_CONFLICT_STYLE_DIFF3 = 1u<<21,
;;   GIT_CHECKOUT_DONT_REMOVE_EXISTING = 1u<<22,
;;   GIT_CHECKOUT_DONT_WRITE_INDEX = 1u<<23,
;;   GIT_CHECKOUT_UPDATE_SUBMODULES = 1u<<16,
;;   GIT_CHECKOUT_UPDATE_SUBMODULES_IF_CHANGED = 1u<<17,
;; } git_checkout_strategy_t;
(define-fh-enum git_checkout_strategy_t
  '((GIT_CHECKOUT_NONE . 0)
    (GIT_CHECKOUT_SAFE . 1)
    (GIT_CHECKOUT_FORCE . 2)
    (GIT_CHECKOUT_RECREATE_MISSING . 4)
    (GIT_CHECKOUT_ALLOW_CONFLICTS . 16)
    (GIT_CHECKOUT_REMOVE_UNTRACKED . 32)
    (GIT_CHECKOUT_REMOVE_IGNORED . 64)
    (GIT_CHECKOUT_UPDATE_ONLY . 128)
    (GIT_CHECKOUT_DONT_UPDATE_INDEX . 256)
    (GIT_CHECKOUT_NO_REFRESH . 512)
    (GIT_CHECKOUT_SKIP_UNMERGED . 1024)
    (GIT_CHECKOUT_USE_OURS . 2048)
    (GIT_CHECKOUT_USE_THEIRS . 4096)
    (GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH . 8192)
    (GIT_CHECKOUT_SKIP_LOCKED_DIRECTORIES . 262144)
    (GIT_CHECKOUT_DONT_OVERWRITE_IGNORED . 524288)
    (GIT_CHECKOUT_CONFLICT_STYLE_MERGE . 1048576)
    (GIT_CHECKOUT_CONFLICT_STYLE_DIFF3 . 2097152)
    (GIT_CHECKOUT_DONT_REMOVE_EXISTING . 4194304)
    (GIT_CHECKOUT_DONT_WRITE_INDEX . 8388608)
    (GIT_CHECKOUT_UPDATE_SUBMODULES . 65536)
    (GIT_CHECKOUT_UPDATE_SUBMODULES_IF_CHANGED
      .
      131072))
  )

;; typedef enum {
;;   GIT_CHECKOUT_NOTIFY_NONE = 0,
;;   GIT_CHECKOUT_NOTIFY_CONFLICT = 1u<<0,
;;   GIT_CHECKOUT_NOTIFY_DIRTY = 1u<<1,
;;   GIT_CHECKOUT_NOTIFY_UPDATED = 1u<<2,
;;   GIT_CHECKOUT_NOTIFY_UNTRACKED = 1u<<3,
;;   GIT_CHECKOUT_NOTIFY_IGNORED = 1u<<4,
;;   GIT_CHECKOUT_NOTIFY_ALL = 0x0FFFFu,
;; } git_checkout_notify_t;
(define-fh-enum git_checkout_notify_t
  '((GIT_CHECKOUT_NOTIFY_NONE . 0)
    (GIT_CHECKOUT_NOTIFY_CONFLICT . 1)
    (GIT_CHECKOUT_NOTIFY_DIRTY . 2)
    (GIT_CHECKOUT_NOTIFY_UPDATED . 4)
    (GIT_CHECKOUT_NOTIFY_UNTRACKED . 8)
    (GIT_CHECKOUT_NOTIFY_IGNORED . 16)
    (GIT_CHECKOUT_NOTIFY_ALL . 65535))
  )

;; typedef struct {
;;   size_t mkdir_calls;
;;   size_t stat_calls;
;;   size_t chmod_calls;
;; } git_checkout_perfdata;
(define git_checkout_perfdata-desc
  (bs:struct
    (list `(mkdir_calls ,size_t)
          `(stat_calls ,size_t)
          `(chmod_calls ,size_t))))
(export git_checkout_perfdata-desc)
(define-fh-compound-type/p git_checkout_perfdata git_checkout_perfdata-desc)

;; typedef int (*git_checkout_notify_cb)(git_checkout_notify_t why, const char 
;;     *path, const git_diff_file *baseline, const git_diff_file *target, const
;;      git_diff_file *workdir, void *payload);
(define-fh-function/p git_checkout_notify_cb
  ffi:int (list ffi:int (quote *) (quote *) (quote *) (quote *) (quote *)))

;; typedef void (*git_checkout_progress_cb)(const char *path, size_t 
;;     completed_steps, size_t total_steps, void *payload);
(define-fh-function/p git_checkout_progress_cb
  ffi:void (list (quote *) ffi:size_t ffi:size_t (quote *)))

;; typedef void (*git_checkout_perfdata_cb)(const git_checkout_perfdata *
;;     perfdata, void *payload);
(define-fh-function/p git_checkout_perfdata_cb
  ffi:void (list (quote *) (quote *)))

;; typedef struct git_checkout_options {
;;   unsigned int version;
;;   unsigned int checkout_strategy; /**< default will be a dry run */
;;   int disable_filters; /**< don't apply filters like CRLF conversion */
;;   unsigned int dir_mode; /**< default is 0755 */
;;   unsigned int file_mode; 
;;       /**< default is 0644 or 0755 as dictated by blob */
;;   int file_open_flags; /**< default is O_CREAT | O_TRUNC | O_WRONLY */
;;   unsigned int notify_flags; /**< see `git_checkout_notify_t` above */
;;   git_checkout_notify_cb notify_cb;
;;   void *notify_payload;
;;   /** Optional callback to notify the consumer of checkout progress. */
;;   git_checkout_progress_cb progress_cb;
;;   void *progress_payload;
;;   /** When not zeroed out, array of fnmatch patterns specifying which
;;    *  paths should be taken into account, otherwise all files.  Use
;;    *  GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH to treat as simple list.
;;    */
;;   git_strarray paths;
;;   /** The expected content of the working directory; defaults to HEAD.
;;    *  If the working directory does not match this baseline information,
;;    *  that will produce a checkout conflict.
;;    */
;;   git_tree *baseline;
;;   /** Like `baseline` above, though expressed as an index.  This
;;    *  option overrides `baseline`.
;;    */
;;   git_index *baseline_index; 
;;       /**< expected content of workdir, expressed as an index. */
;;   const char *target_directory; /**< alternative checkout path to workdir */
;;       
;;   const char *ancestor_label; 
;;       /**< the name of the common ancestor side of conflicts */
;;   const char *our_label; /**< the name of the "our" side of conflicts */
;;   const char *their_label; /**< the name of the "their" side of conflicts */
;;       
;;   /** Optional callback to notify the consumer of performance data. */
;;   git_checkout_perfdata_cb perfdata_cb;
;;   void *perfdata_payload;
;; } git_checkout_options;
(define git_checkout_options-desc
  (bs:struct
    (list `(version ,unsigned-int)
          `(checkout_strategy ,unsigned-int)
          `(disable_filters ,int)
          `(dir_mode ,unsigned-int)
          `(file_mode ,unsigned-int)
          `(file_open_flags ,int)
          `(notify_flags ,unsigned-int)
          `(notify_cb ,(bs:pointer void))
          `(notify_payload ,(bs:pointer void))
          `(progress_cb ,(bs:pointer void))
          `(progress_payload ,(bs:pointer void))
          `(paths ,git_strarray-desc)
          `(baseline ,(bs:pointer (delay git_tree*-desc)))
          `(baseline_index
             ,(bs:pointer (delay git_index*-desc)))
          `(target_directory ,(bs:pointer int))
          `(ancestor_label ,(bs:pointer int))
          `(our_label ,(bs:pointer int))
          `(their_label ,(bs:pointer int))
          `(perfdata_cb ,(bs:pointer void))
          `(perfdata_payload ,(bs:pointer void)))))
(export git_checkout_options-desc)
(define-fh-compound-type/p git_checkout_options git_checkout_options-desc)
(define struct-git_checkout_options git_checkout_options)

;; extern int git_checkout_init_options(git_checkout_options *opts, 
;;     unsigned int version);
(define ~git_checkout_init_options #f)
(define (git_checkout_init_options opts version)
  (unless
    ~git_checkout_init_options
    (set! ~git_checkout_init_options
      (fh-link-proc
        "git_checkout_init_options"
        ffi:int
        (list '* ffi:unsigned-int))))
  (let ((~opts (unwrap-git_checkout_options* opts))
        (~version (unwrap~fixed version)))
    (~git_checkout_init_options ~opts ~version)))
(export git_checkout_init_options)

;; extern int git_checkout_head(git_repository *repo, const 
;;     git_checkout_options *opts);
(define ~git_checkout_head #f)
(define (git_checkout_head repo opts)
  (unless
    ~git_checkout_head
    (set! ~git_checkout_head
      (fh-link-proc
        "git_checkout_head"
        ffi:int
        (list '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~opts (unwrap-git_checkout_options* opts)))
    (~git_checkout_head ~repo ~opts)))
(export git_checkout_head)

;; extern int git_checkout_index(git_repository *repo, git_index *index, const 
;;     git_checkout_options *opts);
(define ~git_checkout_index #f)
(define (git_checkout_index repo index opts)
  (unless
    ~git_checkout_index
    (set! ~git_checkout_index
      (fh-link-proc
        "git_checkout_index"
        ffi:int
        (list '* '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~index (unwrap-git_index* index))
        (~opts (unwrap-git_checkout_options* opts)))
    (~git_checkout_index ~repo ~index ~opts)))
(export git_checkout_index)

;; extern int git_checkout_tree(git_repository *repo, const git_object *treeish
;;     , const git_checkout_options *opts);
(define ~git_checkout_tree #f)
(define (git_checkout_tree repo treeish opts)
  (unless
    ~git_checkout_tree
    (set! ~git_checkout_tree
      (fh-link-proc
        "git_checkout_tree"
        ffi:int
        (list '* '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~treeish (unwrap-git_object* treeish))
        (~opts (unwrap-git_checkout_options* opts)))
    (~git_checkout_tree ~repo ~treeish ~opts)))
(export git_checkout_tree)

;; typedef struct git_oidarray {
;;   git_oid *ids;
;;   size_t count;
;; } git_oidarray;
(define git_oidarray-desc
  (bs:struct
    (list `(ids ,(bs:pointer (delay git_oid*-desc)))
          `(count ,size_t))))
(export git_oidarray-desc)
(define-fh-compound-type/p git_oidarray git_oidarray-desc)
(define struct-git_oidarray git_oidarray)

;; extern void git_oidarray_free(git_oidarray *array);
(define ~git_oidarray_free #f)
(define (git_oidarray_free array)
  (unless
    ~git_oidarray_free
    (set! ~git_oidarray_free
      (fh-link-proc
        "git_oidarray_free"
        ffi:void
        (list '*))))
  (let ((~array (unwrap-git_oidarray* array)))
    (~git_oidarray_free ~array)))
(export git_oidarray_free)

;; typedef struct git_indexer git_indexer;
(define git_indexer-desc void)
(export git_indexer-desc)
(define git_indexer*-desc (bs:pointer git_indexer-desc))
(export git_indexer*-desc)
(define-fh-pointer-type git_indexer* git_indexer*-desc)

;; extern int git_indexer_new(git_indexer **out, const char *path, unsigned int
;;      mode, git_odb *odb, git_transfer_progress_cb progress_cb, void *
;;     progress_cb_payload);
(define ~git_indexer_new #f)
(define (git_indexer_new
         out
         path
         mode
         odb
         progress_cb
         progress_cb_payload)
  (unless
    ~git_indexer_new
    (set! ~git_indexer_new
      (fh-link-proc
        "git_indexer_new"
        ffi:int
        (list '* '* ffi:unsigned-int '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~path (unwrap~pointer path))
        (~mode (unwrap~fixed mode))
        (~odb (unwrap-git_odb* odb))
        (~progress_cb
          ((make-ftn-arg-unwrapper ffi:int (list '* '*))
           progress_cb))
        (~progress_cb_payload
          (unwrap~pointer progress_cb_payload)))
    (~git_indexer_new
      ~out
      ~path
      ~mode
      ~odb
      ~progress_cb
      ~progress_cb_payload)))
(export git_indexer_new)

;; extern int git_indexer_append(git_indexer *idx, const void *data, size_t 
;;     size, git_transfer_progress *stats);
(define ~git_indexer_append #f)
(define (git_indexer_append idx data size stats)
  (unless
    ~git_indexer_append
    (set! ~git_indexer_append
      (fh-link-proc
        "git_indexer_append"
        ffi:int
        (list '* '* ffi:size_t '*))))
  (let ((~idx (unwrap-git_indexer* idx))
        (~data (unwrap~pointer data))
        (~size (unwrap~fixed size))
        (~stats (unwrap-git_transfer_progress* stats)))
    (~git_indexer_append ~idx ~data ~size ~stats)))
(export git_indexer_append)

;; extern int git_indexer_commit(git_indexer *idx, git_transfer_progress *stats
;;     );
(define ~git_indexer_commit #f)
(define (git_indexer_commit idx stats)
  (unless
    ~git_indexer_commit
    (set! ~git_indexer_commit
      (fh-link-proc
        "git_indexer_commit"
        ffi:int
        (list '* '*))))
  (let ((~idx (unwrap-git_indexer* idx))
        (~stats (unwrap-git_transfer_progress* stats)))
    (~git_indexer_commit ~idx ~stats)))
(export git_indexer_commit)

;; extern const git_oid *git_indexer_hash(const git_indexer *idx);
(define ~git_indexer_hash #f)
(define (git_indexer_hash idx)
  (unless
    ~git_indexer_hash
    (set! ~git_indexer_hash
      (fh-link-proc "git_indexer_hash" '* (list '*))))
  (let ((~idx (unwrap-git_indexer* idx)))
    (wrap-git_oid* (~git_indexer_hash ~idx))))
(export git_indexer_hash)

;; extern void git_indexer_free(git_indexer *idx);
(define ~git_indexer_free #f)
(define (git_indexer_free idx)
  (unless
    ~git_indexer_free
    (set! ~git_indexer_free
      (fh-link-proc
        "git_indexer_free"
        ffi:void
        (list '*))))
  (let ((~idx (unwrap-git_indexer* idx)))
    (~git_indexer_free ~idx)))
(export git_indexer_free)

;; typedef struct {
;;   int32_t seconds;
;;   /* nsec should not be stored as time_t compatible */
;;   uint32_t nanoseconds;
;; } git_index_time;
(define git_index_time-desc
  (bs:struct
    (list `(seconds ,int32) `(nanoseconds ,uint64))))
(export git_index_time-desc)
(define-fh-compound-type/p git_index_time git_index_time-desc)

;; typedef struct git_index_entry {
;;   git_index_time ctime;
;;   git_index_time mtime;
;;   uint32_t dev;
;;   uint32_t ino;
;;   uint32_t mode;
;;   uint32_t uid;
;;   uint32_t gid;
;;   uint32_t file_size;
;;   git_oid id;
;;   uint16_t flags;
;;   uint16_t flags_extended;
;;   const char *path;
;; } git_index_entry;
(define git_index_entry-desc
  (bs:struct
    (list `(ctime ,git_index_time-desc)
          `(mtime ,git_index_time-desc)
          `(dev ,uint64)
          `(ino ,uint64)
          `(mode ,uint64)
          `(uid ,uint64)
          `(gid ,uint64)
          `(file_size ,uint64)
          `(id ,git_oid-desc)
          `(flags ,uint16)
          `(flags_extended ,uint16)
          `(path ,(bs:pointer int)))))
(export git_index_entry-desc)
(define-fh-compound-type/p git_index_entry git_index_entry-desc)
(define struct-git_index_entry git_index_entry)

;; typedef enum {
;;   GIT_IDXENTRY_EXTENDED = 0x4000,
;;   GIT_IDXENTRY_VALID = 0x8000,
;; } git_indxentry_flag_t;
(define-fh-enum git_indxentry_flag_t
  '((GIT_IDXENTRY_EXTENDED . 16384)
    (GIT_IDXENTRY_VALID . 32768))
  )

;; typedef enum {
;;   GIT_IDXENTRY_INTENT_TO_ADD = 1<<13,
;;   GIT_IDXENTRY_SKIP_WORKTREE = 1<<14,
;;   GIT_IDXENTRY_EXTENDED2 = 1<<15,
;;   GIT_IDXENTRY_EXTENDED_FLAGS = GIT_IDXENTRY_INTENT_TO_ADD | 
;;       GIT_IDXENTRY_SKIP_WORKTREE,
;;   GIT_IDXENTRY_UPDATE = 1<<0,
;;   GIT_IDXENTRY_REMOVE = 1<<1,
;;   GIT_IDXENTRY_UPTODATE = 1<<2,
;;   GIT_IDXENTRY_ADDED = 1<<3,
;;   GIT_IDXENTRY_HASHED = 1<<4,
;;   GIT_IDXENTRY_UNHASHED = 1<<5,
;;   GIT_IDXENTRY_WT_REMOVE = 1<<6,
;;   GIT_IDXENTRY_CONFLICTED = 1<<7,
;;   GIT_IDXENTRY_UNPACKED = 1<<8,
;;   GIT_IDXENTRY_NEW_SKIP_WORKTREE = 1<<9,
;; } git_idxentry_extended_flag_t;
(define-fh-enum git_idxentry_extended_flag_t
  '((GIT_IDXENTRY_INTENT_TO_ADD . 8192)
    (GIT_IDXENTRY_SKIP_WORKTREE . 16384)
    (GIT_IDXENTRY_EXTENDED2 . 32768)
    (GIT_IDXENTRY_EXTENDED_FLAGS . 24576)
    (GIT_IDXENTRY_UPDATE . 1)
    (GIT_IDXENTRY_REMOVE . 2)
    (GIT_IDXENTRY_UPTODATE . 4)
    (GIT_IDXENTRY_ADDED . 8)
    (GIT_IDXENTRY_HASHED . 16)
    (GIT_IDXENTRY_UNHASHED . 32)
    (GIT_IDXENTRY_WT_REMOVE . 64)
    (GIT_IDXENTRY_CONFLICTED . 128)
    (GIT_IDXENTRY_UNPACKED . 256)
    (GIT_IDXENTRY_NEW_SKIP_WORKTREE . 512))
  )

;; typedef enum {
;;   GIT_INDEXCAP_IGNORE_CASE = 1,
;;   GIT_INDEXCAP_NO_FILEMODE = 2,
;;   GIT_INDEXCAP_NO_SYMLINKS = 4,
;;   GIT_INDEXCAP_FROM_OWNER = -1,
;; } git_indexcap_t;
(define-fh-enum git_indexcap_t
  '((GIT_INDEXCAP_IGNORE_CASE . 1)
    (GIT_INDEXCAP_NO_FILEMODE . 2)
    (GIT_INDEXCAP_NO_SYMLINKS . 4)
    (GIT_INDEXCAP_FROM_OWNER . -1))
  )

;; typedef int (*git_index_matched_path_cb)(const char *path, const char *
;;     matched_pathspec, void *payload);
(define-fh-function/p git_index_matched_path_cb
  ffi:int (list (quote *) (quote *) (quote *)))

;; typedef enum {
;;   GIT_INDEX_ADD_DEFAULT = 0,
;;   GIT_INDEX_ADD_FORCE = 1u<<0,
;;   GIT_INDEX_ADD_DISABLE_PATHSPEC_MATCH = 1u<<1,
;;   GIT_INDEX_ADD_CHECK_PATHSPEC = 1u<<2,
;; } git_index_add_option_t;
(define-fh-enum git_index_add_option_t
  '((GIT_INDEX_ADD_DEFAULT . 0)
    (GIT_INDEX_ADD_FORCE . 1)
    (GIT_INDEX_ADD_DISABLE_PATHSPEC_MATCH . 2)
    (GIT_INDEX_ADD_CHECK_PATHSPEC . 4))
  )

;; typedef enum {
;;   GIT_INDEX_STAGE_ANY = -1,
;;   GIT_INDEX_STAGE_NORMAL = 0,
;;   GIT_INDEX_STAGE_ANCESTOR = 1,
;;   GIT_INDEX_STAGE_OURS = 2,
;;   GIT_INDEX_STAGE_THEIRS = 3,
;; } git_index_stage_t;
(define-fh-enum git_index_stage_t
  '((GIT_INDEX_STAGE_ANY . -1)
    (GIT_INDEX_STAGE_NORMAL . 0)
    (GIT_INDEX_STAGE_ANCESTOR . 1)
    (GIT_INDEX_STAGE_OURS . 2)
    (GIT_INDEX_STAGE_THEIRS . 3))
  )

;; extern int git_index_open(git_index **out, const char *index_path);
(define ~git_index_open #f)
(define (git_index_open out index_path)
  (unless
    ~git_index_open
    (set! ~git_index_open
      (fh-link-proc
        "git_index_open"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~index_path (unwrap~pointer index_path)))
    (~git_index_open ~out ~index_path)))
(export git_index_open)

;; extern int git_index_new(git_index **out);
(define ~git_index_new #f)
(define (git_index_new out)
  (unless
    ~git_index_new
    (set! ~git_index_new
      (fh-link-proc "git_index_new" ffi:int (list '*))))
  (let ((~out (unwrap~pointer out)))
    (~git_index_new ~out)))
(export git_index_new)

;; extern void git_index_free(git_index *index);
(define ~git_index_free #f)
(define (git_index_free index)
  (unless
    ~git_index_free
    (set! ~git_index_free
      (fh-link-proc
        "git_index_free"
        ffi:void
        (list '*))))
  (let ((~index (unwrap-git_index* index)))
    (~git_index_free ~index)))
(export git_index_free)

;; extern git_repository *git_index_owner(const git_index *index);
(define ~git_index_owner #f)
(define (git_index_owner index)
  (unless
    ~git_index_owner
    (set! ~git_index_owner
      (fh-link-proc "git_index_owner" '* (list '*))))
  (let ((~index (unwrap-git_index* index)))
    (wrap-git_repository* (~git_index_owner ~index))))
(export git_index_owner)

;; extern int git_index_caps(const git_index *index);
(define ~git_index_caps #f)
(define (git_index_caps index)
  (unless
    ~git_index_caps
    (set! ~git_index_caps
      (fh-link-proc "git_index_caps" ffi:int (list '*))))
  (let ((~index (unwrap-git_index* index)))
    (~git_index_caps ~index)))
(export git_index_caps)

;; extern int git_index_set_caps(git_index *index, int caps);
(define ~git_index_set_caps #f)
(define (git_index_set_caps index caps)
  (unless
    ~git_index_set_caps
    (set! ~git_index_set_caps
      (fh-link-proc
        "git_index_set_caps"
        ffi:int
        (list '* ffi:int))))
  (let ((~index (unwrap-git_index* index))
        (~caps (unwrap~fixed caps)))
    (~git_index_set_caps ~index ~caps)))
(export git_index_set_caps)

;; extern unsigned int git_index_version(git_index *index);
(define ~git_index_version #f)
(define (git_index_version index)
  (unless
    ~git_index_version
    (set! ~git_index_version
      (fh-link-proc
        "git_index_version"
        ffi:unsigned-int
        (list '*))))
  (let ((~index (unwrap-git_index* index)))
    (~git_index_version ~index)))
(export git_index_version)

;; extern int git_index_set_version(git_index *index, unsigned int version);
(define ~git_index_set_version #f)
(define (git_index_set_version index version)
  (unless
    ~git_index_set_version
    (set! ~git_index_set_version
      (fh-link-proc
        "git_index_set_version"
        ffi:int
        (list '* ffi:unsigned-int))))
  (let ((~index (unwrap-git_index* index))
        (~version (unwrap~fixed version)))
    (~git_index_set_version ~index ~version)))
(export git_index_set_version)

;; extern int git_index_read(git_index *index, int force);
(define ~git_index_read #f)
(define (git_index_read index force)
  (unless
    ~git_index_read
    (set! ~git_index_read
      (fh-link-proc
        "git_index_read"
        ffi:int
        (list '* ffi:int))))
  (let ((~index (unwrap-git_index* index))
        (~force (unwrap~fixed force)))
    (~git_index_read ~index ~force)))
(export git_index_read)

;; extern int git_index_write(git_index *index);
(define ~git_index_write #f)
(define (git_index_write index)
  (unless
    ~git_index_write
    (set! ~git_index_write
      (fh-link-proc
        "git_index_write"
        ffi:int
        (list '*))))
  (let ((~index (unwrap-git_index* index)))
    (~git_index_write ~index)))
(export git_index_write)

;; extern const char *git_index_path(const git_index *index);
(define ~git_index_path #f)
(define (git_index_path index)
  (unless
    ~git_index_path
    (set! ~git_index_path
      (fh-link-proc "git_index_path" '* (list '*))))
  (let ((~index (unwrap-git_index* index)))
    (~git_index_path ~index)))
(export git_index_path)

;; extern const git_oid *git_index_checksum(git_index *index);
(define ~git_index_checksum #f)
(define (git_index_checksum index)
  (unless
    ~git_index_checksum
    (set! ~git_index_checksum
      (fh-link-proc "git_index_checksum" '* (list '*))))
  (let ((~index (unwrap-git_index* index)))
    (wrap-git_oid* (~git_index_checksum ~index))))
(export git_index_checksum)

;; extern int git_index_read_tree(git_index *index, const git_tree *tree);
(define ~git_index_read_tree #f)
(define (git_index_read_tree index tree)
  (unless
    ~git_index_read_tree
    (set! ~git_index_read_tree
      (fh-link-proc
        "git_index_read_tree"
        ffi:int
        (list '* '*))))
  (let ((~index (unwrap-git_index* index))
        (~tree (unwrap-git_tree* tree)))
    (~git_index_read_tree ~index ~tree)))
(export git_index_read_tree)

;; extern int git_index_write_tree(git_oid *out, git_index *index);
(define ~git_index_write_tree #f)
(define (git_index_write_tree out index)
  (unless
    ~git_index_write_tree
    (set! ~git_index_write_tree
      (fh-link-proc
        "git_index_write_tree"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap-git_oid* out))
        (~index (unwrap-git_index* index)))
    (~git_index_write_tree ~out ~index)))
(export git_index_write_tree)

;; extern int git_index_write_tree_to(git_oid *out, git_index *index, 
;;     git_repository *repo);
(define ~git_index_write_tree_to #f)
(define (git_index_write_tree_to out index repo)
  (unless
    ~git_index_write_tree_to
    (set! ~git_index_write_tree_to
      (fh-link-proc
        "git_index_write_tree_to"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap-git_oid* out))
        (~index (unwrap-git_index* index))
        (~repo (unwrap-git_repository* repo)))
    (~git_index_write_tree_to ~out ~index ~repo)))
(export git_index_write_tree_to)

;; extern size_t git_index_entrycount(const git_index *index);
(define ~git_index_entrycount #f)
(define (git_index_entrycount index)
  (unless
    ~git_index_entrycount
    (set! ~git_index_entrycount
      (fh-link-proc
        "git_index_entrycount"
        ffi:size_t
        (list '*))))
  (let ((~index (unwrap-git_index* index)))
    (~git_index_entrycount ~index)))
(export git_index_entrycount)

;; extern int git_index_clear(git_index *index);
(define ~git_index_clear #f)
(define (git_index_clear index)
  (unless
    ~git_index_clear
    (set! ~git_index_clear
      (fh-link-proc
        "git_index_clear"
        ffi:int
        (list '*))))
  (let ((~index (unwrap-git_index* index)))
    (~git_index_clear ~index)))
(export git_index_clear)

;; extern const git_index_entry *git_index_get_byindex(git_index *index, size_t
;;      n);
(define ~git_index_get_byindex #f)
(define (git_index_get_byindex index n)
  (unless
    ~git_index_get_byindex
    (set! ~git_index_get_byindex
      (fh-link-proc
        "git_index_get_byindex"
        '*
        (list '* ffi:size_t))))
  (let ((~index (unwrap-git_index* index))
        (~n (unwrap~fixed n)))
    (wrap-git_index_entry*
      (~git_index_get_byindex ~index ~n))))
(export git_index_get_byindex)

;; extern const git_index_entry *git_index_get_bypath(git_index *index, const 
;;     char *path, int stage);
(define ~git_index_get_bypath #f)
(define (git_index_get_bypath index path stage)
  (unless
    ~git_index_get_bypath
    (set! ~git_index_get_bypath
      (fh-link-proc
        "git_index_get_bypath"
        '*
        (list '* '* ffi:int))))
  (let ((~index (unwrap-git_index* index))
        (~path (unwrap~pointer path))
        (~stage (unwrap~fixed stage)))
    (wrap-git_index_entry*
      (~git_index_get_bypath ~index ~path ~stage))))
(export git_index_get_bypath)

;; extern int git_index_remove(git_index *index, const char *path, int stage);
(define ~git_index_remove #f)
(define (git_index_remove index path stage)
  (unless
    ~git_index_remove
    (set! ~git_index_remove
      (fh-link-proc
        "git_index_remove"
        ffi:int
        (list '* '* ffi:int))))
  (let ((~index (unwrap-git_index* index))
        (~path (unwrap~pointer path))
        (~stage (unwrap~fixed stage)))
    (~git_index_remove ~index ~path ~stage)))
(export git_index_remove)

;; extern int git_index_remove_directory(git_index *index, const char *dir, int
;;      stage);
(define ~git_index_remove_directory #f)
(define (git_index_remove_directory index dir stage)
  (unless
    ~git_index_remove_directory
    (set! ~git_index_remove_directory
      (fh-link-proc
        "git_index_remove_directory"
        ffi:int
        (list '* '* ffi:int))))
  (let ((~index (unwrap-git_index* index))
        (~dir (unwrap~pointer dir))
        (~stage (unwrap~fixed stage)))
    (~git_index_remove_directory ~index ~dir ~stage)))
(export git_index_remove_directory)

;; extern int git_index_add(git_index *index, const git_index_entry *
;;     source_entry);
(define ~git_index_add #f)
(define (git_index_add index source_entry)
  (unless
    ~git_index_add
    (set! ~git_index_add
      (fh-link-proc
        "git_index_add"
        ffi:int
        (list '* '*))))
  (let ((~index (unwrap-git_index* index))
        (~source_entry
          (unwrap-git_index_entry* source_entry)))
    (~git_index_add ~index ~source_entry)))
(export git_index_add)

;; extern int git_index_entry_stage(const git_index_entry *entry);
(define ~git_index_entry_stage #f)
(define (git_index_entry_stage entry)
  (unless
    ~git_index_entry_stage
    (set! ~git_index_entry_stage
      (fh-link-proc
        "git_index_entry_stage"
        ffi:int
        (list '*))))
  (let ((~entry (unwrap-git_index_entry* entry)))
    (~git_index_entry_stage ~entry)))
(export git_index_entry_stage)

;; extern int git_index_entry_is_conflict(const git_index_entry *entry);
(define ~git_index_entry_is_conflict #f)
(define (git_index_entry_is_conflict entry)
  (unless
    ~git_index_entry_is_conflict
    (set! ~git_index_entry_is_conflict
      (fh-link-proc
        "git_index_entry_is_conflict"
        ffi:int
        (list '*))))
  (let ((~entry (unwrap-git_index_entry* entry)))
    (~git_index_entry_is_conflict ~entry)))
(export git_index_entry_is_conflict)

;; extern int git_index_add_bypath(git_index *index, const char *path);
(define ~git_index_add_bypath #f)
(define (git_index_add_bypath index path)
  (unless
    ~git_index_add_bypath
    (set! ~git_index_add_bypath
      (fh-link-proc
        "git_index_add_bypath"
        ffi:int
        (list '* '*))))
  (let ((~index (unwrap-git_index* index))
        (~path (unwrap~pointer path)))
    (~git_index_add_bypath ~index ~path)))
(export git_index_add_bypath)

;; extern int git_index_add_frombuffer(git_index *index, const git_index_entry 
;;     *entry, const void *buffer, size_t len);
(define ~git_index_add_frombuffer #f)
(define (git_index_add_frombuffer index entry buffer len)
  (unless
    ~git_index_add_frombuffer
    (set! ~git_index_add_frombuffer
      (fh-link-proc
        "git_index_add_frombuffer"
        ffi:int
        (list '* '* '* ffi:size_t))))
  (let ((~index (unwrap-git_index* index))
        (~entry (unwrap-git_index_entry* entry))
        (~buffer (unwrap~pointer buffer))
        (~len (unwrap~fixed len)))
    (~git_index_add_frombuffer
      ~index
      ~entry
      ~buffer
      ~len)))
(export git_index_add_frombuffer)

;; extern int git_index_remove_bypath(git_index *index, const char *path);
(define ~git_index_remove_bypath #f)
(define (git_index_remove_bypath index path)
  (unless
    ~git_index_remove_bypath
    (set! ~git_index_remove_bypath
      (fh-link-proc
        "git_index_remove_bypath"
        ffi:int
        (list '* '*))))
  (let ((~index (unwrap-git_index* index))
        (~path (unwrap~pointer path)))
    (~git_index_remove_bypath ~index ~path)))
(export git_index_remove_bypath)

;; extern int git_index_add_all(git_index *index, const git_strarray *pathspec
;;     , unsigned int flags, git_index_matched_path_cb callback, void *payload)
;;     ;
(define ~git_index_add_all #f)
(define (git_index_add_all
         index
         pathspec
         flags
         callback
         payload)
  (unless
    ~git_index_add_all
    (set! ~git_index_add_all
      (fh-link-proc
        "git_index_add_all"
        ffi:int
        (list '* '* ffi:unsigned-int '* '*))))
  (let ((~index (unwrap-git_index* index))
        (~pathspec (unwrap-git_strarray* pathspec))
        (~flags (unwrap~fixed flags))
        (~callback
          ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
           callback))
        (~payload (unwrap~pointer payload)))
    (~git_index_add_all
      ~index
      ~pathspec
      ~flags
      ~callback
      ~payload)))
(export git_index_add_all)

;; extern int git_index_remove_all(git_index *index, const git_strarray *
;;     pathspec, git_index_matched_path_cb callback, void *payload);
(define ~git_index_remove_all #f)
(define (git_index_remove_all
         index
         pathspec
         callback
         payload)
  (unless
    ~git_index_remove_all
    (set! ~git_index_remove_all
      (fh-link-proc
        "git_index_remove_all"
        ffi:int
        (list '* '* '* '*))))
  (let ((~index (unwrap-git_index* index))
        (~pathspec (unwrap-git_strarray* pathspec))
        (~callback
          ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
           callback))
        (~payload (unwrap~pointer payload)))
    (~git_index_remove_all
      ~index
      ~pathspec
      ~callback
      ~payload)))
(export git_index_remove_all)

;; extern int git_index_update_all(git_index *index, const git_strarray *
;;     pathspec, git_index_matched_path_cb callback, void *payload);
(define ~git_index_update_all #f)
(define (git_index_update_all
         index
         pathspec
         callback
         payload)
  (unless
    ~git_index_update_all
    (set! ~git_index_update_all
      (fh-link-proc
        "git_index_update_all"
        ffi:int
        (list '* '* '* '*))))
  (let ((~index (unwrap-git_index* index))
        (~pathspec (unwrap-git_strarray* pathspec))
        (~callback
          ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
           callback))
        (~payload (unwrap~pointer payload)))
    (~git_index_update_all
      ~index
      ~pathspec
      ~callback
      ~payload)))
(export git_index_update_all)

;; extern int git_index_find(size_t *at_pos, git_index *index, const char *path
;;     );
(define ~git_index_find #f)
(define (git_index_find at_pos index path)
  (unless
    ~git_index_find
    (set! ~git_index_find
      (fh-link-proc
        "git_index_find"
        ffi:int
        (list '* '* '*))))
  (let ((~at_pos (unwrap~pointer at_pos))
        (~index (unwrap-git_index* index))
        (~path (unwrap~pointer path)))
    (~git_index_find ~at_pos ~index ~path)))
(export git_index_find)

;; extern int git_index_find_prefix(size_t *at_pos, git_index *index, const 
;;     char *prefix);
(define ~git_index_find_prefix #f)
(define (git_index_find_prefix at_pos index prefix)
  (unless
    ~git_index_find_prefix
    (set! ~git_index_find_prefix
      (fh-link-proc
        "git_index_find_prefix"
        ffi:int
        (list '* '* '*))))
  (let ((~at_pos (unwrap~pointer at_pos))
        (~index (unwrap-git_index* index))
        (~prefix (unwrap~pointer prefix)))
    (~git_index_find_prefix ~at_pos ~index ~prefix)))
(export git_index_find_prefix)

;; extern int git_index_conflict_add(git_index *index, const git_index_entry *
;;     ancestor_entry, const git_index_entry *our_entry, const git_index_entry 
;;     *their_entry);
(define ~git_index_conflict_add #f)
(define (git_index_conflict_add
         index
         ancestor_entry
         our_entry
         their_entry)
  (unless
    ~git_index_conflict_add
    (set! ~git_index_conflict_add
      (fh-link-proc
        "git_index_conflict_add"
        ffi:int
        (list '* '* '* '*))))
  (let ((~index (unwrap-git_index* index))
        (~ancestor_entry
          (unwrap-git_index_entry* ancestor_entry))
        (~our_entry (unwrap-git_index_entry* our_entry))
        (~their_entry
          (unwrap-git_index_entry* their_entry)))
    (~git_index_conflict_add
      ~index
      ~ancestor_entry
      ~our_entry
      ~their_entry)))
(export git_index_conflict_add)

;; extern int git_index_conflict_get(const git_index_entry **ancestor_out, 
;;     const git_index_entry **our_out, const git_index_entry **their_out, 
;;     git_index *index, const char *path);
(define ~git_index_conflict_get #f)
(define (git_index_conflict_get
         ancestor_out
         our_out
         their_out
         index
         path)
  (unless
    ~git_index_conflict_get
    (set! ~git_index_conflict_get
      (fh-link-proc
        "git_index_conflict_get"
        ffi:int
        (list '* '* '* '* '*))))
  (let ((~ancestor_out (unwrap~pointer ancestor_out))
        (~our_out (unwrap~pointer our_out))
        (~their_out (unwrap~pointer their_out))
        (~index (unwrap-git_index* index))
        (~path (unwrap~pointer path)))
    (~git_index_conflict_get
      ~ancestor_out
      ~our_out
      ~their_out
      ~index
      ~path)))
(export git_index_conflict_get)

;; extern int git_index_conflict_remove(git_index *index, const char *path);
(define ~git_index_conflict_remove #f)
(define (git_index_conflict_remove index path)
  (unless
    ~git_index_conflict_remove
    (set! ~git_index_conflict_remove
      (fh-link-proc
        "git_index_conflict_remove"
        ffi:int
        (list '* '*))))
  (let ((~index (unwrap-git_index* index))
        (~path (unwrap~pointer path)))
    (~git_index_conflict_remove ~index ~path)))
(export git_index_conflict_remove)

;; extern int git_index_conflict_cleanup(git_index *index);
(define ~git_index_conflict_cleanup #f)
(define (git_index_conflict_cleanup index)
  (unless
    ~git_index_conflict_cleanup
    (set! ~git_index_conflict_cleanup
      (fh-link-proc
        "git_index_conflict_cleanup"
        ffi:int
        (list '*))))
  (let ((~index (unwrap-git_index* index)))
    (~git_index_conflict_cleanup ~index)))
(export git_index_conflict_cleanup)

;; extern int git_index_has_conflicts(const git_index *index);
(define ~git_index_has_conflicts #f)
(define (git_index_has_conflicts index)
  (unless
    ~git_index_has_conflicts
    (set! ~git_index_has_conflicts
      (fh-link-proc
        "git_index_has_conflicts"
        ffi:int
        (list '*))))
  (let ((~index (unwrap-git_index* index)))
    (~git_index_has_conflicts ~index)))
(export git_index_has_conflicts)

;; extern int git_index_conflict_iterator_new(git_index_conflict_iterator **
;;     iterator_out, git_index *index);
(define ~git_index_conflict_iterator_new #f)
(define (git_index_conflict_iterator_new
         iterator_out
         index)
  (unless
    ~git_index_conflict_iterator_new
    (set! ~git_index_conflict_iterator_new
      (fh-link-proc
        "git_index_conflict_iterator_new"
        ffi:int
        (list '* '*))))
  (let ((~iterator_out (unwrap~pointer iterator_out))
        (~index (unwrap-git_index* index)))
    (~git_index_conflict_iterator_new
      ~iterator_out
      ~index)))
(export git_index_conflict_iterator_new)

;; extern int git_index_conflict_next(const git_index_entry **ancestor_out, 
;;     const git_index_entry **our_out, const git_index_entry **their_out, 
;;     git_index_conflict_iterator *iterator);
(define ~git_index_conflict_next #f)
(define (git_index_conflict_next
         ancestor_out
         our_out
         their_out
         iterator)
  (unless
    ~git_index_conflict_next
    (set! ~git_index_conflict_next
      (fh-link-proc
        "git_index_conflict_next"
        ffi:int
        (list '* '* '* '*))))
  (let ((~ancestor_out (unwrap~pointer ancestor_out))
        (~our_out (unwrap~pointer our_out))
        (~their_out (unwrap~pointer their_out))
        (~iterator
          (unwrap-git_index_conflict_iterator* iterator)))
    (~git_index_conflict_next
      ~ancestor_out
      ~our_out
      ~their_out
      ~iterator)))
(export git_index_conflict_next)

;; extern void git_index_conflict_iterator_free(git_index_conflict_iterator *
;;     iterator);
(define ~git_index_conflict_iterator_free #f)
(define (git_index_conflict_iterator_free iterator)
  (unless
    ~git_index_conflict_iterator_free
    (set! ~git_index_conflict_iterator_free
      (fh-link-proc
        "git_index_conflict_iterator_free"
        ffi:void
        (list '*))))
  (let ((~iterator
          (unwrap-git_index_conflict_iterator* iterator)))
    (~git_index_conflict_iterator_free ~iterator)))
(export git_index_conflict_iterator_free)

;; typedef struct {
;;   unsigned int version;
;;   /** Pointer to the contents of the file. */
;;   const char *ptr;
;;   /** Size of the contents pointed to in `ptr`. */
;;   size_t size;
;;   /** File name of the conflicted file, or `NULL` to not merge the path. */
;;   const char *path;
;;   /** File mode of the conflicted file, or `0` to not merge the mode. */
;;   unsigned int mode;
;; } git_merge_file_input;
(define git_merge_file_input-desc
  (bs:struct
    (list `(version ,unsigned-int)
          `(ptr ,(bs:pointer int))
          `(size ,size_t)
          `(path ,(bs:pointer int))
          `(mode ,unsigned-int))))
(export git_merge_file_input-desc)
(define-fh-compound-type/p git_merge_file_input git_merge_file_input-desc)

;; extern int git_merge_file_init_input(git_merge_file_input *opts, 
;;     unsigned int version);
(define ~git_merge_file_init_input #f)
(define (git_merge_file_init_input opts version)
  (unless
    ~git_merge_file_init_input
    (set! ~git_merge_file_init_input
      (fh-link-proc
        "git_merge_file_init_input"
        ffi:int
        (list '* ffi:unsigned-int))))
  (let ((~opts (unwrap-git_merge_file_input* opts))
        (~version (unwrap~fixed version)))
    (~git_merge_file_init_input ~opts ~version)))
(export git_merge_file_init_input)

;; typedef enum {
;;   GIT_MERGE_FIND_RENAMES = 1<<0,
;;   GIT_MERGE_FAIL_ON_CONFLICT = 1<<1,
;;   GIT_MERGE_SKIP_REUC = 1<<2,
;;   GIT_MERGE_NO_RECURSIVE = 1<<3,
;; } git_merge_flag_t;
(define-fh-enum git_merge_flag_t
  '((GIT_MERGE_FIND_RENAMES . 1)
    (GIT_MERGE_FAIL_ON_CONFLICT . 2)
    (GIT_MERGE_SKIP_REUC . 4)
    (GIT_MERGE_NO_RECURSIVE . 8))
  )

;; typedef enum {
;;   GIT_MERGE_FILE_FAVOR_NORMAL = 0,
;;   GIT_MERGE_FILE_FAVOR_OURS = 1,
;;   GIT_MERGE_FILE_FAVOR_THEIRS = 2,
;;   GIT_MERGE_FILE_FAVOR_UNION = 3,
;; } git_merge_file_favor_t;
(define-fh-enum git_merge_file_favor_t
  '((GIT_MERGE_FILE_FAVOR_NORMAL . 0)
    (GIT_MERGE_FILE_FAVOR_OURS . 1)
    (GIT_MERGE_FILE_FAVOR_THEIRS . 2)
    (GIT_MERGE_FILE_FAVOR_UNION . 3))
  )

;; typedef enum {
;;   GIT_MERGE_FILE_DEFAULT = 0,
;;   GIT_MERGE_FILE_STYLE_MERGE = 1<<0,
;;   GIT_MERGE_FILE_STYLE_DIFF3 = 1<<1,
;;   GIT_MERGE_FILE_SIMPLIFY_ALNUM = 1<<2,
;;   GIT_MERGE_FILE_IGNORE_WHITESPACE = 1<<3,
;;   GIT_MERGE_FILE_IGNORE_WHITESPACE_CHANGE = 1<<4,
;;   GIT_MERGE_FILE_IGNORE_WHITESPACE_EOL = 1<<5,
;;   GIT_MERGE_FILE_DIFF_PATIENCE = 1<<6,
;;   GIT_MERGE_FILE_DIFF_MINIMAL = 1<<7,
;; } git_merge_file_flag_t;
(define-fh-enum git_merge_file_flag_t
  '((GIT_MERGE_FILE_DEFAULT . 0)
    (GIT_MERGE_FILE_STYLE_MERGE . 1)
    (GIT_MERGE_FILE_STYLE_DIFF3 . 2)
    (GIT_MERGE_FILE_SIMPLIFY_ALNUM . 4)
    (GIT_MERGE_FILE_IGNORE_WHITESPACE . 8)
    (GIT_MERGE_FILE_IGNORE_WHITESPACE_CHANGE . 16)
    (GIT_MERGE_FILE_IGNORE_WHITESPACE_EOL . 32)
    (GIT_MERGE_FILE_DIFF_PATIENCE . 64)
    (GIT_MERGE_FILE_DIFF_MINIMAL . 128))
  )

;; typedef struct {
;;   unsigned int version;
;;   /**
;;    * Label for the ancestor file side of the conflict which will be prepended
;;       
;;    * to labels in diff3-format merge files.
;;    */
;;   const char *ancestor_label;
;;   /**
;;    * Label for our file side of the conflict which will be prepended
;;    * to labels in merge files.
;;    */
;;   const char *our_label;
;;   /**
;;    * Label for their file side of the conflict which will be prepended
;;    * to labels in merge files.
;;    */
;;   const char *their_label;
;;   /** The file to favor in region conflicts. */
;;   git_merge_file_favor_t favor;
;;   /** see `git_merge_file_flag_t` above */
;;   git_merge_file_flag_t flags;
;; } git_merge_file_options;
(define git_merge_file_options-desc
  (bs:struct
    (list `(version ,unsigned-int)
          `(ancestor_label ,(bs:pointer int))
          `(our_label ,(bs:pointer int))
          `(their_label ,(bs:pointer int))
          `(favor ,int)
          `(flags ,int))))
(export git_merge_file_options-desc)
(define-fh-compound-type/p git_merge_file_options git_merge_file_options-desc)

;; extern int git_merge_file_init_options(git_merge_file_options *opts, 
;;     unsigned int version);
(define ~git_merge_file_init_options #f)
(define (git_merge_file_init_options opts version)
  (unless
    ~git_merge_file_init_options
    (set! ~git_merge_file_init_options
      (fh-link-proc
        "git_merge_file_init_options"
        ffi:int
        (list '* ffi:unsigned-int))))
  (let ((~opts (unwrap-git_merge_file_options* opts))
        (~version (unwrap~fixed version)))
    (~git_merge_file_init_options ~opts ~version)))
(export git_merge_file_init_options)

;; typedef struct {
;;   /**
;;    * True if the output was automerged, false if the output contains
;;    * conflict markers.
;;    */
;;   unsigned int automergeable;
;;   /**
;;    * The path that the resultant merge file should use, or NULL if a
;;    * filename conflict would occur.
;;    */
;;   const char *path;
;;   /** The mode that the resultant merge file should use.  */
;;   unsigned int mode;
;;   /** The contents of the merge. */
;;   const char *ptr;
;;   /** The length of the merge contents. */
;;   size_t len;
;; } git_merge_file_result;
(define git_merge_file_result-desc
  (bs:struct
    (list `(automergeable ,unsigned-int)
          `(path ,(bs:pointer int))
          `(mode ,unsigned-int)
          `(ptr ,(bs:pointer int))
          `(len ,size_t))))
(export git_merge_file_result-desc)
(define-fh-compound-type/p git_merge_file_result git_merge_file_result-desc)

;; typedef struct {
;;   unsigned int version;
;;   /** See `git_merge_flag_t` above */
;;   git_merge_flag_t flags;
;;   /**
;;    * Similarity to consider a file renamed (default 50).  If
;;    * `GIT_MERGE_FIND_RENAMES` is enabled, added files will be compared
;;    * with deleted files to determine their similarity.  Files that are
;;    * more similar than the rename threshold (percentage-wise) will be
;;    * treated as a rename.
;;    */
;;   unsigned int rename_threshold;
;;   /**
;;    * Maximum similarity sources to examine for renames (default 200).
;;    * If the number of rename candidates (add / delete pairs) is greater
;;    * than this value, inexact rename detection is aborted.
;;    *
;;    * This setting overrides the `merge.renameLimit` configuration value.
;;    */
;;   unsigned int target_limit;
;;   /** Pluggable similarity metric; pass NULL to use internal metric */
;;   git_diff_similarity_metric *metric;
;;   /**
;;    * Maximum number of times to merge common ancestors to build a
;;    * virtual merge base when faced with criss-cross merges.  When this
;;    * limit is reached, the next ancestor will simply be used instead of
;;    * attempting to merge it.  The default is unlimited.
;;    */
;;   unsigned int recursion_limit;
;;   /**
;;    * Default merge driver to be used when both sides of a merge have
;;    * changed.  The default is the `text` driver.
;;    */
;;   const char *default_driver;
;;   /**
;;    * Flags for handling conflicting content, to be used with the standard
;;    * (`text`) merge driver.
;;    */
;;   git_merge_file_favor_t file_favor;
;;   /** see `git_merge_file_flag_t` above */
;;   git_merge_file_flag_t file_flags;
;; } git_merge_options;
(define git_merge_options-desc
  (bs:struct
    (list `(version ,unsigned-int)
          `(flags ,int)
          `(rename_threshold ,unsigned-int)
          `(target_limit ,unsigned-int)
          `(metric
             ,(bs:pointer
                (delay git_diff_similarity_metric*-desc)))
          `(recursion_limit ,unsigned-int)
          `(default_driver ,(bs:pointer int))
          `(file_favor ,int)
          `(file_flags ,int))))
(export git_merge_options-desc)
(define-fh-compound-type/p git_merge_options git_merge_options-desc)

;; extern int git_merge_init_options(git_merge_options *opts, unsigned int 
;;     version);
(define ~git_merge_init_options #f)
(define (git_merge_init_options opts version)
  (unless
    ~git_merge_init_options
    (set! ~git_merge_init_options
      (fh-link-proc
        "git_merge_init_options"
        ffi:int
        (list '* ffi:unsigned-int))))
  (let ((~opts (unwrap-git_merge_options* opts))
        (~version (unwrap~fixed version)))
    (~git_merge_init_options ~opts ~version)))
(export git_merge_init_options)

;; typedef enum {
;;   GIT_MERGE_ANALYSIS_NONE = 0,
;;   GIT_MERGE_ANALYSIS_NORMAL = 1<<0,
;;   GIT_MERGE_ANALYSIS_UP_TO_DATE = 1<<1,
;;   GIT_MERGE_ANALYSIS_FASTFORWARD = 1<<2,
;;   GIT_MERGE_ANALYSIS_UNBORN = 1<<3,
;; } git_merge_analysis_t;
(define-fh-enum git_merge_analysis_t
  '((GIT_MERGE_ANALYSIS_NONE . 0)
    (GIT_MERGE_ANALYSIS_NORMAL . 1)
    (GIT_MERGE_ANALYSIS_UP_TO_DATE . 2)
    (GIT_MERGE_ANALYSIS_FASTFORWARD . 4)
    (GIT_MERGE_ANALYSIS_UNBORN . 8))
  )

;; typedef enum {
;;   GIT_MERGE_PREFERENCE_NONE = 0,
;;   GIT_MERGE_PREFERENCE_NO_FASTFORWARD = 1<<0,
;;   GIT_MERGE_PREFERENCE_FASTFORWARD_ONLY = 1<<1,
;; } git_merge_preference_t;
(define-fh-enum git_merge_preference_t
  '((GIT_MERGE_PREFERENCE_NONE . 0)
    (GIT_MERGE_PREFERENCE_NO_FASTFORWARD . 1)
    (GIT_MERGE_PREFERENCE_FASTFORWARD_ONLY . 2))
  )

;; extern int git_merge_analysis(git_merge_analysis_t *analysis_out, 
;;     git_merge_preference_t *preference_out, git_repository *repo, const 
;;     git_annotated_commit **their_heads, size_t their_heads_len);
(define ~git_merge_analysis #f)
(define (git_merge_analysis
         analysis_out
         preference_out
         repo
         their_heads
         their_heads_len)
  (unless
    ~git_merge_analysis
    (set! ~git_merge_analysis
      (fh-link-proc
        "git_merge_analysis"
        ffi:int
        (list '* '* '* '* ffi:size_t))))
  (let ((~analysis_out (unwrap~pointer analysis_out))
        (~preference_out (unwrap~pointer preference_out))
        (~repo (unwrap-git_repository* repo))
        (~their_heads (unwrap~pointer their_heads))
        (~their_heads_len (unwrap~fixed their_heads_len)))
    (~git_merge_analysis
      ~analysis_out
      ~preference_out
      ~repo
      ~their_heads
      ~their_heads_len)))
(export git_merge_analysis)

;; extern int git_merge_base(git_oid *out, git_repository *repo, const git_oid 
;;     *one, const git_oid *two);
(define ~git_merge_base #f)
(define (git_merge_base out repo one two)
  (unless
    ~git_merge_base
    (set! ~git_merge_base
      (fh-link-proc
        "git_merge_base"
        ffi:int
        (list '* '* '* '*))))
  (let ((~out (unwrap-git_oid* out))
        (~repo (unwrap-git_repository* repo))
        (~one (unwrap-git_oid* one))
        (~two (unwrap-git_oid* two)))
    (~git_merge_base ~out ~repo ~one ~two)))
(export git_merge_base)

;; extern int git_merge_bases(git_oidarray *out, git_repository *repo, const 
;;     git_oid *one, const git_oid *two);
(define ~git_merge_bases #f)
(define (git_merge_bases out repo one two)
  (unless
    ~git_merge_bases
    (set! ~git_merge_bases
      (fh-link-proc
        "git_merge_bases"
        ffi:int
        (list '* '* '* '*))))
  (let ((~out (unwrap-git_oidarray* out))
        (~repo (unwrap-git_repository* repo))
        (~one (unwrap-git_oid* one))
        (~two (unwrap-git_oid* two)))
    (~git_merge_bases ~out ~repo ~one ~two)))
(export git_merge_bases)

;; extern int git_merge_base_many(git_oid *out, git_repository *repo, size_t 
;;     length, const git_oid input_array[]);
(define ~git_merge_base_many #f)
(define (git_merge_base_many out repo length input_array)
  (unless
    ~git_merge_base_many
    (set! ~git_merge_base_many
      (fh-link-proc
        "git_merge_base_many"
        ffi:int
        (list '* '* ffi:size_t '*))))
  (let ((~out (unwrap-git_oid* out))
        (~repo (unwrap-git_repository* repo))
        (~length (unwrap~fixed length))
        (~input_array (unwrap~array input_array)))
    (~git_merge_base_many
      ~out
      ~repo
      ~length
      ~input_array)))
(export git_merge_base_many)

;; extern int git_merge_bases_many(git_oidarray *out, git_repository *repo, 
;;     size_t length, const git_oid input_array[]);
(define ~git_merge_bases_many #f)
(define (git_merge_bases_many
         out
         repo
         length
         input_array)
  (unless
    ~git_merge_bases_many
    (set! ~git_merge_bases_many
      (fh-link-proc
        "git_merge_bases_many"
        ffi:int
        (list '* '* ffi:size_t '*))))
  (let ((~out (unwrap-git_oidarray* out))
        (~repo (unwrap-git_repository* repo))
        (~length (unwrap~fixed length))
        (~input_array (unwrap~array input_array)))
    (~git_merge_bases_many
      ~out
      ~repo
      ~length
      ~input_array)))
(export git_merge_bases_many)

;; extern int git_merge_base_octopus(git_oid *out, git_repository *repo, size_t
;;      length, const git_oid input_array[]);
(define ~git_merge_base_octopus #f)
(define (git_merge_base_octopus
         out
         repo
         length
         input_array)
  (unless
    ~git_merge_base_octopus
    (set! ~git_merge_base_octopus
      (fh-link-proc
        "git_merge_base_octopus"
        ffi:int
        (list '* '* ffi:size_t '*))))
  (let ((~out (unwrap-git_oid* out))
        (~repo (unwrap-git_repository* repo))
        (~length (unwrap~fixed length))
        (~input_array (unwrap~array input_array)))
    (~git_merge_base_octopus
      ~out
      ~repo
      ~length
      ~input_array)))
(export git_merge_base_octopus)

;; extern int git_merge_file(git_merge_file_result *out, const 
;;     git_merge_file_input *ancestor, const git_merge_file_input *ours, const 
;;     git_merge_file_input *theirs, const git_merge_file_options *opts);
(define ~git_merge_file #f)
(define (git_merge_file out ancestor ours theirs opts)
  (unless
    ~git_merge_file
    (set! ~git_merge_file
      (fh-link-proc
        "git_merge_file"
        ffi:int
        (list '* '* '* '* '*))))
  (let ((~out (unwrap-git_merge_file_result* out))
        (~ancestor
          (unwrap-git_merge_file_input* ancestor))
        (~ours (unwrap-git_merge_file_input* ours))
        (~theirs (unwrap-git_merge_file_input* theirs))
        (~opts (unwrap-git_merge_file_options* opts)))
    (~git_merge_file
      ~out
      ~ancestor
      ~ours
      ~theirs
      ~opts)))
(export git_merge_file)

;; extern int git_merge_file_from_index(git_merge_file_result *out, 
;;     git_repository *repo, const git_index_entry *ancestor, const 
;;     git_index_entry *ours, const git_index_entry *theirs, const 
;;     git_merge_file_options *opts);
(define ~git_merge_file_from_index #f)
(define (git_merge_file_from_index
         out
         repo
         ancestor
         ours
         theirs
         opts)
  (unless
    ~git_merge_file_from_index
    (set! ~git_merge_file_from_index
      (fh-link-proc
        "git_merge_file_from_index"
        ffi:int
        (list '* '* '* '* '* '*))))
  (let ((~out (unwrap-git_merge_file_result* out))
        (~repo (unwrap-git_repository* repo))
        (~ancestor (unwrap-git_index_entry* ancestor))
        (~ours (unwrap-git_index_entry* ours))
        (~theirs (unwrap-git_index_entry* theirs))
        (~opts (unwrap-git_merge_file_options* opts)))
    (~git_merge_file_from_index
      ~out
      ~repo
      ~ancestor
      ~ours
      ~theirs
      ~opts)))
(export git_merge_file_from_index)

;; extern void git_merge_file_result_free(git_merge_file_result *result);
(define ~git_merge_file_result_free #f)
(define (git_merge_file_result_free result)
  (unless
    ~git_merge_file_result_free
    (set! ~git_merge_file_result_free
      (fh-link-proc
        "git_merge_file_result_free"
        ffi:void
        (list '*))))
  (let ((~result (unwrap-git_merge_file_result* result)))
    (~git_merge_file_result_free ~result)))
(export git_merge_file_result_free)

;; extern int git_merge_trees(git_index **out, git_repository *repo, const 
;;     git_tree *ancestor_tree, const git_tree *our_tree, const git_tree *
;;     their_tree, const git_merge_options *opts);
(define ~git_merge_trees #f)
(define (git_merge_trees
         out
         repo
         ancestor_tree
         our_tree
         their_tree
         opts)
  (unless
    ~git_merge_trees
    (set! ~git_merge_trees
      (fh-link-proc
        "git_merge_trees"
        ffi:int
        (list '* '* '* '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo))
        (~ancestor_tree (unwrap-git_tree* ancestor_tree))
        (~our_tree (unwrap-git_tree* our_tree))
        (~their_tree (unwrap-git_tree* their_tree))
        (~opts (unwrap-git_merge_options* opts)))
    (~git_merge_trees
      ~out
      ~repo
      ~ancestor_tree
      ~our_tree
      ~their_tree
      ~opts)))
(export git_merge_trees)

;; extern int git_merge_commits(git_index **out, git_repository *repo, const 
;;     git_commit *our_commit, const git_commit *their_commit, const 
;;     git_merge_options *opts);
(define ~git_merge_commits #f)
(define (git_merge_commits
         out
         repo
         our_commit
         their_commit
         opts)
  (unless
    ~git_merge_commits
    (set! ~git_merge_commits
      (fh-link-proc
        "git_merge_commits"
        ffi:int
        (list '* '* '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo))
        (~our_commit (unwrap-git_commit* our_commit))
        (~their_commit (unwrap-git_commit* their_commit))
        (~opts (unwrap-git_merge_options* opts)))
    (~git_merge_commits
      ~out
      ~repo
      ~our_commit
      ~their_commit
      ~opts)))
(export git_merge_commits)

;; extern int git_merge(git_repository *repo, const git_annotated_commit **
;;     their_heads, size_t their_heads_len, const git_merge_options *merge_opts
;;     , const git_checkout_options *checkout_opts);
(define ~git_merge #f)
(define (git_merge
         repo
         their_heads
         their_heads_len
         merge_opts
         checkout_opts)
  (unless
    ~git_merge
    (set! ~git_merge
      (fh-link-proc
        "git_merge"
        ffi:int
        (list '* '* ffi:size_t '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~their_heads (unwrap~pointer their_heads))
        (~their_heads_len (unwrap~fixed their_heads_len))
        (~merge_opts
          (unwrap-git_merge_options* merge_opts))
        (~checkout_opts
          (unwrap-git_checkout_options* checkout_opts)))
    (~git_merge
      ~repo
      ~their_heads
      ~their_heads_len
      ~merge_opts
      ~checkout_opts)))
(export git_merge)

;; typedef struct {
;;   unsigned int version;
;;   /** For merge commits, the "mainline" is treated as the parent. */
;;   unsigned int mainline;
;;   git_merge_options merge_opts; /**< Options for the merging */
;;   git_checkout_options checkout_opts; /**< Options for the checkout */
;; } git_cherrypick_options;
(define git_cherrypick_options-desc
  (bs:struct
    (list `(version ,unsigned-int)
          `(mainline ,unsigned-int)
          `(merge_opts ,git_merge_options-desc)
          `(checkout_opts ,git_checkout_options-desc))))
(export git_cherrypick_options-desc)
(define-fh-compound-type/p git_cherrypick_options git_cherrypick_options-desc)

;; extern int git_cherrypick_init_options(git_cherrypick_options *opts, 
;;     unsigned int version);
(define ~git_cherrypick_init_options #f)
(define (git_cherrypick_init_options opts version)
  (unless
    ~git_cherrypick_init_options
    (set! ~git_cherrypick_init_options
      (fh-link-proc
        "git_cherrypick_init_options"
        ffi:int
        (list '* ffi:unsigned-int))))
  (let ((~opts (unwrap-git_cherrypick_options* opts))
        (~version (unwrap~fixed version)))
    (~git_cherrypick_init_options ~opts ~version)))
(export git_cherrypick_init_options)

;; extern int git_cherrypick_commit(git_index **out, git_repository *repo, 
;;     git_commit *cherrypick_commit, git_commit *our_commit, unsigned int 
;;     mainline, const git_merge_options *merge_options);
(define ~git_cherrypick_commit #f)
(define (git_cherrypick_commit
         out
         repo
         cherrypick_commit
         our_commit
         mainline
         merge_options)
  (unless
    ~git_cherrypick_commit
    (set! ~git_cherrypick_commit
      (fh-link-proc
        "git_cherrypick_commit"
        ffi:int
        (list '* '* '* '* ffi:unsigned-int '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo))
        (~cherrypick_commit
          (unwrap-git_commit* cherrypick_commit))
        (~our_commit (unwrap-git_commit* our_commit))
        (~mainline (unwrap~fixed mainline))
        (~merge_options
          (unwrap-git_merge_options* merge_options)))
    (~git_cherrypick_commit
      ~out
      ~repo
      ~cherrypick_commit
      ~our_commit
      ~mainline
      ~merge_options)))
(export git_cherrypick_commit)

;; extern int git_cherrypick(git_repository *repo, git_commit *commit, const 
;;     git_cherrypick_options *cherrypick_options);
(define ~git_cherrypick #f)
(define (git_cherrypick repo commit cherrypick_options)
  (unless
    ~git_cherrypick
    (set! ~git_cherrypick
      (fh-link-proc
        "git_cherrypick"
        ffi:int
        (list '* '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~commit (unwrap-git_commit* commit))
        (~cherrypick_options
          (unwrap-git_cherrypick_options*
            cherrypick_options)))
    (~git_cherrypick
      ~repo
      ~commit
      ~cherrypick_options)))
(export git_cherrypick)

;; typedef enum {
;;   GIT_DIRECTION_FETCH = 0,
;;   GIT_DIRECTION_PUSH = 1,
;; } git_direction;
(define-fh-enum git_direction
  '((GIT_DIRECTION_FETCH . 0)
    (GIT_DIRECTION_PUSH . 1))
  )

;; struct git_remote_head {
;;   int local; /* available locally */
;;   git_oid oid;
;;   git_oid loid;
;;   char *name;
;;   /**
;;    * If the server send a symref mapping for this ref, this will
;;    * point to the target.
;;    */
;;   char *symref_target;
;; };
(define struct-git_remote_head-desc
  (bs:struct
    (list `(local ,int)
          `(oid ,git_oid-desc)
          `(loid ,git_oid-desc)
          `(name ,(bs:pointer int))
          `(symref_target ,(bs:pointer int)))))
(export struct-git_remote_head-desc)
(define-fh-compound-type/p struct-git_remote_head struct-git_remote_head-desc)
(set! git_remote_head-desc struct-git_remote_head-desc)
(define-fh-compound-type git_remote_head git_remote_head-desc)

;; typedef int (*git_headlist_cb)(git_remote_head *rhead, void *payload);
(define-fh-function/p git_headlist_cb
  ffi:int (list (quote *) (quote *)))

;; extern const char *git_refspec_src(const git_refspec *refspec);
(define ~git_refspec_src #f)
(define (git_refspec_src refspec)
  (unless
    ~git_refspec_src
    (set! ~git_refspec_src
      (fh-link-proc "git_refspec_src" '* (list '*))))
  (let ((~refspec (unwrap-git_refspec* refspec)))
    (~git_refspec_src ~refspec)))
(export git_refspec_src)

;; extern const char *git_refspec_dst(const git_refspec *refspec);
(define ~git_refspec_dst #f)
(define (git_refspec_dst refspec)
  (unless
    ~git_refspec_dst
    (set! ~git_refspec_dst
      (fh-link-proc "git_refspec_dst" '* (list '*))))
  (let ((~refspec (unwrap-git_refspec* refspec)))
    (~git_refspec_dst ~refspec)))
(export git_refspec_dst)

;; extern const char *git_refspec_string(const git_refspec *refspec);
(define ~git_refspec_string #f)
(define (git_refspec_string refspec)
  (unless
    ~git_refspec_string
    (set! ~git_refspec_string
      (fh-link-proc "git_refspec_string" '* (list '*))))
  (let ((~refspec (unwrap-git_refspec* refspec)))
    (~git_refspec_string ~refspec)))
(export git_refspec_string)

;; extern int git_refspec_force(const git_refspec *refspec);
(define ~git_refspec_force #f)
(define (git_refspec_force refspec)
  (unless
    ~git_refspec_force
    (set! ~git_refspec_force
      (fh-link-proc
        "git_refspec_force"
        ffi:int
        (list '*))))
  (let ((~refspec (unwrap-git_refspec* refspec)))
    (~git_refspec_force ~refspec)))
(export git_refspec_force)

;; extern git_direction git_refspec_direction(const git_refspec *spec);
(define ~git_refspec_direction #f)
(define (git_refspec_direction spec)
  (unless
    ~git_refspec_direction
    (set! ~git_refspec_direction
      (fh-link-proc
        "git_refspec_direction"
        ffi:int
        (list '*))))
  (let ((~spec (unwrap-git_refspec* spec)))
    (~git_refspec_direction ~spec)))
(export git_refspec_direction)

;; extern int git_refspec_src_matches(const git_refspec *refspec, const char *
;;     refname);
(define ~git_refspec_src_matches #f)
(define (git_refspec_src_matches refspec refname)
  (unless
    ~git_refspec_src_matches
    (set! ~git_refspec_src_matches
      (fh-link-proc
        "git_refspec_src_matches"
        ffi:int
        (list '* '*))))
  (let ((~refspec (unwrap-git_refspec* refspec))
        (~refname (unwrap~pointer refname)))
    (~git_refspec_src_matches ~refspec ~refname)))
(export git_refspec_src_matches)

;; extern int git_refspec_dst_matches(const git_refspec *refspec, const char *
;;     refname);
(define ~git_refspec_dst_matches #f)
(define (git_refspec_dst_matches refspec refname)
  (unless
    ~git_refspec_dst_matches
    (set! ~git_refspec_dst_matches
      (fh-link-proc
        "git_refspec_dst_matches"
        ffi:int
        (list '* '*))))
  (let ((~refspec (unwrap-git_refspec* refspec))
        (~refname (unwrap~pointer refname)))
    (~git_refspec_dst_matches ~refspec ~refname)))
(export git_refspec_dst_matches)

;; extern int git_refspec_transform(git_buf *out, const git_refspec *spec, 
;;     const char *name);
(define ~git_refspec_transform #f)
(define (git_refspec_transform out spec name)
  (unless
    ~git_refspec_transform
    (set! ~git_refspec_transform
      (fh-link-proc
        "git_refspec_transform"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap-git_buf* out))
        (~spec (unwrap-git_refspec* spec))
        (~name (unwrap~pointer name)))
    (~git_refspec_transform ~out ~spec ~name)))
(export git_refspec_transform)

;; extern int git_refspec_rtransform(git_buf *out, const git_refspec *spec, 
;;     const char *name);
(define ~git_refspec_rtransform #f)
(define (git_refspec_rtransform out spec name)
  (unless
    ~git_refspec_rtransform
    (set! ~git_refspec_rtransform
      (fh-link-proc
        "git_refspec_rtransform"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap-git_buf* out))
        (~spec (unwrap-git_refspec* spec))
        (~name (unwrap~pointer name)))
    (~git_refspec_rtransform ~out ~spec ~name)))
(export git_refspec_rtransform)

;; typedef int (*git_transport_cb)(git_transport **out, git_remote *owner, void
;;      *param);
(define-fh-function/p git_transport_cb
  ffi:int (list (quote *) (quote *) (quote *)))

;; typedef enum {
;;   GIT_CERT_SSH_MD5 = 1<<0,
;;   GIT_CERT_SSH_SHA1 = 1<<1,
;; } git_cert_ssh_t;
(define-fh-enum git_cert_ssh_t
  '((GIT_CERT_SSH_MD5 . 1) (GIT_CERT_SSH_SHA1 . 2))
  )

;; typedef struct {
;;   git_cert parent;
;;   /**
;;    * A hostkey type from libssh2, either
;;    * `GIT_CERT_SSH_MD5` or `GIT_CERT_SSH_SHA1`
;;    */
;;   git_cert_ssh_t type;
;;   /**
;;    * Hostkey hash. If type has `GIT_CERT_SSH_MD5` set, this will
;;    * have the MD5 hash of the hostkey.
;;    */
;;   unsigned char hash_md5[16];
;;   /**
;;    * Hostkey hash. If type has `GIT_CERT_SSH_SHA1` set, this will
;;    * have the SHA-1 hash of the hostkey.
;;    */
;;   unsigned char hash_sha1[20];
;; } git_cert_hostkey;
(define git_cert_hostkey-desc
  (bs:struct
    (list `(parent ,git_cert-desc)
          `(type ,int)
          `(hash_md5 ,(bs:vector 16 uint8))
          `(hash_sha1 ,(bs:vector 20 uint8)))))
(export git_cert_hostkey-desc)
(define-fh-compound-type/p git_cert_hostkey git_cert_hostkey-desc)

;; typedef struct {
;;   git_cert parent;
;;   /**
;;    * Pointer to the X.509 certificate data
;;    */
;;   void *data;
;;   /**
;;    * Length of the memory block pointed to by `data`.
;;    */
;;   size_t len;
;; } git_cert_x509;
(define git_cert_x509-desc
  (bs:struct
    (list `(parent ,git_cert-desc)
          `(data ,(bs:pointer void))
          `(len ,size_t))))
(export git_cert_x509-desc)
(define-fh-compound-type/p git_cert_x509 git_cert_x509-desc)

;; typedef enum {
;;   GIT_CREDTYPE_USERPASS_PLAINTEXT = 1u<<0,
;;   GIT_CREDTYPE_SSH_KEY = 1u<<1,
;;   GIT_CREDTYPE_SSH_CUSTOM = 1u<<2,
;;   GIT_CREDTYPE_DEFAULT = 1u<<3,
;;   GIT_CREDTYPE_SSH_INTERACTIVE = 1u<<4,
;;   GIT_CREDTYPE_USERNAME = 1u<<5,
;;   GIT_CREDTYPE_SSH_MEMORY = 1u<<6,
;; } git_credtype_t;
(define-fh-enum git_credtype_t
  '((GIT_CREDTYPE_USERPASS_PLAINTEXT . 1)
    (GIT_CREDTYPE_SSH_KEY . 2)
    (GIT_CREDTYPE_SSH_CUSTOM . 4)
    (GIT_CREDTYPE_DEFAULT . 8)
    (GIT_CREDTYPE_SSH_INTERACTIVE . 16)
    (GIT_CREDTYPE_USERNAME . 32)
    (GIT_CREDTYPE_SSH_MEMORY . 64))
  )

;; typedef struct git_cred git_cred;
(define git_cred-desc void)
(export git_cred-desc)
(define git_cred*-desc (bs:pointer (delay git_cred-desc)))
(export git_cred*-desc)
(define-fh-pointer-type git_cred* git_cred*-desc)

;; struct git_cred {
;;   git_credtype_t credtype;
;;   void (*free)(git_cred *cred);
;; };
(define struct-git_cred-desc
  (bs:struct
    (list `(credtype ,int)
          `(free ,(bs:pointer void)))))
(export struct-git_cred-desc)
(define-fh-compound-type/p struct-git_cred struct-git_cred-desc)
(set! git_cred-desc struct-git_cred-desc)
(define-fh-compound-type git_cred git_cred-desc)

;; typedef struct {
;;   git_cred parent;
;;   char *username;
;;   char *password;
;; } git_cred_userpass_plaintext;
(define git_cred_userpass_plaintext-desc
  (bs:struct
    (list `(parent ,git_cred-desc)
          `(username ,(bs:pointer int))
          `(password ,(bs:pointer int)))))
(export git_cred_userpass_plaintext-desc)
(define-fh-compound-type/p git_cred_userpass_plaintext git_cred_userpass_plaintext-desc)

;; typedef struct _LIBSSH2_SESSION LIBSSH2_SESSION;
(define LIBSSH2_SESSION-desc void)
(export LIBSSH2_SESSION-desc)
(define LIBSSH2_SESSION*-desc (bs:pointer LIBSSH2_SESSION-desc))
(export LIBSSH2_SESSION*-desc)
(define-fh-pointer-type LIBSSH2_SESSION* LIBSSH2_SESSION*-desc)

;; typedef struct _LIBSSH2_USERAUTH_KBDINT_PROMPT 
;;     LIBSSH2_USERAUTH_KBDINT_PROMPT;
(define LIBSSH2_USERAUTH_KBDINT_PROMPT-desc void)
(export LIBSSH2_USERAUTH_KBDINT_PROMPT-desc)
(define LIBSSH2_USERAUTH_KBDINT_PROMPT*-desc (bs:pointer LIBSSH2_USERAUTH_KBDINT_PROMPT-desc))
(export LIBSSH2_USERAUTH_KBDINT_PROMPT*-desc)
(define-fh-pointer-type LIBSSH2_USERAUTH_KBDINT_PROMPT* LIBSSH2_USERAUTH_KBDINT_PROMPT*-desc)

;; typedef struct _LIBSSH2_USERAUTH_KBDINT_RESPONSE 
;;     LIBSSH2_USERAUTH_KBDINT_RESPONSE;
(define LIBSSH2_USERAUTH_KBDINT_RESPONSE-desc void)
(export LIBSSH2_USERAUTH_KBDINT_RESPONSE-desc)
(define LIBSSH2_USERAUTH_KBDINT_RESPONSE*-desc (bs:pointer LIBSSH2_USERAUTH_KBDINT_RESPONSE-desc))
(export LIBSSH2_USERAUTH_KBDINT_RESPONSE*-desc)
(define-fh-pointer-type LIBSSH2_USERAUTH_KBDINT_RESPONSE* LIBSSH2_USERAUTH_KBDINT_RESPONSE*-desc)

;; typedef int (*git_cred_sign_callback)(LIBSSH2_SESSION *session, 
;;     unsigned char **sig, size_t *sig_len, const unsigned char *data, size_t 
;;     data_len, void **abstract);
(define-fh-function/p git_cred_sign_callback
  ffi:int (list (quote *) (quote *) (quote *) (quote *) ffi:size_t (quote *)))

;; typedef void (*git_cred_ssh_interactive_callback)(const char *name, int 
;;     name_len, const char *instruction, int instruction_len, int num_prompts
;;     , const LIBSSH2_USERAUTH_KBDINT_PROMPT *prompts, 
;;     LIBSSH2_USERAUTH_KBDINT_RESPONSE *responses, void **abstract);
(define-fh-function/p git_cred_ssh_interactive_callback
  ffi:void (list (quote *) ffi:int (quote *) ffi:int ffi:int (quote *) (quote *) (quote *)))

;; typedef struct git_cred_ssh_key {
;;   git_cred parent;
;;   char *username;
;;   char *publickey;
;;   char *privatekey;
;;   char *passphrase;
;; } git_cred_ssh_key;
(define git_cred_ssh_key-desc
  (bs:struct
    (list `(parent ,git_cred-desc)
          `(username ,(bs:pointer int))
          `(publickey ,(bs:pointer int))
          `(privatekey ,(bs:pointer int))
          `(passphrase ,(bs:pointer int)))))
(export git_cred_ssh_key-desc)
(define-fh-compound-type/p git_cred_ssh_key git_cred_ssh_key-desc)
(define struct-git_cred_ssh_key git_cred_ssh_key)

;; typedef struct git_cred_ssh_interactive {
;;   git_cred parent;
;;   char *username;
;;   git_cred_ssh_interactive_callback prompt_callback;
;;   void *payload;
;; } git_cred_ssh_interactive;
(define git_cred_ssh_interactive-desc
  (bs:struct
    (list `(parent ,git_cred-desc)
          `(username ,(bs:pointer int))
          `(prompt_callback ,(bs:pointer void))
          `(payload ,(bs:pointer void)))))
(export git_cred_ssh_interactive-desc)
(define-fh-compound-type/p git_cred_ssh_interactive git_cred_ssh_interactive-desc)
(define struct-git_cred_ssh_interactive git_cred_ssh_interactive)

;; typedef struct git_cred_ssh_custom {
;;   git_cred parent;
;;   char *username;
;;   char *publickey;
;;   size_t publickey_len;
;;   git_cred_sign_callback sign_callback;
;;   void *payload;
;; } git_cred_ssh_custom;
(define git_cred_ssh_custom-desc
  (bs:struct
    (list `(parent ,git_cred-desc)
          `(username ,(bs:pointer int))
          `(publickey ,(bs:pointer int))
          `(publickey_len ,size_t)
          `(sign_callback ,(bs:pointer void))
          `(payload ,(bs:pointer void)))))
(export git_cred_ssh_custom-desc)
(define-fh-compound-type/p git_cred_ssh_custom git_cred_ssh_custom-desc)
(define struct-git_cred_ssh_custom git_cred_ssh_custom)

;; typedef struct git_cred git_cred_default;
(define git_cred_default-desc void)
(export git_cred_default-desc)
(define git_cred_default*-desc (bs:pointer (delay git_cred_default-desc)))
(export git_cred_default*-desc)
(define-fh-pointer-type git_cred_default* git_cred_default*-desc)

;; typedef struct git_cred_username {
;;   git_cred parent;
;;   char username[1];
;; } git_cred_username;
(define git_cred_username-desc
  (bs:struct
    (list `(parent ,git_cred-desc)
          `(username ,(bs:vector 1 int8)))))
(export git_cred_username-desc)
(define-fh-compound-type/p git_cred_username git_cred_username-desc)
(define struct-git_cred_username git_cred_username)

;; extern int git_cred_has_username(git_cred *cred);
(define ~git_cred_has_username #f)
(define (git_cred_has_username cred)
  (unless
    ~git_cred_has_username
    (set! ~git_cred_has_username
      (fh-link-proc
        "git_cred_has_username"
        ffi:int
        (list '*))))
  (let ((~cred (unwrap-git_cred* cred)))
    (~git_cred_has_username ~cred)))
(export git_cred_has_username)

;; extern int git_cred_userpass_plaintext_new(git_cred **out, const char *
;;     username, const char *password);
(define ~git_cred_userpass_plaintext_new #f)
(define (git_cred_userpass_plaintext_new
         out
         username
         password)
  (unless
    ~git_cred_userpass_plaintext_new
    (set! ~git_cred_userpass_plaintext_new
      (fh-link-proc
        "git_cred_userpass_plaintext_new"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~username (unwrap~pointer username))
        (~password (unwrap~pointer password)))
    (~git_cred_userpass_plaintext_new
      ~out
      ~username
      ~password)))
(export git_cred_userpass_plaintext_new)

;; extern int git_cred_ssh_key_new(git_cred **out, const char *username, const 
;;     char *publickey, const char *privatekey, const char *passphrase);
(define ~git_cred_ssh_key_new #f)
(define (git_cred_ssh_key_new
         out
         username
         publickey
         privatekey
         passphrase)
  (unless
    ~git_cred_ssh_key_new
    (set! ~git_cred_ssh_key_new
      (fh-link-proc
        "git_cred_ssh_key_new"
        ffi:int
        (list '* '* '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~username (unwrap~pointer username))
        (~publickey (unwrap~pointer publickey))
        (~privatekey (unwrap~pointer privatekey))
        (~passphrase (unwrap~pointer passphrase)))
    (~git_cred_ssh_key_new
      ~out
      ~username
      ~publickey
      ~privatekey
      ~passphrase)))
(export git_cred_ssh_key_new)

;; extern int git_cred_ssh_interactive_new(git_cred **out, const char *username
;;     , git_cred_ssh_interactive_callback prompt_callback, void *payload);
(define ~git_cred_ssh_interactive_new #f)
(define (git_cred_ssh_interactive_new
         out
         username
         prompt_callback
         payload)
  (unless
    ~git_cred_ssh_interactive_new
    (set! ~git_cred_ssh_interactive_new
      (fh-link-proc
        "git_cred_ssh_interactive_new"
        ffi:int
        (list '* '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~username (unwrap~pointer username))
        (~prompt_callback
          ((make-ftn-arg-unwrapper
             ffi:void
             (list '* ffi:int '* ffi:int ffi:int '* '* '*))
           prompt_callback))
        (~payload (unwrap~pointer payload)))
    (~git_cred_ssh_interactive_new
      ~out
      ~username
      ~prompt_callback
      ~payload)))
(export git_cred_ssh_interactive_new)

;; extern int git_cred_ssh_key_from_agent(git_cred **out, const char *username)
;;     ;
(define ~git_cred_ssh_key_from_agent #f)
(define (git_cred_ssh_key_from_agent out username)
  (unless
    ~git_cred_ssh_key_from_agent
    (set! ~git_cred_ssh_key_from_agent
      (fh-link-proc
        "git_cred_ssh_key_from_agent"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~username (unwrap~pointer username)))
    (~git_cred_ssh_key_from_agent ~out ~username)))
(export git_cred_ssh_key_from_agent)

;; extern int git_cred_ssh_custom_new(git_cred **out, const char *username, 
;;     const char *publickey, size_t publickey_len, git_cred_sign_callback 
;;     sign_callback, void *payload);
(define ~git_cred_ssh_custom_new #f)
(define (git_cred_ssh_custom_new
         out
         username
         publickey
         publickey_len
         sign_callback
         payload)
  (unless
    ~git_cred_ssh_custom_new
    (set! ~git_cred_ssh_custom_new
      (fh-link-proc
        "git_cred_ssh_custom_new"
        ffi:int
        (list '* '* '* ffi:size_t '* '*))))
  (let ((~out (unwrap~pointer out))
        (~username (unwrap~pointer username))
        (~publickey (unwrap~pointer publickey))
        (~publickey_len (unwrap~fixed publickey_len))
        (~sign_callback
          ((make-ftn-arg-unwrapper
             ffi:int
             (list '* '* '* '* ffi:size_t '*))
           sign_callback))
        (~payload (unwrap~pointer payload)))
    (~git_cred_ssh_custom_new
      ~out
      ~username
      ~publickey
      ~publickey_len
      ~sign_callback
      ~payload)))
(export git_cred_ssh_custom_new)

;; extern int git_cred_default_new(git_cred **out);
(define ~git_cred_default_new #f)
(define (git_cred_default_new out)
  (unless
    ~git_cred_default_new
    (set! ~git_cred_default_new
      (fh-link-proc
        "git_cred_default_new"
        ffi:int
        (list '*))))
  (let ((~out (unwrap~pointer out)))
    (~git_cred_default_new ~out)))
(export git_cred_default_new)

;; extern int git_cred_username_new(git_cred **cred, const char *username);
(define ~git_cred_username_new #f)
(define (git_cred_username_new cred username)
  (unless
    ~git_cred_username_new
    (set! ~git_cred_username_new
      (fh-link-proc
        "git_cred_username_new"
        ffi:int
        (list '* '*))))
  (let ((~cred (unwrap~pointer cred))
        (~username (unwrap~pointer username)))
    (~git_cred_username_new ~cred ~username)))
(export git_cred_username_new)

;; extern int git_cred_ssh_key_memory_new(git_cred **out, const char *username
;;     , const char *publickey, const char *privatekey, const char *passphrase)
;;     ;
(define ~git_cred_ssh_key_memory_new #f)
(define (git_cred_ssh_key_memory_new
         out
         username
         publickey
         privatekey
         passphrase)
  (unless
    ~git_cred_ssh_key_memory_new
    (set! ~git_cred_ssh_key_memory_new
      (fh-link-proc
        "git_cred_ssh_key_memory_new"
        ffi:int
        (list '* '* '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~username (unwrap~pointer username))
        (~publickey (unwrap~pointer publickey))
        (~privatekey (unwrap~pointer privatekey))
        (~passphrase (unwrap~pointer passphrase)))
    (~git_cred_ssh_key_memory_new
      ~out
      ~username
      ~publickey
      ~privatekey
      ~passphrase)))
(export git_cred_ssh_key_memory_new)

;; extern void git_cred_free(git_cred *cred);
(define ~git_cred_free #f)
(define (git_cred_free cred)
  (unless
    ~git_cred_free
    (set! ~git_cred_free
      (fh-link-proc "git_cred_free" ffi:void (list '*))))
  (let ((~cred (unwrap-git_cred* cred)))
    (~git_cred_free ~cred)))
(export git_cred_free)

;; typedef int (*git_cred_acquire_cb)(git_cred **cred, const char *url, const 
;;     char *username_from_url, unsigned int allowed_types, void *payload);
(define-fh-function/p git_cred_acquire_cb
  ffi:int (list (quote *) (quote *) (quote *) ffi:unsigned-int (quote *)))

;; typedef enum {
;;   GIT_PACKBUILDER_ADDING_OBJECTS = 0,
;;   GIT_PACKBUILDER_DELTAFICATION = 1,
;; } git_packbuilder_stage_t;
(define-fh-enum git_packbuilder_stage_t
  '((GIT_PACKBUILDER_ADDING_OBJECTS . 0)
    (GIT_PACKBUILDER_DELTAFICATION . 1))
  )

;; extern int git_packbuilder_new(git_packbuilder **out, git_repository *repo)
;;     ;
(define ~git_packbuilder_new #f)
(define (git_packbuilder_new out repo)
  (unless
    ~git_packbuilder_new
    (set! ~git_packbuilder_new
      (fh-link-proc
        "git_packbuilder_new"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo)))
    (~git_packbuilder_new ~out ~repo)))
(export git_packbuilder_new)

;; extern unsigned int git_packbuilder_set_threads(git_packbuilder *pb, 
;;     unsigned int n);
(define ~git_packbuilder_set_threads #f)
(define (git_packbuilder_set_threads pb n)
  (unless
    ~git_packbuilder_set_threads
    (set! ~git_packbuilder_set_threads
      (fh-link-proc
        "git_packbuilder_set_threads"
        ffi:unsigned-int
        (list '* ffi:unsigned-int))))
  (let ((~pb (unwrap-git_packbuilder* pb))
        (~n (unwrap~fixed n)))
    (~git_packbuilder_set_threads ~pb ~n)))
(export git_packbuilder_set_threads)

;; extern int git_packbuilder_insert(git_packbuilder *pb, const git_oid *id, 
;;     const char *name);
(define ~git_packbuilder_insert #f)
(define (git_packbuilder_insert pb id name)
  (unless
    ~git_packbuilder_insert
    (set! ~git_packbuilder_insert
      (fh-link-proc
        "git_packbuilder_insert"
        ffi:int
        (list '* '* '*))))
  (let ((~pb (unwrap-git_packbuilder* pb))
        (~id (unwrap-git_oid* id))
        (~name (unwrap~pointer name)))
    (~git_packbuilder_insert ~pb ~id ~name)))
(export git_packbuilder_insert)

;; extern int git_packbuilder_insert_tree(git_packbuilder *pb, const git_oid *
;;     id);
(define ~git_packbuilder_insert_tree #f)
(define (git_packbuilder_insert_tree pb id)
  (unless
    ~git_packbuilder_insert_tree
    (set! ~git_packbuilder_insert_tree
      (fh-link-proc
        "git_packbuilder_insert_tree"
        ffi:int
        (list '* '*))))
  (let ((~pb (unwrap-git_packbuilder* pb))
        (~id (unwrap-git_oid* id)))
    (~git_packbuilder_insert_tree ~pb ~id)))
(export git_packbuilder_insert_tree)

;; extern int git_packbuilder_insert_commit(git_packbuilder *pb, const git_oid 
;;     *id);
(define ~git_packbuilder_insert_commit #f)
(define (git_packbuilder_insert_commit pb id)
  (unless
    ~git_packbuilder_insert_commit
    (set! ~git_packbuilder_insert_commit
      (fh-link-proc
        "git_packbuilder_insert_commit"
        ffi:int
        (list '* '*))))
  (let ((~pb (unwrap-git_packbuilder* pb))
        (~id (unwrap-git_oid* id)))
    (~git_packbuilder_insert_commit ~pb ~id)))
(export git_packbuilder_insert_commit)

;; extern int git_packbuilder_insert_walk(git_packbuilder *pb, git_revwalk *
;;     walk);
(define ~git_packbuilder_insert_walk #f)
(define (git_packbuilder_insert_walk pb walk)
  (unless
    ~git_packbuilder_insert_walk
    (set! ~git_packbuilder_insert_walk
      (fh-link-proc
        "git_packbuilder_insert_walk"
        ffi:int
        (list '* '*))))
  (let ((~pb (unwrap-git_packbuilder* pb))
        (~walk (unwrap-git_revwalk* walk)))
    (~git_packbuilder_insert_walk ~pb ~walk)))
(export git_packbuilder_insert_walk)

;; extern int git_packbuilder_insert_recur(git_packbuilder *pb, const git_oid *
;;     id, const char *name);
(define ~git_packbuilder_insert_recur #f)
(define (git_packbuilder_insert_recur pb id name)
  (unless
    ~git_packbuilder_insert_recur
    (set! ~git_packbuilder_insert_recur
      (fh-link-proc
        "git_packbuilder_insert_recur"
        ffi:int
        (list '* '* '*))))
  (let ((~pb (unwrap-git_packbuilder* pb))
        (~id (unwrap-git_oid* id))
        (~name (unwrap~pointer name)))
    (~git_packbuilder_insert_recur ~pb ~id ~name)))
(export git_packbuilder_insert_recur)

;; extern int git_packbuilder_write_buf(git_buf *buf, git_packbuilder *pb);
(define ~git_packbuilder_write_buf #f)
(define (git_packbuilder_write_buf buf pb)
  (unless
    ~git_packbuilder_write_buf
    (set! ~git_packbuilder_write_buf
      (fh-link-proc
        "git_packbuilder_write_buf"
        ffi:int
        (list '* '*))))
  (let ((~buf (unwrap-git_buf* buf))
        (~pb (unwrap-git_packbuilder* pb)))
    (~git_packbuilder_write_buf ~buf ~pb)))
(export git_packbuilder_write_buf)

;; extern int git_packbuilder_write(git_packbuilder *pb, const char *path, 
;;     unsigned int mode, git_transfer_progress_cb progress_cb, void *
;;     progress_cb_payload);
(define ~git_packbuilder_write #f)
(define (git_packbuilder_write
         pb
         path
         mode
         progress_cb
         progress_cb_payload)
  (unless
    ~git_packbuilder_write
    (set! ~git_packbuilder_write
      (fh-link-proc
        "git_packbuilder_write"
        ffi:int
        (list '* '* ffi:unsigned-int '* '*))))
  (let ((~pb (unwrap-git_packbuilder* pb))
        (~path (unwrap~pointer path))
        (~mode (unwrap~fixed mode))
        (~progress_cb
          ((make-ftn-arg-unwrapper ffi:int (list '* '*))
           progress_cb))
        (~progress_cb_payload
          (unwrap~pointer progress_cb_payload)))
    (~git_packbuilder_write
      ~pb
      ~path
      ~mode
      ~progress_cb
      ~progress_cb_payload)))
(export git_packbuilder_write)

;; extern const git_oid *git_packbuilder_hash(git_packbuilder *pb);
(define ~git_packbuilder_hash #f)
(define (git_packbuilder_hash pb)
  (unless
    ~git_packbuilder_hash
    (set! ~git_packbuilder_hash
      (fh-link-proc
        "git_packbuilder_hash"
        '*
        (list '*))))
  (let ((~pb (unwrap-git_packbuilder* pb)))
    (wrap-git_oid* (~git_packbuilder_hash ~pb))))
(export git_packbuilder_hash)

;; typedef int (*git_packbuilder_foreach_cb)(void *buf, size_t size, void *
;;     payload);
(define-fh-function/p git_packbuilder_foreach_cb
  ffi:int (list (quote *) ffi:size_t (quote *)))

;; extern int git_packbuilder_foreach(git_packbuilder *pb, 
;;     git_packbuilder_foreach_cb cb, void *payload);
(define ~git_packbuilder_foreach #f)
(define (git_packbuilder_foreach pb cb payload)
  (unless
    ~git_packbuilder_foreach
    (set! ~git_packbuilder_foreach
      (fh-link-proc
        "git_packbuilder_foreach"
        ffi:int
        (list '* '* '*))))
  (let ((~pb (unwrap-git_packbuilder* pb))
        (~cb ((make-ftn-arg-unwrapper
                ffi:int
                (list '* ffi:size_t '*))
              cb))
        (~payload (unwrap~pointer payload)))
    (~git_packbuilder_foreach ~pb ~cb ~payload)))
(export git_packbuilder_foreach)

;; extern size_t git_packbuilder_object_count(git_packbuilder *pb);
(define ~git_packbuilder_object_count #f)
(define (git_packbuilder_object_count pb)
  (unless
    ~git_packbuilder_object_count
    (set! ~git_packbuilder_object_count
      (fh-link-proc
        "git_packbuilder_object_count"
        ffi:size_t
        (list '*))))
  (let ((~pb (unwrap-git_packbuilder* pb)))
    (~git_packbuilder_object_count ~pb)))
(export git_packbuilder_object_count)

;; extern size_t git_packbuilder_written(git_packbuilder *pb);
(define ~git_packbuilder_written #f)
(define (git_packbuilder_written pb)
  (unless
    ~git_packbuilder_written
    (set! ~git_packbuilder_written
      (fh-link-proc
        "git_packbuilder_written"
        ffi:size_t
        (list '*))))
  (let ((~pb (unwrap-git_packbuilder* pb)))
    (~git_packbuilder_written ~pb)))
(export git_packbuilder_written)

;; typedef int (*git_packbuilder_progress)(int stage, uint32_t current, 
;;     uint32_t total, void *payload);
(define-fh-function/p git_packbuilder_progress
  ffi:int (list ffi:int ffi:uint32 ffi:uint32 (quote *)))

;; extern int git_packbuilder_set_callbacks(git_packbuilder *pb, 
;;     git_packbuilder_progress progress_cb, void *progress_cb_payload);
(define ~git_packbuilder_set_callbacks #f)
(define (git_packbuilder_set_callbacks
         pb
         progress_cb
         progress_cb_payload)
  (unless
    ~git_packbuilder_set_callbacks
    (set! ~git_packbuilder_set_callbacks
      (fh-link-proc
        "git_packbuilder_set_callbacks"
        ffi:int
        (list '* '* '*))))
  (let ((~pb (unwrap-git_packbuilder* pb))
        (~progress_cb
          ((make-ftn-arg-unwrapper
             ffi:int
             (list ffi:int ffi:uint32 ffi:uint32 '*))
           progress_cb))
        (~progress_cb_payload
          (unwrap~pointer progress_cb_payload)))
    (~git_packbuilder_set_callbacks
      ~pb
      ~progress_cb
      ~progress_cb_payload)))
(export git_packbuilder_set_callbacks)

;; extern void git_packbuilder_free(git_packbuilder *pb);
(define ~git_packbuilder_free #f)
(define (git_packbuilder_free pb)
  (unless
    ~git_packbuilder_free
    (set! ~git_packbuilder_free
      (fh-link-proc
        "git_packbuilder_free"
        ffi:void
        (list '*))))
  (let ((~pb (unwrap-git_packbuilder* pb)))
    (~git_packbuilder_free ~pb)))
(export git_packbuilder_free)

;; typedef enum {
;;   GIT_PROXY_NONE,
;;   GIT_PROXY_AUTO,
;;   GIT_PROXY_SPECIFIED,
;; } git_proxy_t;
(define-fh-enum git_proxy_t
  '((GIT_PROXY_NONE . 0)
    (GIT_PROXY_AUTO . 1)
    (GIT_PROXY_SPECIFIED . 2))
  )

;; typedef struct {
;;   unsigned int version;
;;   /**
;;    * The type of proxy to use, by URL, auto-detect.
;;    */
;;   git_proxy_t type;
;;   /**
;;    * The URL of the proxy.
;;    */
;;   const char *url;
;;   /**
;;    * This will be called if the remote host requires
;;    * authentication in order to connect to it.
;;    *
;;    * Returning GIT_PASSTHROUGH will make libgit2 behave as
;;    * though this field isn't set.
;;    */
;;   git_cred_acquire_cb credentials;
;;   /**
;;    * If cert verification fails, this will be called to let the
;;    * user make the final decision of whether to allow the
;;    * connection to proceed. Returns 1 to allow the connection, 0
;;    * to disallow it or a negative value to indicate an error.
;;    */
;;   git_transport_certificate_check_cb certificate_check;
;;   /**
;;    * Payload to be provided to the credentials and certificate
;;    * check callbacks.
;;    */
;;   void *payload;
;; } git_proxy_options;
(define git_proxy_options-desc
  (bs:struct
    (list `(version ,unsigned-int)
          `(type ,int)
          `(url ,(bs:pointer int))
          `(credentials ,(bs:pointer void))
          `(certificate_check ,(bs:pointer void))
          `(payload ,(bs:pointer void)))))
(export git_proxy_options-desc)
(define-fh-compound-type/p git_proxy_options git_proxy_options-desc)

;; extern int git_proxy_init_options(git_proxy_options *opts, unsigned int 
;;     version);
(define ~git_proxy_init_options #f)
(define (git_proxy_init_options opts version)
  (unless
    ~git_proxy_init_options
    (set! ~git_proxy_init_options
      (fh-link-proc
        "git_proxy_init_options"
        ffi:int
        (list '* ffi:unsigned-int))))
  (let ((~opts (unwrap-git_proxy_options* opts))
        (~version (unwrap~fixed version)))
    (~git_proxy_init_options ~opts ~version)))
(export git_proxy_init_options)

;; extern int git_remote_create(git_remote **out, git_repository *repo, const 
;;     char *name, const char *url);
(define ~git_remote_create #f)
(define (git_remote_create out repo name url)
  (unless
    ~git_remote_create
    (set! ~git_remote_create
      (fh-link-proc
        "git_remote_create"
        ffi:int
        (list '* '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo))
        (~name (unwrap~pointer name))
        (~url (unwrap~pointer url)))
    (~git_remote_create ~out ~repo ~name ~url)))
(export git_remote_create)

;; extern int git_remote_create_with_fetchspec(git_remote **out, git_repository
;;      *repo, const char *name, const char *url, const char *fetch);
(define ~git_remote_create_with_fetchspec #f)
(define (git_remote_create_with_fetchspec
         out
         repo
         name
         url
         fetch)
  (unless
    ~git_remote_create_with_fetchspec
    (set! ~git_remote_create_with_fetchspec
      (fh-link-proc
        "git_remote_create_with_fetchspec"
        ffi:int
        (list '* '* '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo))
        (~name (unwrap~pointer name))
        (~url (unwrap~pointer url))
        (~fetch (unwrap~pointer fetch)))
    (~git_remote_create_with_fetchspec
      ~out
      ~repo
      ~name
      ~url
      ~fetch)))
(export git_remote_create_with_fetchspec)

;; extern int git_remote_create_anonymous(git_remote **out, git_repository *
;;     repo, const char *url);
(define ~git_remote_create_anonymous #f)
(define (git_remote_create_anonymous out repo url)
  (unless
    ~git_remote_create_anonymous
    (set! ~git_remote_create_anonymous
      (fh-link-proc
        "git_remote_create_anonymous"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo))
        (~url (unwrap~pointer url)))
    (~git_remote_create_anonymous ~out ~repo ~url)))
(export git_remote_create_anonymous)

;; extern int git_remote_lookup(git_remote **out, git_repository *repo, const 
;;     char *name);
(define ~git_remote_lookup #f)
(define (git_remote_lookup out repo name)
  (unless
    ~git_remote_lookup
    (set! ~git_remote_lookup
      (fh-link-proc
        "git_remote_lookup"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo))
        (~name (unwrap~pointer name)))
    (~git_remote_lookup ~out ~repo ~name)))
(export git_remote_lookup)

;; extern int git_remote_dup(git_remote **dest, git_remote *source);
(define ~git_remote_dup #f)
(define (git_remote_dup dest source)
  (unless
    ~git_remote_dup
    (set! ~git_remote_dup
      (fh-link-proc
        "git_remote_dup"
        ffi:int
        (list '* '*))))
  (let ((~dest (unwrap~pointer dest))
        (~source (unwrap-git_remote* source)))
    (~git_remote_dup ~dest ~source)))
(export git_remote_dup)

;; extern git_repository *git_remote_owner(const git_remote *remote);
(define ~git_remote_owner #f)
(define (git_remote_owner remote)
  (unless
    ~git_remote_owner
    (set! ~git_remote_owner
      (fh-link-proc "git_remote_owner" '* (list '*))))
  (let ((~remote (unwrap-git_remote* remote)))
    (wrap-git_repository*
      (~git_remote_owner ~remote))))
(export git_remote_owner)

;; extern const char *git_remote_name(const git_remote *remote);
(define ~git_remote_name #f)
(define (git_remote_name remote)
  (unless
    ~git_remote_name
    (set! ~git_remote_name
      (fh-link-proc "git_remote_name" '* (list '*))))
  (let ((~remote (unwrap-git_remote* remote)))
    (~git_remote_name ~remote)))
(export git_remote_name)

;; extern const char *git_remote_url(const git_remote *remote);
(define ~git_remote_url #f)
(define (git_remote_url remote)
  (unless
    ~git_remote_url
    (set! ~git_remote_url
      (fh-link-proc "git_remote_url" '* (list '*))))
  (let ((~remote (unwrap-git_remote* remote)))
    (~git_remote_url ~remote)))
(export git_remote_url)

;; extern const char *git_remote_pushurl(const git_remote *remote);
(define ~git_remote_pushurl #f)
(define (git_remote_pushurl remote)
  (unless
    ~git_remote_pushurl
    (set! ~git_remote_pushurl
      (fh-link-proc "git_remote_pushurl" '* (list '*))))
  (let ((~remote (unwrap-git_remote* remote)))
    (~git_remote_pushurl ~remote)))
(export git_remote_pushurl)

;; extern int git_remote_set_url(git_repository *repo, const char *remote, 
;;     const char *url);
(define ~git_remote_set_url #f)
(define (git_remote_set_url repo remote url)
  (unless
    ~git_remote_set_url
    (set! ~git_remote_set_url
      (fh-link-proc
        "git_remote_set_url"
        ffi:int
        (list '* '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~remote (unwrap~pointer remote))
        (~url (unwrap~pointer url)))
    (~git_remote_set_url ~repo ~remote ~url)))
(export git_remote_set_url)

;; extern int git_remote_set_pushurl(git_repository *repo, const char *remote, 
;;     const char *url);
(define ~git_remote_set_pushurl #f)
(define (git_remote_set_pushurl repo remote url)
  (unless
    ~git_remote_set_pushurl
    (set! ~git_remote_set_pushurl
      (fh-link-proc
        "git_remote_set_pushurl"
        ffi:int
        (list '* '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~remote (unwrap~pointer remote))
        (~url (unwrap~pointer url)))
    (~git_remote_set_pushurl ~repo ~remote ~url)))
(export git_remote_set_pushurl)

;; extern int git_remote_add_fetch(git_repository *repo, const char *remote, 
;;     const char *refspec);
(define ~git_remote_add_fetch #f)
(define (git_remote_add_fetch repo remote refspec)
  (unless
    ~git_remote_add_fetch
    (set! ~git_remote_add_fetch
      (fh-link-proc
        "git_remote_add_fetch"
        ffi:int
        (list '* '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~remote (unwrap~pointer remote))
        (~refspec (unwrap~pointer refspec)))
    (~git_remote_add_fetch ~repo ~remote ~refspec)))
(export git_remote_add_fetch)

;; extern int git_remote_get_fetch_refspecs(git_strarray *array, const 
;;     git_remote *remote);
(define ~git_remote_get_fetch_refspecs #f)
(define (git_remote_get_fetch_refspecs array remote)
  (unless
    ~git_remote_get_fetch_refspecs
    (set! ~git_remote_get_fetch_refspecs
      (fh-link-proc
        "git_remote_get_fetch_refspecs"
        ffi:int
        (list '* '*))))
  (let ((~array (unwrap-git_strarray* array))
        (~remote (unwrap-git_remote* remote)))
    (~git_remote_get_fetch_refspecs ~array ~remote)))
(export git_remote_get_fetch_refspecs)

;; extern int git_remote_add_push(git_repository *repo, const char *remote, 
;;     const char *refspec);
(define ~git_remote_add_push #f)
(define (git_remote_add_push repo remote refspec)
  (unless
    ~git_remote_add_push
    (set! ~git_remote_add_push
      (fh-link-proc
        "git_remote_add_push"
        ffi:int
        (list '* '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~remote (unwrap~pointer remote))
        (~refspec (unwrap~pointer refspec)))
    (~git_remote_add_push ~repo ~remote ~refspec)))
(export git_remote_add_push)

;; extern int git_remote_get_push_refspecs(git_strarray *array, const 
;;     git_remote *remote);
(define ~git_remote_get_push_refspecs #f)
(define (git_remote_get_push_refspecs array remote)
  (unless
    ~git_remote_get_push_refspecs
    (set! ~git_remote_get_push_refspecs
      (fh-link-proc
        "git_remote_get_push_refspecs"
        ffi:int
        (list '* '*))))
  (let ((~array (unwrap-git_strarray* array))
        (~remote (unwrap-git_remote* remote)))
    (~git_remote_get_push_refspecs ~array ~remote)))
(export git_remote_get_push_refspecs)

;; extern size_t git_remote_refspec_count(const git_remote *remote);
(define ~git_remote_refspec_count #f)
(define (git_remote_refspec_count remote)
  (unless
    ~git_remote_refspec_count
    (set! ~git_remote_refspec_count
      (fh-link-proc
        "git_remote_refspec_count"
        ffi:size_t
        (list '*))))
  (let ((~remote (unwrap-git_remote* remote)))
    (~git_remote_refspec_count ~remote)))
(export git_remote_refspec_count)

;; extern const git_refspec *git_remote_get_refspec(const git_remote *remote, 
;;     size_t n);
(define ~git_remote_get_refspec #f)
(define (git_remote_get_refspec remote n)
  (unless
    ~git_remote_get_refspec
    (set! ~git_remote_get_refspec
      (fh-link-proc
        "git_remote_get_refspec"
        '*
        (list '* ffi:size_t))))
  (let ((~remote (unwrap-git_remote* remote))
        (~n (unwrap~fixed n)))
    (wrap-git_refspec*
      (~git_remote_get_refspec ~remote ~n))))
(export git_remote_get_refspec)

;; extern int git_remote_connect(git_remote *remote, git_direction direction, 
;;     const git_remote_callbacks *callbacks, const git_proxy_options *
;;     proxy_opts, const git_strarray *custom_headers);
(define ~git_remote_connect #f)
(define (git_remote_connect
         remote
         direction
         callbacks
         proxy_opts
         custom_headers)
  (unless
    ~git_remote_connect
    (set! ~git_remote_connect
      (fh-link-proc
        "git_remote_connect"
        ffi:int
        (list '* ffi:int '* '* '*))))
  (let ((~remote (unwrap-git_remote* remote))
        (~direction (unwrap~fixed direction))
        (~callbacks
          (unwrap-git_remote_callbacks* callbacks))
        (~proxy_opts
          (unwrap-git_proxy_options* proxy_opts))
        (~custom_headers
          (unwrap-git_strarray* custom_headers)))
    (~git_remote_connect
      ~remote
      ~direction
      ~callbacks
      ~proxy_opts
      ~custom_headers)))
(export git_remote_connect)

;; extern int git_remote_ls(const git_remote_head ***out, size_t *size, 
;;     git_remote *remote);
(define ~git_remote_ls #f)
(define (git_remote_ls out size remote)
  (unless
    ~git_remote_ls
    (set! ~git_remote_ls
      (fh-link-proc
        "git_remote_ls"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~size (unwrap~pointer size))
        (~remote (unwrap-git_remote* remote)))
    (~git_remote_ls ~out ~size ~remote)))
(export git_remote_ls)

;; extern int git_remote_connected(const git_remote *remote);
(define ~git_remote_connected #f)
(define (git_remote_connected remote)
  (unless
    ~git_remote_connected
    (set! ~git_remote_connected
      (fh-link-proc
        "git_remote_connected"
        ffi:int
        (list '*))))
  (let ((~remote (unwrap-git_remote* remote)))
    (~git_remote_connected ~remote)))
(export git_remote_connected)

;; extern void git_remote_stop(git_remote *remote);
(define ~git_remote_stop #f)
(define (git_remote_stop remote)
  (unless
    ~git_remote_stop
    (set! ~git_remote_stop
      (fh-link-proc
        "git_remote_stop"
        ffi:void
        (list '*))))
  (let ((~remote (unwrap-git_remote* remote)))
    (~git_remote_stop ~remote)))
(export git_remote_stop)

;; extern void git_remote_disconnect(git_remote *remote);
(define ~git_remote_disconnect #f)
(define (git_remote_disconnect remote)
  (unless
    ~git_remote_disconnect
    (set! ~git_remote_disconnect
      (fh-link-proc
        "git_remote_disconnect"
        ffi:void
        (list '*))))
  (let ((~remote (unwrap-git_remote* remote)))
    (~git_remote_disconnect ~remote)))
(export git_remote_disconnect)

;; extern void git_remote_free(git_remote *remote);
(define ~git_remote_free #f)
(define (git_remote_free remote)
  (unless
    ~git_remote_free
    (set! ~git_remote_free
      (fh-link-proc
        "git_remote_free"
        ffi:void
        (list '*))))
  (let ((~remote (unwrap-git_remote* remote)))
    (~git_remote_free ~remote)))
(export git_remote_free)

;; extern int git_remote_list(git_strarray *out, git_repository *repo);
(define ~git_remote_list #f)
(define (git_remote_list out repo)
  (unless
    ~git_remote_list
    (set! ~git_remote_list
      (fh-link-proc
        "git_remote_list"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap-git_strarray* out))
        (~repo (unwrap-git_repository* repo)))
    (~git_remote_list ~out ~repo)))
(export git_remote_list)

;; typedef enum git_remote_completion_type {
;;   GIT_REMOTE_COMPLETION_DOWNLOAD,
;;   GIT_REMOTE_COMPLETION_INDEXING,
;;   GIT_REMOTE_COMPLETION_ERROR,
;; } git_remote_completion_type;
(define-fh-enum git_remote_completion_type
  '((GIT_REMOTE_COMPLETION_DOWNLOAD . 0)
    (GIT_REMOTE_COMPLETION_INDEXING . 1)
    (GIT_REMOTE_COMPLETION_ERROR . 2))
  )
(define unwrap-enum-git_remote_completion_type unwrap-git_remote_completion_type)
(define wrap-enum-git_remote_completion_type wrap-git_remote_completion_type)

;; typedef int (*git_push_transfer_progress)(unsigned int current, unsigned int
;;      total, size_t bytes, void *payload);
(define-fh-function/p git_push_transfer_progress
  ffi:int (list ffi:unsigned-int ffi:unsigned-int ffi:size_t (quote *)))

;; typedef struct {
;;   /**
;;    * The source name of the reference
;;    */
;;   char *src_refname;
;;   /**
;;    * The name of the reference to update on the server
;;    */
;;   char *dst_refname;
;;   /**
;;    * The current target of the reference
;;    */
;;   git_oid src;
;;   /**
;;    * The new target for the reference
;;    */
;;   git_oid dst;
;; } git_push_update;
(define git_push_update-desc
  (bs:struct
    (list `(src_refname ,(bs:pointer int))
          `(dst_refname ,(bs:pointer int))
          `(src ,git_oid-desc)
          `(dst ,git_oid-desc))))
(export git_push_update-desc)
(define-fh-compound-type/p git_push_update git_push_update-desc)

;; typedef int (*git_push_negotiation)(const git_push_update **updates, size_t 
;;     len, void *payload);
(define-fh-function/p git_push_negotiation
  ffi:int (list (quote *) ffi:size_t (quote *)))

;; struct git_remote_callbacks {
;;   unsigned int version;
;;   /**
;;    * Textual progress from the remote. Text send over the
;;    * progress side-band will be passed to this function (this is
;;    * the 'counting objects' output).
;;    */
;;   git_transport_message_cb sideband_progress;
;;   /**
;;    * Completion is called when different parts of the download
;;    * process are done (currently unused).
;;    */
;;   int (*completion)(git_remote_completion_type type, void *data);
;;   /**
;;    * This will be called if the remote host requires
;;    * authentication in order to connect to it.
;;    *
;;    * Returning GIT_PASSTHROUGH will make libgit2 behave as
;;    * though this field isn't set.
;;    */
;;   git_cred_acquire_cb credentials;
;;   /**
;;    * If cert verification fails, this will be called to let the
;;    * user make the final decision of whether to allow the
;;    * connection to proceed. Returns 1 to allow the connection, 0
;;    * to disallow it or a negative value to indicate an error.
;;    */
;;   git_transport_certificate_check_cb certificate_check;
;;   /**
;;    * During the download of new data, this will be regularly
;;    * called with the current count of progress done by the
;;    * indexer.
;;    */
;;   git_transfer_progress_cb transfer_progress;
;;   /**
;;    * Each time a reference is updated locally, this function
;;    * will be called with information about it.
;;    */
;;   int (*update_tips)(const char *refname, const git_oid *a, const git_oid *b
;;       , void *data);
;;   /**
;;    * Function to call with progress information during pack
;;    * building. Be aware that this is called inline with pack
;;    * building operations, so performance may be affected.
;;    */
;;   git_packbuilder_progress pack_progress;
;;   /**
;;    * Function to call with progress information during the
;;    * upload portion of a push. Be aware that this is called
;;    * inline with pack building operations, so performance may be
;;    * affected.
;;    */
;;   git_push_transfer_progress push_transfer_progress;
;;   /**
;;    * Called for each updated reference on push. If `status` is
;;    * not `NULL`, the update was rejected by the remote server
;;    * and `status` contains the reason given.
;;    */
;;   int (*push_update_reference)(const char *refname, const char *status, void
;;        *data);
;;   /**
;;    * Called once between the negotiation step and the upload. It
;;    * provides information about what updates will be performed.
;;    */
;;   git_push_negotiation push_negotiation;
;;   /**
;;    * Create the transport to use for this operation. Leave NULL
;;    * to auto-detect.
;;    */
;;   git_transport_cb transport;
;;   /**
;;    * This will be passed to each of the callbacks in this struct
;;    * as the last parameter.
;;    */
;;   void *payload;
;; };
(define struct-git_remote_callbacks-desc
  (bs:struct
    (list `(version ,unsigned-int)
          `(sideband_progress ,(bs:pointer void))
          `(completion ,(bs:pointer void))
          `(credentials ,(bs:pointer void))
          `(certificate_check ,(bs:pointer void))
          `(transfer_progress ,(bs:pointer void))
          `(update_tips ,(bs:pointer void))
          `(pack_progress ,(bs:pointer void))
          `(push_transfer_progress ,(bs:pointer void))
          `(push_update_reference ,(bs:pointer void))
          `(push_negotiation ,(bs:pointer void))
          `(transport ,(bs:pointer void))
          `(payload ,(bs:pointer void)))))
(export struct-git_remote_callbacks-desc)
(define-fh-compound-type/p struct-git_remote_callbacks struct-git_remote_callbacks-desc)
(set! git_remote_callbacks-desc struct-git_remote_callbacks-desc)
(define-fh-compound-type git_remote_callbacks git_remote_callbacks-desc)

;; extern int git_remote_init_callbacks(git_remote_callbacks *opts, 
;;     unsigned int version);
(define ~git_remote_init_callbacks #f)
(define (git_remote_init_callbacks opts version)
  (unless
    ~git_remote_init_callbacks
    (set! ~git_remote_init_callbacks
      (fh-link-proc
        "git_remote_init_callbacks"
        ffi:int
        (list '* ffi:unsigned-int))))
  (let ((~opts (unwrap-git_remote_callbacks* opts))
        (~version (unwrap~fixed version)))
    (~git_remote_init_callbacks ~opts ~version)))
(export git_remote_init_callbacks)

;; typedef enum {
;;   GIT_FETCH_PRUNE_UNSPECIFIED,
;;   GIT_FETCH_PRUNE,
;;   GIT_FETCH_NO_PRUNE,
;; } git_fetch_prune_t;
(define-fh-enum git_fetch_prune_t
  '((GIT_FETCH_PRUNE_UNSPECIFIED . 0)
    (GIT_FETCH_PRUNE . 1)
    (GIT_FETCH_NO_PRUNE . 2))
  )

;; typedef enum {
;;   GIT_REMOTE_DOWNLOAD_TAGS_UNSPECIFIED = 0,
;;   GIT_REMOTE_DOWNLOAD_TAGS_AUTO,
;;   GIT_REMOTE_DOWNLOAD_TAGS_NONE,
;;   GIT_REMOTE_DOWNLOAD_TAGS_ALL,
;; } git_remote_autotag_option_t;
(define-fh-enum git_remote_autotag_option_t
  '((GIT_REMOTE_DOWNLOAD_TAGS_UNSPECIFIED . 0)
    (GIT_REMOTE_DOWNLOAD_TAGS_AUTO . 1)
    (GIT_REMOTE_DOWNLOAD_TAGS_NONE . 2)
    (GIT_REMOTE_DOWNLOAD_TAGS_ALL . 3))
  )

;; typedef struct {
;;   int version;
;;   /**
;;    * Callbacks to use for this fetch operation
;;    */
;;   git_remote_callbacks callbacks;
;;   /**
;;    * Whether to perform a prune after the fetch
;;    */
;;   git_fetch_prune_t prune;
;;   /**
;;    * Whether to write the results to FETCH_HEAD. Defaults to
;;    * on. Leave this default in order to behave like git.
;;    */
;;   int update_fetchhead;
;;   /**
;;    * Determines how to behave regarding tags on the remote, such
;;    * as auto-downloading tags for objects we're downloading or
;;    * downloading all of them.
;;    *
;;    * The default is to auto-follow tags.
;;    */
;;   git_remote_autotag_option_t download_tags;
;;   /**
;;    * Proxy options to use, by default no proxy is used.
;;    */
;;   git_proxy_options proxy_opts;
;;   /**
;;    * Extra headers for this fetch operation
;;    */
;;   git_strarray custom_headers;
;; } git_fetch_options;
(define git_fetch_options-desc
  (bs:struct
    (list `(version ,int)
          `(callbacks ,git_remote_callbacks-desc)
          `(prune ,int)
          `(update_fetchhead ,int)
          `(download_tags ,int)
          `(proxy_opts ,git_proxy_options-desc)
          `(custom_headers ,git_strarray-desc))))
(export git_fetch_options-desc)
(define-fh-compound-type/p git_fetch_options git_fetch_options-desc)

;; extern int git_fetch_init_options(git_fetch_options *opts, unsigned int 
;;     version);
(define ~git_fetch_init_options #f)
(define (git_fetch_init_options opts version)
  (unless
    ~git_fetch_init_options
    (set! ~git_fetch_init_options
      (fh-link-proc
        "git_fetch_init_options"
        ffi:int
        (list '* ffi:unsigned-int))))
  (let ((~opts (unwrap-git_fetch_options* opts))
        (~version (unwrap~fixed version)))
    (~git_fetch_init_options ~opts ~version)))
(export git_fetch_init_options)

;; typedef struct {
;;   unsigned int version;
;;   /**
;;    * If the transport being used to push to the remote requires the creation
;;       
;;    * of a pack file, this controls the number of worker threads used by
;;    * the packbuilder when creating that pack file to be sent to the remote.
;;    *
;;    * If set to 0, the packbuilder will auto-detect the number of threads
;;    * to create. The default value is 1.
;;    */
;;   unsigned int pb_parallelism;
;;   /**
;;    * Callbacks to use for this push operation
;;    */
;;   git_remote_callbacks callbacks;
;;   /**
;;   * Proxy options to use, by default no proxy is used.
;;   */
;;   git_proxy_options proxy_opts;
;;   /**
;;    * Extra headers for this push operation
;;    */
;;   git_strarray custom_headers;
;; } git_push_options;
(define git_push_options-desc
  (bs:struct
    (list `(version ,unsigned-int)
          `(pb_parallelism ,unsigned-int)
          `(callbacks ,git_remote_callbacks-desc)
          `(proxy_opts ,git_proxy_options-desc)
          `(custom_headers ,git_strarray-desc))))
(export git_push_options-desc)
(define-fh-compound-type/p git_push_options git_push_options-desc)

;; extern int git_push_init_options(git_push_options *opts, unsigned int 
;;     version);
(define ~git_push_init_options #f)
(define (git_push_init_options opts version)
  (unless
    ~git_push_init_options
    (set! ~git_push_init_options
      (fh-link-proc
        "git_push_init_options"
        ffi:int
        (list '* ffi:unsigned-int))))
  (let ((~opts (unwrap-git_push_options* opts))
        (~version (unwrap~fixed version)))
    (~git_push_init_options ~opts ~version)))
(export git_push_init_options)

;; extern int git_remote_download(git_remote *remote, const git_strarray *
;;     refspecs, const git_fetch_options *opts);
(define ~git_remote_download #f)
(define (git_remote_download remote refspecs opts)
  (unless
    ~git_remote_download
    (set! ~git_remote_download
      (fh-link-proc
        "git_remote_download"
        ffi:int
        (list '* '* '*))))
  (let ((~remote (unwrap-git_remote* remote))
        (~refspecs (unwrap-git_strarray* refspecs))
        (~opts (unwrap-git_fetch_options* opts)))
    (~git_remote_download ~remote ~refspecs ~opts)))
(export git_remote_download)

;; extern int git_remote_upload(git_remote *remote, const git_strarray *
;;     refspecs, const git_push_options *opts);
(define ~git_remote_upload #f)
(define (git_remote_upload remote refspecs opts)
  (unless
    ~git_remote_upload
    (set! ~git_remote_upload
      (fh-link-proc
        "git_remote_upload"
        ffi:int
        (list '* '* '*))))
  (let ((~remote (unwrap-git_remote* remote))
        (~refspecs (unwrap-git_strarray* refspecs))
        (~opts (unwrap-git_push_options* opts)))
    (~git_remote_upload ~remote ~refspecs ~opts)))
(export git_remote_upload)

;; extern int git_remote_update_tips(git_remote *remote, const 
;;     git_remote_callbacks *callbacks, int update_fetchhead, 
;;     git_remote_autotag_option_t download_tags, const char *reflog_message);
(define ~git_remote_update_tips #f)
(define (git_remote_update_tips
         remote
         callbacks
         update_fetchhead
         download_tags
         reflog_message)
  (unless
    ~git_remote_update_tips
    (set! ~git_remote_update_tips
      (fh-link-proc
        "git_remote_update_tips"
        ffi:int
        (list '* '* ffi:int ffi:int '*))))
  (let ((~remote (unwrap-git_remote* remote))
        (~callbacks
          (unwrap-git_remote_callbacks* callbacks))
        (~update_fetchhead
          (unwrap~fixed update_fetchhead))
        (~download_tags (unwrap~fixed download_tags))
        (~reflog_message (unwrap~pointer reflog_message)))
    (~git_remote_update_tips
      ~remote
      ~callbacks
      ~update_fetchhead
      ~download_tags
      ~reflog_message)))
(export git_remote_update_tips)

;; extern int git_remote_fetch(git_remote *remote, const git_strarray *refspecs
;;     , const git_fetch_options *opts, const char *reflog_message);
(define ~git_remote_fetch #f)
(define (git_remote_fetch
         remote
         refspecs
         opts
         reflog_message)
  (unless
    ~git_remote_fetch
    (set! ~git_remote_fetch
      (fh-link-proc
        "git_remote_fetch"
        ffi:int
        (list '* '* '* '*))))
  (let ((~remote (unwrap-git_remote* remote))
        (~refspecs (unwrap-git_strarray* refspecs))
        (~opts (unwrap-git_fetch_options* opts))
        (~reflog_message (unwrap~pointer reflog_message)))
    (~git_remote_fetch
      ~remote
      ~refspecs
      ~opts
      ~reflog_message)))
(export git_remote_fetch)

;; extern int git_remote_prune(git_remote *remote, const git_remote_callbacks *
;;     callbacks);
(define ~git_remote_prune #f)
(define (git_remote_prune remote callbacks)
  (unless
    ~git_remote_prune
    (set! ~git_remote_prune
      (fh-link-proc
        "git_remote_prune"
        ffi:int
        (list '* '*))))
  (let ((~remote (unwrap-git_remote* remote))
        (~callbacks
          (unwrap-git_remote_callbacks* callbacks)))
    (~git_remote_prune ~remote ~callbacks)))
(export git_remote_prune)

;; extern int git_remote_push(git_remote *remote, const git_strarray *refspecs
;;     , const git_push_options *opts);
(define ~git_remote_push #f)
(define (git_remote_push remote refspecs opts)
  (unless
    ~git_remote_push
    (set! ~git_remote_push
      (fh-link-proc
        "git_remote_push"
        ffi:int
        (list '* '* '*))))
  (let ((~remote (unwrap-git_remote* remote))
        (~refspecs (unwrap-git_strarray* refspecs))
        (~opts (unwrap-git_push_options* opts)))
    (~git_remote_push ~remote ~refspecs ~opts)))
(export git_remote_push)

;; extern const git_transfer_progress *git_remote_stats(git_remote *remote);
(define ~git_remote_stats #f)
(define (git_remote_stats remote)
  (unless
    ~git_remote_stats
    (set! ~git_remote_stats
      (fh-link-proc "git_remote_stats" '* (list '*))))
  (let ((~remote (unwrap-git_remote* remote)))
    (wrap-git_transfer_progress*
      (~git_remote_stats ~remote))))
(export git_remote_stats)

;; extern git_remote_autotag_option_t git_remote_autotag(const git_remote *
;;     remote);
(define ~git_remote_autotag #f)
(define (git_remote_autotag remote)
  (unless
    ~git_remote_autotag
    (set! ~git_remote_autotag
      (fh-link-proc
        "git_remote_autotag"
        ffi:int
        (list '*))))
  (let ((~remote (unwrap-git_remote* remote)))
    (~git_remote_autotag ~remote)))
(export git_remote_autotag)

;; extern int git_remote_set_autotag(git_repository *repo, const char *remote, 
;;     git_remote_autotag_option_t value);
(define ~git_remote_set_autotag #f)
(define (git_remote_set_autotag repo remote value)
  (unless
    ~git_remote_set_autotag
    (set! ~git_remote_set_autotag
      (fh-link-proc
        "git_remote_set_autotag"
        ffi:int
        (list '* '* ffi:int))))
  (let ((~repo (unwrap-git_repository* repo))
        (~remote (unwrap~pointer remote))
        (~value (unwrap~fixed value)))
    (~git_remote_set_autotag ~repo ~remote ~value)))
(export git_remote_set_autotag)

;; extern int git_remote_prune_refs(const git_remote *remote);
(define ~git_remote_prune_refs #f)
(define (git_remote_prune_refs remote)
  (unless
    ~git_remote_prune_refs
    (set! ~git_remote_prune_refs
      (fh-link-proc
        "git_remote_prune_refs"
        ffi:int
        (list '*))))
  (let ((~remote (unwrap-git_remote* remote)))
    (~git_remote_prune_refs ~remote)))
(export git_remote_prune_refs)

;; extern int git_remote_rename(git_strarray *problems, git_repository *repo, 
;;     const char *name, const char *new_name);
(define ~git_remote_rename #f)
(define (git_remote_rename problems repo name new_name)
  (unless
    ~git_remote_rename
    (set! ~git_remote_rename
      (fh-link-proc
        "git_remote_rename"
        ffi:int
        (list '* '* '* '*))))
  (let ((~problems (unwrap-git_strarray* problems))
        (~repo (unwrap-git_repository* repo))
        (~name (unwrap~pointer name))
        (~new_name (unwrap~pointer new_name)))
    (~git_remote_rename
      ~problems
      ~repo
      ~name
      ~new_name)))
(export git_remote_rename)

;; extern int git_remote_is_valid_name(const char *remote_name);
(define ~git_remote_is_valid_name #f)
(define (git_remote_is_valid_name remote_name)
  (unless
    ~git_remote_is_valid_name
    (set! ~git_remote_is_valid_name
      (fh-link-proc
        "git_remote_is_valid_name"
        ffi:int
        (list '*))))
  (let ((~remote_name (unwrap~pointer remote_name)))
    (~git_remote_is_valid_name ~remote_name)))
(export git_remote_is_valid_name)

;; extern int git_remote_delete(git_repository *repo, const char *name);
(define ~git_remote_delete #f)
(define (git_remote_delete repo name)
  (unless
    ~git_remote_delete
    (set! ~git_remote_delete
      (fh-link-proc
        "git_remote_delete"
        ffi:int
        (list '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~name (unwrap~pointer name)))
    (~git_remote_delete ~repo ~name)))
(export git_remote_delete)

;; extern int git_remote_default_branch(git_buf *out, git_remote *remote);
(define ~git_remote_default_branch #f)
(define (git_remote_default_branch out remote)
  (unless
    ~git_remote_default_branch
    (set! ~git_remote_default_branch
      (fh-link-proc
        "git_remote_default_branch"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap-git_buf* out))
        (~remote (unwrap-git_remote* remote)))
    (~git_remote_default_branch ~out ~remote)))
(export git_remote_default_branch)

;; typedef enum {
;;   GIT_CLONE_LOCAL_AUTO,
;;   GIT_CLONE_LOCAL,
;;   GIT_CLONE_NO_LOCAL,
;;   GIT_CLONE_LOCAL_NO_LINKS,
;; } git_clone_local_t;
(define-fh-enum git_clone_local_t
  '((GIT_CLONE_LOCAL_AUTO . 0)
    (GIT_CLONE_LOCAL . 1)
    (GIT_CLONE_NO_LOCAL . 2)
    (GIT_CLONE_LOCAL_NO_LINKS . 3))
  )

;; typedef int (*git_remote_create_cb)(git_remote **out, git_repository *repo, 
;;     const char *name, const char *url, void *payload);
(define-fh-function/p git_remote_create_cb
  ffi:int (list (quote *) (quote *) (quote *) (quote *) (quote *)))

;; typedef int (*git_repository_create_cb)(git_repository **out, const char *
;;     path, int bare, void *payload);
(define-fh-function/p git_repository_create_cb
  ffi:int (list (quote *) (quote *) ffi:int (quote *)))

;; typedef struct git_clone_options {
;;   unsigned int version;
;;   /**
;;    * These options are passed to the checkout step. To disable
;;    * checkout, set the `checkout_strategy` to
;;    * `GIT_CHECKOUT_NONE`.
;;    */
;;   git_checkout_options checkout_opts;
;;   /**
;;    * Options which control the fetch, including callbacks.
;;    *
;;    * The callbacks are used for reporting fetch progress, and for acquiring
;;    * credentials in the event they are needed.
;;    */
;;   git_fetch_options fetch_opts;
;;   /**
;;    * Set to zero (false) to create a standard repo, or non-zero
;;    * for a bare repo
;;    */
;;   int bare;
;;   /**
;;    * Whether to use a fetch or copy the object database.
;;    */
;;   git_clone_local_t local;
;;   /**
;;    * The name of the branch to checkout. NULL means use the
;;    * remote's default branch.
;;    */
;;   const char *checkout_branch;
;;   /**
;;    * A callback used to create the new repository into which to
;;    * clone. If NULL, the 'bare' field will be used to determine
;;    * whether to create a bare repository.
;;    */
;;   git_repository_create_cb repository_cb;
;;   /**
;;    * An opaque payload to pass to the git_repository creation callback.
;;    * This parameter is ignored unless repository_cb is non-NULL.
;;    */
;;   void *repository_cb_payload;
;;   /**
;;    * A callback used to create the git_remote, prior to its being
;;    * used to perform the clone operation. See the documentation for
;;    * git_remote_create_cb for details. This parameter may be NULL,
;;    * indicating that git_clone should provide default behavior.
;;    */
;;   git_remote_create_cb remote_cb;
;;   /**
;;    * An opaque payload to pass to the git_remote creation callback.
;;    * This parameter is ignored unless remote_cb is non-NULL.
;;    */
;;   void *remote_cb_payload;
;; } git_clone_options;
(define git_clone_options-desc
  (bs:struct
    (list `(version ,unsigned-int)
          `(checkout_opts ,git_checkout_options-desc)
          `(fetch_opts ,git_fetch_options-desc)
          `(bare ,int)
          `(local ,int)
          `(checkout_branch ,(bs:pointer int))
          `(repository_cb ,(bs:pointer void))
          `(repository_cb_payload ,(bs:pointer void))
          `(remote_cb ,(bs:pointer void))
          `(remote_cb_payload ,(bs:pointer void)))))
(export git_clone_options-desc)
(define-fh-compound-type/p git_clone_options git_clone_options-desc)
(define struct-git_clone_options git_clone_options)

;; extern int git_clone_init_options(git_clone_options *opts, unsigned int 
;;     version);
(define ~git_clone_init_options #f)
(define (git_clone_init_options opts version)
  (unless
    ~git_clone_init_options
    (set! ~git_clone_init_options
      (fh-link-proc
        "git_clone_init_options"
        ffi:int
        (list '* ffi:unsigned-int))))
  (let ((~opts (unwrap-git_clone_options* opts))
        (~version (unwrap~fixed version)))
    (~git_clone_init_options ~opts ~version)))
(export git_clone_init_options)

;; extern int git_clone(git_repository **out, const char *url, const char *
;;     local_path, const git_clone_options *options);
(define ~git_clone #f)
(define (git_clone out url local_path options)
  (unless
    ~git_clone
    (set! ~git_clone
      (fh-link-proc
        "git_clone"
        ffi:int
        (list '* '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~url (unwrap~pointer url))
        (~local_path (unwrap~pointer local_path))
        (~options (unwrap-git_clone_options* options)))
    (~git_clone ~out ~url ~local_path ~options)))
(export git_clone)

;; extern int git_commit_lookup(git_commit **commit, git_repository *repo, 
;;     const git_oid *id);
(define ~git_commit_lookup #f)
(define (git_commit_lookup commit repo id)
  (unless
    ~git_commit_lookup
    (set! ~git_commit_lookup
      (fh-link-proc
        "git_commit_lookup"
        ffi:int
        (list '* '* '*))))
  (let ((~commit (unwrap~pointer commit))
        (~repo (unwrap-git_repository* repo))
        (~id (unwrap-git_oid* id)))
    (~git_commit_lookup ~commit ~repo ~id)))
(export git_commit_lookup)

;; extern int git_commit_lookup_prefix(git_commit **commit, git_repository *
;;     repo, const git_oid *id, size_t len);
(define ~git_commit_lookup_prefix #f)
(define (git_commit_lookup_prefix commit repo id len)
  (unless
    ~git_commit_lookup_prefix
    (set! ~git_commit_lookup_prefix
      (fh-link-proc
        "git_commit_lookup_prefix"
        ffi:int
        (list '* '* '* ffi:size_t))))
  (let ((~commit (unwrap~pointer commit))
        (~repo (unwrap-git_repository* repo))
        (~id (unwrap-git_oid* id))
        (~len (unwrap~fixed len)))
    (~git_commit_lookup_prefix
      ~commit
      ~repo
      ~id
      ~len)))
(export git_commit_lookup_prefix)

;; extern void git_commit_free(git_commit *commit);
(define ~git_commit_free #f)
(define (git_commit_free commit)
  (unless
    ~git_commit_free
    (set! ~git_commit_free
      (fh-link-proc
        "git_commit_free"
        ffi:void
        (list '*))))
  (let ((~commit (unwrap-git_commit* commit)))
    (~git_commit_free ~commit)))
(export git_commit_free)

;; extern const git_oid *git_commit_id(const git_commit *commit);
(define ~git_commit_id #f)
(define (git_commit_id commit)
  (unless
    ~git_commit_id
    (set! ~git_commit_id
      (fh-link-proc "git_commit_id" '* (list '*))))
  (let ((~commit (unwrap-git_commit* commit)))
    (wrap-git_oid* (~git_commit_id ~commit))))
(export git_commit_id)

;; extern git_repository *git_commit_owner(const git_commit *commit);
(define ~git_commit_owner #f)
(define (git_commit_owner commit)
  (unless
    ~git_commit_owner
    (set! ~git_commit_owner
      (fh-link-proc "git_commit_owner" '* (list '*))))
  (let ((~commit (unwrap-git_commit* commit)))
    (wrap-git_repository*
      (~git_commit_owner ~commit))))
(export git_commit_owner)

;; extern const char *git_commit_message_encoding(const git_commit *commit);
(define ~git_commit_message_encoding #f)
(define (git_commit_message_encoding commit)
  (unless
    ~git_commit_message_encoding
    (set! ~git_commit_message_encoding
      (fh-link-proc
        "git_commit_message_encoding"
        '*
        (list '*))))
  (let ((~commit (unwrap-git_commit* commit)))
    (~git_commit_message_encoding ~commit)))
(export git_commit_message_encoding)

;; extern const char *git_commit_message(const git_commit *commit);
(define ~git_commit_message #f)
(define (git_commit_message commit)
  (unless
    ~git_commit_message
    (set! ~git_commit_message
      (fh-link-proc "git_commit_message" '* (list '*))))
  (let ((~commit (unwrap-git_commit* commit)))
    (~git_commit_message ~commit)))
(export git_commit_message)

;; extern const char *git_commit_message_raw(const git_commit *commit);
(define ~git_commit_message_raw #f)
(define (git_commit_message_raw commit)
  (unless
    ~git_commit_message_raw
    (set! ~git_commit_message_raw
      (fh-link-proc
        "git_commit_message_raw"
        '*
        (list '*))))
  (let ((~commit (unwrap-git_commit* commit)))
    (~git_commit_message_raw ~commit)))
(export git_commit_message_raw)

;; extern const char *git_commit_summary(git_commit *commit);
(define ~git_commit_summary #f)
(define (git_commit_summary commit)
  (unless
    ~git_commit_summary
    (set! ~git_commit_summary
      (fh-link-proc "git_commit_summary" '* (list '*))))
  (let ((~commit (unwrap-git_commit* commit)))
    (~git_commit_summary ~commit)))
(export git_commit_summary)

;; extern const char *git_commit_body(git_commit *commit);
(define ~git_commit_body #f)
(define (git_commit_body commit)
  (unless
    ~git_commit_body
    (set! ~git_commit_body
      (fh-link-proc "git_commit_body" '* (list '*))))
  (let ((~commit (unwrap-git_commit* commit)))
    (~git_commit_body ~commit)))
(export git_commit_body)

;; extern git_time_t git_commit_time(const git_commit *commit);
(define ~git_commit_time #f)
(define (git_commit_time commit)
  (unless
    ~git_commit_time
    (set! ~git_commit_time
      (fh-link-proc
        "git_commit_time"
        ffi:int64
        (list '*))))
  (let ((~commit (unwrap-git_commit* commit)))
    (~git_commit_time ~commit)))
(export git_commit_time)

;; extern int git_commit_time_offset(const git_commit *commit);
(define ~git_commit_time_offset #f)
(define (git_commit_time_offset commit)
  (unless
    ~git_commit_time_offset
    (set! ~git_commit_time_offset
      (fh-link-proc
        "git_commit_time_offset"
        ffi:int
        (list '*))))
  (let ((~commit (unwrap-git_commit* commit)))
    (~git_commit_time_offset ~commit)))
(export git_commit_time_offset)

;; extern const git_signature *git_commit_committer(const git_commit *commit);
(define ~git_commit_committer #f)
(define (git_commit_committer commit)
  (unless
    ~git_commit_committer
    (set! ~git_commit_committer
      (fh-link-proc
        "git_commit_committer"
        '*
        (list '*))))
  (let ((~commit (unwrap-git_commit* commit)))
    (wrap-git_signature*
      (~git_commit_committer ~commit))))
(export git_commit_committer)

;; extern const git_signature *git_commit_author(const git_commit *commit);
(define ~git_commit_author #f)
(define (git_commit_author commit)
  (unless
    ~git_commit_author
    (set! ~git_commit_author
      (fh-link-proc "git_commit_author" '* (list '*))))
  (let ((~commit (unwrap-git_commit* commit)))
    (wrap-git_signature*
      (~git_commit_author ~commit))))
(export git_commit_author)

;; extern const char *git_commit_raw_header(const git_commit *commit);
(define ~git_commit_raw_header #f)
(define (git_commit_raw_header commit)
  (unless
    ~git_commit_raw_header
    (set! ~git_commit_raw_header
      (fh-link-proc
        "git_commit_raw_header"
        '*
        (list '*))))
  (let ((~commit (unwrap-git_commit* commit)))
    (~git_commit_raw_header ~commit)))
(export git_commit_raw_header)

;; extern int git_commit_tree(git_tree **tree_out, const git_commit *commit);
(define ~git_commit_tree #f)
(define (git_commit_tree tree_out commit)
  (unless
    ~git_commit_tree
    (set! ~git_commit_tree
      (fh-link-proc
        "git_commit_tree"
        ffi:int
        (list '* '*))))
  (let ((~tree_out (unwrap~pointer tree_out))
        (~commit (unwrap-git_commit* commit)))
    (~git_commit_tree ~tree_out ~commit)))
(export git_commit_tree)

;; extern const git_oid *git_commit_tree_id(const git_commit *commit);
(define ~git_commit_tree_id #f)
(define (git_commit_tree_id commit)
  (unless
    ~git_commit_tree_id
    (set! ~git_commit_tree_id
      (fh-link-proc "git_commit_tree_id" '* (list '*))))
  (let ((~commit (unwrap-git_commit* commit)))
    (wrap-git_oid* (~git_commit_tree_id ~commit))))
(export git_commit_tree_id)

;; extern unsigned int git_commit_parentcount(const git_commit *commit);
(define ~git_commit_parentcount #f)
(define (git_commit_parentcount commit)
  (unless
    ~git_commit_parentcount
    (set! ~git_commit_parentcount
      (fh-link-proc
        "git_commit_parentcount"
        ffi:unsigned-int
        (list '*))))
  (let ((~commit (unwrap-git_commit* commit)))
    (~git_commit_parentcount ~commit)))
(export git_commit_parentcount)

;; extern int git_commit_parent(git_commit **out, const git_commit *commit, 
;;     unsigned int n);
(define ~git_commit_parent #f)
(define (git_commit_parent out commit n)
  (unless
    ~git_commit_parent
    (set! ~git_commit_parent
      (fh-link-proc
        "git_commit_parent"
        ffi:int
        (list '* '* ffi:unsigned-int))))
  (let ((~out (unwrap~pointer out))
        (~commit (unwrap-git_commit* commit))
        (~n (unwrap~fixed n)))
    (~git_commit_parent ~out ~commit ~n)))
(export git_commit_parent)

;; extern const git_oid *git_commit_parent_id(const git_commit *commit, 
;;     unsigned int n);
(define ~git_commit_parent_id #f)
(define (git_commit_parent_id commit n)
  (unless
    ~git_commit_parent_id
    (set! ~git_commit_parent_id
      (fh-link-proc
        "git_commit_parent_id"
        '*
        (list '* ffi:unsigned-int))))
  (let ((~commit (unwrap-git_commit* commit))
        (~n (unwrap~fixed n)))
    (wrap-git_oid*
      (~git_commit_parent_id ~commit ~n))))
(export git_commit_parent_id)

;; extern int git_commit_nth_gen_ancestor(git_commit **ancestor, const 
;;     git_commit *commit, unsigned int n);
(define ~git_commit_nth_gen_ancestor #f)
(define (git_commit_nth_gen_ancestor ancestor commit n)
  (unless
    ~git_commit_nth_gen_ancestor
    (set! ~git_commit_nth_gen_ancestor
      (fh-link-proc
        "git_commit_nth_gen_ancestor"
        ffi:int
        (list '* '* ffi:unsigned-int))))
  (let ((~ancestor (unwrap~pointer ancestor))
        (~commit (unwrap-git_commit* commit))
        (~n (unwrap~fixed n)))
    (~git_commit_nth_gen_ancestor
      ~ancestor
      ~commit
      ~n)))
(export git_commit_nth_gen_ancestor)

;; extern int git_commit_header_field(git_buf *out, const git_commit *commit, 
;;     const char *field);
(define ~git_commit_header_field #f)
(define (git_commit_header_field out commit field)
  (unless
    ~git_commit_header_field
    (set! ~git_commit_header_field
      (fh-link-proc
        "git_commit_header_field"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap-git_buf* out))
        (~commit (unwrap-git_commit* commit))
        (~field (unwrap~pointer field)))
    (~git_commit_header_field ~out ~commit ~field)))
(export git_commit_header_field)

;; extern int git_commit_extract_signature(git_buf *signature, git_buf *
;;     signed_data, git_repository *repo, git_oid *commit_id, const char *field
;;     );
(define ~git_commit_extract_signature #f)
(define (git_commit_extract_signature
         signature
         signed_data
         repo
         commit_id
         field)
  (unless
    ~git_commit_extract_signature
    (set! ~git_commit_extract_signature
      (fh-link-proc
        "git_commit_extract_signature"
        ffi:int
        (list '* '* '* '* '*))))
  (let ((~signature (unwrap-git_buf* signature))
        (~signed_data (unwrap-git_buf* signed_data))
        (~repo (unwrap-git_repository* repo))
        (~commit_id (unwrap-git_oid* commit_id))
        (~field (unwrap~pointer field)))
    (~git_commit_extract_signature
      ~signature
      ~signed_data
      ~repo
      ~commit_id
      ~field)))
(export git_commit_extract_signature)

;; extern int git_commit_create(git_oid *id, git_repository *repo, const char *
;;     update_ref, const git_signature *author, const git_signature *committer
;;     , const char *message_encoding, const char *message, const git_tree *
;;     tree, size_t parent_count, const git_commit *parents[]);
(define ~git_commit_create #f)
(define (git_commit_create
         id
         repo
         update_ref
         author
         committer
         message_encoding
         message
         tree
         parent_count
         parents)
  (unless
    ~git_commit_create
    (set! ~git_commit_create
      (fh-link-proc
        "git_commit_create"
        ffi:int
        (list '* '* '* '* '* '* '* '* ffi:size_t '*))))
  (let ((~id (unwrap-git_oid* id))
        (~repo (unwrap-git_repository* repo))
        (~update_ref (unwrap~pointer update_ref))
        (~author (unwrap-git_signature* author))
        (~committer (unwrap-git_signature* committer))
        (~message_encoding
          (unwrap~pointer message_encoding))
        (~message (unwrap~pointer message))
        (~tree (unwrap-git_tree* tree))
        (~parent_count (unwrap~fixed parent_count))
        (~parents (unwrap~array parents)))
    (~git_commit_create
      ~id
      ~repo
      ~update_ref
      ~author
      ~committer
      ~message_encoding
      ~message
      ~tree
      ~parent_count
      ~parents)))
(export git_commit_create)

;; extern int git_commit_create_v(git_oid *id, git_repository *repo, const char
;;      *update_ref, const git_signature *author, const git_signature *
;;     committer, const char *message_encoding, const char *message, const 
;;     git_tree *tree, size_t parent_count, ...);
;; ... failed.

;; extern int git_commit_amend(git_oid *id, const git_commit *commit_to_amend, 
;;     const char *update_ref, const git_signature *author, const git_signature
;;      *committer, const char *message_encoding, const char *message, const 
;;     git_tree *tree);
(define ~git_commit_amend #f)
(define (git_commit_amend
         id
         commit_to_amend
         update_ref
         author
         committer
         message_encoding
         message
         tree)
  (unless
    ~git_commit_amend
    (set! ~git_commit_amend
      (fh-link-proc
        "git_commit_amend"
        ffi:int
        (list '* '* '* '* '* '* '* '*))))
  (let ((~id (unwrap-git_oid* id))
        (~commit_to_amend
          (unwrap-git_commit* commit_to_amend))
        (~update_ref (unwrap~pointer update_ref))
        (~author (unwrap-git_signature* author))
        (~committer (unwrap-git_signature* committer))
        (~message_encoding
          (unwrap~pointer message_encoding))
        (~message (unwrap~pointer message))
        (~tree (unwrap-git_tree* tree)))
    (~git_commit_amend
      ~id
      ~commit_to_amend
      ~update_ref
      ~author
      ~committer
      ~message_encoding
      ~message
      ~tree)))
(export git_commit_amend)

;; extern int git_commit_create_buffer(git_buf *out, git_repository *repo, 
;;     const git_signature *author, const git_signature *committer, const char 
;;     *message_encoding, const char *message, const git_tree *tree, size_t 
;;     parent_count, const git_commit *parents[]);
(define ~git_commit_create_buffer #f)
(define (git_commit_create_buffer
         out
         repo
         author
         committer
         message_encoding
         message
         tree
         parent_count
         parents)
  (unless
    ~git_commit_create_buffer
    (set! ~git_commit_create_buffer
      (fh-link-proc
        "git_commit_create_buffer"
        ffi:int
        (list '* '* '* '* '* '* '* ffi:size_t '*))))
  (let ((~out (unwrap-git_buf* out))
        (~repo (unwrap-git_repository* repo))
        (~author (unwrap-git_signature* author))
        (~committer (unwrap-git_signature* committer))
        (~message_encoding
          (unwrap~pointer message_encoding))
        (~message (unwrap~pointer message))
        (~tree (unwrap-git_tree* tree))
        (~parent_count (unwrap~fixed parent_count))
        (~parents (unwrap~array parents)))
    (~git_commit_create_buffer
      ~out
      ~repo
      ~author
      ~committer
      ~message_encoding
      ~message
      ~tree
      ~parent_count
      ~parents)))
(export git_commit_create_buffer)

;; extern int git_commit_create_with_signature(git_oid *out, git_repository *
;;     repo, const char *commit_content, const char *signature, const char *
;;     signature_field);
(define ~git_commit_create_with_signature #f)
(define (git_commit_create_with_signature
         out
         repo
         commit_content
         signature
         signature_field)
  (unless
    ~git_commit_create_with_signature
    (set! ~git_commit_create_with_signature
      (fh-link-proc
        "git_commit_create_with_signature"
        ffi:int
        (list '* '* '* '* '*))))
  (let ((~out (unwrap-git_oid* out))
        (~repo (unwrap-git_repository* repo))
        (~commit_content (unwrap~pointer commit_content))
        (~signature (unwrap~pointer signature))
        (~signature_field
          (unwrap~pointer signature_field)))
    (~git_commit_create_with_signature
      ~out
      ~repo
      ~commit_content
      ~signature
      ~signature_field)))
(export git_commit_create_with_signature)

;; extern int git_commit_dup(git_commit **out, git_commit *source);
(define ~git_commit_dup #f)
(define (git_commit_dup out source)
  (unless
    ~git_commit_dup
    (set! ~git_commit_dup
      (fh-link-proc
        "git_commit_dup"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~source (unwrap-git_commit* source)))
    (~git_commit_dup ~out ~source)))
(export git_commit_dup)

;; typedef enum {
;;   GIT_CONFIG_LEVEL_PROGRAMDATA = 1,
;;   GIT_CONFIG_LEVEL_SYSTEM = 2,
;;   GIT_CONFIG_LEVEL_XDG = 3,
;;   GIT_CONFIG_LEVEL_GLOBAL = 4,
;;   GIT_CONFIG_LEVEL_LOCAL = 5,
;;   GIT_CONFIG_LEVEL_APP = 6,
;;   GIT_CONFIG_HIGHEST_LEVEL = -1,
;; } git_config_level_t;
(define-fh-enum git_config_level_t
  '((GIT_CONFIG_LEVEL_PROGRAMDATA . 1)
    (GIT_CONFIG_LEVEL_SYSTEM . 2)
    (GIT_CONFIG_LEVEL_XDG . 3)
    (GIT_CONFIG_LEVEL_GLOBAL . 4)
    (GIT_CONFIG_LEVEL_LOCAL . 5)
    (GIT_CONFIG_LEVEL_APP . 6)
    (GIT_CONFIG_HIGHEST_LEVEL . -1))
  )

;; typedef struct git_config_entry {
;;   const char *name; /**< Name of the entry (normalised) */
;;   const char *value; /**< String value of the entry */
;;   git_config_level_t level; /**< Which config file this was found in */
;;   void (*free)(struct git_config_entry *entry); 
;;       /**< Free function for this entry */
;;   void *payload; 
;;       /**< Opaque value for the free function. Do not read or write */
;; } git_config_entry;
(define git_config_entry-desc
  (bs:struct
    (list `(name ,(bs:pointer int))
          `(value ,(bs:pointer int))
          `(level ,int)
          `(free ,(bs:pointer void))
          `(payload ,(bs:pointer void)))))
(export git_config_entry-desc)
(define-fh-compound-type/p git_config_entry git_config_entry-desc)
(define struct-git_config_entry git_config_entry)

;; extern void git_config_entry_free(git_config_entry *);
(define ~git_config_entry_free #f)
(define (git_config_entry_free @76)
  (unless
    ~git_config_entry_free
    (set! ~git_config_entry_free
      (fh-link-proc
        "git_config_entry_free"
        ffi:void
        (list '*))))
  (let ((~@76 (unwrap-git_config_entry* @76)))
    (~git_config_entry_free ~@76)))
(export git_config_entry_free)

;; typedef int (*git_config_foreach_cb)(const git_config_entry *, void *);
(define-fh-function/p git_config_foreach_cb
  ffi:int (list (quote *) (quote *)))

;; typedef struct git_config_iterator git_config_iterator;
(define git_config_iterator-desc void)
(export git_config_iterator-desc)
(define git_config_iterator*-desc (bs:pointer git_config_iterator-desc))
(export git_config_iterator*-desc)
(define-fh-pointer-type git_config_iterator* git_config_iterator*-desc)

;; typedef enum {
;;   GIT_CVAR_FALSE = 0,
;;   GIT_CVAR_TRUE = 1,
;;   GIT_CVAR_INT32,
;;   GIT_CVAR_STRING,
;; } git_cvar_t;
(define-fh-enum git_cvar_t
  '((GIT_CVAR_FALSE . 0)
    (GIT_CVAR_TRUE . 1)
    (GIT_CVAR_INT32 . 2)
    (GIT_CVAR_STRING . 3))
  )

;; typedef struct {
;;   git_cvar_t cvar_type;
;;   const char *str_match;
;;   int map_value;
;; } git_cvar_map;
(define git_cvar_map-desc
  (bs:struct
    (list `(cvar_type ,int)
          `(str_match ,(bs:pointer int))
          `(map_value ,int))))
(export git_cvar_map-desc)
(define-fh-compound-type/p git_cvar_map git_cvar_map-desc)

;; extern int git_config_find_global(git_buf *out);
(define ~git_config_find_global #f)
(define (git_config_find_global out)
  (unless
    ~git_config_find_global
    (set! ~git_config_find_global
      (fh-link-proc
        "git_config_find_global"
        ffi:int
        (list '*))))
  (let ((~out (unwrap-git_buf* out)))
    (~git_config_find_global ~out)))
(export git_config_find_global)

;; extern int git_config_find_xdg(git_buf *out);
(define ~git_config_find_xdg #f)
(define (git_config_find_xdg out)
  (unless
    ~git_config_find_xdg
    (set! ~git_config_find_xdg
      (fh-link-proc
        "git_config_find_xdg"
        ffi:int
        (list '*))))
  (let ((~out (unwrap-git_buf* out)))
    (~git_config_find_xdg ~out)))
(export git_config_find_xdg)

;; extern int git_config_find_system(git_buf *out);
(define ~git_config_find_system #f)
(define (git_config_find_system out)
  (unless
    ~git_config_find_system
    (set! ~git_config_find_system
      (fh-link-proc
        "git_config_find_system"
        ffi:int
        (list '*))))
  (let ((~out (unwrap-git_buf* out)))
    (~git_config_find_system ~out)))
(export git_config_find_system)

;; extern int git_config_find_programdata(git_buf *out);
(define ~git_config_find_programdata #f)
(define (git_config_find_programdata out)
  (unless
    ~git_config_find_programdata
    (set! ~git_config_find_programdata
      (fh-link-proc
        "git_config_find_programdata"
        ffi:int
        (list '*))))
  (let ((~out (unwrap-git_buf* out)))
    (~git_config_find_programdata ~out)))
(export git_config_find_programdata)

;; extern int git_config_open_default(git_config **out);
(define ~git_config_open_default #f)
(define (git_config_open_default out)
  (unless
    ~git_config_open_default
    (set! ~git_config_open_default
      (fh-link-proc
        "git_config_open_default"
        ffi:int
        (list '*))))
  (let ((~out (unwrap~pointer out)))
    (~git_config_open_default ~out)))
(export git_config_open_default)

;; extern int git_config_new(git_config **out);
(define ~git_config_new #f)
(define (git_config_new out)
  (unless
    ~git_config_new
    (set! ~git_config_new
      (fh-link-proc "git_config_new" ffi:int (list '*))))
  (let ((~out (unwrap~pointer out)))
    (~git_config_new ~out)))
(export git_config_new)

;; extern int git_config_add_file_ondisk(git_config *cfg, const char *path, 
;;     git_config_level_t level, int force);
(define ~git_config_add_file_ondisk #f)
(define (git_config_add_file_ondisk cfg path level force)
  (unless
    ~git_config_add_file_ondisk
    (set! ~git_config_add_file_ondisk
      (fh-link-proc
        "git_config_add_file_ondisk"
        ffi:int
        (list '* '* ffi:int ffi:int))))
  (let ((~cfg (unwrap-git_config* cfg))
        (~path (unwrap~pointer path))
        (~level (unwrap~fixed level))
        (~force (unwrap~fixed force)))
    (~git_config_add_file_ondisk
      ~cfg
      ~path
      ~level
      ~force)))
(export git_config_add_file_ondisk)

;; extern int git_config_open_ondisk(git_config **out, const char *path);
(define ~git_config_open_ondisk #f)
(define (git_config_open_ondisk out path)
  (unless
    ~git_config_open_ondisk
    (set! ~git_config_open_ondisk
      (fh-link-proc
        "git_config_open_ondisk"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~path (unwrap~pointer path)))
    (~git_config_open_ondisk ~out ~path)))
(export git_config_open_ondisk)

;; extern int git_config_open_level(git_config **out, const git_config *parent
;;     , git_config_level_t level);
(define ~git_config_open_level #f)
(define (git_config_open_level out parent level)
  (unless
    ~git_config_open_level
    (set! ~git_config_open_level
      (fh-link-proc
        "git_config_open_level"
        ffi:int
        (list '* '* ffi:int))))
  (let ((~out (unwrap~pointer out))
        (~parent (unwrap-git_config* parent))
        (~level (unwrap~fixed level)))
    (~git_config_open_level ~out ~parent ~level)))
(export git_config_open_level)

;; extern int git_config_open_global(git_config **out, git_config *config);
(define ~git_config_open_global #f)
(define (git_config_open_global out config)
  (unless
    ~git_config_open_global
    (set! ~git_config_open_global
      (fh-link-proc
        "git_config_open_global"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~config (unwrap-git_config* config)))
    (~git_config_open_global ~out ~config)))
(export git_config_open_global)

;; extern int git_config_snapshot(git_config **out, git_config *config);
(define ~git_config_snapshot #f)
(define (git_config_snapshot out config)
  (unless
    ~git_config_snapshot
    (set! ~git_config_snapshot
      (fh-link-proc
        "git_config_snapshot"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~config (unwrap-git_config* config)))
    (~git_config_snapshot ~out ~config)))
(export git_config_snapshot)

;; extern void git_config_free(git_config *cfg);
(define ~git_config_free #f)
(define (git_config_free cfg)
  (unless
    ~git_config_free
    (set! ~git_config_free
      (fh-link-proc
        "git_config_free"
        ffi:void
        (list '*))))
  (let ((~cfg (unwrap-git_config* cfg)))
    (~git_config_free ~cfg)))
(export git_config_free)

;; extern int git_config_get_entry(git_config_entry **out, const git_config *
;;     cfg, const char *name);
(define ~git_config_get_entry #f)
(define (git_config_get_entry out cfg name)
  (unless
    ~git_config_get_entry
    (set! ~git_config_get_entry
      (fh-link-proc
        "git_config_get_entry"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~cfg (unwrap-git_config* cfg))
        (~name (unwrap~pointer name)))
    (~git_config_get_entry ~out ~cfg ~name)))
(export git_config_get_entry)

;; extern int git_config_get_int32(int32_t *out, const git_config *cfg, const 
;;     char *name);
(define ~git_config_get_int32 #f)
(define (git_config_get_int32 out cfg name)
  (unless
    ~git_config_get_int32
    (set! ~git_config_get_int32
      (fh-link-proc
        "git_config_get_int32"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~cfg (unwrap-git_config* cfg))
        (~name (unwrap~pointer name)))
    (~git_config_get_int32 ~out ~cfg ~name)))
(export git_config_get_int32)

;; extern int git_config_get_int64(int64_t *out, const git_config *cfg, const 
;;     char *name);
(define ~git_config_get_int64 #f)
(define (git_config_get_int64 out cfg name)
  (unless
    ~git_config_get_int64
    (set! ~git_config_get_int64
      (fh-link-proc
        "git_config_get_int64"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~cfg (unwrap-git_config* cfg))
        (~name (unwrap~pointer name)))
    (~git_config_get_int64 ~out ~cfg ~name)))
(export git_config_get_int64)

;; extern int git_config_get_bool(int *out, const git_config *cfg, const char *
;;     name);
(define ~git_config_get_bool #f)
(define (git_config_get_bool out cfg name)
  (unless
    ~git_config_get_bool
    (set! ~git_config_get_bool
      (fh-link-proc
        "git_config_get_bool"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~cfg (unwrap-git_config* cfg))
        (~name (unwrap~pointer name)))
    (~git_config_get_bool ~out ~cfg ~name)))
(export git_config_get_bool)

;; extern int git_config_get_path(git_buf *out, const git_config *cfg, const 
;;     char *name);
(define ~git_config_get_path #f)
(define (git_config_get_path out cfg name)
  (unless
    ~git_config_get_path
    (set! ~git_config_get_path
      (fh-link-proc
        "git_config_get_path"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap-git_buf* out))
        (~cfg (unwrap-git_config* cfg))
        (~name (unwrap~pointer name)))
    (~git_config_get_path ~out ~cfg ~name)))
(export git_config_get_path)

;; extern int git_config_get_string(const char **out, const git_config *cfg, 
;;     const char *name);
(define ~git_config_get_string #f)
(define (git_config_get_string out cfg name)
  (unless
    ~git_config_get_string
    (set! ~git_config_get_string
      (fh-link-proc
        "git_config_get_string"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~cfg (unwrap-git_config* cfg))
        (~name (unwrap~pointer name)))
    (~git_config_get_string ~out ~cfg ~name)))
(export git_config_get_string)

;; extern int git_config_get_string_buf(git_buf *out, const git_config *cfg, 
;;     const char *name);
(define ~git_config_get_string_buf #f)
(define (git_config_get_string_buf out cfg name)
  (unless
    ~git_config_get_string_buf
    (set! ~git_config_get_string_buf
      (fh-link-proc
        "git_config_get_string_buf"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap-git_buf* out))
        (~cfg (unwrap-git_config* cfg))
        (~name (unwrap~pointer name)))
    (~git_config_get_string_buf ~out ~cfg ~name)))
(export git_config_get_string_buf)

;; extern int git_config_get_multivar_foreach(const git_config *cfg, const char
;;      *name, const char *regexp, git_config_foreach_cb callback, void *
;;     payload);
(define ~git_config_get_multivar_foreach #f)
(define (git_config_get_multivar_foreach
         cfg
         name
         regexp
         callback
         payload)
  (unless
    ~git_config_get_multivar_foreach
    (set! ~git_config_get_multivar_foreach
      (fh-link-proc
        "git_config_get_multivar_foreach"
        ffi:int
        (list '* '* '* '* '*))))
  (let ((~cfg (unwrap-git_config* cfg))
        (~name (unwrap~pointer name))
        (~regexp (unwrap~pointer regexp))
        (~callback
          ((make-ftn-arg-unwrapper ffi:int (list '* '*))
           callback))
        (~payload (unwrap~pointer payload)))
    (~git_config_get_multivar_foreach
      ~cfg
      ~name
      ~regexp
      ~callback
      ~payload)))
(export git_config_get_multivar_foreach)

;; extern int git_config_multivar_iterator_new(git_config_iterator **out, const
;;      git_config *cfg, const char *name, const char *regexp);
(define ~git_config_multivar_iterator_new #f)
(define (git_config_multivar_iterator_new
         out
         cfg
         name
         regexp)
  (unless
    ~git_config_multivar_iterator_new
    (set! ~git_config_multivar_iterator_new
      (fh-link-proc
        "git_config_multivar_iterator_new"
        ffi:int
        (list '* '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~cfg (unwrap-git_config* cfg))
        (~name (unwrap~pointer name))
        (~regexp (unwrap~pointer regexp)))
    (~git_config_multivar_iterator_new
      ~out
      ~cfg
      ~name
      ~regexp)))
(export git_config_multivar_iterator_new)

;; extern int git_config_next(git_config_entry **entry, git_config_iterator *
;;     iter);
(define ~git_config_next #f)
(define (git_config_next entry iter)
  (unless
    ~git_config_next
    (set! ~git_config_next
      (fh-link-proc
        "git_config_next"
        ffi:int
        (list '* '*))))
  (let ((~entry (unwrap~pointer entry))
        (~iter (unwrap-git_config_iterator* iter)))
    (~git_config_next ~entry ~iter)))
(export git_config_next)

;; extern void git_config_iterator_free(git_config_iterator *iter);
(define ~git_config_iterator_free #f)
(define (git_config_iterator_free iter)
  (unless
    ~git_config_iterator_free
    (set! ~git_config_iterator_free
      (fh-link-proc
        "git_config_iterator_free"
        ffi:void
        (list '*))))
  (let ((~iter (unwrap-git_config_iterator* iter)))
    (~git_config_iterator_free ~iter)))
(export git_config_iterator_free)

;; extern int git_config_set_int32(git_config *cfg, const char *name, int32_t 
;;     value);
(define ~git_config_set_int32 #f)
(define (git_config_set_int32 cfg name value)
  (unless
    ~git_config_set_int32
    (set! ~git_config_set_int32
      (fh-link-proc
        "git_config_set_int32"
        ffi:int
        (list '* '* ffi:int32))))
  (let ((~cfg (unwrap-git_config* cfg))
        (~name (unwrap~pointer name))
        (~value (unwrap~fixed value)))
    (~git_config_set_int32 ~cfg ~name ~value)))
(export git_config_set_int32)

;; extern int git_config_set_int64(git_config *cfg, const char *name, int64_t 
;;     value);
(define ~git_config_set_int64 #f)
(define (git_config_set_int64 cfg name value)
  (unless
    ~git_config_set_int64
    (set! ~git_config_set_int64
      (fh-link-proc
        "git_config_set_int64"
        ffi:int
        (list '* '* ffi:int64))))
  (let ((~cfg (unwrap-git_config* cfg))
        (~name (unwrap~pointer name))
        (~value (unwrap~fixed value)))
    (~git_config_set_int64 ~cfg ~name ~value)))
(export git_config_set_int64)

;; extern int git_config_set_bool(git_config *cfg, const char *name, int value)
;;     ;
(define ~git_config_set_bool #f)
(define (git_config_set_bool cfg name value)
  (unless
    ~git_config_set_bool
    (set! ~git_config_set_bool
      (fh-link-proc
        "git_config_set_bool"
        ffi:int
        (list '* '* ffi:int))))
  (let ((~cfg (unwrap-git_config* cfg))
        (~name (unwrap~pointer name))
        (~value (unwrap~fixed value)))
    (~git_config_set_bool ~cfg ~name ~value)))
(export git_config_set_bool)

;; extern int git_config_set_string(git_config *cfg, const char *name, const 
;;     char *value);
(define ~git_config_set_string #f)
(define (git_config_set_string cfg name value)
  (unless
    ~git_config_set_string
    (set! ~git_config_set_string
      (fh-link-proc
        "git_config_set_string"
        ffi:int
        (list '* '* '*))))
  (let ((~cfg (unwrap-git_config* cfg))
        (~name (unwrap~pointer name))
        (~value (unwrap~pointer value)))
    (~git_config_set_string ~cfg ~name ~value)))
(export git_config_set_string)

;; extern int git_config_set_multivar(git_config *cfg, const char *name, const 
;;     char *regexp, const char *value);
(define ~git_config_set_multivar #f)
(define (git_config_set_multivar cfg name regexp value)
  (unless
    ~git_config_set_multivar
    (set! ~git_config_set_multivar
      (fh-link-proc
        "git_config_set_multivar"
        ffi:int
        (list '* '* '* '*))))
  (let ((~cfg (unwrap-git_config* cfg))
        (~name (unwrap~pointer name))
        (~regexp (unwrap~pointer regexp))
        (~value (unwrap~pointer value)))
    (~git_config_set_multivar
      ~cfg
      ~name
      ~regexp
      ~value)))
(export git_config_set_multivar)

;; extern int git_config_delete_entry(git_config *cfg, const char *name);
(define ~git_config_delete_entry #f)
(define (git_config_delete_entry cfg name)
  (unless
    ~git_config_delete_entry
    (set! ~git_config_delete_entry
      (fh-link-proc
        "git_config_delete_entry"
        ffi:int
        (list '* '*))))
  (let ((~cfg (unwrap-git_config* cfg))
        (~name (unwrap~pointer name)))
    (~git_config_delete_entry ~cfg ~name)))
(export git_config_delete_entry)

;; extern int git_config_delete_multivar(git_config *cfg, const char *name, 
;;     const char *regexp);
(define ~git_config_delete_multivar #f)
(define (git_config_delete_multivar cfg name regexp)
  (unless
    ~git_config_delete_multivar
    (set! ~git_config_delete_multivar
      (fh-link-proc
        "git_config_delete_multivar"
        ffi:int
        (list '* '* '*))))
  (let ((~cfg (unwrap-git_config* cfg))
        (~name (unwrap~pointer name))
        (~regexp (unwrap~pointer regexp)))
    (~git_config_delete_multivar ~cfg ~name ~regexp)))
(export git_config_delete_multivar)

;; extern int git_config_foreach(const git_config *cfg, git_config_foreach_cb 
;;     callback, void *payload);
(define ~git_config_foreach #f)
(define (git_config_foreach cfg callback payload)
  (unless
    ~git_config_foreach
    (set! ~git_config_foreach
      (fh-link-proc
        "git_config_foreach"
        ffi:int
        (list '* '* '*))))
  (let ((~cfg (unwrap-git_config* cfg))
        (~callback
          ((make-ftn-arg-unwrapper ffi:int (list '* '*))
           callback))
        (~payload (unwrap~pointer payload)))
    (~git_config_foreach ~cfg ~callback ~payload)))
(export git_config_foreach)

;; extern int git_config_iterator_new(git_config_iterator **out, const 
;;     git_config *cfg);
(define ~git_config_iterator_new #f)
(define (git_config_iterator_new out cfg)
  (unless
    ~git_config_iterator_new
    (set! ~git_config_iterator_new
      (fh-link-proc
        "git_config_iterator_new"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~cfg (unwrap-git_config* cfg)))
    (~git_config_iterator_new ~out ~cfg)))
(export git_config_iterator_new)

;; extern int git_config_iterator_glob_new(git_config_iterator **out, const 
;;     git_config *cfg, const char *regexp);
(define ~git_config_iterator_glob_new #f)
(define (git_config_iterator_glob_new out cfg regexp)
  (unless
    ~git_config_iterator_glob_new
    (set! ~git_config_iterator_glob_new
      (fh-link-proc
        "git_config_iterator_glob_new"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~cfg (unwrap-git_config* cfg))
        (~regexp (unwrap~pointer regexp)))
    (~git_config_iterator_glob_new ~out ~cfg ~regexp)))
(export git_config_iterator_glob_new)

;; extern int git_config_foreach_match(const git_config *cfg, const char *
;;     regexp, git_config_foreach_cb callback, void *payload);
(define ~git_config_foreach_match #f)
(define (git_config_foreach_match
         cfg
         regexp
         callback
         payload)
  (unless
    ~git_config_foreach_match
    (set! ~git_config_foreach_match
      (fh-link-proc
        "git_config_foreach_match"
        ffi:int
        (list '* '* '* '*))))
  (let ((~cfg (unwrap-git_config* cfg))
        (~regexp (unwrap~pointer regexp))
        (~callback
          ((make-ftn-arg-unwrapper ffi:int (list '* '*))
           callback))
        (~payload (unwrap~pointer payload)))
    (~git_config_foreach_match
      ~cfg
      ~regexp
      ~callback
      ~payload)))
(export git_config_foreach_match)

;; extern int git_config_get_mapped(int *out, const git_config *cfg, const char
;;      *name, const git_cvar_map *maps, size_t map_n);
(define ~git_config_get_mapped #f)
(define (git_config_get_mapped out cfg name maps map_n)
  (unless
    ~git_config_get_mapped
    (set! ~git_config_get_mapped
      (fh-link-proc
        "git_config_get_mapped"
        ffi:int
        (list '* '* '* '* ffi:size_t))))
  (let ((~out (unwrap~pointer out))
        (~cfg (unwrap-git_config* cfg))
        (~name (unwrap~pointer name))
        (~maps (unwrap-git_cvar_map* maps))
        (~map_n (unwrap~fixed map_n)))
    (~git_config_get_mapped
      ~out
      ~cfg
      ~name
      ~maps
      ~map_n)))
(export git_config_get_mapped)

;; extern int git_config_lookup_map_value(int *out, const git_cvar_map *maps, 
;;     size_t map_n, const char *value);
(define ~git_config_lookup_map_value #f)
(define (git_config_lookup_map_value
         out
         maps
         map_n
         value)
  (unless
    ~git_config_lookup_map_value
    (set! ~git_config_lookup_map_value
      (fh-link-proc
        "git_config_lookup_map_value"
        ffi:int
        (list '* '* ffi:size_t '*))))
  (let ((~out (unwrap~pointer out))
        (~maps (unwrap-git_cvar_map* maps))
        (~map_n (unwrap~fixed map_n))
        (~value (unwrap~pointer value)))
    (~git_config_lookup_map_value
      ~out
      ~maps
      ~map_n
      ~value)))
(export git_config_lookup_map_value)

;; extern int git_config_parse_bool(int *out, const char *value);
(define ~git_config_parse_bool #f)
(define (git_config_parse_bool out value)
  (unless
    ~git_config_parse_bool
    (set! ~git_config_parse_bool
      (fh-link-proc
        "git_config_parse_bool"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~value (unwrap~pointer value)))
    (~git_config_parse_bool ~out ~value)))
(export git_config_parse_bool)

;; extern int git_config_parse_int32(int32_t *out, const char *value);
(define ~git_config_parse_int32 #f)
(define (git_config_parse_int32 out value)
  (unless
    ~git_config_parse_int32
    (set! ~git_config_parse_int32
      (fh-link-proc
        "git_config_parse_int32"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~value (unwrap~pointer value)))
    (~git_config_parse_int32 ~out ~value)))
(export git_config_parse_int32)

;; extern int git_config_parse_int64(int64_t *out, const char *value);
(define ~git_config_parse_int64 #f)
(define (git_config_parse_int64 out value)
  (unless
    ~git_config_parse_int64
    (set! ~git_config_parse_int64
      (fh-link-proc
        "git_config_parse_int64"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~value (unwrap~pointer value)))
    (~git_config_parse_int64 ~out ~value)))
(export git_config_parse_int64)

;; extern int git_config_parse_path(git_buf *out, const char *value);
(define ~git_config_parse_path #f)
(define (git_config_parse_path out value)
  (unless
    ~git_config_parse_path
    (set! ~git_config_parse_path
      (fh-link-proc
        "git_config_parse_path"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap-git_buf* out))
        (~value (unwrap~pointer value)))
    (~git_config_parse_path ~out ~value)))
(export git_config_parse_path)

;; extern int git_config_backend_foreach_match(git_config_backend *backend, 
;;     const char *regexp, git_config_foreach_cb callback, void *payload);
(define ~git_config_backend_foreach_match #f)
(define (git_config_backend_foreach_match
         backend
         regexp
         callback
         payload)
  (unless
    ~git_config_backend_foreach_match
    (set! ~git_config_backend_foreach_match
      (fh-link-proc
        "git_config_backend_foreach_match"
        ffi:int
        (list '* '* '* '*))))
  (let ((~backend (unwrap-git_config_backend* backend))
        (~regexp (unwrap~pointer regexp))
        (~callback
          ((make-ftn-arg-unwrapper ffi:int (list '* '*))
           callback))
        (~payload (unwrap~pointer payload)))
    (~git_config_backend_foreach_match
      ~backend
      ~regexp
      ~callback
      ~payload)))
(export git_config_backend_foreach_match)

;; extern int git_config_lock(git_transaction **tx, git_config *cfg);
(define ~git_config_lock #f)
(define (git_config_lock tx cfg)
  (unless
    ~git_config_lock
    (set! ~git_config_lock
      (fh-link-proc
        "git_config_lock"
        ffi:int
        (list '* '*))))
  (let ((~tx (unwrap~pointer tx))
        (~cfg (unwrap-git_config* cfg)))
    (~git_config_lock ~tx ~cfg)))
(export git_config_lock)

;; typedef enum {
;;   GIT_DESCRIBE_DEFAULT,
;;   GIT_DESCRIBE_TAGS,
;;   GIT_DESCRIBE_ALL,
;; } git_describe_strategy_t;
(define-fh-enum git_describe_strategy_t
  '((GIT_DESCRIBE_DEFAULT . 0)
    (GIT_DESCRIBE_TAGS . 1)
    (GIT_DESCRIBE_ALL . 2))
  )

;; typedef struct git_describe_options {
;;   unsigned int version;
;;   unsigned int max_candidates_tags; /**< default: 10 */
;;   unsigned int describe_strategy; /**< default: GIT_DESCRIBE_DEFAULT */
;;   const char *pattern;
;;   /**
;;    * When calculating the distance from the matching tag or
;;    * reference, only walk down the first-parent ancestry.
;;    */
;;   int only_follow_first_parent;
;;   /**
;;    * If no matching tag or reference is found, the describe
;;    * operation would normally fail. If this option is set, it
;;    * will instead fall back to showing the full id of the
;;    * commit.
;;    */
;;   int show_commit_oid_as_fallback;
;; } git_describe_options;
(define git_describe_options-desc
  (bs:struct
    (list `(version ,unsigned-int)
          `(max_candidates_tags ,unsigned-int)
          `(describe_strategy ,unsigned-int)
          `(pattern ,(bs:pointer int))
          `(only_follow_first_parent ,int)
          `(show_commit_oid_as_fallback ,int))))
(export git_describe_options-desc)
(define-fh-compound-type/p git_describe_options git_describe_options-desc)
(define struct-git_describe_options git_describe_options)

;; extern int git_describe_init_options(git_describe_options *opts, 
;;     unsigned int version);
(define ~git_describe_init_options #f)
(define (git_describe_init_options opts version)
  (unless
    ~git_describe_init_options
    (set! ~git_describe_init_options
      (fh-link-proc
        "git_describe_init_options"
        ffi:int
        (list '* ffi:unsigned-int))))
  (let ((~opts (unwrap-git_describe_options* opts))
        (~version (unwrap~fixed version)))
    (~git_describe_init_options ~opts ~version)))
(export git_describe_init_options)

;; typedef struct {
;;   unsigned int version;
;;   /**
;;    * Size of the abbreviated commit id to use. This value is the
;;    * lower bound for the length of the abbreviated string. The
;;    * default is 7.
;;    */
;;   unsigned int abbreviated_size;
;;   /**
;;    * Set to use the long format even when a shorter name could be used.
;;    */
;;   int always_use_long_format;
;;   /**
;;    * If the workdir is dirty and this is set, this string will
;;    * be appended to the description string.
;;    */
;;   const char *dirty_suffix;
;; } git_describe_format_options;
(define git_describe_format_options-desc
  (bs:struct
    (list `(version ,unsigned-int)
          `(abbreviated_size ,unsigned-int)
          `(always_use_long_format ,int)
          `(dirty_suffix ,(bs:pointer int)))))
(export git_describe_format_options-desc)
(define-fh-compound-type/p git_describe_format_options git_describe_format_options-desc)

;; extern int git_describe_init_format_options(git_describe_format_options *
;;     opts, unsigned int version);
(define ~git_describe_init_format_options #f)
(define (git_describe_init_format_options opts version)
  (unless
    ~git_describe_init_format_options
    (set! ~git_describe_init_format_options
      (fh-link-proc
        "git_describe_init_format_options"
        ffi:int
        (list '* ffi:unsigned-int))))
  (let ((~opts (unwrap-git_describe_format_options* opts))
        (~version (unwrap~fixed version)))
    (~git_describe_init_format_options
      ~opts
      ~version)))
(export git_describe_init_format_options)

;; typedef struct git_describe_result git_describe_result;
(define git_describe_result-desc void)
(export git_describe_result-desc)
(define git_describe_result*-desc (bs:pointer git_describe_result-desc))
(export git_describe_result*-desc)
(define-fh-pointer-type git_describe_result* git_describe_result*-desc)

;; extern int git_describe_commit(git_describe_result **result, git_object *
;;     committish, git_describe_options *opts);
(define ~git_describe_commit #f)
(define (git_describe_commit result committish opts)
  (unless
    ~git_describe_commit
    (set! ~git_describe_commit
      (fh-link-proc
        "git_describe_commit"
        ffi:int
        (list '* '* '*))))
  (let ((~result (unwrap~pointer result))
        (~committish (unwrap-git_object* committish))
        (~opts (unwrap-git_describe_options* opts)))
    (~git_describe_commit ~result ~committish ~opts)))
(export git_describe_commit)

;; extern int git_describe_workdir(git_describe_result **out, git_repository *
;;     repo, git_describe_options *opts);
(define ~git_describe_workdir #f)
(define (git_describe_workdir out repo opts)
  (unless
    ~git_describe_workdir
    (set! ~git_describe_workdir
      (fh-link-proc
        "git_describe_workdir"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo))
        (~opts (unwrap-git_describe_options* opts)))
    (~git_describe_workdir ~out ~repo ~opts)))
(export git_describe_workdir)

;; extern int git_describe_format(git_buf *out, const git_describe_result *
;;     result, const git_describe_format_options *opts);
(define ~git_describe_format #f)
(define (git_describe_format out result opts)
  (unless
    ~git_describe_format
    (set! ~git_describe_format
      (fh-link-proc
        "git_describe_format"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap-git_buf* out))
        (~result (unwrap-git_describe_result* result))
        (~opts (unwrap-git_describe_format_options* opts)))
    (~git_describe_format ~out ~result ~opts)))
(export git_describe_format)

;; extern void git_describe_result_free(git_describe_result *result);
(define ~git_describe_result_free #f)
(define (git_describe_result_free result)
  (unless
    ~git_describe_result_free
    (set! ~git_describe_result_free
      (fh-link-proc
        "git_describe_result_free"
        ffi:void
        (list '*))))
  (let ((~result (unwrap-git_describe_result* result)))
    (~git_describe_result_free ~result)))
(export git_describe_result_free)

;; typedef enum {
;;   GIT_OK = 0,
;;   GIT_ERROR = -1,
;;   GIT_ENOTFOUND = -3,
;;   GIT_EEXISTS = -4,
;;   GIT_EAMBIGUOUS = -5,
;;   GIT_EBUFS = -6,
;;   GIT_EUSER = -7,
;;   GIT_EBAREREPO = -8,
;;   GIT_EUNBORNBRANCH = -9,
;;   GIT_EUNMERGED = -10,
;;   GIT_ENONFASTFORWARD = -11,
;;   GIT_EINVALIDSPEC = -12,
;;   GIT_ECONFLICT = -13,
;;   GIT_ELOCKED = -14,
;;   GIT_EMODIFIED = -15,
;;   GIT_EAUTH = -16,
;;   GIT_ECERTIFICATE = -17,
;;   GIT_EAPPLIED = -18,
;;   GIT_EPEEL = -19,
;;   GIT_EEOF = -20,
;;   GIT_EINVALID = -21,
;;   GIT_EUNCOMMITTED = -22,
;;   GIT_EDIRECTORY = -23,
;;   GIT_EMERGECONFLICT = -24,
;;   GIT_PASSTHROUGH = -30,
;;   GIT_ITEROVER = -31,
;;   GIT_RETRY = -32,
;;   GIT_EMISMATCH = -33,
;; } git_error_code;
(define-fh-enum git_error_code
  '((GIT_OK . 0)
    (GIT_ERROR . -1)
    (GIT_ENOTFOUND . -3)
    (GIT_EEXISTS . -4)
    (GIT_EAMBIGUOUS . -5)
    (GIT_EBUFS . -6)
    (GIT_EUSER . -7)
    (GIT_EBAREREPO . -8)
    (GIT_EUNBORNBRANCH . -9)
    (GIT_EUNMERGED . -10)
    (GIT_ENONFASTFORWARD . -11)
    (GIT_EINVALIDSPEC . -12)
    (GIT_ECONFLICT . -13)
    (GIT_ELOCKED . -14)
    (GIT_EMODIFIED . -15)
    (GIT_EAUTH . -16)
    (GIT_ECERTIFICATE . -17)
    (GIT_EAPPLIED . -18)
    (GIT_EPEEL . -19)
    (GIT_EEOF . -20)
    (GIT_EINVALID . -21)
    (GIT_EUNCOMMITTED . -22)
    (GIT_EDIRECTORY . -23)
    (GIT_EMERGECONFLICT . -24)
    (GIT_PASSTHROUGH . -30)
    (GIT_ITEROVER . -31)
    (GIT_RETRY . -32)
    (GIT_EMISMATCH . -33))
  )

;; typedef struct {
;;   char *message;
;;   int klass;
;; } git_error;
(define git_error-desc
  (bs:struct
    (list `(message ,(bs:pointer int)) `(klass ,int))))
(export git_error-desc)
(define-fh-compound-type/p git_error git_error-desc)

;; typedef enum {
;;   GITERR_NONE = 0,
;;   GITERR_NOMEMORY,
;;   GITERR_OS,
;;   GITERR_INVALID,
;;   GITERR_REFERENCE,
;;   GITERR_ZLIB,
;;   GITERR_REPOSITORY,
;;   GITERR_CONFIG,
;;   GITERR_REGEX,
;;   GITERR_ODB,
;;   GITERR_INDEX,
;;   GITERR_OBJECT,
;;   GITERR_NET,
;;   GITERR_TAG,
;;   GITERR_TREE,
;;   GITERR_INDEXER,
;;   GITERR_SSL,
;;   GITERR_SUBMODULE,
;;   GITERR_THREAD,
;;   GITERR_STASH,
;;   GITERR_CHECKOUT,
;;   GITERR_FETCHHEAD,
;;   GITERR_MERGE,
;;   GITERR_SSH,
;;   GITERR_FILTER,
;;   GITERR_REVERT,
;;   GITERR_CALLBACK,
;;   GITERR_CHERRYPICK,
;;   GITERR_DESCRIBE,
;;   GITERR_REBASE,
;;   GITERR_FILESYSTEM,
;;   GITERR_PATCH,
;;   GITERR_WORKTREE,
;;   GITERR_SHA1,
;; } git_error_t;
(define-fh-enum git_error_t
  '((GITERR_NONE . 0)
    (GITERR_NOMEMORY . 1)
    (GITERR_OS . 2)
    (GITERR_INVALID . 3)
    (GITERR_REFERENCE . 4)
    (GITERR_ZLIB . 5)
    (GITERR_REPOSITORY . 6)
    (GITERR_CONFIG . 7)
    (GITERR_REGEX . 8)
    (GITERR_ODB . 9)
    (GITERR_INDEX . 10)
    (GITERR_OBJECT . 11)
    (GITERR_NET . 12)
    (GITERR_TAG . 13)
    (GITERR_TREE . 14)
    (GITERR_INDEXER . 15)
    (GITERR_SSL . 16)
    (GITERR_SUBMODULE . 17)
    (GITERR_THREAD . 18)
    (GITERR_STASH . 19)
    (GITERR_CHECKOUT . 20)
    (GITERR_FETCHHEAD . 21)
    (GITERR_MERGE . 22)
    (GITERR_SSH . 23)
    (GITERR_FILTER . 24)
    (GITERR_REVERT . 25)
    (GITERR_CALLBACK . 26)
    (GITERR_CHERRYPICK . 27)
    (GITERR_DESCRIBE . 28)
    (GITERR_REBASE . 29)
    (GITERR_FILESYSTEM . 30)
    (GITERR_PATCH . 31)
    (GITERR_WORKTREE . 32)
    (GITERR_SHA1 . 33))
  )

;; extern const git_error *giterr_last(void);
(define ~giterr_last #f)
(define (giterr_last)
  (unless
    ~giterr_last
    (set! ~giterr_last
      (fh-link-proc "giterr_last" '* (list))))
  (let () (wrap-git_error* (~giterr_last))))
(export giterr_last)

;; extern void giterr_clear(void);
(define ~giterr_clear #f)
(define (giterr_clear)
  (unless
    ~giterr_clear
    (set! ~giterr_clear
      (fh-link-proc "giterr_clear" ffi:void (list))))
  (let () (~giterr_clear)))
(export giterr_clear)

;; extern void giterr_set_str(int error_class, const char *string);
(define ~giterr_set_str #f)
(define (giterr_set_str error_class string)
  (unless
    ~giterr_set_str
    (set! ~giterr_set_str
      (fh-link-proc
        "giterr_set_str"
        ffi:void
        (list ffi:int '*))))
  (let ((~error_class (unwrap~fixed error_class))
        (~string (unwrap~pointer string)))
    (~giterr_set_str ~error_class ~string)))
(export giterr_set_str)

;; extern void giterr_set_oom(void);
(define ~giterr_set_oom #f)
(define (giterr_set_oom)
  (unless
    ~giterr_set_oom
    (set! ~giterr_set_oom
      (fh-link-proc "giterr_set_oom" ffi:void (list))))
  (let () (~giterr_set_oom)))
(export giterr_set_oom)

;; typedef enum {
;;   GIT_FILTER_TO_WORKTREE = 0,
;;   GIT_FILTER_SMUDGE = GIT_FILTER_TO_WORKTREE,
;;   GIT_FILTER_TO_ODB = 1,
;;   GIT_FILTER_CLEAN = GIT_FILTER_TO_ODB,
;; } git_filter_mode_t;
(define-fh-enum git_filter_mode_t
  '((GIT_FILTER_TO_WORKTREE . 0)
    (GIT_FILTER_SMUDGE . 0)
    (GIT_FILTER_TO_ODB . 1)
    (GIT_FILTER_CLEAN . 1))
  )

;; typedef enum {
;;   GIT_FILTER_DEFAULT = 0u,
;;   GIT_FILTER_ALLOW_UNSAFE = 1u<<0,
;; } git_filter_flag_t;
(define-fh-enum git_filter_flag_t
  '((GIT_FILTER_DEFAULT . 0)
    (GIT_FILTER_ALLOW_UNSAFE . 1))
  )

;; typedef struct git_filter git_filter;
(define git_filter-desc void)
(export git_filter-desc)
(define git_filter*-desc (bs:pointer git_filter-desc))
(export git_filter*-desc)
(define-fh-pointer-type git_filter* git_filter*-desc)

;; typedef struct git_filter_list git_filter_list;
(define git_filter_list-desc void)
(export git_filter_list-desc)
(define git_filter_list*-desc (bs:pointer git_filter_list-desc))
(export git_filter_list*-desc)
(define-fh-pointer-type git_filter_list* git_filter_list*-desc)

;; extern int git_filter_list_load(git_filter_list **filters, git_repository *
;;     repo, git_blob *blob, const char *path, git_filter_mode_t mode, uint32_t
;;      flags);
(define ~git_filter_list_load #f)
(define (git_filter_list_load
         filters
         repo
         blob
         path
         mode
         flags)
  (unless
    ~git_filter_list_load
    (set! ~git_filter_list_load
      (fh-link-proc
        "git_filter_list_load"
        ffi:int
        (list '* '* '* '* ffi:int ffi:uint32))))
  (let ((~filters (unwrap~pointer filters))
        (~repo (unwrap-git_repository* repo))
        (~blob (unwrap-git_blob* blob))
        (~path (unwrap~pointer path))
        (~mode (unwrap~fixed mode))
        (~flags (unwrap~fixed flags)))
    (~git_filter_list_load
      ~filters
      ~repo
      ~blob
      ~path
      ~mode
      ~flags)))
(export git_filter_list_load)

;; extern int git_filter_list_contains(git_filter_list *filters, const char *
;;     name);
(define ~git_filter_list_contains #f)
(define (git_filter_list_contains filters name)
  (unless
    ~git_filter_list_contains
    (set! ~git_filter_list_contains
      (fh-link-proc
        "git_filter_list_contains"
        ffi:int
        (list '* '*))))
  (let ((~filters (unwrap-git_filter_list* filters))
        (~name (unwrap~pointer name)))
    (~git_filter_list_contains ~filters ~name)))
(export git_filter_list_contains)

;; extern int git_filter_list_apply_to_data(git_buf *out, git_filter_list *
;;     filters, git_buf *in);
(define ~git_filter_list_apply_to_data #f)
(define (git_filter_list_apply_to_data out filters in)
  (unless
    ~git_filter_list_apply_to_data
    (set! ~git_filter_list_apply_to_data
      (fh-link-proc
        "git_filter_list_apply_to_data"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap-git_buf* out))
        (~filters (unwrap-git_filter_list* filters))
        (~in (unwrap-git_buf* in)))
    (~git_filter_list_apply_to_data
      ~out
      ~filters
      ~in)))
(export git_filter_list_apply_to_data)

;; extern int git_filter_list_apply_to_file(git_buf *out, git_filter_list *
;;     filters, git_repository *repo, const char *path);
(define ~git_filter_list_apply_to_file #f)
(define (git_filter_list_apply_to_file
         out
         filters
         repo
         path)
  (unless
    ~git_filter_list_apply_to_file
    (set! ~git_filter_list_apply_to_file
      (fh-link-proc
        "git_filter_list_apply_to_file"
        ffi:int
        (list '* '* '* '*))))
  (let ((~out (unwrap-git_buf* out))
        (~filters (unwrap-git_filter_list* filters))
        (~repo (unwrap-git_repository* repo))
        (~path (unwrap~pointer path)))
    (~git_filter_list_apply_to_file
      ~out
      ~filters
      ~repo
      ~path)))
(export git_filter_list_apply_to_file)

;; extern int git_filter_list_apply_to_blob(git_buf *out, git_filter_list *
;;     filters, git_blob *blob);
(define ~git_filter_list_apply_to_blob #f)
(define (git_filter_list_apply_to_blob out filters blob)
  (unless
    ~git_filter_list_apply_to_blob
    (set! ~git_filter_list_apply_to_blob
      (fh-link-proc
        "git_filter_list_apply_to_blob"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap-git_buf* out))
        (~filters (unwrap-git_filter_list* filters))
        (~blob (unwrap-git_blob* blob)))
    (~git_filter_list_apply_to_blob
      ~out
      ~filters
      ~blob)))
(export git_filter_list_apply_to_blob)

;; extern int git_filter_list_stream_data(git_filter_list *filters, git_buf *
;;     data, git_writestream *target);
(define ~git_filter_list_stream_data #f)
(define (git_filter_list_stream_data filters data target)
  (unless
    ~git_filter_list_stream_data
    (set! ~git_filter_list_stream_data
      (fh-link-proc
        "git_filter_list_stream_data"
        ffi:int
        (list '* '* '*))))
  (let ((~filters (unwrap-git_filter_list* filters))
        (~data (unwrap-git_buf* data))
        (~target (unwrap-git_writestream* target)))
    (~git_filter_list_stream_data
      ~filters
      ~data
      ~target)))
(export git_filter_list_stream_data)

;; extern int git_filter_list_stream_file(git_filter_list *filters, 
;;     git_repository *repo, const char *path, git_writestream *target);
(define ~git_filter_list_stream_file #f)
(define (git_filter_list_stream_file
         filters
         repo
         path
         target)
  (unless
    ~git_filter_list_stream_file
    (set! ~git_filter_list_stream_file
      (fh-link-proc
        "git_filter_list_stream_file"
        ffi:int
        (list '* '* '* '*))))
  (let ((~filters (unwrap-git_filter_list* filters))
        (~repo (unwrap-git_repository* repo))
        (~path (unwrap~pointer path))
        (~target (unwrap-git_writestream* target)))
    (~git_filter_list_stream_file
      ~filters
      ~repo
      ~path
      ~target)))
(export git_filter_list_stream_file)

;; extern int git_filter_list_stream_blob(git_filter_list *filters, git_blob *
;;     blob, git_writestream *target);
(define ~git_filter_list_stream_blob #f)
(define (git_filter_list_stream_blob filters blob target)
  (unless
    ~git_filter_list_stream_blob
    (set! ~git_filter_list_stream_blob
      (fh-link-proc
        "git_filter_list_stream_blob"
        ffi:int
        (list '* '* '*))))
  (let ((~filters (unwrap-git_filter_list* filters))
        (~blob (unwrap-git_blob* blob))
        (~target (unwrap-git_writestream* target)))
    (~git_filter_list_stream_blob
      ~filters
      ~blob
      ~target)))
(export git_filter_list_stream_blob)

;; extern void git_filter_list_free(git_filter_list *filters);
(define ~git_filter_list_free #f)
(define (git_filter_list_free filters)
  (unless
    ~git_filter_list_free
    (set! ~git_filter_list_free
      (fh-link-proc
        "git_filter_list_free"
        ffi:void
        (list '*))))
  (let ((~filters (unwrap-git_filter_list* filters)))
    (~git_filter_list_free ~filters)))
(export git_filter_list_free)

;; extern int git_libgit2_init(void);
(define ~git_libgit2_init #f)
(define (git_libgit2_init)
  (unless
    ~git_libgit2_init
    (set! ~git_libgit2_init
      (fh-link-proc "git_libgit2_init" ffi:int (list))))
  (let () (~git_libgit2_init)))
(export git_libgit2_init)

;; extern int git_libgit2_shutdown(void);
(define ~git_libgit2_shutdown #f)
(define (git_libgit2_shutdown)
  (unless
    ~git_libgit2_shutdown
    (set! ~git_libgit2_shutdown
      (fh-link-proc
        "git_libgit2_shutdown"
        ffi:int
        (list))))
  (let () (~git_libgit2_shutdown)))
(export git_libgit2_shutdown)

;; extern int git_graph_ahead_behind(size_t *ahead, size_t *behind, 
;;     git_repository *repo, const git_oid *local, const git_oid *upstream);
(define ~git_graph_ahead_behind #f)
(define (git_graph_ahead_behind
         ahead
         behind
         repo
         local
         upstream)
  (unless
    ~git_graph_ahead_behind
    (set! ~git_graph_ahead_behind
      (fh-link-proc
        "git_graph_ahead_behind"
        ffi:int
        (list '* '* '* '* '*))))
  (let ((~ahead (unwrap~pointer ahead))
        (~behind (unwrap~pointer behind))
        (~repo (unwrap-git_repository* repo))
        (~local (unwrap-git_oid* local))
        (~upstream (unwrap-git_oid* upstream)))
    (~git_graph_ahead_behind
      ~ahead
      ~behind
      ~repo
      ~local
      ~upstream)))
(export git_graph_ahead_behind)

;; extern int git_graph_descendant_of(git_repository *repo, const git_oid *
;;     commit, const git_oid *ancestor);
(define ~git_graph_descendant_of #f)
(define (git_graph_descendant_of repo commit ancestor)
  (unless
    ~git_graph_descendant_of
    (set! ~git_graph_descendant_of
      (fh-link-proc
        "git_graph_descendant_of"
        ffi:int
        (list '* '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~commit (unwrap-git_oid* commit))
        (~ancestor (unwrap-git_oid* ancestor)))
    (~git_graph_descendant_of
      ~repo
      ~commit
      ~ancestor)))
(export git_graph_descendant_of)

;; extern int git_ignore_add_rule(git_repository *repo, const char *rules);
(define ~git_ignore_add_rule #f)
(define (git_ignore_add_rule repo rules)
  (unless
    ~git_ignore_add_rule
    (set! ~git_ignore_add_rule
      (fh-link-proc
        "git_ignore_add_rule"
        ffi:int
        (list '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~rules (unwrap~pointer rules)))
    (~git_ignore_add_rule ~repo ~rules)))
(export git_ignore_add_rule)

;; extern int git_ignore_clear_internal_rules(git_repository *repo);
(define ~git_ignore_clear_internal_rules #f)
(define (git_ignore_clear_internal_rules repo)
  (unless
    ~git_ignore_clear_internal_rules
    (set! ~git_ignore_clear_internal_rules
      (fh-link-proc
        "git_ignore_clear_internal_rules"
        ffi:int
        (list '*))))
  (let ((~repo (unwrap-git_repository* repo)))
    (~git_ignore_clear_internal_rules ~repo)))
(export git_ignore_clear_internal_rules)

;; extern int git_ignore_path_is_ignored(int *ignored, git_repository *repo, 
;;     const char *path);
(define ~git_ignore_path_is_ignored #f)
(define (git_ignore_path_is_ignored ignored repo path)
  (unless
    ~git_ignore_path_is_ignored
    (set! ~git_ignore_path_is_ignored
      (fh-link-proc
        "git_ignore_path_is_ignored"
        ffi:int
        (list '* '* '*))))
  (let ((~ignored (unwrap~pointer ignored))
        (~repo (unwrap-git_repository* repo))
        (~path (unwrap~pointer path)))
    (~git_ignore_path_is_ignored
      ~ignored
      ~repo
      ~path)))
(export git_ignore_path_is_ignored)

;; extern int git_message_prettify(git_buf *out, const char *message, int 
;;     strip_comments, char comment_char);
(define ~git_message_prettify #f)
(define (git_message_prettify
         out
         message
         strip_comments
         comment_char)
  (unless
    ~git_message_prettify
    (set! ~git_message_prettify
      (fh-link-proc
        "git_message_prettify"
        ffi:int
        (list '* '* ffi:int ffi:int))))
  (let ((~out (unwrap-git_buf* out))
        (~message (unwrap~pointer message))
        (~strip_comments (unwrap~fixed strip_comments))
        (~comment_char (unwrap~fixed comment_char)))
    (~git_message_prettify
      ~out
      ~message
      ~strip_comments
      ~comment_char)))
(export git_message_prettify)

;; typedef int (*git_note_foreach_cb)(const git_oid *blob_id, const git_oid *
;;     annotated_object_id, void *payload);
(define-fh-function/p git_note_foreach_cb
  ffi:int (list (quote *) (quote *) (quote *)))

;; typedef struct git_iterator git_note_iterator;
(define git_note_iterator-desc void)
(export git_note_iterator-desc)
(define git_note_iterator*-desc (bs:pointer git_note_iterator-desc))
(export git_note_iterator*-desc)
(define-fh-pointer-type git_note_iterator* git_note_iterator*-desc)

;; extern int git_note_iterator_new(git_note_iterator **out, git_repository *
;;     repo, const char *notes_ref);
(define ~git_note_iterator_new #f)
(define (git_note_iterator_new out repo notes_ref)
  (unless
    ~git_note_iterator_new
    (set! ~git_note_iterator_new
      (fh-link-proc
        "git_note_iterator_new"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo))
        (~notes_ref (unwrap~pointer notes_ref)))
    (~git_note_iterator_new ~out ~repo ~notes_ref)))
(export git_note_iterator_new)

;; extern void git_note_iterator_free(git_note_iterator *it);
(define ~git_note_iterator_free #f)
(define (git_note_iterator_free it)
  (unless
    ~git_note_iterator_free
    (set! ~git_note_iterator_free
      (fh-link-proc
        "git_note_iterator_free"
        ffi:void
        (list '*))))
  (let ((~it (unwrap-git_note_iterator* it)))
    (~git_note_iterator_free ~it)))
(export git_note_iterator_free)

;; extern int git_note_next(git_oid *note_id, git_oid *annotated_id, 
;;     git_note_iterator *it);
(define ~git_note_next #f)
(define (git_note_next note_id annotated_id it)
  (unless
    ~git_note_next
    (set! ~git_note_next
      (fh-link-proc
        "git_note_next"
        ffi:int
        (list '* '* '*))))
  (let ((~note_id (unwrap-git_oid* note_id))
        (~annotated_id (unwrap-git_oid* annotated_id))
        (~it (unwrap-git_note_iterator* it)))
    (~git_note_next ~note_id ~annotated_id ~it)))
(export git_note_next)

;; extern int git_note_read(git_note **out, git_repository *repo, const char *
;;     notes_ref, const git_oid *oid);
(define ~git_note_read #f)
(define (git_note_read out repo notes_ref oid)
  (unless
    ~git_note_read
    (set! ~git_note_read
      (fh-link-proc
        "git_note_read"
        ffi:int
        (list '* '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo))
        (~notes_ref (unwrap~pointer notes_ref))
        (~oid (unwrap-git_oid* oid)))
    (~git_note_read ~out ~repo ~notes_ref ~oid)))
(export git_note_read)

;; extern const git_signature *git_note_author(const git_note *note);
(define ~git_note_author #f)
(define (git_note_author note)
  (unless
    ~git_note_author
    (set! ~git_note_author
      (fh-link-proc "git_note_author" '* (list '*))))
  (let ((~note (unwrap-git_note* note)))
    (wrap-git_signature* (~git_note_author ~note))))
(export git_note_author)

;; extern const git_signature *git_note_committer(const git_note *note);
(define ~git_note_committer #f)
(define (git_note_committer note)
  (unless
    ~git_note_committer
    (set! ~git_note_committer
      (fh-link-proc "git_note_committer" '* (list '*))))
  (let ((~note (unwrap-git_note* note)))
    (wrap-git_signature* (~git_note_committer ~note))))
(export git_note_committer)

;; extern const char *git_note_message(const git_note *note);
(define ~git_note_message #f)
(define (git_note_message note)
  (unless
    ~git_note_message
    (set! ~git_note_message
      (fh-link-proc "git_note_message" '* (list '*))))
  (let ((~note (unwrap-git_note* note)))
    (~git_note_message ~note)))
(export git_note_message)

;; extern const git_oid *git_note_id(const git_note *note);
(define ~git_note_id #f)
(define (git_note_id note)
  (unless
    ~git_note_id
    (set! ~git_note_id
      (fh-link-proc "git_note_id" '* (list '*))))
  (let ((~note (unwrap-git_note* note)))
    (wrap-git_oid* (~git_note_id ~note))))
(export git_note_id)

;; extern int git_note_create(git_oid *out, git_repository *repo, const char *
;;     notes_ref, const git_signature *author, const git_signature *committer, 
;;     const git_oid *oid, const char *note, int force);
(define ~git_note_create #f)
(define (git_note_create
         out
         repo
         notes_ref
         author
         committer
         oid
         note
         force)
  (unless
    ~git_note_create
    (set! ~git_note_create
      (fh-link-proc
        "git_note_create"
        ffi:int
        (list '* '* '* '* '* '* '* ffi:int))))
  (let ((~out (unwrap-git_oid* out))
        (~repo (unwrap-git_repository* repo))
        (~notes_ref (unwrap~pointer notes_ref))
        (~author (unwrap-git_signature* author))
        (~committer (unwrap-git_signature* committer))
        (~oid (unwrap-git_oid* oid))
        (~note (unwrap~pointer note))
        (~force (unwrap~fixed force)))
    (~git_note_create
      ~out
      ~repo
      ~notes_ref
      ~author
      ~committer
      ~oid
      ~note
      ~force)))
(export git_note_create)

;; extern int git_note_remove(git_repository *repo, const char *notes_ref, 
;;     const git_signature *author, const git_signature *committer, const 
;;     git_oid *oid);
(define ~git_note_remove #f)
(define (git_note_remove
         repo
         notes_ref
         author
         committer
         oid)
  (unless
    ~git_note_remove
    (set! ~git_note_remove
      (fh-link-proc
        "git_note_remove"
        ffi:int
        (list '* '* '* '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~notes_ref (unwrap~pointer notes_ref))
        (~author (unwrap-git_signature* author))
        (~committer (unwrap-git_signature* committer))
        (~oid (unwrap-git_oid* oid)))
    (~git_note_remove
      ~repo
      ~notes_ref
      ~author
      ~committer
      ~oid)))
(export git_note_remove)

;; extern void git_note_free(git_note *note);
(define ~git_note_free #f)
(define (git_note_free note)
  (unless
    ~git_note_free
    (set! ~git_note_free
      (fh-link-proc "git_note_free" ffi:void (list '*))))
  (let ((~note (unwrap-git_note* note)))
    (~git_note_free ~note)))
(export git_note_free)

;; extern int git_note_default_ref(git_buf *out, git_repository *repo);
(define ~git_note_default_ref #f)
(define (git_note_default_ref out repo)
  (unless
    ~git_note_default_ref
    (set! ~git_note_default_ref
      (fh-link-proc
        "git_note_default_ref"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap-git_buf* out))
        (~repo (unwrap-git_repository* repo)))
    (~git_note_default_ref ~out ~repo)))
(export git_note_default_ref)

;; extern int git_note_foreach(git_repository *repo, const char *notes_ref, 
;;     git_note_foreach_cb note_cb, void *payload);
(define ~git_note_foreach #f)
(define (git_note_foreach repo notes_ref note_cb payload)
  (unless
    ~git_note_foreach
    (set! ~git_note_foreach
      (fh-link-proc
        "git_note_foreach"
        ffi:int
        (list '* '* '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~notes_ref (unwrap~pointer notes_ref))
        (~note_cb
          ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
           note_cb))
        (~payload (unwrap~pointer payload)))
    (~git_note_foreach
      ~repo
      ~notes_ref
      ~note_cb
      ~payload)))
(export git_note_foreach)

;; typedef int (*git_odb_foreach_cb)(const git_oid *id, void *payload);
(define-fh-function/p git_odb_foreach_cb
  ffi:int (list (quote *) (quote *)))

;; extern int git_odb_new(git_odb **out);
(define ~git_odb_new #f)
(define (git_odb_new out)
  (unless
    ~git_odb_new
    (set! ~git_odb_new
      (fh-link-proc "git_odb_new" ffi:int (list '*))))
  (let ((~out (unwrap~pointer out)))
    (~git_odb_new ~out)))
(export git_odb_new)

;; extern int git_odb_open(git_odb **out, const char *objects_dir);
(define ~git_odb_open #f)
(define (git_odb_open out objects_dir)
  (unless
    ~git_odb_open
    (set! ~git_odb_open
      (fh-link-proc
        "git_odb_open"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~objects_dir (unwrap~pointer objects_dir)))
    (~git_odb_open ~out ~objects_dir)))
(export git_odb_open)

;; extern int git_odb_add_disk_alternate(git_odb *odb, const char *path);
(define ~git_odb_add_disk_alternate #f)
(define (git_odb_add_disk_alternate odb path)
  (unless
    ~git_odb_add_disk_alternate
    (set! ~git_odb_add_disk_alternate
      (fh-link-proc
        "git_odb_add_disk_alternate"
        ffi:int
        (list '* '*))))
  (let ((~odb (unwrap-git_odb* odb))
        (~path (unwrap~pointer path)))
    (~git_odb_add_disk_alternate ~odb ~path)))
(export git_odb_add_disk_alternate)

;; extern void git_odb_free(git_odb *db);
(define ~git_odb_free #f)
(define (git_odb_free db)
  (unless
    ~git_odb_free
    (set! ~git_odb_free
      (fh-link-proc "git_odb_free" ffi:void (list '*))))
  (let ((~db (unwrap-git_odb* db)))
    (~git_odb_free ~db)))
(export git_odb_free)

;; extern int git_odb_read(git_odb_object **out, git_odb *db, const git_oid *id
;;     );
(define ~git_odb_read #f)
(define (git_odb_read out db id)
  (unless
    ~git_odb_read
    (set! ~git_odb_read
      (fh-link-proc
        "git_odb_read"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~db (unwrap-git_odb* db))
        (~id (unwrap-git_oid* id)))
    (~git_odb_read ~out ~db ~id)))
(export git_odb_read)

;; extern int git_odb_read_prefix(git_odb_object **out, git_odb *db, const 
;;     git_oid *short_id, size_t len);
(define ~git_odb_read_prefix #f)
(define (git_odb_read_prefix out db short_id len)
  (unless
    ~git_odb_read_prefix
    (set! ~git_odb_read_prefix
      (fh-link-proc
        "git_odb_read_prefix"
        ffi:int
        (list '* '* '* ffi:size_t))))
  (let ((~out (unwrap~pointer out))
        (~db (unwrap-git_odb* db))
        (~short_id (unwrap-git_oid* short_id))
        (~len (unwrap~fixed len)))
    (~git_odb_read_prefix ~out ~db ~short_id ~len)))
(export git_odb_read_prefix)

;; extern int git_odb_read_header(size_t *len_out, git_otype *type_out, git_odb
;;      *db, const git_oid *id);
(define ~git_odb_read_header #f)
(define (git_odb_read_header len_out type_out db id)
  (unless
    ~git_odb_read_header
    (set! ~git_odb_read_header
      (fh-link-proc
        "git_odb_read_header"
        ffi:int
        (list '* '* '* '*))))
  (let ((~len_out (unwrap~pointer len_out))
        (~type_out (unwrap~pointer type_out))
        (~db (unwrap-git_odb* db))
        (~id (unwrap-git_oid* id)))
    (~git_odb_read_header ~len_out ~type_out ~db ~id)))
(export git_odb_read_header)

;; extern int git_odb_exists(git_odb *db, const git_oid *id);
(define ~git_odb_exists #f)
(define (git_odb_exists db id)
  (unless
    ~git_odb_exists
    (set! ~git_odb_exists
      (fh-link-proc
        "git_odb_exists"
        ffi:int
        (list '* '*))))
  (let ((~db (unwrap-git_odb* db))
        (~id (unwrap-git_oid* id)))
    (~git_odb_exists ~db ~id)))
(export git_odb_exists)

;; extern int git_odb_exists_prefix(git_oid *out, git_odb *db, const git_oid *
;;     short_id, size_t len);
(define ~git_odb_exists_prefix #f)
(define (git_odb_exists_prefix out db short_id len)
  (unless
    ~git_odb_exists_prefix
    (set! ~git_odb_exists_prefix
      (fh-link-proc
        "git_odb_exists_prefix"
        ffi:int
        (list '* '* '* ffi:size_t))))
  (let ((~out (unwrap-git_oid* out))
        (~db (unwrap-git_odb* db))
        (~short_id (unwrap-git_oid* short_id))
        (~len (unwrap~fixed len)))
    (~git_odb_exists_prefix ~out ~db ~short_id ~len)))
(export git_odb_exists_prefix)

;; typedef struct git_odb_expand_id {
;;   /** The object ID to expand */
;;   git_oid id;
;;   /**
;;    * The length of the object ID (in nibbles, or packets of 4 bits; the
;;    * number of hex characters)
;;    * */
;;   unsigned short length;
;;   /**
;;    * The (optional) type of the object to search for; leave as `0` or set
;;    * to `GIT_OBJ_ANY` to query for any object matching the ID.
;;    */
;;   git_otype type;
;; } git_odb_expand_id;
(define git_odb_expand_id-desc
  (bs:struct
    (list `(id ,git_oid-desc)
          `(length ,unsigned-short)
          `(type ,int))))
(export git_odb_expand_id-desc)
(define-fh-compound-type/p git_odb_expand_id git_odb_expand_id-desc)
(define struct-git_odb_expand_id git_odb_expand_id)

;; extern int git_odb_expand_ids(git_odb *db, git_odb_expand_id *ids, size_t 
;;     count);
(define ~git_odb_expand_ids #f)
(define (git_odb_expand_ids db ids count)
  (unless
    ~git_odb_expand_ids
    (set! ~git_odb_expand_ids
      (fh-link-proc
        "git_odb_expand_ids"
        ffi:int
        (list '* '* ffi:size_t))))
  (let ((~db (unwrap-git_odb* db))
        (~ids (unwrap-git_odb_expand_id* ids))
        (~count (unwrap~fixed count)))
    (~git_odb_expand_ids ~db ~ids ~count)))
(export git_odb_expand_ids)

;; extern int git_odb_refresh(struct git_odb *db);
(define ~git_odb_refresh #f)
(define (git_odb_refresh db)
  (unless
    ~git_odb_refresh
    (set! ~git_odb_refresh
      (fh-link-proc
        "git_odb_refresh"
        ffi:int
        (list '*))))
  (let ((~db (unwrap~pointer db)))
    (~git_odb_refresh ~db)))
(export git_odb_refresh)

;; extern int git_odb_foreach(git_odb *db, git_odb_foreach_cb cb, void *payload
;;     );
(define ~git_odb_foreach #f)
(define (git_odb_foreach db cb payload)
  (unless
    ~git_odb_foreach
    (set! ~git_odb_foreach
      (fh-link-proc
        "git_odb_foreach"
        ffi:int
        (list '* '* '*))))
  (let ((~db (unwrap-git_odb* db))
        (~cb ((make-ftn-arg-unwrapper ffi:int (list '* '*))
              cb))
        (~payload (unwrap~pointer payload)))
    (~git_odb_foreach ~db ~cb ~payload)))
(export git_odb_foreach)

;; extern int git_odb_write(git_oid *out, git_odb *odb, const void *data, 
;;     size_t len, git_otype type);
(define ~git_odb_write #f)
(define (git_odb_write out odb data len type)
  (unless
    ~git_odb_write
    (set! ~git_odb_write
      (fh-link-proc
        "git_odb_write"
        ffi:int
        (list '* '* '* ffi:size_t ffi:int))))
  (let ((~out (unwrap-git_oid* out))
        (~odb (unwrap-git_odb* odb))
        (~data (unwrap~pointer data))
        (~len (unwrap~fixed len))
        (~type (unwrap~fixed type)))
    (~git_odb_write ~out ~odb ~data ~len ~type)))
(export git_odb_write)

;; extern int git_odb_open_wstream(git_odb_stream **out, git_odb *db, git_off_t
;;      size, git_otype type);
(define ~git_odb_open_wstream #f)
(define (git_odb_open_wstream out db size type)
  (unless
    ~git_odb_open_wstream
    (set! ~git_odb_open_wstream
      (fh-link-proc
        "git_odb_open_wstream"
        ffi:int
        (list '* '* ffi:int64 ffi:int))))
  (let ((~out (unwrap~pointer out))
        (~db (unwrap-git_odb* db))
        (~size (unwrap~fixed size))
        (~type (unwrap~fixed type)))
    (~git_odb_open_wstream ~out ~db ~size ~type)))
(export git_odb_open_wstream)

;; extern int git_odb_stream_write(git_odb_stream *stream, const char *buffer, 
;;     size_t len);
(define ~git_odb_stream_write #f)
(define (git_odb_stream_write stream buffer len)
  (unless
    ~git_odb_stream_write
    (set! ~git_odb_stream_write
      (fh-link-proc
        "git_odb_stream_write"
        ffi:int
        (list '* '* ffi:size_t))))
  (let ((~stream (unwrap-git_odb_stream* stream))
        (~buffer (unwrap~pointer buffer))
        (~len (unwrap~fixed len)))
    (~git_odb_stream_write ~stream ~buffer ~len)))
(export git_odb_stream_write)

;; extern int git_odb_stream_finalize_write(git_oid *out, git_odb_stream *
;;     stream);
(define ~git_odb_stream_finalize_write #f)
(define (git_odb_stream_finalize_write out stream)
  (unless
    ~git_odb_stream_finalize_write
    (set! ~git_odb_stream_finalize_write
      (fh-link-proc
        "git_odb_stream_finalize_write"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap-git_oid* out))
        (~stream (unwrap-git_odb_stream* stream)))
    (~git_odb_stream_finalize_write ~out ~stream)))
(export git_odb_stream_finalize_write)

;; extern int git_odb_stream_read(git_odb_stream *stream, char *buffer, size_t 
;;     len);
(define ~git_odb_stream_read #f)
(define (git_odb_stream_read stream buffer len)
  (unless
    ~git_odb_stream_read
    (set! ~git_odb_stream_read
      (fh-link-proc
        "git_odb_stream_read"
        ffi:int
        (list '* '* ffi:size_t))))
  (let ((~stream (unwrap-git_odb_stream* stream))
        (~buffer (unwrap~pointer buffer))
        (~len (unwrap~fixed len)))
    (~git_odb_stream_read ~stream ~buffer ~len)))
(export git_odb_stream_read)

;; extern void git_odb_stream_free(git_odb_stream *stream);
(define ~git_odb_stream_free #f)
(define (git_odb_stream_free stream)
  (unless
    ~git_odb_stream_free
    (set! ~git_odb_stream_free
      (fh-link-proc
        "git_odb_stream_free"
        ffi:void
        (list '*))))
  (let ((~stream (unwrap-git_odb_stream* stream)))
    (~git_odb_stream_free ~stream)))
(export git_odb_stream_free)

;; extern int git_odb_open_rstream(git_odb_stream **out, git_odb *db, const 
;;     git_oid *oid);
(define ~git_odb_open_rstream #f)
(define (git_odb_open_rstream out db oid)
  (unless
    ~git_odb_open_rstream
    (set! ~git_odb_open_rstream
      (fh-link-proc
        "git_odb_open_rstream"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~db (unwrap-git_odb* db))
        (~oid (unwrap-git_oid* oid)))
    (~git_odb_open_rstream ~out ~db ~oid)))
(export git_odb_open_rstream)

;; extern int git_odb_write_pack(git_odb_writepack **out, git_odb *db, 
;;     git_transfer_progress_cb progress_cb, void *progress_payload);
(define ~git_odb_write_pack #f)
(define (git_odb_write_pack
         out
         db
         progress_cb
         progress_payload)
  (unless
    ~git_odb_write_pack
    (set! ~git_odb_write_pack
      (fh-link-proc
        "git_odb_write_pack"
        ffi:int
        (list '* '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~db (unwrap-git_odb* db))
        (~progress_cb
          ((make-ftn-arg-unwrapper ffi:int (list '* '*))
           progress_cb))
        (~progress_payload
          (unwrap~pointer progress_payload)))
    (~git_odb_write_pack
      ~out
      ~db
      ~progress_cb
      ~progress_payload)))
(export git_odb_write_pack)

;; extern int git_odb_hash(git_oid *out, const void *data, size_t len, 
;;     git_otype type);
(define ~git_odb_hash #f)
(define (git_odb_hash out data len type)
  (unless
    ~git_odb_hash
    (set! ~git_odb_hash
      (fh-link-proc
        "git_odb_hash"
        ffi:int
        (list '* '* ffi:size_t ffi:int))))
  (let ((~out (unwrap-git_oid* out))
        (~data (unwrap~pointer data))
        (~len (unwrap~fixed len))
        (~type (unwrap~fixed type)))
    (~git_odb_hash ~out ~data ~len ~type)))
(export git_odb_hash)

;; extern int git_odb_hashfile(git_oid *out, const char *path, git_otype type)
;;     ;
(define ~git_odb_hashfile #f)
(define (git_odb_hashfile out path type)
  (unless
    ~git_odb_hashfile
    (set! ~git_odb_hashfile
      (fh-link-proc
        "git_odb_hashfile"
        ffi:int
        (list '* '* ffi:int))))
  (let ((~out (unwrap-git_oid* out))
        (~path (unwrap~pointer path))
        (~type (unwrap~fixed type)))
    (~git_odb_hashfile ~out ~path ~type)))
(export git_odb_hashfile)

;; extern int git_odb_object_dup(git_odb_object **dest, git_odb_object *source)
;;     ;
(define ~git_odb_object_dup #f)
(define (git_odb_object_dup dest source)
  (unless
    ~git_odb_object_dup
    (set! ~git_odb_object_dup
      (fh-link-proc
        "git_odb_object_dup"
        ffi:int
        (list '* '*))))
  (let ((~dest (unwrap~pointer dest))
        (~source (unwrap-git_odb_object* source)))
    (~git_odb_object_dup ~dest ~source)))
(export git_odb_object_dup)

;; extern void git_odb_object_free(git_odb_object *object);
(define ~git_odb_object_free #f)
(define (git_odb_object_free object)
  (unless
    ~git_odb_object_free
    (set! ~git_odb_object_free
      (fh-link-proc
        "git_odb_object_free"
        ffi:void
        (list '*))))
  (let ((~object (unwrap-git_odb_object* object)))
    (~git_odb_object_free ~object)))
(export git_odb_object_free)

;; extern const git_oid *git_odb_object_id(git_odb_object *object);
(define ~git_odb_object_id #f)
(define (git_odb_object_id object)
  (unless
    ~git_odb_object_id
    (set! ~git_odb_object_id
      (fh-link-proc "git_odb_object_id" '* (list '*))))
  (let ((~object (unwrap-git_odb_object* object)))
    (wrap-git_oid* (~git_odb_object_id ~object))))
(export git_odb_object_id)

;; extern const void *git_odb_object_data(git_odb_object *object);
(define ~git_odb_object_data #f)
(define (git_odb_object_data object)
  (unless
    ~git_odb_object_data
    (set! ~git_odb_object_data
      (fh-link-proc "git_odb_object_data" '* (list '*))))
  (let ((~object (unwrap-git_odb_object* object)))
    (~git_odb_object_data ~object)))
(export git_odb_object_data)

;; extern size_t git_odb_object_size(git_odb_object *object);
(define ~git_odb_object_size #f)
(define (git_odb_object_size object)
  (unless
    ~git_odb_object_size
    (set! ~git_odb_object_size
      (fh-link-proc
        "git_odb_object_size"
        ffi:size_t
        (list '*))))
  (let ((~object (unwrap-git_odb_object* object)))
    (~git_odb_object_size ~object)))
(export git_odb_object_size)

;; extern git_otype git_odb_object_type(git_odb_object *object);
(define ~git_odb_object_type #f)
(define (git_odb_object_type object)
  (unless
    ~git_odb_object_type
    (set! ~git_odb_object_type
      (fh-link-proc
        "git_odb_object_type"
        ffi:int
        (list '*))))
  (let ((~object (unwrap-git_odb_object* object)))
    (~git_odb_object_type ~object)))
(export git_odb_object_type)

;; extern int git_odb_add_backend(git_odb *odb, git_odb_backend *backend, int 
;;     priority);
(define ~git_odb_add_backend #f)
(define (git_odb_add_backend odb backend priority)
  (unless
    ~git_odb_add_backend
    (set! ~git_odb_add_backend
      (fh-link-proc
        "git_odb_add_backend"
        ffi:int
        (list '* '* ffi:int))))
  (let ((~odb (unwrap-git_odb* odb))
        (~backend (unwrap-git_odb_backend* backend))
        (~priority (unwrap~fixed priority)))
    (~git_odb_add_backend ~odb ~backend ~priority)))
(export git_odb_add_backend)

;; extern int git_odb_add_alternate(git_odb *odb, git_odb_backend *backend, int
;;      priority);
(define ~git_odb_add_alternate #f)
(define (git_odb_add_alternate odb backend priority)
  (unless
    ~git_odb_add_alternate
    (set! ~git_odb_add_alternate
      (fh-link-proc
        "git_odb_add_alternate"
        ffi:int
        (list '* '* ffi:int))))
  (let ((~odb (unwrap-git_odb* odb))
        (~backend (unwrap-git_odb_backend* backend))
        (~priority (unwrap~fixed priority)))
    (~git_odb_add_alternate ~odb ~backend ~priority)))
(export git_odb_add_alternate)

;; extern size_t git_odb_num_backends(git_odb *odb);
(define ~git_odb_num_backends #f)
(define (git_odb_num_backends odb)
  (unless
    ~git_odb_num_backends
    (set! ~git_odb_num_backends
      (fh-link-proc
        "git_odb_num_backends"
        ffi:size_t
        (list '*))))
  (let ((~odb (unwrap-git_odb* odb)))
    (~git_odb_num_backends ~odb)))
(export git_odb_num_backends)

;; extern int git_odb_get_backend(git_odb_backend **out, git_odb *odb, size_t 
;;     pos);
(define ~git_odb_get_backend #f)
(define (git_odb_get_backend out odb pos)
  (unless
    ~git_odb_get_backend
    (set! ~git_odb_get_backend
      (fh-link-proc
        "git_odb_get_backend"
        ffi:int
        (list '* '* ffi:size_t))))
  (let ((~out (unwrap~pointer out))
        (~odb (unwrap-git_odb* odb))
        (~pos (unwrap~fixed pos)))
    (~git_odb_get_backend ~out ~odb ~pos)))
(export git_odb_get_backend)

;; extern int git_odb_backend_pack(git_odb_backend **out, const char *
;;     objects_dir);
(define ~git_odb_backend_pack #f)
(define (git_odb_backend_pack out objects_dir)
  (unless
    ~git_odb_backend_pack
    (set! ~git_odb_backend_pack
      (fh-link-proc
        "git_odb_backend_pack"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~objects_dir (unwrap~pointer objects_dir)))
    (~git_odb_backend_pack ~out ~objects_dir)))
(export git_odb_backend_pack)

;; extern int git_odb_backend_loose(git_odb_backend **out, const char *
;;     objects_dir, int compression_level, int do_fsync, unsigned int dir_mode
;;     , unsigned int file_mode);
(define ~git_odb_backend_loose #f)
(define (git_odb_backend_loose
         out
         objects_dir
         compression_level
         do_fsync
         dir_mode
         file_mode)
  (unless
    ~git_odb_backend_loose
    (set! ~git_odb_backend_loose
      (fh-link-proc
        "git_odb_backend_loose"
        ffi:int
        (list '*
              '*
              ffi:int
              ffi:int
              ffi:unsigned-int
              ffi:unsigned-int))))
  (let ((~out (unwrap~pointer out))
        (~objects_dir (unwrap~pointer objects_dir))
        (~compression_level
          (unwrap~fixed compression_level))
        (~do_fsync (unwrap~fixed do_fsync))
        (~dir_mode (unwrap~fixed dir_mode))
        (~file_mode (unwrap~fixed file_mode)))
    (~git_odb_backend_loose
      ~out
      ~objects_dir
      ~compression_level
      ~do_fsync
      ~dir_mode
      ~file_mode)))
(export git_odb_backend_loose)

;; extern int git_odb_backend_one_pack(git_odb_backend **out, const char *
;;     index_file);
(define ~git_odb_backend_one_pack #f)
(define (git_odb_backend_one_pack out index_file)
  (unless
    ~git_odb_backend_one_pack
    (set! ~git_odb_backend_one_pack
      (fh-link-proc
        "git_odb_backend_one_pack"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~index_file (unwrap~pointer index_file)))
    (~git_odb_backend_one_pack ~out ~index_file)))
(export git_odb_backend_one_pack)

;; typedef enum {
;;   GIT_STREAM_RDONLY = 1<<1,
;;   GIT_STREAM_WRONLY = 1<<2,
;;   GIT_STREAM_RW = GIT_STREAM_RDONLY | GIT_STREAM_WRONLY,
;; } git_odb_stream_t;
(define-fh-enum git_odb_stream_t
  '((GIT_STREAM_RDONLY . 2)
    (GIT_STREAM_WRONLY . 4)
    (GIT_STREAM_RW . 6))
  )

;; struct git_odb_stream {
;;   git_odb_backend *backend;
;;   unsigned int mode;
;;   void *hash_ctx;
;;   git_off_t declared_size;
;;   git_off_t received_bytes;
;;   /**
;;    * Write at most `len` bytes into `buffer` and advance the stream.
;;    */
;;   int (*read)(git_odb_stream *stream, char *buffer, size_t len);
;;   /**
;;    * Write `len` bytes from `buffer` into the stream.
;;    */
;;   int (*write)(git_odb_stream *stream, const char *buffer, size_t len);
;;   /**
;;    * Store the contents of the stream as an object with the id
;;    * specified in `oid`.
;;    *
;;    * This method might not be invoked if:
;;    * - an error occurs earlier with the `write` callback,
;;    * - the object referred to by `oid` already exists in any backend, or
;;    * - the final number of received bytes differs from the size declared
;;    *   with `git_odb_open_wstream()`
;;    */
;;   int (*finalize_write)(git_odb_stream *stream, const git_oid *oid);
;;   /**
;;    * Free the stream's memory.
;;    *
;;    * This method might be called without a call to `finalize_write` if
;;    * an error occurs or if the object is already present in the ODB.
;;    */
;;   void (*free)(git_odb_stream *stream);
;; };
(define struct-git_odb_stream-desc
  (bs:struct
    (list `(backend
             ,(bs:pointer (delay git_odb_backend*-desc)))
          `(mode ,unsigned-int)
          `(hash_ctx ,(bs:pointer void))
          `(declared_size ,int32)
          `(received_bytes ,int32)
          `(read ,(bs:pointer void))
          `(write ,(bs:pointer void))
          `(finalize_write ,(bs:pointer void))
          `(free ,(bs:pointer void)))))
(export struct-git_odb_stream-desc)
(define-fh-compound-type/p struct-git_odb_stream struct-git_odb_stream-desc)
(set! git_odb_stream-desc struct-git_odb_stream-desc)
(define-fh-compound-type git_odb_stream git_odb_stream-desc)

;; struct git_odb_writepack {
;;   git_odb_backend *backend;
;;   int (*append)(git_odb_writepack *writepack, const void *data, size_t size
;;       , git_transfer_progress *stats);
;;   int (*commit)(git_odb_writepack *writepack, git_transfer_progress *stats)
;;       ;
;;   void (*free)(git_odb_writepack *writepack);
;; };
(define struct-git_odb_writepack-desc
  (bs:struct
    (list `(backend
             ,(bs:pointer (delay git_odb_backend*-desc)))
          `(append ,(bs:pointer void))
          `(commit ,(bs:pointer void))
          `(free ,(bs:pointer void)))))
(export struct-git_odb_writepack-desc)
(define-fh-compound-type/p struct-git_odb_writepack struct-git_odb_writepack-desc)
(set! git_odb_writepack-desc struct-git_odb_writepack-desc)
(define-fh-compound-type git_odb_writepack git_odb_writepack-desc)

;; typedef struct git_patch git_patch;
(define git_patch-desc void)
(export git_patch-desc)
(define git_patch*-desc (bs:pointer git_patch-desc))
(export git_patch*-desc)
(define-fh-pointer-type git_patch* git_patch*-desc)

;; extern int git_patch_from_diff(git_patch **out, git_diff *diff, size_t idx)
;;     ;
(define ~git_patch_from_diff #f)
(define (git_patch_from_diff out diff idx)
  (unless
    ~git_patch_from_diff
    (set! ~git_patch_from_diff
      (fh-link-proc
        "git_patch_from_diff"
        ffi:int
        (list '* '* ffi:size_t))))
  (let ((~out (unwrap~pointer out))
        (~diff (unwrap-git_diff* diff))
        (~idx (unwrap~fixed idx)))
    (~git_patch_from_diff ~out ~diff ~idx)))
(export git_patch_from_diff)

;; extern int git_patch_from_blobs(git_patch **out, const git_blob *old_blob, 
;;     const char *old_as_path, const git_blob *new_blob, const char *
;;     new_as_path, const git_diff_options *opts);
(define ~git_patch_from_blobs #f)
(define (git_patch_from_blobs
         out
         old_blob
         old_as_path
         new_blob
         new_as_path
         opts)
  (unless
    ~git_patch_from_blobs
    (set! ~git_patch_from_blobs
      (fh-link-proc
        "git_patch_from_blobs"
        ffi:int
        (list '* '* '* '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~old_blob (unwrap-git_blob* old_blob))
        (~old_as_path (unwrap~pointer old_as_path))
        (~new_blob (unwrap-git_blob* new_blob))
        (~new_as_path (unwrap~pointer new_as_path))
        (~opts (unwrap-git_diff_options* opts)))
    (~git_patch_from_blobs
      ~out
      ~old_blob
      ~old_as_path
      ~new_blob
      ~new_as_path
      ~opts)))
(export git_patch_from_blobs)

;; extern int git_patch_from_blob_and_buffer(git_patch **out, const git_blob *
;;     old_blob, const char *old_as_path, const char *buffer, size_t buffer_len
;;     , const char *buffer_as_path, const git_diff_options *opts);
(define ~git_patch_from_blob_and_buffer #f)
(define (git_patch_from_blob_and_buffer
         out
         old_blob
         old_as_path
         buffer
         buffer_len
         buffer_as_path
         opts)
  (unless
    ~git_patch_from_blob_and_buffer
    (set! ~git_patch_from_blob_and_buffer
      (fh-link-proc
        "git_patch_from_blob_and_buffer"
        ffi:int
        (list '* '* '* '* ffi:size_t '* '*))))
  (let ((~out (unwrap~pointer out))
        (~old_blob (unwrap-git_blob* old_blob))
        (~old_as_path (unwrap~pointer old_as_path))
        (~buffer (unwrap~pointer buffer))
        (~buffer_len (unwrap~fixed buffer_len))
        (~buffer_as_path (unwrap~pointer buffer_as_path))
        (~opts (unwrap-git_diff_options* opts)))
    (~git_patch_from_blob_and_buffer
      ~out
      ~old_blob
      ~old_as_path
      ~buffer
      ~buffer_len
      ~buffer_as_path
      ~opts)))
(export git_patch_from_blob_and_buffer)

;; extern int git_patch_from_buffers(git_patch **out, const void *old_buffer, 
;;     size_t old_len, const char *old_as_path, const char *new_buffer, size_t 
;;     new_len, const char *new_as_path, const git_diff_options *opts);
(define ~git_patch_from_buffers #f)
(define (git_patch_from_buffers
         out
         old_buffer
         old_len
         old_as_path
         new_buffer
         new_len
         new_as_path
         opts)
  (unless
    ~git_patch_from_buffers
    (set! ~git_patch_from_buffers
      (fh-link-proc
        "git_patch_from_buffers"
        ffi:int
        (list '* '* ffi:size_t '* '* ffi:size_t '* '*))))
  (let ((~out (unwrap~pointer out))
        (~old_buffer (unwrap~pointer old_buffer))
        (~old_len (unwrap~fixed old_len))
        (~old_as_path (unwrap~pointer old_as_path))
        (~new_buffer (unwrap~pointer new_buffer))
        (~new_len (unwrap~fixed new_len))
        (~new_as_path (unwrap~pointer new_as_path))
        (~opts (unwrap-git_diff_options* opts)))
    (~git_patch_from_buffers
      ~out
      ~old_buffer
      ~old_len
      ~old_as_path
      ~new_buffer
      ~new_len
      ~new_as_path
      ~opts)))
(export git_patch_from_buffers)

;; extern void git_patch_free(git_patch *patch);
(define ~git_patch_free #f)
(define (git_patch_free patch)
  (unless
    ~git_patch_free
    (set! ~git_patch_free
      (fh-link-proc
        "git_patch_free"
        ffi:void
        (list '*))))
  (let ((~patch (unwrap-git_patch* patch)))
    (~git_patch_free ~patch)))
(export git_patch_free)

;; extern const git_diff_delta *git_patch_get_delta(const git_patch *patch);
(define ~git_patch_get_delta #f)
(define (git_patch_get_delta patch)
  (unless
    ~git_patch_get_delta
    (set! ~git_patch_get_delta
      (fh-link-proc "git_patch_get_delta" '* (list '*))))
  (let ((~patch (unwrap-git_patch* patch)))
    (wrap-git_diff_delta*
      (~git_patch_get_delta ~patch))))
(export git_patch_get_delta)

;; extern size_t git_patch_num_hunks(const git_patch *patch);
(define ~git_patch_num_hunks #f)
(define (git_patch_num_hunks patch)
  (unless
    ~git_patch_num_hunks
    (set! ~git_patch_num_hunks
      (fh-link-proc
        "git_patch_num_hunks"
        ffi:size_t
        (list '*))))
  (let ((~patch (unwrap-git_patch* patch)))
    (~git_patch_num_hunks ~patch)))
(export git_patch_num_hunks)

;; extern int git_patch_line_stats(size_t *total_context, size_t *
;;     total_additions, size_t *total_deletions, const git_patch *patch);
(define ~git_patch_line_stats #f)
(define (git_patch_line_stats
         total_context
         total_additions
         total_deletions
         patch)
  (unless
    ~git_patch_line_stats
    (set! ~git_patch_line_stats
      (fh-link-proc
        "git_patch_line_stats"
        ffi:int
        (list '* '* '* '*))))
  (let ((~total_context (unwrap~pointer total_context))
        (~total_additions
          (unwrap~pointer total_additions))
        (~total_deletions
          (unwrap~pointer total_deletions))
        (~patch (unwrap-git_patch* patch)))
    (~git_patch_line_stats
      ~total_context
      ~total_additions
      ~total_deletions
      ~patch)))
(export git_patch_line_stats)

;; extern int git_patch_get_hunk(const git_diff_hunk **out, size_t *
;;     lines_in_hunk, git_patch *patch, size_t hunk_idx);
(define ~git_patch_get_hunk #f)
(define (git_patch_get_hunk
         out
         lines_in_hunk
         patch
         hunk_idx)
  (unless
    ~git_patch_get_hunk
    (set! ~git_patch_get_hunk
      (fh-link-proc
        "git_patch_get_hunk"
        ffi:int
        (list '* '* '* ffi:size_t))))
  (let ((~out (unwrap~pointer out))
        (~lines_in_hunk (unwrap~pointer lines_in_hunk))
        (~patch (unwrap-git_patch* patch))
        (~hunk_idx (unwrap~fixed hunk_idx)))
    (~git_patch_get_hunk
      ~out
      ~lines_in_hunk
      ~patch
      ~hunk_idx)))
(export git_patch_get_hunk)

;; extern int git_patch_num_lines_in_hunk(const git_patch *patch, size_t 
;;     hunk_idx);
(define ~git_patch_num_lines_in_hunk #f)
(define (git_patch_num_lines_in_hunk patch hunk_idx)
  (unless
    ~git_patch_num_lines_in_hunk
    (set! ~git_patch_num_lines_in_hunk
      (fh-link-proc
        "git_patch_num_lines_in_hunk"
        ffi:int
        (list '* ffi:size_t))))
  (let ((~patch (unwrap-git_patch* patch))
        (~hunk_idx (unwrap~fixed hunk_idx)))
    (~git_patch_num_lines_in_hunk ~patch ~hunk_idx)))
(export git_patch_num_lines_in_hunk)

;; extern int git_patch_get_line_in_hunk(const git_diff_line **out, git_patch *
;;     patch, size_t hunk_idx, size_t line_of_hunk);
(define ~git_patch_get_line_in_hunk #f)
(define (git_patch_get_line_in_hunk
         out
         patch
         hunk_idx
         line_of_hunk)
  (unless
    ~git_patch_get_line_in_hunk
    (set! ~git_patch_get_line_in_hunk
      (fh-link-proc
        "git_patch_get_line_in_hunk"
        ffi:int
        (list '* '* ffi:size_t ffi:size_t))))
  (let ((~out (unwrap~pointer out))
        (~patch (unwrap-git_patch* patch))
        (~hunk_idx (unwrap~fixed hunk_idx))
        (~line_of_hunk (unwrap~fixed line_of_hunk)))
    (~git_patch_get_line_in_hunk
      ~out
      ~patch
      ~hunk_idx
      ~line_of_hunk)))
(export git_patch_get_line_in_hunk)

;; extern size_t git_patch_size(git_patch *patch, int include_context, int 
;;     include_hunk_headers, int include_file_headers);
(define ~git_patch_size #f)
(define (git_patch_size
         patch
         include_context
         include_hunk_headers
         include_file_headers)
  (unless
    ~git_patch_size
    (set! ~git_patch_size
      (fh-link-proc
        "git_patch_size"
        ffi:size_t
        (list '* ffi:int ffi:int ffi:int))))
  (let ((~patch (unwrap-git_patch* patch))
        (~include_context (unwrap~fixed include_context))
        (~include_hunk_headers
          (unwrap~fixed include_hunk_headers))
        (~include_file_headers
          (unwrap~fixed include_file_headers)))
    (~git_patch_size
      ~patch
      ~include_context
      ~include_hunk_headers
      ~include_file_headers)))
(export git_patch_size)

;; extern int git_patch_print(git_patch *patch, git_diff_line_cb print_cb, void
;;      *payload);
(define ~git_patch_print #f)
(define (git_patch_print patch print_cb payload)
  (unless
    ~git_patch_print
    (set! ~git_patch_print
      (fh-link-proc
        "git_patch_print"
        ffi:int
        (list '* '* '*))))
  (let ((~patch (unwrap-git_patch* patch))
        (~print_cb
          ((make-ftn-arg-unwrapper
             ffi:int
             (list '* '* '* '*))
           print_cb))
        (~payload (unwrap~pointer payload)))
    (~git_patch_print ~patch ~print_cb ~payload)))
(export git_patch_print)

;; extern int git_patch_to_buf(git_buf *out, git_patch *patch);
(define ~git_patch_to_buf #f)
(define (git_patch_to_buf out patch)
  (unless
    ~git_patch_to_buf
    (set! ~git_patch_to_buf
      (fh-link-proc
        "git_patch_to_buf"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap-git_buf* out))
        (~patch (unwrap-git_patch* patch)))
    (~git_patch_to_buf ~out ~patch)))
(export git_patch_to_buf)

;; typedef struct git_pathspec git_pathspec;
(define git_pathspec-desc void)
(export git_pathspec-desc)
(define git_pathspec*-desc (bs:pointer git_pathspec-desc))
(export git_pathspec*-desc)
(define-fh-pointer-type git_pathspec* git_pathspec*-desc)

;; typedef struct git_pathspec_match_list git_pathspec_match_list;
(define git_pathspec_match_list-desc void)
(export git_pathspec_match_list-desc)
(define git_pathspec_match_list*-desc (bs:pointer git_pathspec_match_list-desc))
(export git_pathspec_match_list*-desc)
(define-fh-pointer-type git_pathspec_match_list* git_pathspec_match_list*-desc)

;; typedef enum {
;;   GIT_PATHSPEC_DEFAULT = 0,
;;   GIT_PATHSPEC_IGNORE_CASE = 1u<<0,
;;   GIT_PATHSPEC_USE_CASE = 1u<<1,
;;   GIT_PATHSPEC_NO_GLOB = 1u<<2,
;;   GIT_PATHSPEC_NO_MATCH_ERROR = 1u<<3,
;;   GIT_PATHSPEC_FIND_FAILURES = 1u<<4,
;;   GIT_PATHSPEC_FAILURES_ONLY = 1u<<5,
;; } git_pathspec_flag_t;
(define-fh-enum git_pathspec_flag_t
  '((GIT_PATHSPEC_DEFAULT . 0)
    (GIT_PATHSPEC_IGNORE_CASE . 1)
    (GIT_PATHSPEC_USE_CASE . 2)
    (GIT_PATHSPEC_NO_GLOB . 4)
    (GIT_PATHSPEC_NO_MATCH_ERROR . 8)
    (GIT_PATHSPEC_FIND_FAILURES . 16)
    (GIT_PATHSPEC_FAILURES_ONLY . 32))
  )

;; extern int git_pathspec_new(git_pathspec **out, const git_strarray *pathspec
;;     );
(define ~git_pathspec_new #f)
(define (git_pathspec_new out pathspec)
  (unless
    ~git_pathspec_new
    (set! ~git_pathspec_new
      (fh-link-proc
        "git_pathspec_new"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~pathspec (unwrap-git_strarray* pathspec)))
    (~git_pathspec_new ~out ~pathspec)))
(export git_pathspec_new)

;; extern void git_pathspec_free(git_pathspec *ps);
(define ~git_pathspec_free #f)
(define (git_pathspec_free ps)
  (unless
    ~git_pathspec_free
    (set! ~git_pathspec_free
      (fh-link-proc
        "git_pathspec_free"
        ffi:void
        (list '*))))
  (let ((~ps (unwrap-git_pathspec* ps)))
    (~git_pathspec_free ~ps)))
(export git_pathspec_free)

;; extern int git_pathspec_matches_path(const git_pathspec *ps, uint32_t flags
;;     , const char *path);
(define ~git_pathspec_matches_path #f)
(define (git_pathspec_matches_path ps flags path)
  (unless
    ~git_pathspec_matches_path
    (set! ~git_pathspec_matches_path
      (fh-link-proc
        "git_pathspec_matches_path"
        ffi:int
        (list '* ffi:uint32 '*))))
  (let ((~ps (unwrap-git_pathspec* ps))
        (~flags (unwrap~fixed flags))
        (~path (unwrap~pointer path)))
    (~git_pathspec_matches_path ~ps ~flags ~path)))
(export git_pathspec_matches_path)

;; extern int git_pathspec_match_workdir(git_pathspec_match_list **out, 
;;     git_repository *repo, uint32_t flags, git_pathspec *ps);
(define ~git_pathspec_match_workdir #f)
(define (git_pathspec_match_workdir out repo flags ps)
  (unless
    ~git_pathspec_match_workdir
    (set! ~git_pathspec_match_workdir
      (fh-link-proc
        "git_pathspec_match_workdir"
        ffi:int
        (list '* '* ffi:uint32 '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo))
        (~flags (unwrap~fixed flags))
        (~ps (unwrap-git_pathspec* ps)))
    (~git_pathspec_match_workdir
      ~out
      ~repo
      ~flags
      ~ps)))
(export git_pathspec_match_workdir)

;; extern int git_pathspec_match_index(git_pathspec_match_list **out, git_index
;;      *index, uint32_t flags, git_pathspec *ps);
(define ~git_pathspec_match_index #f)
(define (git_pathspec_match_index out index flags ps)
  (unless
    ~git_pathspec_match_index
    (set! ~git_pathspec_match_index
      (fh-link-proc
        "git_pathspec_match_index"
        ffi:int
        (list '* '* ffi:uint32 '*))))
  (let ((~out (unwrap~pointer out))
        (~index (unwrap-git_index* index))
        (~flags (unwrap~fixed flags))
        (~ps (unwrap-git_pathspec* ps)))
    (~git_pathspec_match_index
      ~out
      ~index
      ~flags
      ~ps)))
(export git_pathspec_match_index)

;; extern int git_pathspec_match_tree(git_pathspec_match_list **out, git_tree *
;;     tree, uint32_t flags, git_pathspec *ps);
(define ~git_pathspec_match_tree #f)
(define (git_pathspec_match_tree out tree flags ps)
  (unless
    ~git_pathspec_match_tree
    (set! ~git_pathspec_match_tree
      (fh-link-proc
        "git_pathspec_match_tree"
        ffi:int
        (list '* '* ffi:uint32 '*))))
  (let ((~out (unwrap~pointer out))
        (~tree (unwrap-git_tree* tree))
        (~flags (unwrap~fixed flags))
        (~ps (unwrap-git_pathspec* ps)))
    (~git_pathspec_match_tree ~out ~tree ~flags ~ps)))
(export git_pathspec_match_tree)

;; extern int git_pathspec_match_diff(git_pathspec_match_list **out, git_diff *
;;     diff, uint32_t flags, git_pathspec *ps);
(define ~git_pathspec_match_diff #f)
(define (git_pathspec_match_diff out diff flags ps)
  (unless
    ~git_pathspec_match_diff
    (set! ~git_pathspec_match_diff
      (fh-link-proc
        "git_pathspec_match_diff"
        ffi:int
        (list '* '* ffi:uint32 '*))))
  (let ((~out (unwrap~pointer out))
        (~diff (unwrap-git_diff* diff))
        (~flags (unwrap~fixed flags))
        (~ps (unwrap-git_pathspec* ps)))
    (~git_pathspec_match_diff ~out ~diff ~flags ~ps)))
(export git_pathspec_match_diff)

;; extern void git_pathspec_match_list_free(git_pathspec_match_list *m);
(define ~git_pathspec_match_list_free #f)
(define (git_pathspec_match_list_free m)
  (unless
    ~git_pathspec_match_list_free
    (set! ~git_pathspec_match_list_free
      (fh-link-proc
        "git_pathspec_match_list_free"
        ffi:void
        (list '*))))
  (let ((~m (unwrap-git_pathspec_match_list* m)))
    (~git_pathspec_match_list_free ~m)))
(export git_pathspec_match_list_free)

;; extern size_t git_pathspec_match_list_entrycount(const 
;;     git_pathspec_match_list *m);
(define ~git_pathspec_match_list_entrycount #f)
(define (git_pathspec_match_list_entrycount m)
  (unless
    ~git_pathspec_match_list_entrycount
    (set! ~git_pathspec_match_list_entrycount
      (fh-link-proc
        "git_pathspec_match_list_entrycount"
        ffi:size_t
        (list '*))))
  (let ((~m (unwrap-git_pathspec_match_list* m)))
    (~git_pathspec_match_list_entrycount ~m)))
(export git_pathspec_match_list_entrycount)

;; extern const char *git_pathspec_match_list_entry(const 
;;     git_pathspec_match_list *m, size_t pos);
(define ~git_pathspec_match_list_entry #f)
(define (git_pathspec_match_list_entry m pos)
  (unless
    ~git_pathspec_match_list_entry
    (set! ~git_pathspec_match_list_entry
      (fh-link-proc
        "git_pathspec_match_list_entry"
        '*
        (list '* ffi:size_t))))
  (let ((~m (unwrap-git_pathspec_match_list* m))
        (~pos (unwrap~fixed pos)))
    (~git_pathspec_match_list_entry ~m ~pos)))
(export git_pathspec_match_list_entry)

;; extern const git_diff_delta *git_pathspec_match_list_diff_entry(const 
;;     git_pathspec_match_list *m, size_t pos);
(define ~git_pathspec_match_list_diff_entry #f)
(define (git_pathspec_match_list_diff_entry m pos)
  (unless
    ~git_pathspec_match_list_diff_entry
    (set! ~git_pathspec_match_list_diff_entry
      (fh-link-proc
        "git_pathspec_match_list_diff_entry"
        '*
        (list '* ffi:size_t))))
  (let ((~m (unwrap-git_pathspec_match_list* m))
        (~pos (unwrap~fixed pos)))
    (wrap-git_diff_delta*
      (~git_pathspec_match_list_diff_entry ~m ~pos))))
(export git_pathspec_match_list_diff_entry)

;; extern size_t git_pathspec_match_list_failed_entrycount(const 
;;     git_pathspec_match_list *m);
(define ~git_pathspec_match_list_failed_entrycount #f)
(define (git_pathspec_match_list_failed_entrycount m)
  (unless
    ~git_pathspec_match_list_failed_entrycount
    (set! ~git_pathspec_match_list_failed_entrycount
      (fh-link-proc
        "git_pathspec_match_list_failed_entrycount"
        ffi:size_t
        (list '*))))
  (let ((~m (unwrap-git_pathspec_match_list* m)))
    (~git_pathspec_match_list_failed_entrycount ~m)))
(export git_pathspec_match_list_failed_entrycount)

;; extern const char *git_pathspec_match_list_failed_entry(const 
;;     git_pathspec_match_list *m, size_t pos);
(define ~git_pathspec_match_list_failed_entry #f)
(define (git_pathspec_match_list_failed_entry m pos)
  (unless
    ~git_pathspec_match_list_failed_entry
    (set! ~git_pathspec_match_list_failed_entry
      (fh-link-proc
        "git_pathspec_match_list_failed_entry"
        '*
        (list '* ffi:size_t))))
  (let ((~m (unwrap-git_pathspec_match_list* m))
        (~pos (unwrap~fixed pos)))
    (~git_pathspec_match_list_failed_entry ~m ~pos)))
(export git_pathspec_match_list_failed_entry)

;; typedef struct {
;;   unsigned int version;
;;   /**
;;    * Used by `git_rebase_init`, this will instruct other clients working
;;    * on this rebase that you want a quiet rebase experience, which they
;;    * may choose to provide in an application-specific manner.  This has no
;;    * effect upon libgit2 directly, but is provided for interoperability
;;    * between Git tools.
;;    */
;;   int quiet;
;;   /**
;;    * Used by `git_rebase_init`, this will begin an in-memory rebase,
;;    * which will allow callers to step through the rebase operations and
;;    * commit the rebased changes, but will not rewind HEAD or update the
;;    * repository to be in a rebasing state.  This will not interfere with
;;    * the working directory (if there is one).
;;    */
;;   int inmemory;
;;   /**
;;    * Used by `git_rebase_finish`, this is the name of the notes reference
;;    * used to rewrite notes for rebased commits when finishing the rebase;
;;    * if NULL, the contents of the configuration option `notes.rewriteRef`
;;    * is examined, unless the configuration option `notes.rewrite.rebase`
;;    * is set to false.  If `notes.rewriteRef` is also NULL, notes will
;;    * not be rewritten.
;;    */
;;   const char *rewrite_notes_ref;
;;   /**
;;    * Options to control how trees are merged during `git_rebase_next`.
;;    */
;;   git_merge_options merge_options;
;;   /**
;;    * Options to control how files are written during `git_rebase_init`,
;;    * `git_rebase_next` and `git_rebase_abort`.  Note that a minimum
;;    * strategy of `GIT_CHECKOUT_SAFE` is defaulted in `init` and `next`,
;;    * and a minimum strategy of `GIT_CHECKOUT_FORCE` is defaulted in
;;    * `abort` to match git semantics.
;;    */
;;   git_checkout_options checkout_options;
;; } git_rebase_options;
(define git_rebase_options-desc
  (bs:struct
    (list `(version ,unsigned-int)
          `(quiet ,int)
          `(inmemory ,int)
          `(rewrite_notes_ref ,(bs:pointer int))
          `(merge_options ,git_merge_options-desc)
          `(checkout_options ,git_checkout_options-desc))))
(export git_rebase_options-desc)
(define-fh-compound-type/p git_rebase_options git_rebase_options-desc)

;; typedef enum {
;;   GIT_REBASE_OPERATION_PICK = 0,
;;   GIT_REBASE_OPERATION_REWORD,
;;   GIT_REBASE_OPERATION_EDIT,
;;   GIT_REBASE_OPERATION_SQUASH,
;;   GIT_REBASE_OPERATION_FIXUP,
;;   GIT_REBASE_OPERATION_EXEC,
;; } git_rebase_operation_t;
(define-fh-enum git_rebase_operation_t
  '((GIT_REBASE_OPERATION_PICK . 0)
    (GIT_REBASE_OPERATION_REWORD . 1)
    (GIT_REBASE_OPERATION_EDIT . 2)
    (GIT_REBASE_OPERATION_SQUASH . 3)
    (GIT_REBASE_OPERATION_FIXUP . 4)
    (GIT_REBASE_OPERATION_EXEC . 5))
  )

;; typedef struct {
;;   /** The type of rebase operation. */
;;   git_rebase_operation_t type;
;;   /**
;;    * The commit ID being cherry-picked.  This will be populated for
;;    * all operations except those of type `GIT_REBASE_OPERATION_EXEC`.
;;    */
;;   const git_oid id;
;;   /**
;;    * The executable the user has requested be run.  This will only
;;    * be populated for operations of type `GIT_REBASE_OPERATION_EXEC`.
;;    */
;;   const char *exec;
;; } git_rebase_operation;
(define git_rebase_operation-desc
  (bs:struct
    (list `(type ,int)
          `(id ,git_oid-desc)
          `(exec ,(bs:pointer int)))))
(export git_rebase_operation-desc)
(define-fh-compound-type/p git_rebase_operation git_rebase_operation-desc)

;; extern int git_rebase_init_options(git_rebase_options *opts, unsigned int 
;;     version);
(define ~git_rebase_init_options #f)
(define (git_rebase_init_options opts version)
  (unless
    ~git_rebase_init_options
    (set! ~git_rebase_init_options
      (fh-link-proc
        "git_rebase_init_options"
        ffi:int
        (list '* ffi:unsigned-int))))
  (let ((~opts (unwrap-git_rebase_options* opts))
        (~version (unwrap~fixed version)))
    (~git_rebase_init_options ~opts ~version)))
(export git_rebase_init_options)

;; extern int git_rebase_init(git_rebase **out, git_repository *repo, const 
;;     git_annotated_commit *branch, const git_annotated_commit *upstream, 
;;     const git_annotated_commit *onto, const git_rebase_options *opts);
(define ~git_rebase_init #f)
(define (git_rebase_init
         out
         repo
         branch
         upstream
         onto
         opts)
  (unless
    ~git_rebase_init
    (set! ~git_rebase_init
      (fh-link-proc
        "git_rebase_init"
        ffi:int
        (list '* '* '* '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo))
        (~branch (unwrap-git_annotated_commit* branch))
        (~upstream
          (unwrap-git_annotated_commit* upstream))
        (~onto (unwrap-git_annotated_commit* onto))
        (~opts (unwrap-git_rebase_options* opts)))
    (~git_rebase_init
      ~out
      ~repo
      ~branch
      ~upstream
      ~onto
      ~opts)))
(export git_rebase_init)

;; extern int git_rebase_open(git_rebase **out, git_repository *repo, const 
;;     git_rebase_options *opts);
(define ~git_rebase_open #f)
(define (git_rebase_open out repo opts)
  (unless
    ~git_rebase_open
    (set! ~git_rebase_open
      (fh-link-proc
        "git_rebase_open"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo))
        (~opts (unwrap-git_rebase_options* opts)))
    (~git_rebase_open ~out ~repo ~opts)))
(export git_rebase_open)

;; extern size_t git_rebase_operation_entrycount(git_rebase *rebase);
(define ~git_rebase_operation_entrycount #f)
(define (git_rebase_operation_entrycount rebase)
  (unless
    ~git_rebase_operation_entrycount
    (set! ~git_rebase_operation_entrycount
      (fh-link-proc
        "git_rebase_operation_entrycount"
        ffi:size_t
        (list '*))))
  (let ((~rebase (unwrap-git_rebase* rebase)))
    (~git_rebase_operation_entrycount ~rebase)))
(export git_rebase_operation_entrycount)

;; extern size_t git_rebase_operation_current(git_rebase *rebase);
(define ~git_rebase_operation_current #f)
(define (git_rebase_operation_current rebase)
  (unless
    ~git_rebase_operation_current
    (set! ~git_rebase_operation_current
      (fh-link-proc
        "git_rebase_operation_current"
        ffi:size_t
        (list '*))))
  (let ((~rebase (unwrap-git_rebase* rebase)))
    (~git_rebase_operation_current ~rebase)))
(export git_rebase_operation_current)

;; extern git_rebase_operation *git_rebase_operation_byindex(git_rebase *rebase
;;     , size_t idx);
(define ~git_rebase_operation_byindex #f)
(define (git_rebase_operation_byindex rebase idx)
  (unless
    ~git_rebase_operation_byindex
    (set! ~git_rebase_operation_byindex
      (fh-link-proc
        "git_rebase_operation_byindex"
        '*
        (list '* ffi:size_t))))
  (let ((~rebase (unwrap-git_rebase* rebase))
        (~idx (unwrap~fixed idx)))
    (wrap-git_rebase_operation*
      (~git_rebase_operation_byindex ~rebase ~idx))))
(export git_rebase_operation_byindex)

;; extern int git_rebase_next(git_rebase_operation **operation, git_rebase *
;;     rebase);
(define ~git_rebase_next #f)
(define (git_rebase_next operation rebase)
  (unless
    ~git_rebase_next
    (set! ~git_rebase_next
      (fh-link-proc
        "git_rebase_next"
        ffi:int
        (list '* '*))))
  (let ((~operation (unwrap~pointer operation))
        (~rebase (unwrap-git_rebase* rebase)))
    (~git_rebase_next ~operation ~rebase)))
(export git_rebase_next)

;; extern int git_rebase_inmemory_index(git_index **index, git_rebase *rebase)
;;     ;
(define ~git_rebase_inmemory_index #f)
(define (git_rebase_inmemory_index index rebase)
  (unless
    ~git_rebase_inmemory_index
    (set! ~git_rebase_inmemory_index
      (fh-link-proc
        "git_rebase_inmemory_index"
        ffi:int
        (list '* '*))))
  (let ((~index (unwrap~pointer index))
        (~rebase (unwrap-git_rebase* rebase)))
    (~git_rebase_inmemory_index ~index ~rebase)))
(export git_rebase_inmemory_index)

;; extern int git_rebase_commit(git_oid *id, git_rebase *rebase, const 
;;     git_signature *author, const git_signature *committer, const char *
;;     message_encoding, const char *message);
(define ~git_rebase_commit #f)
(define (git_rebase_commit
         id
         rebase
         author
         committer
         message_encoding
         message)
  (unless
    ~git_rebase_commit
    (set! ~git_rebase_commit
      (fh-link-proc
        "git_rebase_commit"
        ffi:int
        (list '* '* '* '* '* '*))))
  (let ((~id (unwrap-git_oid* id))
        (~rebase (unwrap-git_rebase* rebase))
        (~author (unwrap-git_signature* author))
        (~committer (unwrap-git_signature* committer))
        (~message_encoding
          (unwrap~pointer message_encoding))
        (~message (unwrap~pointer message)))
    (~git_rebase_commit
      ~id
      ~rebase
      ~author
      ~committer
      ~message_encoding
      ~message)))
(export git_rebase_commit)

;; extern int git_rebase_abort(git_rebase *rebase);
(define ~git_rebase_abort #f)
(define (git_rebase_abort rebase)
  (unless
    ~git_rebase_abort
    (set! ~git_rebase_abort
      (fh-link-proc
        "git_rebase_abort"
        ffi:int
        (list '*))))
  (let ((~rebase (unwrap-git_rebase* rebase)))
    (~git_rebase_abort ~rebase)))
(export git_rebase_abort)

;; extern int git_rebase_finish(git_rebase *rebase, const git_signature *
;;     signature);
(define ~git_rebase_finish #f)
(define (git_rebase_finish rebase signature)
  (unless
    ~git_rebase_finish
    (set! ~git_rebase_finish
      (fh-link-proc
        "git_rebase_finish"
        ffi:int
        (list '* '*))))
  (let ((~rebase (unwrap-git_rebase* rebase))
        (~signature (unwrap-git_signature* signature)))
    (~git_rebase_finish ~rebase ~signature)))
(export git_rebase_finish)

;; extern void git_rebase_free(git_rebase *rebase);
(define ~git_rebase_free #f)
(define (git_rebase_free rebase)
  (unless
    ~git_rebase_free
    (set! ~git_rebase_free
      (fh-link-proc
        "git_rebase_free"
        ffi:void
        (list '*))))
  (let ((~rebase (unwrap-git_rebase* rebase)))
    (~git_rebase_free ~rebase)))
(export git_rebase_free)

;; extern int git_refdb_new(git_refdb **out, git_repository *repo);
(define ~git_refdb_new #f)
(define (git_refdb_new out repo)
  (unless
    ~git_refdb_new
    (set! ~git_refdb_new
      (fh-link-proc
        "git_refdb_new"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo)))
    (~git_refdb_new ~out ~repo)))
(export git_refdb_new)

;; extern int git_refdb_open(git_refdb **out, git_repository *repo);
(define ~git_refdb_open #f)
(define (git_refdb_open out repo)
  (unless
    ~git_refdb_open
    (set! ~git_refdb_open
      (fh-link-proc
        "git_refdb_open"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo)))
    (~git_refdb_open ~out ~repo)))
(export git_refdb_open)

;; extern int git_refdb_compress(git_refdb *refdb);
(define ~git_refdb_compress #f)
(define (git_refdb_compress refdb)
  (unless
    ~git_refdb_compress
    (set! ~git_refdb_compress
      (fh-link-proc
        "git_refdb_compress"
        ffi:int
        (list '*))))
  (let ((~refdb (unwrap-git_refdb* refdb)))
    (~git_refdb_compress ~refdb)))
(export git_refdb_compress)

;; extern void git_refdb_free(git_refdb *refdb);
(define ~git_refdb_free #f)
(define (git_refdb_free refdb)
  (unless
    ~git_refdb_free
    (set! ~git_refdb_free
      (fh-link-proc
        "git_refdb_free"
        ffi:void
        (list '*))))
  (let ((~refdb (unwrap-git_refdb* refdb)))
    (~git_refdb_free ~refdb)))
(export git_refdb_free)

;; extern int git_reflog_read(git_reflog **out, git_repository *repo, const 
;;     char *name);
(define ~git_reflog_read #f)
(define (git_reflog_read out repo name)
  (unless
    ~git_reflog_read
    (set! ~git_reflog_read
      (fh-link-proc
        "git_reflog_read"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo))
        (~name (unwrap~pointer name)))
    (~git_reflog_read ~out ~repo ~name)))
(export git_reflog_read)

;; extern int git_reflog_write(git_reflog *reflog);
(define ~git_reflog_write #f)
(define (git_reflog_write reflog)
  (unless
    ~git_reflog_write
    (set! ~git_reflog_write
      (fh-link-proc
        "git_reflog_write"
        ffi:int
        (list '*))))
  (let ((~reflog (unwrap-git_reflog* reflog)))
    (~git_reflog_write ~reflog)))
(export git_reflog_write)

;; extern int git_reflog_append(git_reflog *reflog, const git_oid *id, const 
;;     git_signature *committer, const char *msg);
(define ~git_reflog_append #f)
(define (git_reflog_append reflog id committer msg)
  (unless
    ~git_reflog_append
    (set! ~git_reflog_append
      (fh-link-proc
        "git_reflog_append"
        ffi:int
        (list '* '* '* '*))))
  (let ((~reflog (unwrap-git_reflog* reflog))
        (~id (unwrap-git_oid* id))
        (~committer (unwrap-git_signature* committer))
        (~msg (unwrap~pointer msg)))
    (~git_reflog_append ~reflog ~id ~committer ~msg)))
(export git_reflog_append)

;; extern int git_reflog_rename(git_repository *repo, const char *old_name, 
;;     const char *name);
(define ~git_reflog_rename #f)
(define (git_reflog_rename repo old_name name)
  (unless
    ~git_reflog_rename
    (set! ~git_reflog_rename
      (fh-link-proc
        "git_reflog_rename"
        ffi:int
        (list '* '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~old_name (unwrap~pointer old_name))
        (~name (unwrap~pointer name)))
    (~git_reflog_rename ~repo ~old_name ~name)))
(export git_reflog_rename)

;; extern int git_reflog_delete(git_repository *repo, const char *name);
(define ~git_reflog_delete #f)
(define (git_reflog_delete repo name)
  (unless
    ~git_reflog_delete
    (set! ~git_reflog_delete
      (fh-link-proc
        "git_reflog_delete"
        ffi:int
        (list '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~name (unwrap~pointer name)))
    (~git_reflog_delete ~repo ~name)))
(export git_reflog_delete)

;; extern size_t git_reflog_entrycount(git_reflog *reflog);
(define ~git_reflog_entrycount #f)
(define (git_reflog_entrycount reflog)
  (unless
    ~git_reflog_entrycount
    (set! ~git_reflog_entrycount
      (fh-link-proc
        "git_reflog_entrycount"
        ffi:size_t
        (list '*))))
  (let ((~reflog (unwrap-git_reflog* reflog)))
    (~git_reflog_entrycount ~reflog)))
(export git_reflog_entrycount)

;; extern const git_reflog_entry *git_reflog_entry_byindex(const git_reflog *
;;     reflog, size_t idx);
(define ~git_reflog_entry_byindex #f)
(define (git_reflog_entry_byindex reflog idx)
  (unless
    ~git_reflog_entry_byindex
    (set! ~git_reflog_entry_byindex
      (fh-link-proc
        "git_reflog_entry_byindex"
        '*
        (list '* ffi:size_t))))
  (let ((~reflog (unwrap-git_reflog* reflog))
        (~idx (unwrap~fixed idx)))
    (wrap-git_reflog_entry*
      (~git_reflog_entry_byindex ~reflog ~idx))))
(export git_reflog_entry_byindex)

;; extern int git_reflog_drop(git_reflog *reflog, size_t idx, int 
;;     rewrite_previous_entry);
(define ~git_reflog_drop #f)
(define (git_reflog_drop
         reflog
         idx
         rewrite_previous_entry)
  (unless
    ~git_reflog_drop
    (set! ~git_reflog_drop
      (fh-link-proc
        "git_reflog_drop"
        ffi:int
        (list '* ffi:size_t ffi:int))))
  (let ((~reflog (unwrap-git_reflog* reflog))
        (~idx (unwrap~fixed idx))
        (~rewrite_previous_entry
          (unwrap~fixed rewrite_previous_entry)))
    (~git_reflog_drop
      ~reflog
      ~idx
      ~rewrite_previous_entry)))
(export git_reflog_drop)

;; extern const git_oid *git_reflog_entry_id_old(const git_reflog_entry *entry)
;;     ;
(define ~git_reflog_entry_id_old #f)
(define (git_reflog_entry_id_old entry)
  (unless
    ~git_reflog_entry_id_old
    (set! ~git_reflog_entry_id_old
      (fh-link-proc
        "git_reflog_entry_id_old"
        '*
        (list '*))))
  (let ((~entry (unwrap-git_reflog_entry* entry)))
    (wrap-git_oid* (~git_reflog_entry_id_old ~entry))))
(export git_reflog_entry_id_old)

;; extern const git_oid *git_reflog_entry_id_new(const git_reflog_entry *entry)
;;     ;
(define ~git_reflog_entry_id_new #f)
(define (git_reflog_entry_id_new entry)
  (unless
    ~git_reflog_entry_id_new
    (set! ~git_reflog_entry_id_new
      (fh-link-proc
        "git_reflog_entry_id_new"
        '*
        (list '*))))
  (let ((~entry (unwrap-git_reflog_entry* entry)))
    (wrap-git_oid* (~git_reflog_entry_id_new ~entry))))
(export git_reflog_entry_id_new)

;; extern const git_signature *git_reflog_entry_committer(const 
;;     git_reflog_entry *entry);
(define ~git_reflog_entry_committer #f)
(define (git_reflog_entry_committer entry)
  (unless
    ~git_reflog_entry_committer
    (set! ~git_reflog_entry_committer
      (fh-link-proc
        "git_reflog_entry_committer"
        '*
        (list '*))))
  (let ((~entry (unwrap-git_reflog_entry* entry)))
    (wrap-git_signature*
      (~git_reflog_entry_committer ~entry))))
(export git_reflog_entry_committer)

;; extern const char *git_reflog_entry_message(const git_reflog_entry *entry);
(define ~git_reflog_entry_message #f)
(define (git_reflog_entry_message entry)
  (unless
    ~git_reflog_entry_message
    (set! ~git_reflog_entry_message
      (fh-link-proc
        "git_reflog_entry_message"
        '*
        (list '*))))
  (let ((~entry (unwrap-git_reflog_entry* entry)))
    (~git_reflog_entry_message ~entry)))
(export git_reflog_entry_message)

;; extern void git_reflog_free(git_reflog *reflog);
(define ~git_reflog_free #f)
(define (git_reflog_free reflog)
  (unless
    ~git_reflog_free
    (set! ~git_reflog_free
      (fh-link-proc
        "git_reflog_free"
        ffi:void
        (list '*))))
  (let ((~reflog (unwrap-git_reflog* reflog)))
    (~git_reflog_free ~reflog)))
(export git_reflog_free)

;; typedef enum {
;;   GIT_RESET_SOFT = 1,
;;   GIT_RESET_MIXED = 2,
;;   GIT_RESET_HARD = 3,
;; } git_reset_t;
(define-fh-enum git_reset_t
  '((GIT_RESET_SOFT . 1)
    (GIT_RESET_MIXED . 2)
    (GIT_RESET_HARD . 3))
  )

;; extern int git_reset(git_repository *repo, git_object *target, git_reset_t 
;;     reset_type, const git_checkout_options *checkout_opts);
(define ~git_reset #f)
(define (git_reset repo target reset_type checkout_opts)
  (unless
    ~git_reset
    (set! ~git_reset
      (fh-link-proc
        "git_reset"
        ffi:int
        (list '* '* ffi:int '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~target (unwrap-git_object* target))
        (~reset_type (unwrap~fixed reset_type))
        (~checkout_opts
          (unwrap-git_checkout_options* checkout_opts)))
    (~git_reset
      ~repo
      ~target
      ~reset_type
      ~checkout_opts)))
(export git_reset)

;; extern int git_reset_from_annotated(git_repository *repo, 
;;     git_annotated_commit *commit, git_reset_t reset_type, const 
;;     git_checkout_options *checkout_opts);
(define ~git_reset_from_annotated #f)
(define (git_reset_from_annotated
         repo
         commit
         reset_type
         checkout_opts)
  (unless
    ~git_reset_from_annotated
    (set! ~git_reset_from_annotated
      (fh-link-proc
        "git_reset_from_annotated"
        ffi:int
        (list '* '* ffi:int '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~commit (unwrap-git_annotated_commit* commit))
        (~reset_type (unwrap~fixed reset_type))
        (~checkout_opts
          (unwrap-git_checkout_options* checkout_opts)))
    (~git_reset_from_annotated
      ~repo
      ~commit
      ~reset_type
      ~checkout_opts)))
(export git_reset_from_annotated)

;; extern int git_reset_default(git_repository *repo, git_object *target, 
;;     git_strarray *pathspecs);
(define ~git_reset_default #f)
(define (git_reset_default repo target pathspecs)
  (unless
    ~git_reset_default
    (set! ~git_reset_default
      (fh-link-proc
        "git_reset_default"
        ffi:int
        (list '* '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~target (unwrap-git_object* target))
        (~pathspecs (unwrap-git_strarray* pathspecs)))
    (~git_reset_default ~repo ~target ~pathspecs)))
(export git_reset_default)

;; typedef struct {
;;   unsigned int version;
;;   /** For merge commits, the "mainline" is treated as the parent. */
;;   unsigned int mainline;
;;   git_merge_options merge_opts; /**< Options for the merging */
;;   git_checkout_options checkout_opts; /**< Options for the checkout */
;; } git_revert_options;
(define git_revert_options-desc
  (bs:struct
    (list `(version ,unsigned-int)
          `(mainline ,unsigned-int)
          `(merge_opts ,git_merge_options-desc)
          `(checkout_opts ,git_checkout_options-desc))))
(export git_revert_options-desc)
(define-fh-compound-type/p git_revert_options git_revert_options-desc)

;; extern int git_revert_init_options(git_revert_options *opts, unsigned int 
;;     version);
(define ~git_revert_init_options #f)
(define (git_revert_init_options opts version)
  (unless
    ~git_revert_init_options
    (set! ~git_revert_init_options
      (fh-link-proc
        "git_revert_init_options"
        ffi:int
        (list '* ffi:unsigned-int))))
  (let ((~opts (unwrap-git_revert_options* opts))
        (~version (unwrap~fixed version)))
    (~git_revert_init_options ~opts ~version)))
(export git_revert_init_options)

;; extern int git_revert_commit(git_index **out, git_repository *repo, 
;;     git_commit *revert_commit, git_commit *our_commit, unsigned int mainline
;;     , const git_merge_options *merge_options);
(define ~git_revert_commit #f)
(define (git_revert_commit
         out
         repo
         revert_commit
         our_commit
         mainline
         merge_options)
  (unless
    ~git_revert_commit
    (set! ~git_revert_commit
      (fh-link-proc
        "git_revert_commit"
        ffi:int
        (list '* '* '* '* ffi:unsigned-int '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo))
        (~revert_commit
          (unwrap-git_commit* revert_commit))
        (~our_commit (unwrap-git_commit* our_commit))
        (~mainline (unwrap~fixed mainline))
        (~merge_options
          (unwrap-git_merge_options* merge_options)))
    (~git_revert_commit
      ~out
      ~repo
      ~revert_commit
      ~our_commit
      ~mainline
      ~merge_options)))
(export git_revert_commit)

;; extern int git_revert(git_repository *repo, git_commit *commit, const 
;;     git_revert_options *given_opts);
(define ~git_revert #f)
(define (git_revert repo commit given_opts)
  (unless
    ~git_revert
    (set! ~git_revert
      (fh-link-proc
        "git_revert"
        ffi:int
        (list '* '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~commit (unwrap-git_commit* commit))
        (~given_opts
          (unwrap-git_revert_options* given_opts)))
    (~git_revert ~repo ~commit ~given_opts)))
(export git_revert)

;; extern int git_revparse_single(git_object **out, git_repository *repo, const
;;      char *spec);
(define ~git_revparse_single #f)
(define (git_revparse_single out repo spec)
  (unless
    ~git_revparse_single
    (set! ~git_revparse_single
      (fh-link-proc
        "git_revparse_single"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo))
        (~spec (unwrap~pointer spec)))
    (~git_revparse_single ~out ~repo ~spec)))
(export git_revparse_single)

;; extern int git_revparse_ext(git_object **object_out, git_reference **
;;     reference_out, git_repository *repo, const char *spec);
(define ~git_revparse_ext #f)
(define (git_revparse_ext
         object_out
         reference_out
         repo
         spec)
  (unless
    ~git_revparse_ext
    (set! ~git_revparse_ext
      (fh-link-proc
        "git_revparse_ext"
        ffi:int
        (list '* '* '* '*))))
  (let ((~object_out (unwrap~pointer object_out))
        (~reference_out (unwrap~pointer reference_out))
        (~repo (unwrap-git_repository* repo))
        (~spec (unwrap~pointer spec)))
    (~git_revparse_ext
      ~object_out
      ~reference_out
      ~repo
      ~spec)))
(export git_revparse_ext)

;; typedef enum {
;;   GIT_REVPARSE_SINGLE = 1<<0,
;;   GIT_REVPARSE_RANGE = 1<<1,
;;   GIT_REVPARSE_MERGE_BASE = 1<<2,
;; } git_revparse_mode_t;
(define-fh-enum git_revparse_mode_t
  '((GIT_REVPARSE_SINGLE . 1)
    (GIT_REVPARSE_RANGE . 2)
    (GIT_REVPARSE_MERGE_BASE . 4))
  )

;; typedef struct {
;;   /** The left element of the revspec; must be freed by the user */
;;   git_object *from;
;;   /** The right element of the revspec; must be freed by the user */
;;   git_object *to;
;;   /** The intent of the revspec (i.e. `git_revparse_mode_t` flags) */
;;   unsigned int flags;
;; } git_revspec;
(define git_revspec-desc
  (bs:struct
    (list `(from ,(bs:pointer (delay git_object*-desc)))
          `(to ,(bs:pointer (delay git_object*-desc)))
          `(flags ,unsigned-int))))
(export git_revspec-desc)
(define-fh-compound-type/p git_revspec git_revspec-desc)

;; extern int git_revparse(git_revspec *revspec, git_repository *repo, const 
;;     char *spec);
(define ~git_revparse #f)
(define (git_revparse revspec repo spec)
  (unless
    ~git_revparse
    (set! ~git_revparse
      (fh-link-proc
        "git_revparse"
        ffi:int
        (list '* '* '*))))
  (let ((~revspec (unwrap-git_revspec* revspec))
        (~repo (unwrap-git_repository* repo))
        (~spec (unwrap~pointer spec)))
    (~git_revparse ~revspec ~repo ~spec)))
(export git_revparse)

;; typedef enum {
;;   GIT_SORT_NONE = 0,
;;   GIT_SORT_TOPOLOGICAL = 1<<0,
;;   GIT_SORT_TIME = 1<<1,
;;   GIT_SORT_REVERSE = 1<<2,
;; } git_sort_t;
(define-fh-enum git_sort_t
  '((GIT_SORT_NONE . 0)
    (GIT_SORT_TOPOLOGICAL . 1)
    (GIT_SORT_TIME . 2)
    (GIT_SORT_REVERSE . 4))
  )

;; extern int git_revwalk_new(git_revwalk **out, git_repository *repo);
(define ~git_revwalk_new #f)
(define (git_revwalk_new out repo)
  (unless
    ~git_revwalk_new
    (set! ~git_revwalk_new
      (fh-link-proc
        "git_revwalk_new"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo)))
    (~git_revwalk_new ~out ~repo)))
(export git_revwalk_new)

;; extern void git_revwalk_reset(git_revwalk *walker);
(define ~git_revwalk_reset #f)
(define (git_revwalk_reset walker)
  (unless
    ~git_revwalk_reset
    (set! ~git_revwalk_reset
      (fh-link-proc
        "git_revwalk_reset"
        ffi:void
        (list '*))))
  (let ((~walker (unwrap-git_revwalk* walker)))
    (~git_revwalk_reset ~walker)))
(export git_revwalk_reset)

;; extern int git_revwalk_push(git_revwalk *walk, const git_oid *id);
(define ~git_revwalk_push #f)
(define (git_revwalk_push walk id)
  (unless
    ~git_revwalk_push
    (set! ~git_revwalk_push
      (fh-link-proc
        "git_revwalk_push"
        ffi:int
        (list '* '*))))
  (let ((~walk (unwrap-git_revwalk* walk))
        (~id (unwrap-git_oid* id)))
    (~git_revwalk_push ~walk ~id)))
(export git_revwalk_push)

;; extern int git_revwalk_push_glob(git_revwalk *walk, const char *glob);
(define ~git_revwalk_push_glob #f)
(define (git_revwalk_push_glob walk glob)
  (unless
    ~git_revwalk_push_glob
    (set! ~git_revwalk_push_glob
      (fh-link-proc
        "git_revwalk_push_glob"
        ffi:int
        (list '* '*))))
  (let ((~walk (unwrap-git_revwalk* walk))
        (~glob (unwrap~pointer glob)))
    (~git_revwalk_push_glob ~walk ~glob)))
(export git_revwalk_push_glob)

;; extern int git_revwalk_push_head(git_revwalk *walk);
(define ~git_revwalk_push_head #f)
(define (git_revwalk_push_head walk)
  (unless
    ~git_revwalk_push_head
    (set! ~git_revwalk_push_head
      (fh-link-proc
        "git_revwalk_push_head"
        ffi:int
        (list '*))))
  (let ((~walk (unwrap-git_revwalk* walk)))
    (~git_revwalk_push_head ~walk)))
(export git_revwalk_push_head)

;; extern int git_revwalk_hide(git_revwalk *walk, const git_oid *commit_id);
(define ~git_revwalk_hide #f)
(define (git_revwalk_hide walk commit_id)
  (unless
    ~git_revwalk_hide
    (set! ~git_revwalk_hide
      (fh-link-proc
        "git_revwalk_hide"
        ffi:int
        (list '* '*))))
  (let ((~walk (unwrap-git_revwalk* walk))
        (~commit_id (unwrap-git_oid* commit_id)))
    (~git_revwalk_hide ~walk ~commit_id)))
(export git_revwalk_hide)

;; extern int git_revwalk_hide_glob(git_revwalk *walk, const char *glob);
(define ~git_revwalk_hide_glob #f)
(define (git_revwalk_hide_glob walk glob)
  (unless
    ~git_revwalk_hide_glob
    (set! ~git_revwalk_hide_glob
      (fh-link-proc
        "git_revwalk_hide_glob"
        ffi:int
        (list '* '*))))
  (let ((~walk (unwrap-git_revwalk* walk))
        (~glob (unwrap~pointer glob)))
    (~git_revwalk_hide_glob ~walk ~glob)))
(export git_revwalk_hide_glob)

;; extern int git_revwalk_hide_head(git_revwalk *walk);
(define ~git_revwalk_hide_head #f)
(define (git_revwalk_hide_head walk)
  (unless
    ~git_revwalk_hide_head
    (set! ~git_revwalk_hide_head
      (fh-link-proc
        "git_revwalk_hide_head"
        ffi:int
        (list '*))))
  (let ((~walk (unwrap-git_revwalk* walk)))
    (~git_revwalk_hide_head ~walk)))
(export git_revwalk_hide_head)

;; extern int git_revwalk_push_ref(git_revwalk *walk, const char *refname);
(define ~git_revwalk_push_ref #f)
(define (git_revwalk_push_ref walk refname)
  (unless
    ~git_revwalk_push_ref
    (set! ~git_revwalk_push_ref
      (fh-link-proc
        "git_revwalk_push_ref"
        ffi:int
        (list '* '*))))
  (let ((~walk (unwrap-git_revwalk* walk))
        (~refname (unwrap~pointer refname)))
    (~git_revwalk_push_ref ~walk ~refname)))
(export git_revwalk_push_ref)

;; extern int git_revwalk_hide_ref(git_revwalk *walk, const char *refname);
(define ~git_revwalk_hide_ref #f)
(define (git_revwalk_hide_ref walk refname)
  (unless
    ~git_revwalk_hide_ref
    (set! ~git_revwalk_hide_ref
      (fh-link-proc
        "git_revwalk_hide_ref"
        ffi:int
        (list '* '*))))
  (let ((~walk (unwrap-git_revwalk* walk))
        (~refname (unwrap~pointer refname)))
    (~git_revwalk_hide_ref ~walk ~refname)))
(export git_revwalk_hide_ref)

;; extern int git_revwalk_next(git_oid *out, git_revwalk *walk);
(define ~git_revwalk_next #f)
(define (git_revwalk_next out walk)
  (unless
    ~git_revwalk_next
    (set! ~git_revwalk_next
      (fh-link-proc
        "git_revwalk_next"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap-git_oid* out))
        (~walk (unwrap-git_revwalk* walk)))
    (~git_revwalk_next ~out ~walk)))
(export git_revwalk_next)

;; extern void git_revwalk_sorting(git_revwalk *walk, unsigned int sort_mode);
(define ~git_revwalk_sorting #f)
(define (git_revwalk_sorting walk sort_mode)
  (unless
    ~git_revwalk_sorting
    (set! ~git_revwalk_sorting
      (fh-link-proc
        "git_revwalk_sorting"
        ffi:void
        (list '* ffi:unsigned-int))))
  (let ((~walk (unwrap-git_revwalk* walk))
        (~sort_mode (unwrap~fixed sort_mode)))
    (~git_revwalk_sorting ~walk ~sort_mode)))
(export git_revwalk_sorting)

;; extern int git_revwalk_push_range(git_revwalk *walk, const char *range);
(define ~git_revwalk_push_range #f)
(define (git_revwalk_push_range walk range)
  (unless
    ~git_revwalk_push_range
    (set! ~git_revwalk_push_range
      (fh-link-proc
        "git_revwalk_push_range"
        ffi:int
        (list '* '*))))
  (let ((~walk (unwrap-git_revwalk* walk))
        (~range (unwrap~pointer range)))
    (~git_revwalk_push_range ~walk ~range)))
(export git_revwalk_push_range)

;; extern void git_revwalk_simplify_first_parent(git_revwalk *walk);
(define ~git_revwalk_simplify_first_parent #f)
(define (git_revwalk_simplify_first_parent walk)
  (unless
    ~git_revwalk_simplify_first_parent
    (set! ~git_revwalk_simplify_first_parent
      (fh-link-proc
        "git_revwalk_simplify_first_parent"
        ffi:void
        (list '*))))
  (let ((~walk (unwrap-git_revwalk* walk)))
    (~git_revwalk_simplify_first_parent ~walk)))
(export git_revwalk_simplify_first_parent)

;; extern void git_revwalk_free(git_revwalk *walk);
(define ~git_revwalk_free #f)
(define (git_revwalk_free walk)
  (unless
    ~git_revwalk_free
    (set! ~git_revwalk_free
      (fh-link-proc
        "git_revwalk_free"
        ffi:void
        (list '*))))
  (let ((~walk (unwrap-git_revwalk* walk)))
    (~git_revwalk_free ~walk)))
(export git_revwalk_free)

;; extern git_repository *git_revwalk_repository(git_revwalk *walk);
(define ~git_revwalk_repository #f)
(define (git_revwalk_repository walk)
  (unless
    ~git_revwalk_repository
    (set! ~git_revwalk_repository
      (fh-link-proc
        "git_revwalk_repository"
        '*
        (list '*))))
  (let ((~walk (unwrap-git_revwalk* walk)))
    (wrap-git_repository*
      (~git_revwalk_repository ~walk))))
(export git_revwalk_repository)

;; typedef int (*git_revwalk_hide_cb)(const git_oid *commit_id, void *payload)
;;     ;
(define-fh-function/p git_revwalk_hide_cb
  ffi:int (list (quote *) (quote *)))

;; extern int git_revwalk_add_hide_cb(git_revwalk *walk, git_revwalk_hide_cb 
;;     hide_cb, void *payload);
(define ~git_revwalk_add_hide_cb #f)
(define (git_revwalk_add_hide_cb walk hide_cb payload)
  (unless
    ~git_revwalk_add_hide_cb
    (set! ~git_revwalk_add_hide_cb
      (fh-link-proc
        "git_revwalk_add_hide_cb"
        ffi:int
        (list '* '* '*))))
  (let ((~walk (unwrap-git_revwalk* walk))
        (~hide_cb
          ((make-ftn-arg-unwrapper ffi:int (list '* '*))
           hide_cb))
        (~payload (unwrap~pointer payload)))
    (~git_revwalk_add_hide_cb
      ~walk
      ~hide_cb
      ~payload)))
(export git_revwalk_add_hide_cb)

;; extern int git_signature_new(git_signature **out, const char *name, const 
;;     char *email, git_time_t time, int offset);
(define ~git_signature_new #f)
(define (git_signature_new out name email time offset)
  (unless
    ~git_signature_new
    (set! ~git_signature_new
      (fh-link-proc
        "git_signature_new"
        ffi:int
        (list '* '* '* ffi:int64 ffi:int))))
  (let ((~out (unwrap~pointer out))
        (~name (unwrap~pointer name))
        (~email (unwrap~pointer email))
        (~time (unwrap~fixed time))
        (~offset (unwrap~fixed offset)))
    (~git_signature_new
      ~out
      ~name
      ~email
      ~time
      ~offset)))
(export git_signature_new)

;; extern int git_signature_now(git_signature **out, const char *name, const 
;;     char *email);
(define ~git_signature_now #f)
(define (git_signature_now out name email)
  (unless
    ~git_signature_now
    (set! ~git_signature_now
      (fh-link-proc
        "git_signature_now"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~name (unwrap~pointer name))
        (~email (unwrap~pointer email)))
    (~git_signature_now ~out ~name ~email)))
(export git_signature_now)

;; extern int git_signature_default(git_signature **out, git_repository *repo)
;;     ;
(define ~git_signature_default #f)
(define (git_signature_default out repo)
  (unless
    ~git_signature_default
    (set! ~git_signature_default
      (fh-link-proc
        "git_signature_default"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo)))
    (~git_signature_default ~out ~repo)))
(export git_signature_default)

;; extern int git_signature_from_buffer(git_signature **out, const char *buf);
(define ~git_signature_from_buffer #f)
(define (git_signature_from_buffer out buf)
  (unless
    ~git_signature_from_buffer
    (set! ~git_signature_from_buffer
      (fh-link-proc
        "git_signature_from_buffer"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~buf (unwrap~pointer buf)))
    (~git_signature_from_buffer ~out ~buf)))
(export git_signature_from_buffer)

;; extern int git_signature_dup(git_signature **dest, const git_signature *sig)
;;     ;
(define ~git_signature_dup #f)
(define (git_signature_dup dest sig)
  (unless
    ~git_signature_dup
    (set! ~git_signature_dup
      (fh-link-proc
        "git_signature_dup"
        ffi:int
        (list '* '*))))
  (let ((~dest (unwrap~pointer dest))
        (~sig (unwrap-git_signature* sig)))
    (~git_signature_dup ~dest ~sig)))
(export git_signature_dup)

;; extern void git_signature_free(git_signature *sig);
(define ~git_signature_free #f)
(define (git_signature_free sig)
  (unless
    ~git_signature_free
    (set! ~git_signature_free
      (fh-link-proc
        "git_signature_free"
        ffi:void
        (list '*))))
  (let ((~sig (unwrap-git_signature* sig)))
    (~git_signature_free ~sig)))
(export git_signature_free)

;; typedef enum {
;;   GIT_STASH_DEFAULT = 0,
;;   GIT_STASH_KEEP_INDEX = 1<<0,
;;   GIT_STASH_INCLUDE_UNTRACKED = 1<<1,
;;   GIT_STASH_INCLUDE_IGNORED = 1<<2,
;; } git_stash_flags;
(define-fh-enum git_stash_flags
  '((GIT_STASH_DEFAULT . 0)
    (GIT_STASH_KEEP_INDEX . 1)
    (GIT_STASH_INCLUDE_UNTRACKED . 2)
    (GIT_STASH_INCLUDE_IGNORED . 4))
  )

;; extern int git_stash_save(git_oid *out, git_repository *repo, const 
;;     git_signature *stasher, const char *message, uint32_t flags);
(define ~git_stash_save #f)
(define (git_stash_save out repo stasher message flags)
  (unless
    ~git_stash_save
    (set! ~git_stash_save
      (fh-link-proc
        "git_stash_save"
        ffi:int
        (list '* '* '* '* ffi:uint32))))
  (let ((~out (unwrap-git_oid* out))
        (~repo (unwrap-git_repository* repo))
        (~stasher (unwrap-git_signature* stasher))
        (~message (unwrap~pointer message))
        (~flags (unwrap~fixed flags)))
    (~git_stash_save
      ~out
      ~repo
      ~stasher
      ~message
      ~flags)))
(export git_stash_save)

;; typedef enum {
;;   GIT_STASH_APPLY_DEFAULT = 0,
;;   GIT_STASH_APPLY_REINSTATE_INDEX = 1<<0,
;; } git_stash_apply_flags;
(define-fh-enum git_stash_apply_flags
  '((GIT_STASH_APPLY_DEFAULT . 0)
    (GIT_STASH_APPLY_REINSTATE_INDEX . 1))
  )

;; typedef enum {
;;   GIT_STASH_APPLY_PROGRESS_NONE = 0,
;;   GIT_STASH_APPLY_PROGRESS_LOADING_STASH,
;;   GIT_STASH_APPLY_PROGRESS_ANALYZE_INDEX,
;;   GIT_STASH_APPLY_PROGRESS_ANALYZE_MODIFIED,
;;   GIT_STASH_APPLY_PROGRESS_ANALYZE_UNTRACKED,
;;   GIT_STASH_APPLY_PROGRESS_CHECKOUT_UNTRACKED,
;;   GIT_STASH_APPLY_PROGRESS_CHECKOUT_MODIFIED,
;;   GIT_STASH_APPLY_PROGRESS_DONE,
;; } git_stash_apply_progress_t;
(define-fh-enum git_stash_apply_progress_t
  '((GIT_STASH_APPLY_PROGRESS_NONE . 0)
    (GIT_STASH_APPLY_PROGRESS_LOADING_STASH . 1)
    (GIT_STASH_APPLY_PROGRESS_ANALYZE_INDEX . 2)
    (GIT_STASH_APPLY_PROGRESS_ANALYZE_MODIFIED . 3)
    (GIT_STASH_APPLY_PROGRESS_ANALYZE_UNTRACKED . 4)
    (GIT_STASH_APPLY_PROGRESS_CHECKOUT_UNTRACKED . 5)
    (GIT_STASH_APPLY_PROGRESS_CHECKOUT_MODIFIED . 6)
    (GIT_STASH_APPLY_PROGRESS_DONE . 7))
  )

;; typedef int (*git_stash_apply_progress_cb)(git_stash_apply_progress_t 
;;     progress, void *payload);
(define-fh-function/p git_stash_apply_progress_cb
  ffi:int (list ffi:int (quote *)))

;; typedef struct git_stash_apply_options {
;;   unsigned int version;
;;   /** See `git_stash_apply_flags_t`, above. */
;;   git_stash_apply_flags flags;
;;   /** Options to use when writing files to the working directory. */
;;   git_checkout_options checkout_options;
;;   /** Optional callback to notify the consumer of application progress. */
;;   git_stash_apply_progress_cb progress_cb;
;;   void *progress_payload;
;; } git_stash_apply_options;
(define git_stash_apply_options-desc
  (bs:struct
    (list `(version ,unsigned-int)
          `(flags ,int)
          `(checkout_options ,git_checkout_options-desc)
          `(progress_cb ,(bs:pointer void))
          `(progress_payload ,(bs:pointer void)))))
(export git_stash_apply_options-desc)
(define-fh-compound-type/p git_stash_apply_options git_stash_apply_options-desc)
(define struct-git_stash_apply_options git_stash_apply_options)

;; extern int git_stash_apply_init_options(git_stash_apply_options *opts, 
;;     unsigned int version);
(define ~git_stash_apply_init_options #f)
(define (git_stash_apply_init_options opts version)
  (unless
    ~git_stash_apply_init_options
    (set! ~git_stash_apply_init_options
      (fh-link-proc
        "git_stash_apply_init_options"
        ffi:int
        (list '* ffi:unsigned-int))))
  (let ((~opts (unwrap-git_stash_apply_options* opts))
        (~version (unwrap~fixed version)))
    (~git_stash_apply_init_options ~opts ~version)))
(export git_stash_apply_init_options)

;; extern int git_stash_apply(git_repository *repo, size_t index, const 
;;     git_stash_apply_options *options);
(define ~git_stash_apply #f)
(define (git_stash_apply repo index options)
  (unless
    ~git_stash_apply
    (set! ~git_stash_apply
      (fh-link-proc
        "git_stash_apply"
        ffi:int
        (list '* ffi:size_t '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~index (unwrap~fixed index))
        (~options
          (unwrap-git_stash_apply_options* options)))
    (~git_stash_apply ~repo ~index ~options)))
(export git_stash_apply)

;; typedef int (*git_stash_cb)(size_t index, const char *message, const git_oid
;;      *stash_id, void *payload);
(define-fh-function/p git_stash_cb
  ffi:int (list ffi:size_t (quote *) (quote *) (quote *)))

;; extern int git_stash_foreach(git_repository *repo, git_stash_cb callback, 
;;     void *payload);
(define ~git_stash_foreach #f)
(define (git_stash_foreach repo callback payload)
  (unless
    ~git_stash_foreach
    (set! ~git_stash_foreach
      (fh-link-proc
        "git_stash_foreach"
        ffi:int
        (list '* '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~callback
          ((make-ftn-arg-unwrapper
             ffi:int
             (list ffi:size_t '* '* '*))
           callback))
        (~payload (unwrap~pointer payload)))
    (~git_stash_foreach ~repo ~callback ~payload)))
(export git_stash_foreach)

;; extern int git_stash_drop(git_repository *repo, size_t index);
(define ~git_stash_drop #f)
(define (git_stash_drop repo index)
  (unless
    ~git_stash_drop
    (set! ~git_stash_drop
      (fh-link-proc
        "git_stash_drop"
        ffi:int
        (list '* ffi:size_t))))
  (let ((~repo (unwrap-git_repository* repo))
        (~index (unwrap~fixed index)))
    (~git_stash_drop ~repo ~index)))
(export git_stash_drop)

;; extern int git_stash_pop(git_repository *repo, size_t index, const 
;;     git_stash_apply_options *options);
(define ~git_stash_pop #f)
(define (git_stash_pop repo index options)
  (unless
    ~git_stash_pop
    (set! ~git_stash_pop
      (fh-link-proc
        "git_stash_pop"
        ffi:int
        (list '* ffi:size_t '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~index (unwrap~fixed index))
        (~options
          (unwrap-git_stash_apply_options* options)))
    (~git_stash_pop ~repo ~index ~options)))
(export git_stash_pop)

;; typedef enum {
;;   GIT_STATUS_CURRENT = 0,
;;   GIT_STATUS_INDEX_NEW = 1u<<0,
;;   GIT_STATUS_INDEX_MODIFIED = 1u<<1,
;;   GIT_STATUS_INDEX_DELETED = 1u<<2,
;;   GIT_STATUS_INDEX_RENAMED = 1u<<3,
;;   GIT_STATUS_INDEX_TYPECHANGE = 1u<<4,
;;   GIT_STATUS_WT_NEW = 1u<<7,
;;   GIT_STATUS_WT_MODIFIED = 1u<<8,
;;   GIT_STATUS_WT_DELETED = 1u<<9,
;;   GIT_STATUS_WT_TYPECHANGE = 1u<<10,
;;   GIT_STATUS_WT_RENAMED = 1u<<11,
;;   GIT_STATUS_WT_UNREADABLE = 1u<<12,
;;   GIT_STATUS_IGNORED = 1u<<14,
;;   GIT_STATUS_CONFLICTED = 1u<<15,
;; } git_status_t;
(define-fh-enum git_status_t
  '((GIT_STATUS_CURRENT . 0)
    (GIT_STATUS_INDEX_NEW . 1)
    (GIT_STATUS_INDEX_MODIFIED . 2)
    (GIT_STATUS_INDEX_DELETED . 4)
    (GIT_STATUS_INDEX_RENAMED . 8)
    (GIT_STATUS_INDEX_TYPECHANGE . 16)
    (GIT_STATUS_WT_NEW . 128)
    (GIT_STATUS_WT_MODIFIED . 256)
    (GIT_STATUS_WT_DELETED . 512)
    (GIT_STATUS_WT_TYPECHANGE . 1024)
    (GIT_STATUS_WT_RENAMED . 2048)
    (GIT_STATUS_WT_UNREADABLE . 4096)
    (GIT_STATUS_IGNORED . 16384)
    (GIT_STATUS_CONFLICTED . 32768))
  )

;; typedef int (*git_status_cb)(const char *path, unsigned int status_flags, 
;;     void *payload);
(define-fh-function/p git_status_cb
  ffi:int (list (quote *) ffi:unsigned-int (quote *)))

;; typedef enum {
;;   GIT_STATUS_SHOW_INDEX_AND_WORKDIR = 0,
;;   GIT_STATUS_SHOW_INDEX_ONLY = 1,
;;   GIT_STATUS_SHOW_WORKDIR_ONLY = 2,
;; } git_status_show_t;
(define-fh-enum git_status_show_t
  '((GIT_STATUS_SHOW_INDEX_AND_WORKDIR . 0)
    (GIT_STATUS_SHOW_INDEX_ONLY . 1)
    (GIT_STATUS_SHOW_WORKDIR_ONLY . 2))
  )

;; typedef enum {
;;   GIT_STATUS_OPT_INCLUDE_UNTRACKED = 1u<<0,
;;   GIT_STATUS_OPT_INCLUDE_IGNORED = 1u<<1,
;;   GIT_STATUS_OPT_INCLUDE_UNMODIFIED = 1u<<2,
;;   GIT_STATUS_OPT_EXCLUDE_SUBMODULES = 1u<<3,
;;   GIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS = 1u<<4,
;;   GIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH = 1u<<5,
;;   GIT_STATUS_OPT_RECURSE_IGNORED_DIRS = 1u<<6,
;;   GIT_STATUS_OPT_RENAMES_HEAD_TO_INDEX = 1u<<7,
;;   GIT_STATUS_OPT_RENAMES_INDEX_TO_WORKDIR = 1u<<8,
;;   GIT_STATUS_OPT_SORT_CASE_SENSITIVELY = 1u<<9,
;;   GIT_STATUS_OPT_SORT_CASE_INSENSITIVELY = 1u<<10,
;;   GIT_STATUS_OPT_RENAMES_FROM_REWRITES = 1u<<11,
;;   GIT_STATUS_OPT_NO_REFRESH = 1u<<12,
;;   GIT_STATUS_OPT_UPDATE_INDEX = 1u<<13,
;;   GIT_STATUS_OPT_INCLUDE_UNREADABLE = 1u<<14,
;;   GIT_STATUS_OPT_INCLUDE_UNREADABLE_AS_UNTRACKED = 1u<<15,
;; } git_status_opt_t;
(define-fh-enum git_status_opt_t
  '((GIT_STATUS_OPT_INCLUDE_UNTRACKED . 1)
    (GIT_STATUS_OPT_INCLUDE_IGNORED . 2)
    (GIT_STATUS_OPT_INCLUDE_UNMODIFIED . 4)
    (GIT_STATUS_OPT_EXCLUDE_SUBMODULES . 8)
    (GIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS . 16)
    (GIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH . 32)
    (GIT_STATUS_OPT_RECURSE_IGNORED_DIRS . 64)
    (GIT_STATUS_OPT_RENAMES_HEAD_TO_INDEX . 128)
    (GIT_STATUS_OPT_RENAMES_INDEX_TO_WORKDIR . 256)
    (GIT_STATUS_OPT_SORT_CASE_SENSITIVELY . 512)
    (GIT_STATUS_OPT_SORT_CASE_INSENSITIVELY . 1024)
    (GIT_STATUS_OPT_RENAMES_FROM_REWRITES . 2048)
    (GIT_STATUS_OPT_NO_REFRESH . 4096)
    (GIT_STATUS_OPT_UPDATE_INDEX . 8192)
    (GIT_STATUS_OPT_INCLUDE_UNREADABLE . 16384)
    (GIT_STATUS_OPT_INCLUDE_UNREADABLE_AS_UNTRACKED
      .
      32768))
  )

;; typedef struct {
;;   unsigned int version;
;;   git_status_show_t show;
;;   unsigned int flags;
;;   git_strarray pathspec;
;; } git_status_options;
(define git_status_options-desc
  (bs:struct
    (list `(version ,unsigned-int)
          `(show ,int)
          `(flags ,unsigned-int)
          `(pathspec ,git_strarray-desc))))
(export git_status_options-desc)
(define-fh-compound-type/p git_status_options git_status_options-desc)

;; extern int git_status_init_options(git_status_options *opts, unsigned int 
;;     version);
(define ~git_status_init_options #f)
(define (git_status_init_options opts version)
  (unless
    ~git_status_init_options
    (set! ~git_status_init_options
      (fh-link-proc
        "git_status_init_options"
        ffi:int
        (list '* ffi:unsigned-int))))
  (let ((~opts (unwrap-git_status_options* opts))
        (~version (unwrap~fixed version)))
    (~git_status_init_options ~opts ~version)))
(export git_status_init_options)

;; typedef struct {
;;   git_status_t status;
;;   git_diff_delta *head_to_index;
;;   git_diff_delta *index_to_workdir;
;; } git_status_entry;
(define git_status_entry-desc
  (bs:struct
    (list `(status ,int)
          `(head_to_index
             ,(bs:pointer (delay git_diff_delta*-desc)))
          `(index_to_workdir
             ,(bs:pointer (delay git_diff_delta*-desc))))))
(export git_status_entry-desc)
(define-fh-compound-type/p git_status_entry git_status_entry-desc)

;; extern int git_status_foreach(git_repository *repo, git_status_cb callback, 
;;     void *payload);
(define ~git_status_foreach #f)
(define (git_status_foreach repo callback payload)
  (unless
    ~git_status_foreach
    (set! ~git_status_foreach
      (fh-link-proc
        "git_status_foreach"
        ffi:int
        (list '* '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~callback
          ((make-ftn-arg-unwrapper
             ffi:int
             (list '* ffi:unsigned-int '*))
           callback))
        (~payload (unwrap~pointer payload)))
    (~git_status_foreach ~repo ~callback ~payload)))
(export git_status_foreach)

;; extern int git_status_foreach_ext(git_repository *repo, const 
;;     git_status_options *opts, git_status_cb callback, void *payload);
(define ~git_status_foreach_ext #f)
(define (git_status_foreach_ext
         repo
         opts
         callback
         payload)
  (unless
    ~git_status_foreach_ext
    (set! ~git_status_foreach_ext
      (fh-link-proc
        "git_status_foreach_ext"
        ffi:int
        (list '* '* '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~opts (unwrap-git_status_options* opts))
        (~callback
          ((make-ftn-arg-unwrapper
             ffi:int
             (list '* ffi:unsigned-int '*))
           callback))
        (~payload (unwrap~pointer payload)))
    (~git_status_foreach_ext
      ~repo
      ~opts
      ~callback
      ~payload)))
(export git_status_foreach_ext)

;; extern int git_status_file(unsigned int *status_flags, git_repository *repo
;;     , const char *path);
(define ~git_status_file #f)
(define (git_status_file status_flags repo path)
  (unless
    ~git_status_file
    (set! ~git_status_file
      (fh-link-proc
        "git_status_file"
        ffi:int
        (list '* '* '*))))
  (let ((~status_flags (unwrap~pointer status_flags))
        (~repo (unwrap-git_repository* repo))
        (~path (unwrap~pointer path)))
    (~git_status_file ~status_flags ~repo ~path)))
(export git_status_file)

;; extern int git_status_list_new(git_status_list **out, git_repository *repo, 
;;     const git_status_options *opts);
(define ~git_status_list_new #f)
(define (git_status_list_new out repo opts)
  (unless
    ~git_status_list_new
    (set! ~git_status_list_new
      (fh-link-proc
        "git_status_list_new"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo))
        (~opts (unwrap-git_status_options* opts)))
    (~git_status_list_new ~out ~repo ~opts)))
(export git_status_list_new)

;; extern size_t git_status_list_entrycount(git_status_list *statuslist);
(define ~git_status_list_entrycount #f)
(define (git_status_list_entrycount statuslist)
  (unless
    ~git_status_list_entrycount
    (set! ~git_status_list_entrycount
      (fh-link-proc
        "git_status_list_entrycount"
        ffi:size_t
        (list '*))))
  (let ((~statuslist
          (unwrap-git_status_list* statuslist)))
    (~git_status_list_entrycount ~statuslist)))
(export git_status_list_entrycount)

;; extern const git_status_entry *git_status_byindex(git_status_list *
;;     statuslist, size_t idx);
(define ~git_status_byindex #f)
(define (git_status_byindex statuslist idx)
  (unless
    ~git_status_byindex
    (set! ~git_status_byindex
      (fh-link-proc
        "git_status_byindex"
        '*
        (list '* ffi:size_t))))
  (let ((~statuslist
          (unwrap-git_status_list* statuslist))
        (~idx (unwrap~fixed idx)))
    (wrap-git_status_entry*
      (~git_status_byindex ~statuslist ~idx))))
(export git_status_byindex)

;; extern void git_status_list_free(git_status_list *statuslist);
(define ~git_status_list_free #f)
(define (git_status_list_free statuslist)
  (unless
    ~git_status_list_free
    (set! ~git_status_list_free
      (fh-link-proc
        "git_status_list_free"
        ffi:void
        (list '*))))
  (let ((~statuslist
          (unwrap-git_status_list* statuslist)))
    (~git_status_list_free ~statuslist)))
(export git_status_list_free)

;; extern int git_status_should_ignore(int *ignored, git_repository *repo, 
;;     const char *path);
(define ~git_status_should_ignore #f)
(define (git_status_should_ignore ignored repo path)
  (unless
    ~git_status_should_ignore
    (set! ~git_status_should_ignore
      (fh-link-proc
        "git_status_should_ignore"
        ffi:int
        (list '* '* '*))))
  (let ((~ignored (unwrap~pointer ignored))
        (~repo (unwrap-git_repository* repo))
        (~path (unwrap~pointer path)))
    (~git_status_should_ignore ~ignored ~repo ~path)))
(export git_status_should_ignore)

;; typedef enum {
;;   GIT_SUBMODULE_STATUS_IN_HEAD = 1u<<0,
;;   GIT_SUBMODULE_STATUS_IN_INDEX = 1u<<1,
;;   GIT_SUBMODULE_STATUS_IN_CONFIG = 1u<<2,
;;   GIT_SUBMODULE_STATUS_IN_WD = 1u<<3,
;;   GIT_SUBMODULE_STATUS_INDEX_ADDED = 1u<<4,
;;   GIT_SUBMODULE_STATUS_INDEX_DELETED = 1u<<5,
;;   GIT_SUBMODULE_STATUS_INDEX_MODIFIED = 1u<<6,
;;   GIT_SUBMODULE_STATUS_WD_UNINITIALIZED = 1u<<7,
;;   GIT_SUBMODULE_STATUS_WD_ADDED = 1u<<8,
;;   GIT_SUBMODULE_STATUS_WD_DELETED = 1u<<9,
;;   GIT_SUBMODULE_STATUS_WD_MODIFIED = 1u<<10,
;;   GIT_SUBMODULE_STATUS_WD_INDEX_MODIFIED = 1u<<11,
;;   GIT_SUBMODULE_STATUS_WD_WD_MODIFIED = 1u<<12,
;;   GIT_SUBMODULE_STATUS_WD_UNTRACKED = 1u<<13,
;; } git_submodule_status_t;
(define-fh-enum git_submodule_status_t
  '((GIT_SUBMODULE_STATUS_IN_HEAD . 1)
    (GIT_SUBMODULE_STATUS_IN_INDEX . 2)
    (GIT_SUBMODULE_STATUS_IN_CONFIG . 4)
    (GIT_SUBMODULE_STATUS_IN_WD . 8)
    (GIT_SUBMODULE_STATUS_INDEX_ADDED . 16)
    (GIT_SUBMODULE_STATUS_INDEX_DELETED . 32)
    (GIT_SUBMODULE_STATUS_INDEX_MODIFIED . 64)
    (GIT_SUBMODULE_STATUS_WD_UNINITIALIZED . 128)
    (GIT_SUBMODULE_STATUS_WD_ADDED . 256)
    (GIT_SUBMODULE_STATUS_WD_DELETED . 512)
    (GIT_SUBMODULE_STATUS_WD_MODIFIED . 1024)
    (GIT_SUBMODULE_STATUS_WD_INDEX_MODIFIED . 2048)
    (GIT_SUBMODULE_STATUS_WD_WD_MODIFIED . 4096)
    (GIT_SUBMODULE_STATUS_WD_UNTRACKED . 8192))
  )

;; typedef int (*git_submodule_cb)(git_submodule *sm, const char *name, void *
;;     payload);
(define-fh-function/p git_submodule_cb
  ffi:int (list (quote *) (quote *) (quote *)))

;; typedef struct git_submodule_update_options {
;;   unsigned int version;
;;   /**
;;    * These options are passed to the checkout step. To disable
;;    * checkout, set the `checkout_strategy` to
;;    * `GIT_CHECKOUT_NONE`. Generally you will want the use
;;    * GIT_CHECKOUT_SAFE to update files in the working
;;    * directory. 
;;    */
;;   git_checkout_options checkout_opts;
;;   /**
;;    * Options which control the fetch, including callbacks.
;;    *
;;    * The callbacks to use for reporting fetch progress, and for acquiring
;;    * credentials in the event they are needed.
;;    */
;;   git_fetch_options fetch_opts;
;;   /**
;;    * Allow fetching from the submodule's default remote if the target
;;    * commit isn't found. Enabled by default.
;;    */
;;   int allow_fetch;
;; } git_submodule_update_options;
(define git_submodule_update_options-desc
  (bs:struct
    (list `(version ,unsigned-int)
          `(checkout_opts ,git_checkout_options-desc)
          `(fetch_opts ,git_fetch_options-desc)
          `(allow_fetch ,int))))
(export git_submodule_update_options-desc)
(define-fh-compound-type/p git_submodule_update_options git_submodule_update_options-desc)
(define struct-git_submodule_update_options git_submodule_update_options)

;; extern int git_submodule_update_init_options(git_submodule_update_options *
;;     opts, unsigned int version);
(define ~git_submodule_update_init_options #f)
(define (git_submodule_update_init_options opts version)
  (unless
    ~git_submodule_update_init_options
    (set! ~git_submodule_update_init_options
      (fh-link-proc
        "git_submodule_update_init_options"
        ffi:int
        (list '* ffi:unsigned-int))))
  (let ((~opts (unwrap-git_submodule_update_options* opts))
        (~version (unwrap~fixed version)))
    (~git_submodule_update_init_options
      ~opts
      ~version)))
(export git_submodule_update_init_options)

;; extern int git_submodule_update(git_submodule *submodule, int init, 
;;     git_submodule_update_options *options);
(define ~git_submodule_update #f)
(define (git_submodule_update submodule init options)
  (unless
    ~git_submodule_update
    (set! ~git_submodule_update
      (fh-link-proc
        "git_submodule_update"
        ffi:int
        (list '* ffi:int '*))))
  (let ((~submodule (unwrap-git_submodule* submodule))
        (~init (unwrap~fixed init))
        (~options
          (unwrap-git_submodule_update_options* options)))
    (~git_submodule_update ~submodule ~init ~options)))
(export git_submodule_update)

;; extern int git_submodule_lookup(git_submodule **out, git_repository *repo, 
;;     const char *name);
(define ~git_submodule_lookup #f)
(define (git_submodule_lookup out repo name)
  (unless
    ~git_submodule_lookup
    (set! ~git_submodule_lookup
      (fh-link-proc
        "git_submodule_lookup"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo))
        (~name (unwrap~pointer name)))
    (~git_submodule_lookup ~out ~repo ~name)))
(export git_submodule_lookup)

;; extern void git_submodule_free(git_submodule *submodule);
(define ~git_submodule_free #f)
(define (git_submodule_free submodule)
  (unless
    ~git_submodule_free
    (set! ~git_submodule_free
      (fh-link-proc
        "git_submodule_free"
        ffi:void
        (list '*))))
  (let ((~submodule (unwrap-git_submodule* submodule)))
    (~git_submodule_free ~submodule)))
(export git_submodule_free)

;; extern int git_submodule_foreach(git_repository *repo, git_submodule_cb 
;;     callback, void *payload);
(define ~git_submodule_foreach #f)
(define (git_submodule_foreach repo callback payload)
  (unless
    ~git_submodule_foreach
    (set! ~git_submodule_foreach
      (fh-link-proc
        "git_submodule_foreach"
        ffi:int
        (list '* '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~callback
          ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
           callback))
        (~payload (unwrap~pointer payload)))
    (~git_submodule_foreach ~repo ~callback ~payload)))
(export git_submodule_foreach)

;; extern int git_submodule_add_setup(git_submodule **out, git_repository *repo
;;     , const char *url, const char *path, int use_gitlink);
(define ~git_submodule_add_setup #f)
(define (git_submodule_add_setup
         out
         repo
         url
         path
         use_gitlink)
  (unless
    ~git_submodule_add_setup
    (set! ~git_submodule_add_setup
      (fh-link-proc
        "git_submodule_add_setup"
        ffi:int
        (list '* '* '* '* ffi:int))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo))
        (~url (unwrap~pointer url))
        (~path (unwrap~pointer path))
        (~use_gitlink (unwrap~fixed use_gitlink)))
    (~git_submodule_add_setup
      ~out
      ~repo
      ~url
      ~path
      ~use_gitlink)))
(export git_submodule_add_setup)

;; extern int git_submodule_add_finalize(git_submodule *submodule);
(define ~git_submodule_add_finalize #f)
(define (git_submodule_add_finalize submodule)
  (unless
    ~git_submodule_add_finalize
    (set! ~git_submodule_add_finalize
      (fh-link-proc
        "git_submodule_add_finalize"
        ffi:int
        (list '*))))
  (let ((~submodule (unwrap-git_submodule* submodule)))
    (~git_submodule_add_finalize ~submodule)))
(export git_submodule_add_finalize)

;; extern int git_submodule_add_to_index(git_submodule *submodule, int 
;;     write_index);
(define ~git_submodule_add_to_index #f)
(define (git_submodule_add_to_index
         submodule
         write_index)
  (unless
    ~git_submodule_add_to_index
    (set! ~git_submodule_add_to_index
      (fh-link-proc
        "git_submodule_add_to_index"
        ffi:int
        (list '* ffi:int))))
  (let ((~submodule (unwrap-git_submodule* submodule))
        (~write_index (unwrap~fixed write_index)))
    (~git_submodule_add_to_index
      ~submodule
      ~write_index)))
(export git_submodule_add_to_index)

;; extern git_repository *git_submodule_owner(git_submodule *submodule);
(define ~git_submodule_owner #f)
(define (git_submodule_owner submodule)
  (unless
    ~git_submodule_owner
    (set! ~git_submodule_owner
      (fh-link-proc "git_submodule_owner" '* (list '*))))
  (let ((~submodule (unwrap-git_submodule* submodule)))
    (wrap-git_repository*
      (~git_submodule_owner ~submodule))))
(export git_submodule_owner)

;; extern const char *git_submodule_name(git_submodule *submodule);
(define ~git_submodule_name #f)
(define (git_submodule_name submodule)
  (unless
    ~git_submodule_name
    (set! ~git_submodule_name
      (fh-link-proc "git_submodule_name" '* (list '*))))
  (let ((~submodule (unwrap-git_submodule* submodule)))
    (~git_submodule_name ~submodule)))
(export git_submodule_name)

;; extern const char *git_submodule_path(git_submodule *submodule);
(define ~git_submodule_path #f)
(define (git_submodule_path submodule)
  (unless
    ~git_submodule_path
    (set! ~git_submodule_path
      (fh-link-proc "git_submodule_path" '* (list '*))))
  (let ((~submodule (unwrap-git_submodule* submodule)))
    (~git_submodule_path ~submodule)))
(export git_submodule_path)

;; extern const char *git_submodule_url(git_submodule *submodule);
(define ~git_submodule_url #f)
(define (git_submodule_url submodule)
  (unless
    ~git_submodule_url
    (set! ~git_submodule_url
      (fh-link-proc "git_submodule_url" '* (list '*))))
  (let ((~submodule (unwrap-git_submodule* submodule)))
    (~git_submodule_url ~submodule)))
(export git_submodule_url)

;; extern int git_submodule_resolve_url(git_buf *out, git_repository *repo, 
;;     const char *url);
(define ~git_submodule_resolve_url #f)
(define (git_submodule_resolve_url out repo url)
  (unless
    ~git_submodule_resolve_url
    (set! ~git_submodule_resolve_url
      (fh-link-proc
        "git_submodule_resolve_url"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap-git_buf* out))
        (~repo (unwrap-git_repository* repo))
        (~url (unwrap~pointer url)))
    (~git_submodule_resolve_url ~out ~repo ~url)))
(export git_submodule_resolve_url)

;; extern const char *git_submodule_branch(git_submodule *submodule);
(define ~git_submodule_branch #f)
(define (git_submodule_branch submodule)
  (unless
    ~git_submodule_branch
    (set! ~git_submodule_branch
      (fh-link-proc
        "git_submodule_branch"
        '*
        (list '*))))
  (let ((~submodule (unwrap-git_submodule* submodule)))
    (~git_submodule_branch ~submodule)))
(export git_submodule_branch)

;; extern int git_submodule_set_branch(git_repository *repo, const char *name, 
;;     const char *branch);
(define ~git_submodule_set_branch #f)
(define (git_submodule_set_branch repo name branch)
  (unless
    ~git_submodule_set_branch
    (set! ~git_submodule_set_branch
      (fh-link-proc
        "git_submodule_set_branch"
        ffi:int
        (list '* '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~name (unwrap~pointer name))
        (~branch (unwrap~pointer branch)))
    (~git_submodule_set_branch ~repo ~name ~branch)))
(export git_submodule_set_branch)

;; extern int git_submodule_set_url(git_repository *repo, const char *name, 
;;     const char *url);
(define ~git_submodule_set_url #f)
(define (git_submodule_set_url repo name url)
  (unless
    ~git_submodule_set_url
    (set! ~git_submodule_set_url
      (fh-link-proc
        "git_submodule_set_url"
        ffi:int
        (list '* '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~name (unwrap~pointer name))
        (~url (unwrap~pointer url)))
    (~git_submodule_set_url ~repo ~name ~url)))
(export git_submodule_set_url)

;; extern const git_oid *git_submodule_index_id(git_submodule *submodule);
(define ~git_submodule_index_id #f)
(define (git_submodule_index_id submodule)
  (unless
    ~git_submodule_index_id
    (set! ~git_submodule_index_id
      (fh-link-proc
        "git_submodule_index_id"
        '*
        (list '*))))
  (let ((~submodule (unwrap-git_submodule* submodule)))
    (wrap-git_oid*
      (~git_submodule_index_id ~submodule))))
(export git_submodule_index_id)

;; extern const git_oid *git_submodule_head_id(git_submodule *submodule);
(define ~git_submodule_head_id #f)
(define (git_submodule_head_id submodule)
  (unless
    ~git_submodule_head_id
    (set! ~git_submodule_head_id
      (fh-link-proc
        "git_submodule_head_id"
        '*
        (list '*))))
  (let ((~submodule (unwrap-git_submodule* submodule)))
    (wrap-git_oid*
      (~git_submodule_head_id ~submodule))))
(export git_submodule_head_id)

;; extern const git_oid *git_submodule_wd_id(git_submodule *submodule);
(define ~git_submodule_wd_id #f)
(define (git_submodule_wd_id submodule)
  (unless
    ~git_submodule_wd_id
    (set! ~git_submodule_wd_id
      (fh-link-proc "git_submodule_wd_id" '* (list '*))))
  (let ((~submodule (unwrap-git_submodule* submodule)))
    (wrap-git_oid* (~git_submodule_wd_id ~submodule))))
(export git_submodule_wd_id)

;; extern git_submodule_ignore_t git_submodule_ignore(git_submodule *submodule)
;;     ;
(define ~git_submodule_ignore #f)
(define (git_submodule_ignore submodule)
  (unless
    ~git_submodule_ignore
    (set! ~git_submodule_ignore
      (fh-link-proc
        "git_submodule_ignore"
        ffi:int
        (list '*))))
  (let ((~submodule (unwrap-git_submodule* submodule)))
    (~git_submodule_ignore ~submodule)))
(export git_submodule_ignore)

;; extern int git_submodule_set_ignore(git_repository *repo, const char *name, 
;;     git_submodule_ignore_t ignore);
(define ~git_submodule_set_ignore #f)
(define (git_submodule_set_ignore repo name ignore)
  (unless
    ~git_submodule_set_ignore
    (set! ~git_submodule_set_ignore
      (fh-link-proc
        "git_submodule_set_ignore"
        ffi:int
        (list '* '* ffi:int))))
  (let ((~repo (unwrap-git_repository* repo))
        (~name (unwrap~pointer name))
        (~ignore (unwrap~fixed ignore)))
    (~git_submodule_set_ignore ~repo ~name ~ignore)))
(export git_submodule_set_ignore)

;; extern git_submodule_update_t git_submodule_update_strategy(git_submodule *
;;     submodule);
(define ~git_submodule_update_strategy #f)
(define (git_submodule_update_strategy submodule)
  (unless
    ~git_submodule_update_strategy
    (set! ~git_submodule_update_strategy
      (fh-link-proc
        "git_submodule_update_strategy"
        ffi:int
        (list '*))))
  (let ((~submodule (unwrap-git_submodule* submodule)))
    (~git_submodule_update_strategy ~submodule)))
(export git_submodule_update_strategy)

;; extern int git_submodule_set_update(git_repository *repo, const char *name, 
;;     git_submodule_update_t update);
(define ~git_submodule_set_update #f)
(define (git_submodule_set_update repo name update)
  (unless
    ~git_submodule_set_update
    (set! ~git_submodule_set_update
      (fh-link-proc
        "git_submodule_set_update"
        ffi:int
        (list '* '* ffi:int))))
  (let ((~repo (unwrap-git_repository* repo))
        (~name (unwrap~pointer name))
        (~update (unwrap~fixed update)))
    (~git_submodule_set_update ~repo ~name ~update)))
(export git_submodule_set_update)

;; extern git_submodule_recurse_t git_submodule_fetch_recurse_submodules(
;;     git_submodule *submodule);
(define ~git_submodule_fetch_recurse_submodules #f)
(define (git_submodule_fetch_recurse_submodules
         submodule)
  (unless
    ~git_submodule_fetch_recurse_submodules
    (set! ~git_submodule_fetch_recurse_submodules
      (fh-link-proc
        "git_submodule_fetch_recurse_submodules"
        ffi:int
        (list '*))))
  (let ((~submodule (unwrap-git_submodule* submodule)))
    (~git_submodule_fetch_recurse_submodules
      ~submodule)))
(export git_submodule_fetch_recurse_submodules)

;; extern int git_submodule_set_fetch_recurse_submodules(git_repository *repo, 
;;     const char *name, git_submodule_recurse_t fetch_recurse_submodules);
(define ~git_submodule_set_fetch_recurse_submodules #f)
(define (git_submodule_set_fetch_recurse_submodules
         repo
         name
         fetch_recurse_submodules)
  (unless
    ~git_submodule_set_fetch_recurse_submodules
    (set! ~git_submodule_set_fetch_recurse_submodules
      (fh-link-proc
        "git_submodule_set_fetch_recurse_submodules"
        ffi:int
        (list '* '* ffi:int))))
  (let ((~repo (unwrap-git_repository* repo))
        (~name (unwrap~pointer name))
        (~fetch_recurse_submodules
          (unwrap~fixed fetch_recurse_submodules)))
    (~git_submodule_set_fetch_recurse_submodules
      ~repo
      ~name
      ~fetch_recurse_submodules)))
(export git_submodule_set_fetch_recurse_submodules)

;; extern int git_submodule_init(git_submodule *submodule, int overwrite);
(define ~git_submodule_init #f)
(define (git_submodule_init submodule overwrite)
  (unless
    ~git_submodule_init
    (set! ~git_submodule_init
      (fh-link-proc
        "git_submodule_init"
        ffi:int
        (list '* ffi:int))))
  (let ((~submodule (unwrap-git_submodule* submodule))
        (~overwrite (unwrap~fixed overwrite)))
    (~git_submodule_init ~submodule ~overwrite)))
(export git_submodule_init)

;; extern int git_submodule_repo_init(git_repository **out, const git_submodule
;;      *sm, int use_gitlink);
(define ~git_submodule_repo_init #f)
(define (git_submodule_repo_init out sm use_gitlink)
  (unless
    ~git_submodule_repo_init
    (set! ~git_submodule_repo_init
      (fh-link-proc
        "git_submodule_repo_init"
        ffi:int
        (list '* '* ffi:int))))
  (let ((~out (unwrap~pointer out))
        (~sm (unwrap-git_submodule* sm))
        (~use_gitlink (unwrap~fixed use_gitlink)))
    (~git_submodule_repo_init ~out ~sm ~use_gitlink)))
(export git_submodule_repo_init)

;; extern int git_submodule_sync(git_submodule *submodule);
(define ~git_submodule_sync #f)
(define (git_submodule_sync submodule)
  (unless
    ~git_submodule_sync
    (set! ~git_submodule_sync
      (fh-link-proc
        "git_submodule_sync"
        ffi:int
        (list '*))))
  (let ((~submodule (unwrap-git_submodule* submodule)))
    (~git_submodule_sync ~submodule)))
(export git_submodule_sync)

;; extern int git_submodule_open(git_repository **repo, git_submodule *
;;     submodule);
(define ~git_submodule_open #f)
(define (git_submodule_open repo submodule)
  (unless
    ~git_submodule_open
    (set! ~git_submodule_open
      (fh-link-proc
        "git_submodule_open"
        ffi:int
        (list '* '*))))
  (let ((~repo (unwrap~pointer repo))
        (~submodule (unwrap-git_submodule* submodule)))
    (~git_submodule_open ~repo ~submodule)))
(export git_submodule_open)

;; extern int git_submodule_reload(git_submodule *submodule, int force);
(define ~git_submodule_reload #f)
(define (git_submodule_reload submodule force)
  (unless
    ~git_submodule_reload
    (set! ~git_submodule_reload
      (fh-link-proc
        "git_submodule_reload"
        ffi:int
        (list '* ffi:int))))
  (let ((~submodule (unwrap-git_submodule* submodule))
        (~force (unwrap~fixed force)))
    (~git_submodule_reload ~submodule ~force)))
(export git_submodule_reload)

;; extern int git_submodule_status(unsigned int *status, git_repository *repo, 
;;     const char *name, git_submodule_ignore_t ignore);
(define ~git_submodule_status #f)
(define (git_submodule_status status repo name ignore)
  (unless
    ~git_submodule_status
    (set! ~git_submodule_status
      (fh-link-proc
        "git_submodule_status"
        ffi:int
        (list '* '* '* ffi:int))))
  (let ((~status (unwrap~pointer status))
        (~repo (unwrap-git_repository* repo))
        (~name (unwrap~pointer name))
        (~ignore (unwrap~fixed ignore)))
    (~git_submodule_status
      ~status
      ~repo
      ~name
      ~ignore)))
(export git_submodule_status)

;; extern int git_submodule_location(unsigned int *location_status, 
;;     git_submodule *submodule);
(define ~git_submodule_location #f)
(define (git_submodule_location
         location_status
         submodule)
  (unless
    ~git_submodule_location
    (set! ~git_submodule_location
      (fh-link-proc
        "git_submodule_location"
        ffi:int
        (list '* '*))))
  (let ((~location_status
          (unwrap~pointer location_status))
        (~submodule (unwrap-git_submodule* submodule)))
    (~git_submodule_location
      ~location_status
      ~submodule)))
(export git_submodule_location)

;; extern int git_tag_lookup(git_tag **out, git_repository *repo, const git_oid
;;      *id);
(define ~git_tag_lookup #f)
(define (git_tag_lookup out repo id)
  (unless
    ~git_tag_lookup
    (set! ~git_tag_lookup
      (fh-link-proc
        "git_tag_lookup"
        ffi:int
        (list '* '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo))
        (~id (unwrap-git_oid* id)))
    (~git_tag_lookup ~out ~repo ~id)))
(export git_tag_lookup)

;; extern int git_tag_lookup_prefix(git_tag **out, git_repository *repo, const 
;;     git_oid *id, size_t len);
(define ~git_tag_lookup_prefix #f)
(define (git_tag_lookup_prefix out repo id len)
  (unless
    ~git_tag_lookup_prefix
    (set! ~git_tag_lookup_prefix
      (fh-link-proc
        "git_tag_lookup_prefix"
        ffi:int
        (list '* '* '* ffi:size_t))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo))
        (~id (unwrap-git_oid* id))
        (~len (unwrap~fixed len)))
    (~git_tag_lookup_prefix ~out ~repo ~id ~len)))
(export git_tag_lookup_prefix)

;; extern void git_tag_free(git_tag *tag);
(define ~git_tag_free #f)
(define (git_tag_free tag)
  (unless
    ~git_tag_free
    (set! ~git_tag_free
      (fh-link-proc "git_tag_free" ffi:void (list '*))))
  (let ((~tag (unwrap-git_tag* tag)))
    (~git_tag_free ~tag)))
(export git_tag_free)

;; extern const git_oid *git_tag_id(const git_tag *tag);
(define ~git_tag_id #f)
(define (git_tag_id tag)
  (unless
    ~git_tag_id
    (set! ~git_tag_id
      (fh-link-proc "git_tag_id" '* (list '*))))
  (let ((~tag (unwrap-git_tag* tag)))
    (wrap-git_oid* (~git_tag_id ~tag))))
(export git_tag_id)

;; extern git_repository *git_tag_owner(const git_tag *tag);
(define ~git_tag_owner #f)
(define (git_tag_owner tag)
  (unless
    ~git_tag_owner
    (set! ~git_tag_owner
      (fh-link-proc "git_tag_owner" '* (list '*))))
  (let ((~tag (unwrap-git_tag* tag)))
    (wrap-git_repository* (~git_tag_owner ~tag))))
(export git_tag_owner)

;; extern int git_tag_target(git_object **target_out, const git_tag *tag);
(define ~git_tag_target #f)
(define (git_tag_target target_out tag)
  (unless
    ~git_tag_target
    (set! ~git_tag_target
      (fh-link-proc
        "git_tag_target"
        ffi:int
        (list '* '*))))
  (let ((~target_out (unwrap~pointer target_out))
        (~tag (unwrap-git_tag* tag)))
    (~git_tag_target ~target_out ~tag)))
(export git_tag_target)

;; extern const git_oid *git_tag_target_id(const git_tag *tag);
(define ~git_tag_target_id #f)
(define (git_tag_target_id tag)
  (unless
    ~git_tag_target_id
    (set! ~git_tag_target_id
      (fh-link-proc "git_tag_target_id" '* (list '*))))
  (let ((~tag (unwrap-git_tag* tag)))
    (wrap-git_oid* (~git_tag_target_id ~tag))))
(export git_tag_target_id)

;; extern git_otype git_tag_target_type(const git_tag *tag);
(define ~git_tag_target_type #f)
(define (git_tag_target_type tag)
  (unless
    ~git_tag_target_type
    (set! ~git_tag_target_type
      (fh-link-proc
        "git_tag_target_type"
        ffi:int
        (list '*))))
  (let ((~tag (unwrap-git_tag* tag)))
    (~git_tag_target_type ~tag)))
(export git_tag_target_type)

;; extern const char *git_tag_name(const git_tag *tag);
(define ~git_tag_name #f)
(define (git_tag_name tag)
  (unless
    ~git_tag_name
    (set! ~git_tag_name
      (fh-link-proc "git_tag_name" '* (list '*))))
  (let ((~tag (unwrap-git_tag* tag)))
    (~git_tag_name ~tag)))
(export git_tag_name)

;; extern const git_signature *git_tag_tagger(const git_tag *tag);
(define ~git_tag_tagger #f)
(define (git_tag_tagger tag)
  (unless
    ~git_tag_tagger
    (set! ~git_tag_tagger
      (fh-link-proc "git_tag_tagger" '* (list '*))))
  (let ((~tag (unwrap-git_tag* tag)))
    (wrap-git_signature* (~git_tag_tagger ~tag))))
(export git_tag_tagger)

;; extern const char *git_tag_message(const git_tag *tag);
(define ~git_tag_message #f)
(define (git_tag_message tag)
  (unless
    ~git_tag_message
    (set! ~git_tag_message
      (fh-link-proc "git_tag_message" '* (list '*))))
  (let ((~tag (unwrap-git_tag* tag)))
    (~git_tag_message ~tag)))
(export git_tag_message)

;; extern int git_tag_create(git_oid *oid, git_repository *repo, const char *
;;     tag_name, const git_object *target, const git_signature *tagger, const 
;;     char *message, int force);
(define ~git_tag_create #f)
(define (git_tag_create
         oid
         repo
         tag_name
         target
         tagger
         message
         force)
  (unless
    ~git_tag_create
    (set! ~git_tag_create
      (fh-link-proc
        "git_tag_create"
        ffi:int
        (list '* '* '* '* '* '* ffi:int))))
  (let ((~oid (unwrap-git_oid* oid))
        (~repo (unwrap-git_repository* repo))
        (~tag_name (unwrap~pointer tag_name))
        (~target (unwrap-git_object* target))
        (~tagger (unwrap-git_signature* tagger))
        (~message (unwrap~pointer message))
        (~force (unwrap~fixed force)))
    (~git_tag_create
      ~oid
      ~repo
      ~tag_name
      ~target
      ~tagger
      ~message
      ~force)))
(export git_tag_create)

;; extern int git_tag_annotation_create(git_oid *oid, git_repository *repo, 
;;     const char *tag_name, const git_object *target, const git_signature *
;;     tagger, const char *message);
(define ~git_tag_annotation_create #f)
(define (git_tag_annotation_create
         oid
         repo
         tag_name
         target
         tagger
         message)
  (unless
    ~git_tag_annotation_create
    (set! ~git_tag_annotation_create
      (fh-link-proc
        "git_tag_annotation_create"
        ffi:int
        (list '* '* '* '* '* '*))))
  (let ((~oid (unwrap-git_oid* oid))
        (~repo (unwrap-git_repository* repo))
        (~tag_name (unwrap~pointer tag_name))
        (~target (unwrap-git_object* target))
        (~tagger (unwrap-git_signature* tagger))
        (~message (unwrap~pointer message)))
    (~git_tag_annotation_create
      ~oid
      ~repo
      ~tag_name
      ~target
      ~tagger
      ~message)))
(export git_tag_annotation_create)

;; extern int git_tag_create_frombuffer(git_oid *oid, git_repository *repo, 
;;     const char *buffer, int force);
(define ~git_tag_create_frombuffer #f)
(define (git_tag_create_frombuffer oid repo buffer force)
  (unless
    ~git_tag_create_frombuffer
    (set! ~git_tag_create_frombuffer
      (fh-link-proc
        "git_tag_create_frombuffer"
        ffi:int
        (list '* '* '* ffi:int))))
  (let ((~oid (unwrap-git_oid* oid))
        (~repo (unwrap-git_repository* repo))
        (~buffer (unwrap~pointer buffer))
        (~force (unwrap~fixed force)))
    (~git_tag_create_frombuffer
      ~oid
      ~repo
      ~buffer
      ~force)))
(export git_tag_create_frombuffer)

;; extern int git_tag_create_lightweight(git_oid *oid, git_repository *repo, 
;;     const char *tag_name, const git_object *target, int force);
(define ~git_tag_create_lightweight #f)
(define (git_tag_create_lightweight
         oid
         repo
         tag_name
         target
         force)
  (unless
    ~git_tag_create_lightweight
    (set! ~git_tag_create_lightweight
      (fh-link-proc
        "git_tag_create_lightweight"
        ffi:int
        (list '* '* '* '* ffi:int))))
  (let ((~oid (unwrap-git_oid* oid))
        (~repo (unwrap-git_repository* repo))
        (~tag_name (unwrap~pointer tag_name))
        (~target (unwrap-git_object* target))
        (~force (unwrap~fixed force)))
    (~git_tag_create_lightweight
      ~oid
      ~repo
      ~tag_name
      ~target
      ~force)))
(export git_tag_create_lightweight)

;; extern int git_tag_delete(git_repository *repo, const char *tag_name);
(define ~git_tag_delete #f)
(define (git_tag_delete repo tag_name)
  (unless
    ~git_tag_delete
    (set! ~git_tag_delete
      (fh-link-proc
        "git_tag_delete"
        ffi:int
        (list '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~tag_name (unwrap~pointer tag_name)))
    (~git_tag_delete ~repo ~tag_name)))
(export git_tag_delete)

;; extern int git_tag_list(git_strarray *tag_names, git_repository *repo);
(define ~git_tag_list #f)
(define (git_tag_list tag_names repo)
  (unless
    ~git_tag_list
    (set! ~git_tag_list
      (fh-link-proc
        "git_tag_list"
        ffi:int
        (list '* '*))))
  (let ((~tag_names (unwrap-git_strarray* tag_names))
        (~repo (unwrap-git_repository* repo)))
    (~git_tag_list ~tag_names ~repo)))
(export git_tag_list)

;; extern int git_tag_list_match(git_strarray *tag_names, const char *pattern, 
;;     git_repository *repo);
(define ~git_tag_list_match #f)
(define (git_tag_list_match tag_names pattern repo)
  (unless
    ~git_tag_list_match
    (set! ~git_tag_list_match
      (fh-link-proc
        "git_tag_list_match"
        ffi:int
        (list '* '* '*))))
  (let ((~tag_names (unwrap-git_strarray* tag_names))
        (~pattern (unwrap~pointer pattern))
        (~repo (unwrap-git_repository* repo)))
    (~git_tag_list_match ~tag_names ~pattern ~repo)))
(export git_tag_list_match)

;; typedef int (*git_tag_foreach_cb)(const char *name, git_oid *oid, void *
;;     payload);
(define-fh-function/p git_tag_foreach_cb
  ffi:int (list (quote *) (quote *) (quote *)))

;; extern int git_tag_foreach(git_repository *repo, git_tag_foreach_cb callback
;;     , void *payload);
(define ~git_tag_foreach #f)
(define (git_tag_foreach repo callback payload)
  (unless
    ~git_tag_foreach
    (set! ~git_tag_foreach
      (fh-link-proc
        "git_tag_foreach"
        ffi:int
        (list '* '* '*))))
  (let ((~repo (unwrap-git_repository* repo))
        (~callback
          ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
           callback))
        (~payload (unwrap~pointer payload)))
    (~git_tag_foreach ~repo ~callback ~payload)))
(export git_tag_foreach)

;; extern int git_tag_peel(git_object **tag_target_out, const git_tag *tag);
(define ~git_tag_peel #f)
(define (git_tag_peel tag_target_out tag)
  (unless
    ~git_tag_peel
    (set! ~git_tag_peel
      (fh-link-proc
        "git_tag_peel"
        ffi:int
        (list '* '*))))
  (let ((~tag_target_out (unwrap~pointer tag_target_out))
        (~tag (unwrap-git_tag* tag)))
    (~git_tag_peel ~tag_target_out ~tag)))
(export git_tag_peel)

;; extern int git_tag_dup(git_tag **out, git_tag *source);
(define ~git_tag_dup #f)
(define (git_tag_dup out source)
  (unless
    ~git_tag_dup
    (set! ~git_tag_dup
      (fh-link-proc "git_tag_dup" ffi:int (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~source (unwrap-git_tag* source)))
    (~git_tag_dup ~out ~source)))
(export git_tag_dup)

;; extern int git_transaction_new(git_transaction **out, git_repository *repo)
;;     ;
(define ~git_transaction_new #f)
(define (git_transaction_new out repo)
  (unless
    ~git_transaction_new
    (set! ~git_transaction_new
      (fh-link-proc
        "git_transaction_new"
        ffi:int
        (list '* '*))))
  (let ((~out (unwrap~pointer out))
        (~repo (unwrap-git_repository* repo)))
    (~git_transaction_new ~out ~repo)))
(export git_transaction_new)

;; extern int git_transaction_lock_ref(git_transaction *tx, const char *refname
;;     );
(define ~git_transaction_lock_ref #f)
(define (git_transaction_lock_ref tx refname)
  (unless
    ~git_transaction_lock_ref
    (set! ~git_transaction_lock_ref
      (fh-link-proc
        "git_transaction_lock_ref"
        ffi:int
        (list '* '*))))
  (let ((~tx (unwrap-git_transaction* tx))
        (~refname (unwrap~pointer refname)))
    (~git_transaction_lock_ref ~tx ~refname)))
(export git_transaction_lock_ref)

;; extern int git_transaction_set_target(git_transaction *tx, const char *
;;     refname, const git_oid *target, const git_signature *sig, const char *
;;     msg);
(define ~git_transaction_set_target #f)
(define (git_transaction_set_target
         tx
         refname
         target
         sig
         msg)
  (unless
    ~git_transaction_set_target
    (set! ~git_transaction_set_target
      (fh-link-proc
        "git_transaction_set_target"
        ffi:int
        (list '* '* '* '* '*))))
  (let ((~tx (unwrap-git_transaction* tx))
        (~refname (unwrap~pointer refname))
        (~target (unwrap-git_oid* target))
        (~sig (unwrap-git_signature* sig))
        (~msg (unwrap~pointer msg)))
    (~git_transaction_set_target
      ~tx
      ~refname
      ~target
      ~sig
      ~msg)))
(export git_transaction_set_target)

;; extern int git_transaction_set_symbolic_target(git_transaction *tx, const 
;;     char *refname, const char *target, const git_signature *sig, const char 
;;     *msg);
(define ~git_transaction_set_symbolic_target #f)
(define (git_transaction_set_symbolic_target
         tx
         refname
         target
         sig
         msg)
  (unless
    ~git_transaction_set_symbolic_target
    (set! ~git_transaction_set_symbolic_target
      (fh-link-proc
        "git_transaction_set_symbolic_target"
        ffi:int
        (list '* '* '* '* '*))))
  (let ((~tx (unwrap-git_transaction* tx))
        (~refname (unwrap~pointer refname))
        (~target (unwrap~pointer target))
        (~sig (unwrap-git_signature* sig))
        (~msg (unwrap~pointer msg)))
    (~git_transaction_set_symbolic_target
      ~tx
      ~refname
      ~target
      ~sig
      ~msg)))
(export git_transaction_set_symbolic_target)

;; extern int git_transaction_set_reflog(git_transaction *tx, const char *
;;     refname, const git_reflog *reflog);
(define ~git_transaction_set_reflog #f)
(define (git_transaction_set_reflog tx refname reflog)
  (unless
    ~git_transaction_set_reflog
    (set! ~git_transaction_set_reflog
      (fh-link-proc
        "git_transaction_set_reflog"
        ffi:int
        (list '* '* '*))))
  (let ((~tx (unwrap-git_transaction* tx))
        (~refname (unwrap~pointer refname))
        (~reflog (unwrap-git_reflog* reflog)))
    (~git_transaction_set_reflog
      ~tx
      ~refname
      ~reflog)))
(export git_transaction_set_reflog)

;; extern int git_transaction_remove(git_transaction *tx, const char *refname)
;;     ;
(define ~git_transaction_remove #f)
(define (git_transaction_remove tx refname)
  (unless
    ~git_transaction_remove
    (set! ~git_transaction_remove
      (fh-link-proc
        "git_transaction_remove"
        ffi:int
        (list '* '*))))
  (let ((~tx (unwrap-git_transaction* tx))
        (~refname (unwrap~pointer refname)))
    (~git_transaction_remove ~tx ~refname)))
(export git_transaction_remove)

;; extern int git_transaction_commit(git_transaction *tx);
(define ~git_transaction_commit #f)
(define (git_transaction_commit tx)
  (unless
    ~git_transaction_commit
    (set! ~git_transaction_commit
      (fh-link-proc
        "git_transaction_commit"
        ffi:int
        (list '*))))
  (let ((~tx (unwrap-git_transaction* tx)))
    (~git_transaction_commit ~tx)))
(export git_transaction_commit)

;; extern void git_transaction_free(git_transaction *tx);
(define ~git_transaction_free #f)
(define (git_transaction_free tx)
  (unless
    ~git_transaction_free
    (set! ~git_transaction_free
      (fh-link-proc
        "git_transaction_free"
        ffi:void
        (list '*))))
  (let ((~tx (unwrap-git_transaction* tx)))
    (~git_transaction_free ~tx)))
(export git_transaction_free)

;; access to enum symbols and #define'd constants:
(define ffi-libgit2-symbol-val
  (let ((sym-tab
          '((_CLOCK_REALTIME . 0)
            (_CLOCK_MONOTONIC . 6)
            (_CLOCK_MONOTONIC_RAW . 4)
            (_CLOCK_MONOTONIC_RAW_APPROX . 5)
            (_CLOCK_UPTIME_RAW . 8)
            (_CLOCK_UPTIME_RAW_APPROX . 9)
            (_CLOCK_PROCESS_CPUTIME_ID . 12)
            (_CLOCK_THREAD_CPUTIME_ID . 16)
            (P_ALL . 0)
            (P_PID . 1)
            (P_PGID . 2)
            (GIT_FEATURE_THREADS . 1)
            (GIT_FEATURE_HTTPS . 2)
            (GIT_FEATURE_SSH . 4)
            (GIT_FEATURE_NSEC . 8)
            (GIT_OPT_GET_MWINDOW_SIZE . 0)
            (GIT_OPT_SET_MWINDOW_SIZE . 1)
            (GIT_OPT_GET_MWINDOW_MAPPED_LIMIT . 2)
            (GIT_OPT_SET_MWINDOW_MAPPED_LIMIT . 3)
            (GIT_OPT_GET_SEARCH_PATH . 4)
            (GIT_OPT_SET_SEARCH_PATH . 5)
            (GIT_OPT_SET_CACHE_OBJECT_LIMIT . 6)
            (GIT_OPT_SET_CACHE_MAX_SIZE . 7)
            (GIT_OPT_ENABLE_CACHING . 8)
            (GIT_OPT_GET_CACHED_MEMORY . 9)
            (GIT_OPT_GET_TEMPLATE_PATH . 10)
            (GIT_OPT_SET_TEMPLATE_PATH . 11)
            (GIT_OPT_SET_SSL_CERT_LOCATIONS . 12)
            (GIT_OPT_SET_USER_AGENT . 13)
            (GIT_OPT_ENABLE_STRICT_OBJECT_CREATION . 14)
            (GIT_OPT_ENABLE_STRICT_SYMBOLIC_REF_CREATION
              .
              15)
            (GIT_OPT_SET_SSL_CIPHERS . 16)
            (GIT_OPT_GET_USER_AGENT . 17)
            (GIT_OPT_ENABLE_OFS_DELTA . 18)
            (GIT_OPT_ENABLE_FSYNC_GITDIR . 19)
            (GIT_OPT_GET_WINDOWS_SHAREMODE . 20)
            (GIT_OPT_SET_WINDOWS_SHAREMODE . 21)
            (GIT_OPT_ENABLE_STRICT_HASH_VERIFICATION . 22)
            (GIT_OBJ_ANY . -2)
            (GIT_OBJ_BAD . -1)
            (GIT_OBJ__EXT1 . 0)
            (GIT_OBJ_COMMIT . 1)
            (GIT_OBJ_TREE . 2)
            (GIT_OBJ_BLOB . 3)
            (GIT_OBJ_TAG . 4)
            (GIT_OBJ__EXT2 . 5)
            (GIT_OBJ_OFS_DELTA . 6)
            (GIT_OBJ_REF_DELTA . 7)
            (GIT_REF_INVALID . 0)
            (GIT_REF_OID . 1)
            (GIT_REF_SYMBOLIC . 2)
            (GIT_REF_LISTALL . 3)
            (GIT_BRANCH_LOCAL . 1)
            (GIT_BRANCH_REMOTE . 2)
            (GIT_BRANCH_ALL . 3)
            (GIT_FILEMODE_UNREADABLE . 0)
            (GIT_FILEMODE_TREE . 16384)
            (GIT_FILEMODE_BLOB . 33188)
            (GIT_FILEMODE_BLOB_EXECUTABLE . 33261)
            (GIT_FILEMODE_LINK . 40960)
            (GIT_FILEMODE_COMMIT . 57344)
            (GIT_CERT_NONE . 0)
            (GIT_CERT_X509 . 1)
            (GIT_CERT_HOSTKEY_LIBSSH2 . 2)
            (GIT_CERT_STRARRAY . 3)
            (GIT_SUBMODULE_UPDATE_CHECKOUT . 1)
            (GIT_SUBMODULE_UPDATE_REBASE . 2)
            (GIT_SUBMODULE_UPDATE_MERGE . 3)
            (GIT_SUBMODULE_UPDATE_NONE . 4)
            (GIT_SUBMODULE_UPDATE_DEFAULT . 0)
            (GIT_SUBMODULE_IGNORE_UNSPECIFIED . -1)
            (GIT_SUBMODULE_IGNORE_NONE . 1)
            (GIT_SUBMODULE_IGNORE_UNTRACKED . 2)
            (GIT_SUBMODULE_IGNORE_DIRTY . 3)
            (GIT_SUBMODULE_IGNORE_ALL . 4)
            (GIT_SUBMODULE_RECURSE_NO . 0)
            (GIT_SUBMODULE_RECURSE_YES . 1)
            (GIT_SUBMODULE_RECURSE_ONDEMAND . 2)
            (GIT_REPOSITORY_OPEN_NO_SEARCH . 1)
            (GIT_REPOSITORY_OPEN_CROSS_FS . 2)
            (GIT_REPOSITORY_OPEN_BARE . 4)
            (GIT_REPOSITORY_OPEN_NO_DOTGIT . 8)
            (GIT_REPOSITORY_OPEN_FROM_ENV . 16)
            (GIT_REPOSITORY_INIT_BARE . 1)
            (GIT_REPOSITORY_INIT_NO_REINIT . 2)
            (GIT_REPOSITORY_INIT_NO_DOTGIT_DIR . 4)
            (GIT_REPOSITORY_INIT_MKDIR . 8)
            (GIT_REPOSITORY_INIT_MKPATH . 16)
            (GIT_REPOSITORY_INIT_EXTERNAL_TEMPLATE . 32)
            (GIT_REPOSITORY_INIT_RELATIVE_GITLINK . 64)
            (GIT_REPOSITORY_INIT_SHARED_UMASK . 0)
            (GIT_REPOSITORY_INIT_SHARED_GROUP . 1533)
            (GIT_REPOSITORY_INIT_SHARED_ALL . 1535)
            (GIT_REPOSITORY_ITEM_GITDIR . 0)
            (GIT_REPOSITORY_ITEM_WORKDIR . 1)
            (GIT_REPOSITORY_ITEM_COMMONDIR . 2)
            (GIT_REPOSITORY_ITEM_INDEX . 3)
            (GIT_REPOSITORY_ITEM_OBJECTS . 4)
            (GIT_REPOSITORY_ITEM_REFS . 5)
            (GIT_REPOSITORY_ITEM_PACKED_REFS . 6)
            (GIT_REPOSITORY_ITEM_REMOTES . 7)
            (GIT_REPOSITORY_ITEM_CONFIG . 8)
            (GIT_REPOSITORY_ITEM_INFO . 9)
            (GIT_REPOSITORY_ITEM_HOOKS . 10)
            (GIT_REPOSITORY_ITEM_LOGS . 11)
            (GIT_REPOSITORY_ITEM_MODULES . 12)
            (GIT_REPOSITORY_ITEM_WORKTREES . 13)
            (GIT_REPOSITORY_STATE_NONE . 0)
            (GIT_REPOSITORY_STATE_MERGE . 1)
            (GIT_REPOSITORY_STATE_REVERT . 2)
            (GIT_REPOSITORY_STATE_REVERT_SEQUENCE . 3)
            (GIT_REPOSITORY_STATE_CHERRYPICK . 4)
            (GIT_REPOSITORY_STATE_CHERRYPICK_SEQUENCE . 5)
            (GIT_REPOSITORY_STATE_BISECT . 6)
            (GIT_REPOSITORY_STATE_REBASE . 7)
            (GIT_REPOSITORY_STATE_REBASE_INTERACTIVE . 8)
            (GIT_REPOSITORY_STATE_REBASE_MERGE . 9)
            (GIT_REPOSITORY_STATE_APPLY_MAILBOX . 10)
            (GIT_REPOSITORY_STATE_APPLY_MAILBOX_OR_REBASE
              .
              11)
            (GIT_ATTR_UNSPECIFIED_T . 0)
            (GIT_ATTR_TRUE_T . 1)
            (GIT_ATTR_FALSE_T . 2)
            (GIT_ATTR_VALUE_T . 3)
            (GIT_BLAME_NORMAL . 0)
            (GIT_BLAME_TRACK_COPIES_SAME_FILE . 1)
            (GIT_BLAME_TRACK_COPIES_SAME_COMMIT_MOVES . 2)
            (GIT_BLAME_TRACK_COPIES_SAME_COMMIT_COPIES . 4)
            (GIT_BLAME_TRACK_COPIES_ANY_COMMIT_COPIES . 8)
            (GIT_BLAME_FIRST_PARENT . 16)
            (GIT_TREEWALK_PRE . 0)
            (GIT_TREEWALK_POST . 1)
            (GIT_TREE_UPDATE_UPSERT . 0)
            (GIT_TREE_UPDATE_REMOVE . 1)
            (GIT_REF_FORMAT_NORMAL . 0)
            (GIT_REF_FORMAT_ALLOW_ONELEVEL . 1)
            (GIT_REF_FORMAT_REFSPEC_PATTERN . 2)
            (GIT_REF_FORMAT_REFSPEC_SHORTHAND . 4)
            (GIT_DIFF_NORMAL . 0)
            (GIT_DIFF_REVERSE . 1)
            (GIT_DIFF_INCLUDE_IGNORED . 2)
            (GIT_DIFF_RECURSE_IGNORED_DIRS . 4)
            (GIT_DIFF_INCLUDE_UNTRACKED . 8)
            (GIT_DIFF_RECURSE_UNTRACKED_DIRS . 16)
            (GIT_DIFF_INCLUDE_UNMODIFIED . 32)
            (GIT_DIFF_INCLUDE_TYPECHANGE . 64)
            (GIT_DIFF_INCLUDE_TYPECHANGE_TREES . 128)
            (GIT_DIFF_IGNORE_FILEMODE . 256)
            (GIT_DIFF_IGNORE_SUBMODULES . 512)
            (GIT_DIFF_IGNORE_CASE . 1024)
            (GIT_DIFF_INCLUDE_CASECHANGE . 2048)
            (GIT_DIFF_DISABLE_PATHSPEC_MATCH . 4096)
            (GIT_DIFF_SKIP_BINARY_CHECK . 8192)
            (GIT_DIFF_ENABLE_FAST_UNTRACKED_DIRS . 16384)
            (GIT_DIFF_UPDATE_INDEX . 32768)
            (GIT_DIFF_INCLUDE_UNREADABLE . 65536)
            (GIT_DIFF_INCLUDE_UNREADABLE_AS_UNTRACKED
              .
              131072)
            (GIT_DIFF_FORCE_TEXT . 1048576)
            (GIT_DIFF_FORCE_BINARY . 2097152)
            (GIT_DIFF_IGNORE_WHITESPACE . 4194304)
            (GIT_DIFF_IGNORE_WHITESPACE_CHANGE . 8388608)
            (GIT_DIFF_IGNORE_WHITESPACE_EOL . 16777216)
            (GIT_DIFF_SHOW_UNTRACKED_CONTENT . 33554432)
            (GIT_DIFF_SHOW_UNMODIFIED . 67108864)
            (GIT_DIFF_PATIENCE . 268435456)
            (GIT_DIFF_MINIMAL . 536870912)
            (GIT_DIFF_SHOW_BINARY . 1073741824)
            (GIT_DIFF_FLAG_BINARY . 1)
            (GIT_DIFF_FLAG_NOT_BINARY . 2)
            (GIT_DIFF_FLAG_VALID_ID . 4)
            (GIT_DIFF_FLAG_EXISTS . 8)
            (GIT_DELTA_UNMODIFIED . 0)
            (GIT_DELTA_ADDED . 1)
            (GIT_DELTA_DELETED . 2)
            (GIT_DELTA_MODIFIED . 3)
            (GIT_DELTA_RENAMED . 4)
            (GIT_DELTA_COPIED . 5)
            (GIT_DELTA_IGNORED . 6)
            (GIT_DELTA_UNTRACKED . 7)
            (GIT_DELTA_TYPECHANGE . 8)
            (GIT_DELTA_UNREADABLE . 9)
            (GIT_DELTA_CONFLICTED . 10)
            (GIT_DIFF_BINARY_NONE . 0)
            (GIT_DIFF_BINARY_LITERAL . 1)
            (GIT_DIFF_BINARY_DELTA . 2)
            (GIT_DIFF_LINE_CONTEXT . 32)
            (GIT_DIFF_LINE_ADDITION . 43)
            (GIT_DIFF_LINE_DELETION . 45)
            (GIT_DIFF_LINE_CONTEXT_EOFNL . 61)
            (GIT_DIFF_LINE_ADD_EOFNL . 62)
            (GIT_DIFF_LINE_DEL_EOFNL . 60)
            (GIT_DIFF_LINE_FILE_HDR . 70)
            (GIT_DIFF_LINE_HUNK_HDR . 72)
            (GIT_DIFF_LINE_BINARY . 66)
            (GIT_DIFF_FIND_BY_CONFIG . 0)
            (GIT_DIFF_FIND_RENAMES . 1)
            (GIT_DIFF_FIND_RENAMES_FROM_REWRITES . 2)
            (GIT_DIFF_FIND_COPIES . 4)
            (GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED . 8)
            (GIT_DIFF_FIND_REWRITES . 16)
            (GIT_DIFF_BREAK_REWRITES . 32)
            (GIT_DIFF_FIND_AND_BREAK_REWRITES . 48)
            (GIT_DIFF_FIND_FOR_UNTRACKED . 64)
            (GIT_DIFF_FIND_ALL . 255)
            (GIT_DIFF_FIND_IGNORE_LEADING_WHITESPACE . 0)
            (GIT_DIFF_FIND_IGNORE_WHITESPACE . 4096)
            (GIT_DIFF_FIND_DONT_IGNORE_WHITESPACE . 8192)
            (GIT_DIFF_FIND_EXACT_MATCH_ONLY . 16384)
            (GIT_DIFF_BREAK_REWRITES_FOR_RENAMES_ONLY
              .
              32768)
            (GIT_DIFF_FIND_REMOVE_UNMODIFIED . 65536)
            (GIT_DIFF_FORMAT_PATCH . 1)
            (GIT_DIFF_FORMAT_PATCH_HEADER . 2)
            (GIT_DIFF_FORMAT_RAW . 3)
            (GIT_DIFF_FORMAT_NAME_ONLY . 4)
            (GIT_DIFF_FORMAT_NAME_STATUS . 5)
            (GIT_DIFF_STATS_NONE . 0)
            (GIT_DIFF_STATS_FULL . 1)
            (GIT_DIFF_STATS_SHORT . 2)
            (GIT_DIFF_STATS_NUMBER . 4)
            (GIT_DIFF_STATS_INCLUDE_SUMMARY . 8)
            (GIT_DIFF_FORMAT_EMAIL_NONE . 0)
            (GIT_DIFF_FORMAT_EMAIL_EXCLUDE_SUBJECT_PATCH_MARKER
              .
              1)
            (GIT_CHECKOUT_NONE . 0)
            (GIT_CHECKOUT_SAFE . 1)
            (GIT_CHECKOUT_FORCE . 2)
            (GIT_CHECKOUT_RECREATE_MISSING . 4)
            (GIT_CHECKOUT_ALLOW_CONFLICTS . 16)
            (GIT_CHECKOUT_REMOVE_UNTRACKED . 32)
            (GIT_CHECKOUT_REMOVE_IGNORED . 64)
            (GIT_CHECKOUT_UPDATE_ONLY . 128)
            (GIT_CHECKOUT_DONT_UPDATE_INDEX . 256)
            (GIT_CHECKOUT_NO_REFRESH . 512)
            (GIT_CHECKOUT_SKIP_UNMERGED . 1024)
            (GIT_CHECKOUT_USE_OURS . 2048)
            (GIT_CHECKOUT_USE_THEIRS . 4096)
            (GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH . 8192)
            (GIT_CHECKOUT_SKIP_LOCKED_DIRECTORIES . 262144)
            (GIT_CHECKOUT_DONT_OVERWRITE_IGNORED . 524288)
            (GIT_CHECKOUT_CONFLICT_STYLE_MERGE . 1048576)
            (GIT_CHECKOUT_CONFLICT_STYLE_DIFF3 . 2097152)
            (GIT_CHECKOUT_DONT_REMOVE_EXISTING . 4194304)
            (GIT_CHECKOUT_DONT_WRITE_INDEX . 8388608)
            (GIT_CHECKOUT_UPDATE_SUBMODULES . 65536)
            (GIT_CHECKOUT_UPDATE_SUBMODULES_IF_CHANGED
              .
              131072)
            (GIT_CHECKOUT_NOTIFY_NONE . 0)
            (GIT_CHECKOUT_NOTIFY_CONFLICT . 1)
            (GIT_CHECKOUT_NOTIFY_DIRTY . 2)
            (GIT_CHECKOUT_NOTIFY_UPDATED . 4)
            (GIT_CHECKOUT_NOTIFY_UNTRACKED . 8)
            (GIT_CHECKOUT_NOTIFY_IGNORED . 16)
            (GIT_CHECKOUT_NOTIFY_ALL . 65535)
            (GIT_IDXENTRY_EXTENDED . 16384)
            (GIT_IDXENTRY_VALID . 32768)
            (GIT_IDXENTRY_INTENT_TO_ADD . 8192)
            (GIT_IDXENTRY_SKIP_WORKTREE . 16384)
            (GIT_IDXENTRY_EXTENDED2 . 32768)
            (GIT_IDXENTRY_EXTENDED_FLAGS . 24576)
            (GIT_IDXENTRY_UPDATE . 1)
            (GIT_IDXENTRY_REMOVE . 2)
            (GIT_IDXENTRY_UPTODATE . 4)
            (GIT_IDXENTRY_ADDED . 8)
            (GIT_IDXENTRY_HASHED . 16)
            (GIT_IDXENTRY_UNHASHED . 32)
            (GIT_IDXENTRY_WT_REMOVE . 64)
            (GIT_IDXENTRY_CONFLICTED . 128)
            (GIT_IDXENTRY_UNPACKED . 256)
            (GIT_IDXENTRY_NEW_SKIP_WORKTREE . 512)
            (GIT_INDEXCAP_IGNORE_CASE . 1)
            (GIT_INDEXCAP_NO_FILEMODE . 2)
            (GIT_INDEXCAP_NO_SYMLINKS . 4)
            (GIT_INDEXCAP_FROM_OWNER . -1)
            (GIT_INDEX_ADD_DEFAULT . 0)
            (GIT_INDEX_ADD_FORCE . 1)
            (GIT_INDEX_ADD_DISABLE_PATHSPEC_MATCH . 2)
            (GIT_INDEX_ADD_CHECK_PATHSPEC . 4)
            (GIT_INDEX_STAGE_ANY . -1)
            (GIT_INDEX_STAGE_NORMAL . 0)
            (GIT_INDEX_STAGE_ANCESTOR . 1)
            (GIT_INDEX_STAGE_OURS . 2)
            (GIT_INDEX_STAGE_THEIRS . 3)
            (GIT_MERGE_FIND_RENAMES . 1)
            (GIT_MERGE_FAIL_ON_CONFLICT . 2)
            (GIT_MERGE_SKIP_REUC . 4)
            (GIT_MERGE_NO_RECURSIVE . 8)
            (GIT_MERGE_FILE_FAVOR_NORMAL . 0)
            (GIT_MERGE_FILE_FAVOR_OURS . 1)
            (GIT_MERGE_FILE_FAVOR_THEIRS . 2)
            (GIT_MERGE_FILE_FAVOR_UNION . 3)
            (GIT_MERGE_FILE_DEFAULT . 0)
            (GIT_MERGE_FILE_STYLE_MERGE . 1)
            (GIT_MERGE_FILE_STYLE_DIFF3 . 2)
            (GIT_MERGE_FILE_SIMPLIFY_ALNUM . 4)
            (GIT_MERGE_FILE_IGNORE_WHITESPACE . 8)
            (GIT_MERGE_FILE_IGNORE_WHITESPACE_CHANGE . 16)
            (GIT_MERGE_FILE_IGNORE_WHITESPACE_EOL . 32)
            (GIT_MERGE_FILE_DIFF_PATIENCE . 64)
            (GIT_MERGE_FILE_DIFF_MINIMAL . 128)
            (GIT_MERGE_ANALYSIS_NONE . 0)
            (GIT_MERGE_ANALYSIS_NORMAL . 1)
            (GIT_MERGE_ANALYSIS_UP_TO_DATE . 2)
            (GIT_MERGE_ANALYSIS_FASTFORWARD . 4)
            (GIT_MERGE_ANALYSIS_UNBORN . 8)
            (GIT_MERGE_PREFERENCE_NONE . 0)
            (GIT_MERGE_PREFERENCE_NO_FASTFORWARD . 1)
            (GIT_MERGE_PREFERENCE_FASTFORWARD_ONLY . 2)
            (GIT_DIRECTION_FETCH . 0)
            (GIT_DIRECTION_PUSH . 1)
            (GIT_CERT_SSH_MD5 . 1)
            (GIT_CERT_SSH_SHA1 . 2)
            (GIT_CREDTYPE_USERPASS_PLAINTEXT . 1)
            (GIT_CREDTYPE_SSH_KEY . 2)
            (GIT_CREDTYPE_SSH_CUSTOM . 4)
            (GIT_CREDTYPE_DEFAULT . 8)
            (GIT_CREDTYPE_SSH_INTERACTIVE . 16)
            (GIT_CREDTYPE_USERNAME . 32)
            (GIT_CREDTYPE_SSH_MEMORY . 64)
            (GIT_PACKBUILDER_ADDING_OBJECTS . 0)
            (GIT_PACKBUILDER_DELTAFICATION . 1)
            (GIT_PROXY_NONE . 0)
            (GIT_PROXY_AUTO . 1)
            (GIT_PROXY_SPECIFIED . 2)
            (GIT_REMOTE_COMPLETION_DOWNLOAD . 0)
            (GIT_REMOTE_COMPLETION_INDEXING . 1)
            (GIT_REMOTE_COMPLETION_ERROR . 2)
            (GIT_FETCH_PRUNE_UNSPECIFIED . 0)
            (GIT_FETCH_PRUNE . 1)
            (GIT_FETCH_NO_PRUNE . 2)
            (GIT_REMOTE_DOWNLOAD_TAGS_UNSPECIFIED . 0)
            (GIT_REMOTE_DOWNLOAD_TAGS_AUTO . 1)
            (GIT_REMOTE_DOWNLOAD_TAGS_NONE . 2)
            (GIT_REMOTE_DOWNLOAD_TAGS_ALL . 3)
            (GIT_CLONE_LOCAL_AUTO . 0)
            (GIT_CLONE_LOCAL . 1)
            (GIT_CLONE_NO_LOCAL . 2)
            (GIT_CLONE_LOCAL_NO_LINKS . 3)
            (GIT_CONFIG_LEVEL_PROGRAMDATA . 1)
            (GIT_CONFIG_LEVEL_SYSTEM . 2)
            (GIT_CONFIG_LEVEL_XDG . 3)
            (GIT_CONFIG_LEVEL_GLOBAL . 4)
            (GIT_CONFIG_LEVEL_LOCAL . 5)
            (GIT_CONFIG_LEVEL_APP . 6)
            (GIT_CONFIG_HIGHEST_LEVEL . -1)
            (GIT_CVAR_FALSE . 0)
            (GIT_CVAR_TRUE . 1)
            (GIT_CVAR_INT32 . 2)
            (GIT_CVAR_STRING . 3)
            (GIT_DESCRIBE_DEFAULT . 0)
            (GIT_DESCRIBE_TAGS . 1)
            (GIT_DESCRIBE_ALL . 2)
            (GIT_OK . 0)
            (GIT_ERROR . -1)
            (GIT_ENOTFOUND . -3)
            (GIT_EEXISTS . -4)
            (GIT_EAMBIGUOUS . -5)
            (GIT_EBUFS . -6)
            (GIT_EUSER . -7)
            (GIT_EBAREREPO . -8)
            (GIT_EUNBORNBRANCH . -9)
            (GIT_EUNMERGED . -10)
            (GIT_ENONFASTFORWARD . -11)
            (GIT_EINVALIDSPEC . -12)
            (GIT_ECONFLICT . -13)
            (GIT_ELOCKED . -14)
            (GIT_EMODIFIED . -15)
            (GIT_EAUTH . -16)
            (GIT_ECERTIFICATE . -17)
            (GIT_EAPPLIED . -18)
            (GIT_EPEEL . -19)
            (GIT_EEOF . -20)
            (GIT_EINVALID . -21)
            (GIT_EUNCOMMITTED . -22)
            (GIT_EDIRECTORY . -23)
            (GIT_EMERGECONFLICT . -24)
            (GIT_PASSTHROUGH . -30)
            (GIT_ITEROVER . -31)
            (GIT_RETRY . -32)
            (GIT_EMISMATCH . -33)
            (GITERR_NONE . 0)
            (GITERR_NOMEMORY . 1)
            (GITERR_OS . 2)
            (GITERR_INVALID . 3)
            (GITERR_REFERENCE . 4)
            (GITERR_ZLIB . 5)
            (GITERR_REPOSITORY . 6)
            (GITERR_CONFIG . 7)
            (GITERR_REGEX . 8)
            (GITERR_ODB . 9)
            (GITERR_INDEX . 10)
            (GITERR_OBJECT . 11)
            (GITERR_NET . 12)
            (GITERR_TAG . 13)
            (GITERR_TREE . 14)
            (GITERR_INDEXER . 15)
            (GITERR_SSL . 16)
            (GITERR_SUBMODULE . 17)
            (GITERR_THREAD . 18)
            (GITERR_STASH . 19)
            (GITERR_CHECKOUT . 20)
            (GITERR_FETCHHEAD . 21)
            (GITERR_MERGE . 22)
            (GITERR_SSH . 23)
            (GITERR_FILTER . 24)
            (GITERR_REVERT . 25)
            (GITERR_CALLBACK . 26)
            (GITERR_CHERRYPICK . 27)
            (GITERR_DESCRIBE . 28)
            (GITERR_REBASE . 29)
            (GITERR_FILESYSTEM . 30)
            (GITERR_PATCH . 31)
            (GITERR_WORKTREE . 32)
            (GITERR_SHA1 . 33)
            (GIT_FILTER_TO_WORKTREE . 0)
            (GIT_FILTER_SMUDGE . 0)
            (GIT_FILTER_TO_ODB . 1)
            (GIT_FILTER_CLEAN . 1)
            (GIT_FILTER_DEFAULT . 0)
            (GIT_FILTER_ALLOW_UNSAFE . 1)
            (GIT_STREAM_RDONLY . 2)
            (GIT_STREAM_WRONLY . 4)
            (GIT_STREAM_RW . 6)
            (GIT_PATHSPEC_DEFAULT . 0)
            (GIT_PATHSPEC_IGNORE_CASE . 1)
            (GIT_PATHSPEC_USE_CASE . 2)
            (GIT_PATHSPEC_NO_GLOB . 4)
            (GIT_PATHSPEC_NO_MATCH_ERROR . 8)
            (GIT_PATHSPEC_FIND_FAILURES . 16)
            (GIT_PATHSPEC_FAILURES_ONLY . 32)
            (GIT_REBASE_OPERATION_PICK . 0)
            (GIT_REBASE_OPERATION_REWORD . 1)
            (GIT_REBASE_OPERATION_EDIT . 2)
            (GIT_REBASE_OPERATION_SQUASH . 3)
            (GIT_REBASE_OPERATION_FIXUP . 4)
            (GIT_REBASE_OPERATION_EXEC . 5)
            (GIT_RESET_SOFT . 1)
            (GIT_RESET_MIXED . 2)
            (GIT_RESET_HARD . 3)
            (GIT_REVPARSE_SINGLE . 1)
            (GIT_REVPARSE_RANGE . 2)
            (GIT_REVPARSE_MERGE_BASE . 4)
            (GIT_SORT_NONE . 0)
            (GIT_SORT_TOPOLOGICAL . 1)
            (GIT_SORT_TIME . 2)
            (GIT_SORT_REVERSE . 4)
            (GIT_STASH_DEFAULT . 0)
            (GIT_STASH_KEEP_INDEX . 1)
            (GIT_STASH_INCLUDE_UNTRACKED . 2)
            (GIT_STASH_INCLUDE_IGNORED . 4)
            (GIT_STASH_APPLY_DEFAULT . 0)
            (GIT_STASH_APPLY_REINSTATE_INDEX . 1)
            (GIT_STASH_APPLY_PROGRESS_NONE . 0)
            (GIT_STASH_APPLY_PROGRESS_LOADING_STASH . 1)
            (GIT_STASH_APPLY_PROGRESS_ANALYZE_INDEX . 2)
            (GIT_STASH_APPLY_PROGRESS_ANALYZE_MODIFIED . 3)
            (GIT_STASH_APPLY_PROGRESS_ANALYZE_UNTRACKED . 4)
            (GIT_STASH_APPLY_PROGRESS_CHECKOUT_UNTRACKED . 5)
            (GIT_STASH_APPLY_PROGRESS_CHECKOUT_MODIFIED . 6)
            (GIT_STASH_APPLY_PROGRESS_DONE . 7)
            (GIT_STATUS_CURRENT . 0)
            (GIT_STATUS_INDEX_NEW . 1)
            (GIT_STATUS_INDEX_MODIFIED . 2)
            (GIT_STATUS_INDEX_DELETED . 4)
            (GIT_STATUS_INDEX_RENAMED . 8)
            (GIT_STATUS_INDEX_TYPECHANGE . 16)
            (GIT_STATUS_WT_NEW . 128)
            (GIT_STATUS_WT_MODIFIED . 256)
            (GIT_STATUS_WT_DELETED . 512)
            (GIT_STATUS_WT_TYPECHANGE . 1024)
            (GIT_STATUS_WT_RENAMED . 2048)
            (GIT_STATUS_WT_UNREADABLE . 4096)
            (GIT_STATUS_IGNORED . 16384)
            (GIT_STATUS_CONFLICTED . 32768)
            (GIT_STATUS_SHOW_INDEX_AND_WORKDIR . 0)
            (GIT_STATUS_SHOW_INDEX_ONLY . 1)
            (GIT_STATUS_SHOW_WORKDIR_ONLY . 2)
            (GIT_STATUS_OPT_INCLUDE_UNTRACKED . 1)
            (GIT_STATUS_OPT_INCLUDE_IGNORED . 2)
            (GIT_STATUS_OPT_INCLUDE_UNMODIFIED . 4)
            (GIT_STATUS_OPT_EXCLUDE_SUBMODULES . 8)
            (GIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS . 16)
            (GIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH . 32)
            (GIT_STATUS_OPT_RECURSE_IGNORED_DIRS . 64)
            (GIT_STATUS_OPT_RENAMES_HEAD_TO_INDEX . 128)
            (GIT_STATUS_OPT_RENAMES_INDEX_TO_WORKDIR . 256)
            (GIT_STATUS_OPT_SORT_CASE_SENSITIVELY . 512)
            (GIT_STATUS_OPT_SORT_CASE_INSENSITIVELY . 1024)
            (GIT_STATUS_OPT_RENAMES_FROM_REWRITES . 2048)
            (GIT_STATUS_OPT_NO_REFRESH . 4096)
            (GIT_STATUS_OPT_UPDATE_INDEX . 8192)
            (GIT_STATUS_OPT_INCLUDE_UNREADABLE . 16384)
            (GIT_STATUS_OPT_INCLUDE_UNREADABLE_AS_UNTRACKED
              .
              32768)
            (GIT_SUBMODULE_STATUS_IN_HEAD . 1)
            (GIT_SUBMODULE_STATUS_IN_INDEX . 2)
            (GIT_SUBMODULE_STATUS_IN_CONFIG . 4)
            (GIT_SUBMODULE_STATUS_IN_WD . 8)
            (GIT_SUBMODULE_STATUS_INDEX_ADDED . 16)
            (GIT_SUBMODULE_STATUS_INDEX_DELETED . 32)
            (GIT_SUBMODULE_STATUS_INDEX_MODIFIED . 64)
            (GIT_SUBMODULE_STATUS_WD_UNINITIALIZED . 128)
            (GIT_SUBMODULE_STATUS_WD_ADDED . 256)
            (GIT_SUBMODULE_STATUS_WD_DELETED . 512)
            (GIT_SUBMODULE_STATUS_WD_MODIFIED . 1024)
            (GIT_SUBMODULE_STATUS_WD_INDEX_MODIFIED . 2048)
            (GIT_SUBMODULE_STATUS_WD_WD_MODIFIED . 4096)
            (GIT_SUBMODULE_STATUS_WD_UNTRACKED . 8192)
            (GIT_PATH_MAX . 4096)
            (GIT_OID_HEX_ZERO
              .
              "0000000000000000000000000000000000000000")
            (GIT_OID_RAWSZ . 20)
            (GIT_OID_MINPREFIXLEN . 4)
            (GIT_REPOSITORY_INIT_OPTIONS_VERSION . 1)
            (GIT_ATTR_CHECK_FILE_THEN_INDEX . 0)
            (GIT_ATTR_CHECK_INDEX_THEN_FILE . 1)
            (GIT_ATTR_CHECK_INDEX_ONLY . 2)
            (GIT_BLAME_OPTIONS_VERSION . 1)
            (GIT_DIFF_OPTIONS_VERSION . 1)
            (GIT_DIFF_HUNK_HEADER_SIZE . 128)
            (GIT_DIFF_FIND_OPTIONS_VERSION . 1)
            (GIT_DIFF_FORMAT_EMAIL_OPTIONS_VERSION . 1)
            (GIT_CHECKOUT_OPTIONS_VERSION . 1)
            (GIT_IDXENTRY_STAGESHIFT . 12)
            (GIT_MERGE_FILE_INPUT_VERSION . 1)
            (GIT_MERGE_FILE_OPTIONS_VERSION . 1)
            (GIT_MERGE_OPTIONS_VERSION . 1)
            (GIT_CHERRYPICK_OPTIONS_VERSION . 1)
            (GIT_DEFAULT_PORT . "9418")
            (GIT_PROXY_OPTIONS_VERSION . 1)
            (GIT_REMOTE_CALLBACKS_VERSION . 1)
            (GIT_FETCH_OPTIONS_VERSION . 1)
            (GIT_PUSH_OPTIONS_VERSION . 1)
            (GIT_CLONE_OPTIONS_VERSION . 1)
            (GIT_DESCRIBE_DEFAULT_MAX_CANDIDATES_TAGS . 10)
            (GIT_DESCRIBE_DEFAULT_ABBREVIATED_SIZE . 7)
            (GIT_DESCRIBE_OPTIONS_VERSION . 1)
            (GIT_DESCRIBE_FORMAT_OPTIONS_VERSION . 1)
            (GIT_REBASE_OPTIONS_VERSION . 1)
            (GIT_REVERT_OPTIONS_VERSION . 1)
            (GIT_STASH_APPLY_OPTIONS_VERSION . 1)
            (GIT_STATUS_OPTIONS_VERSION . 1)
            (GIT_SUBMODULE_STATUS__IN_FLAGS . 15)
            (GIT_SUBMODULE_STATUS__INDEX_FLAGS . 112)
            (GIT_SUBMODULE_STATUS__WD_FLAGS . 16256)
            (GIT_SUBMODULE_UPDATE_OPTIONS_VERSION . 1)
            (LIBGIT2_VERSION . "0.26.0")
            (LIBGIT2_VER_MAJOR . 0)
            (LIBGIT2_VER_MINOR . 26)
            (LIBGIT2_VER_REVISION . 0)
            (LIBGIT2_VER_PATCH . 0)
            (LIBGIT2_SOVERSION . 26))))
    (lambda (k) (assq-ref sym-tab k))))
(export ffi-libgit2-symbol-val)

(define (unwrap-enum obj)
  (cond ((number? obj) obj)
        ((symbol? obj) (ffi-libgit2-symbol-val obj))
        ((fh-object? obj) (struct-ref obj 0))
        (else (error "type mismatch"))))

(define ffi-libgit2-types
  '("git_odb" "git_odb_backend" "git_odb_object" "git_odb_stream" 
    "git_odb_writepack" "git_refdb" "git_refdb_backend" "git_repository" 
    "git_worktree" "git_object" "git_revwalk" "git_tag" "git_blob" 
    "git_commit" "git_tree_entry" "git_tree" "git_treebuilder" "git_index" 
    "git_index_conflict_iterator" "git_config" "git_config_backend" 
    "git_reflog_entry" "git_reflog" "git_note" "git_packbuilder" (struct . 
    "git_time") "git_time" (struct . "git_signature") "git_signature" 
    "git_reference" "git_reference_iterator" "git_transaction" 
    "git_annotated_commit" "git_merge_result" "git_status_list" "git_rebase" 
    "git_refspec" "git_remote" "git_transport" "git_push" "git_remote_head" 
    "git_remote_callbacks" (struct . "git_transfer_progress") 
    "git_transfer_progress" "git_cert" "git_submodule" "git_writestream" (
    struct . "git_writestream") (struct . "git_oid") "git_oid" 
    "git_oid_shorten" "git_buf" "git_repository_init_options" (struct . 
    "git_blame_options") "git_blame_options" (struct . "git_blame_hunk") 
    "git_blame_hunk" "git_blame" "git_branch_iterator" "git_tree_update" (
    struct . "git_strarray") "git_strarray" "git_diff" "git_diff_file" 
    "git_diff_delta" "git_diff_options" "git_diff_binary_file" 
    "git_diff_binary" "git_diff_hunk" "git_diff_line" 
    "git_diff_similarity_metric" "git_diff_find_options" "git_diff_stats" 
    "git_diff_format_email_options" "git_checkout_perfdata" (struct . 
    "git_checkout_options") "git_checkout_options" (struct . "git_oidarray") 
    "git_oidarray" "git_indexer" "git_index_time" (struct . "git_index_entry")
    "git_index_entry" "git_merge_file_input" "git_merge_file_options" 
    "git_merge_file_result" "git_merge_options" "git_cherrypick_options" (
    struct . "git_remote_head") "git_cert_hostkey" "git_cert_x509" "git_cred" 
    (struct . "git_cred") "git_cred_userpass_plaintext" "LIBSSH2_SESSION" 
    "LIBSSH2_USERAUTH_KBDINT_PROMPT" "LIBSSH2_USERAUTH_KBDINT_RESPONSE" (
    struct . "git_cred_ssh_key") "git_cred_ssh_key" (struct . 
    "git_cred_ssh_interactive") "git_cred_ssh_interactive" (struct . 
    "git_cred_ssh_custom") "git_cred_ssh_custom" "git_cred_default" (struct . 
    "git_cred_username") "git_cred_username" "git_proxy_options" 
    "git_push_update" (struct . "git_remote_callbacks") "git_fetch_options" 
    "git_push_options" (struct . "git_clone_options") "git_clone_options" (
    struct . "git_config_entry") "git_config_entry" "git_config_iterator" 
    "git_cvar_map" (struct . "git_describe_options") "git_describe_options" 
    "git_describe_format_options" "git_describe_result" "git_error" 
    "git_filter" "git_filter_list" "git_note_iterator" (struct . 
    "git_odb_expand_id") "git_odb_expand_id" (struct . "git_odb_stream") (
    struct . "git_odb_writepack") "git_patch" "git_pathspec" 
    "git_pathspec_match_list" "git_rebase_options" "git_rebase_operation" 
    "git_revert_options" "git_revspec" (struct . "git_stash_apply_options") 
    "git_stash_apply_options" "git_status_options" "git_status_entry" (struct 
    . "git_submodule_update_options") "git_submodule_update_options"))
;;(export ffi-libgit2types)

(define git_repository**-desc
  (bs:pointer git_repository*-desc))

(define-fh-pointer-type
  git_repository**
  git_repository**-desc)

(ref<->deref! git_repository** git_repository*)

;; --- last line ---
