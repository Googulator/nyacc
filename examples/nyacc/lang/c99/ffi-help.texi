\input texinfo.tex
@setfilename ffi-help.info
@settitle FFI Helper for Guile

@copying
Copyright (C) 2017 -- Matthew R. Wette.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included with the distribution as COPYING.DOC.
@end copying

@headings off
@everyfooting @| @thispage @|
@alias section = heading
@alias subsection = subheading
@alias subsubsection = subsubheading

@node Top
@top FFI Helper for Guile
@format
Matt Wette
July 2017
Version $Id$
@end format

@section Introduction

The acronym FFI stands for ``Foreign Function Interface''.  It is the
Guile system for binding functions and variables from C source libraries 
into guild programs.

The compiler is based on the C99 parser and utilities which are
include in the @uref{https://www.nongnu.org/nyacc/,@sc{NYACC}}
package.  Development is currently being performed in the
@code{c99dev} branch of the associated git repository.  Within the
@sc{NYACC} distribution, the FFI-helper modules can be found in the
directory @file{examples/nyacc/lang/c99/}.

Use of the FFI-helper module depends on the
@uref{https://github.com/TaylanUB/scheme-bytestructures,scheme-bytestrucures}
module.

@subsection Current Assumptions

Here is a list of assumptions
@enumerate
@item
no raw aggregates get passed to C functions
@end enumerate

@subsection Caveats

@enumerate
@item
Forward references are handled by lookup.
@item
Function pointer types as fields in structures are just turned into
pointers to @code{intptr_t}.
@item
How the hell do I deal with varargs?  Skip for now.
@end enumerate

@section Demonstration

The FFI Helper may best be introduced through a small example.
For our example we use the Cairo library.  This example assumes Cairo
is installed on the system and the associated @emph{pkg-config}
support is present.

WARNING: The FFI-helper package is under active development and there
is good chance the following example will cease to work in the future.

We start by genererating, in a directory called @file{cairo}, a file named
@file{cairo.ffi} with the following contents:
@example
(define-ffi-module (cairo cairo)
  #:pkg-config "cairo"
  #:include '("cairo.h" "cairo-pdf.h" "cairo-svg.h")
  #:export (make-cairo-unit-matrix))

(define (make-cairo-unit-matrix)
  (make-cairo_matrix_t #(1.0 0.0 0.0 1.0 0.0 0.0)))
@end example

Now to generate a Guile module you use @code{guild} as follows:
@example
$ guild compile-ffi cairo/cairo.ffi
@end example
@noindent
The above command execution will generate the file
@file{cairo/cairo.scm}.  Though the file @file{cairo/cairo.ffi} is
only seven lines long, the file 
@file{cairo/cairo.scm} will be over five thousand lines long.  It looks
like the following:
@example
(define-module (cairo cairo)
  #:export (make-cairo-unit-matrix)
  #:use-module (system ffi-help-rt)
  #:use-module ((system foreign) #:prefix ffi:)
  #:use-module (bytestructures guile)
  )
(define link-lib (dynamic-link "libcairo")
(define (lib-func name) (dynamic-func name link-lib))

;; int cairo_version(void);
(define cairo_version
  (let ((f (ffi:pointer->procedure
             ffi:int
             (lib-func "cairo_version")
             (list))))
    (lambda () (let () (f)))))
(export cairo_version)

@dots{} @i{many, many more declarations} @dots{}

(define cairo-lookup
  (let ((sym-tab
          '((CAIRO_VERSION_STRING . "1.14.10")
            @dots{}
            (CAIRO_SVG_VERSION_1_2 . 2))))
    (lambda (k) (assq-ref sym-tab k))))
(export cairo-lookup)

(define (make-cairo-unit-matrix)
  (make-cairo_matrix_t #(1.0 0.0 0.0 1.0 0.0 0.0)))
@end example

Notice that the helper generated a function @code{cairo-lookup} to
provide values for all @code{#define}'d symbols and @code{enum}
values.  In addition, the @code{#:export} option and scheme definition
provided in the dot-ffi file were copied into associated scm-file.

To execute an example, let's fire up Guile and execute some code:
@example
scheme@@(guile-user)> (use-modules (cairo cairo-svg))
scheme@@(guile-user)> (use-modules (system ffi-help-rt))
scheme@@(guile-user)> (use-modules (system foreign))

scheme@@(guile-user)> (define srf (cairo_svg_surface_create (string->pointer "abc.svg") 200.0 200.0))
scheme@@(guile-user)> srf
$1 = #<cairo_surface_t* 0x7f9997d0cd40>

scheme@@(guile-user)> (define cr (cairo_create srf))
scheme@@(guile-user)> cr
$2 = #<cairo_t* 0x7f9999809e00>

scheme@@(guile-user)> (define mx (make-cairo_matrix_t))
scheme@@(guile-user)> mx
$3 = #<cairo_matrix_t 0x10aac4fa0>

scheme@@(guile-user)> (pointer-to mx)                           
$4 = #<cairo_matrix_t* 0x10aac4fa0>

scheme@@(guile-user)> (cairo_get_font_matrix cr (pointer-to mx))
scheme@@(guile-user)>

scheme@@(guile-user)> (cairo_move_to cr 10.0 10.0)
scheme@@(guile-user)> (cairo_line_to cr 190.0 10.0)
scheme@@(guile-user)> (cairo_line_to cr 190.0 190.0)
scheme@@(guile-user)> (cairo_line_to cr 10.0 190.0)
scheme@@(guile-user)> (cairo_line_to cr 10.0 10.0)
scheme@@(guile-user)> (cairo_stroke cr)

scheme@@(guile-user)> (cairo_destroy cr)
scheme@@(guile-user)> (cairo_surface_destroy srf)
@end example
The above example should generate an SVG file @file{abc.svg}.
The call to @code{cairo_get_font_matrix} was not needed: it was
provided to illustrate the use of @code{pointer-to}: a C function 
which expects to receive a pointer to an allocated struct of type
@code{cairo_matrix_t}.


@section Creating FFI Modules

@example
  #:library '("libcairo" "libmisc")
  #:inc-dirs '("/opt/local/include/cairo" "/opt/local/include")
  #:renamer (string-renamer
	     (lambda (n)
	       (if (string=? "cairo" (substring n 0 5)) n
		   (string-append "cairo-" n))))
  #:pkg-config "cairo"
  #:include '("cairo.h" "cairo-svg.h")
  #:inc-help (cond
              ((string-contains %host-type "darwin")
               '(("__builtin" "__builtin_va_list=void*")
                 ("sys/cdefs.h" "__DARWIN_ALIAS(X)=")))
              (else '()))
  #:decl-filter (string-member-proc
  		 "cairo_t" "cairo_status_t" "cairo_surface_t"
                 "cairo_create" "cairo_svg_surface_create"
                 "cairo_destroy" "cairo_surface_destroy")
  #:export (make-cairo-unit-matrix)
@end example

Another decl-filter, useful for debugging.
@example
  #:decl-filter (lambda (k)
                  (cond
                   ((member k '(
                                "cairo_t" "cairo_status_t"
                                "cairo_glyph_t" "cairo_path_data_t"
				)) #t)
                   ((equal? k '(union . "union-_cairo_glyph_t")) #t)
                   (else #f)))
@end example
                   
@section The Guile Foreign Function Interface

@subsection Function Calls

There are two parts to calling functions.  The first is to declare a
function from the C-function address, the C-function argument types
and the C-function return type.  The second is to call the
function.  Scheme does not have the same type system as C and the
Guile FFI is forgiving here.   When we declare a C function interface
with, say, an int32 argument type, Guile expects us to pass a possibly
negative TBD type. [TODO Figure out what Guile really does wrt
C-Scheme type validity and conversion.

@section Bytestructure Function Type
We need to add bytestructure function (pointer) type.  Now C is a bit
odd about function and function pointers.  They are treated as the
same.  We will work functions as follows, where @code{f-bs} represents
a pointer to a function bytestructure 
@example
(fh-object-ref f-bs) => #<pointer ...>
(fh-object-ref f-bs '*) => #<procedure ...>
@end example
@noindent
On the other hand, setters can take either.  Any of these will get
the desired behavior:
@example
(fh-object-set! f-bs #<pointer ...>)
(fh-object-set! f-bs #<number>) ;; aka pointer-address
(fh-object-set! f-bs #<procedure ...>)
@end example
@noindent
We still have to deal with @code{ref<->deref!}.  I think this should
be self referencing.  That is
@example
(pointer-to f-bs) => f-bs
@end example

This descriptor includes fields
@enumerate
@item return descriptor
@item parameter list
@end enumerate
@noindent
Elements of parameter list may be
@itemize
@item descriptor
@item a pair: symbolic name and descriptor
@item the ellipsis symbol: @code{'...}
@end itemize

When @code{bs:function} is called to create a descriptor, either the
descriptor for the return type, or the list of descriptors for the
parameters can be a promise.  That is
@example
(define f-desc (bs:function (delay ret-desc) (delay (list int xxx xxx))))
@end example
@noindent

@section The Type System

Explain why in Scheme we need to have distinct pointer types!  And
then explain how we deal with them: type => define type*.
expand-typerefs will not expand pointer types if

We want a closed type system with accessors and setters.  We rely on
@emph{bytestrutures} for compound types, vectors, etc.  For base C
types we will keep xxx.  Enums are a speial case.
Let use the following convention
@table @code
@item objS
FH object with scheme type representation
@item objB
FH object with underying bytestructure representation
@item valGS
A Guile Scheme value: number, xxx
@item valGP
A Guile Pointer (@code{#<pointer ...>})
@item valBS
A bytestructure: @code{#<bytestructure ...>}.
@item valBV
A bytevector @code{#<bytevector ...>}.
@end table
@noindent
There will be FH types for structs, unions, vectors, pointers, but not
for enums, scalar integer or floating types.  Strings will be handled
as pointers.

Consider working with the following C types
@table @code
@item foo_t
a compount type
@item bar_t
a typedef for a doulble
@item int
base type
@item who_t
an enum
@end table

The user use cases are generate variable
@itemize
@item
Generate type w/ any content:
@code{(make foo_t)}
@item

@code{(make foo_t objGS)}
@item
@code{(make foo_t objBS)}
@end itemize

@itemize
@item
Pass pointer to data to C function:
@example
(define v (make-double))
(c_funtion (pointer-to v))
(fh-object-ref v) => number
@end example
@end itemize

@code{bar_t} that is a @code{double} and an enum type @code{baz_t}.
In the items below, @code{foo_t} is a type and @code{bar} is a wrap/unwrap.
@itemize
@item
(make-foo_t) => #<foo_t valS> | #<foo_t valX>
@item
(make-foo_t valS) => #<foo_t valS|valX>
@item
(fh-object-ref objS) => valS
@item
(fh-object-ref objX) => valX
@item
(fh-object-ref objX 'sel) => valX | valS
@end itemize
@noindent
We need a (somewhat?) closed type system.  In the FFI Helper we choose
to classify the following
@table @asis
@item compound
structs, unions and arrays (Scheme does not have arrays)
@item simple
fixed and float scalars
@item special
special are enums and pointers
@end table

The FFI Helper uses the Guile struct-vtable constructs to deal with
types.  In addition to the builtin name and printer fields, each type
includes
@table @asis
@item wrapper
a procedure to convert a (raw) Scheme object into a FH type
@item un-wrapper
(sloppy) procedure to convert a FH type (or simpilar) into a (raw)
scheme object
@item pointer-to
the FH type describing a pointer to this type, or @code{#f}
@item points-to
the FH type describing the dereferened pointer type, or @code{#f}
@end table

Think of wrapper as @code{ffi->scm} and unwrapper as @code{scm->ffi}.

@itemize
@item
For vectors, structs and unions the raw Scheme object type is
`bytevector'.
@item
For numeric types, the raw Scheme object type is a Scheme numeric type.
@end itemize

@subsection Support for Aggregate Types

As mentioned @code{scheme-bytestructures} is used to support structs
and unions.  Here is a segment of generated code to illustrate:
@example
;; typedef union _cairo_path_data_t cairo_path_data_t;
;; union _cairo_path_data_t @{
;;   struct @{
;;     cairo_path_data_type_t type;
;;     int length;
;;   @} header;
;;   struct @{
;;     double x, y;
;;   @} point;
;; @};
(define union-_cairo_path_data_t-desc
  (bs:union
    (list `(header
             ,(bs:struct
                (list `(type ,cairo_path_data_type_t-desc)
                      `(length ,int))))
          `(point ,(bs:struct (list `(y ,double) `(x ,double)))))))
(define cairo_path_data_t-desc union-_cairo_path_data_t-desc)
@end example
@noindent
Note that forward references are swapped around.

@subsubsection forward references

Here we do it but store @code{GObject} 
@example
;; typedef struct _GObject GObject;
(define-public GObject-desc 'void)
(define-public GObject*-desc (bs:pointer (delay GObject-desc)))
(define-fh-pointer-type GObject* GObject*-desc GObject*? make-GObject*)
(export GObject* GObject*? make-GObject*)
@end example

@example
;; typedef struct _GObject GInitiallyUnowned;
(define-public GInitiallyUnowned-desc 'void)
(define-public GInitiallyUnowned*-desc
  (bs:pointer (delay GInitiallyUnowned-desc)))
(define-fh-pointer-type GInitiallyUnowned* GInitiallyUnowned*-desc 
                        GInitiallyUnowned*? make-GInitiallyUnowned*)
(export GInitiallyUnowned* GInitiallyUnowned*? make-GInitiallyUnowned*)
@end example

@example
;; struct _GObject {
;;   GTypeInstance g_type_instance;
;;   /*< private >*/
;;   volatile guint ref_count;
;;   GData *qdata;
;; };
(define-public struct-_GObject-desc
  (bs:struct
    (list `(g_type_instance ,GTypeInstance-desc)
          `(ref_count ,unsigned-int)
          `(qdata ,(bs:pointer GData-desc)))))
(define-fh-compound-type struct-_GObject struct-_GObject-desc struct-_GObject?
 make-struct-_GObject)
(export struct-_GObject struct-_GObject? make-struct-_GObject)
(define-public struct-_GObject*-desc
  (bs:pointer struct-_GObject-desc))
(define-fh-pointer-type struct-_GObject* struct-_GObject*-desc 
 struct-_GObject*? make-struct-_GObject*)
(export struct-_GObject* struct-_GObject*? make-struct-_GObject*)
(ref<->deref! struct-_GObject* make-struct-_GObject*
              struct-_GObject make-struct-_GObject)
(set! GObject-desc struct-_GObject-desc)
(define-fh-compound-type GObject GObject-desc GObject? make-GObject)
(export GObject GObject? make-GObject)
@end example


@subsection Base Types

The module @code{(system ffi-help-rt)} provides types for
the following
@table @code
@item char*
string pointer
@item double*
pointer to double
@item int*
pointer to int
@item unsigned-int*
pointer to unsigned int
@end table
@noindent
These types are useful for sitaions where the corresponding types are
passed by reference as return types.  For example
@lisp
(let ((name (make-char*)))
  (some_function (pointer-to name))
  (display "name: ") (display (char*->string name)) (newline))
(let ((return-val (make-double))) ;; <= to do ???
  (another_function (pointer-to return-val))
  (simple-format #t "val is ~S\n" (fh-object-ref return-val)))
@end lisp



@subsection Type Support

For @code{bytestructures}, arguments to setters and return values
from getters are Scheme values for numerical types and bytestructures
for other types (e.g., structs and unions).

In FH C object types are either ``wrapped'' or ``defined''.  If a type
is wrapped then we provide a wrap and unwrap function for that type.
Numeric types and enum's are wrapped.  Other types are defined as FH
types.  The FH types have a wrapper and unwrapper properties.  These
properties are procedures and
can be accessed with
@code{(fht-unwrap type)} and @code{(fht-wrap type)}
or executed with
@code{(fh-unwrap object)} and @code{(fh-wrap object)}.

@deffn {Procedure} fh-type? type
This predicate tests for FH types.
@end deffn

@deffn {Procedure} fh-object? obj
This predicate tests for FH objects.
@end deffn

@deffn {Syntax} define-fh-aggregate-type name desc
@deffnx {Syntax} define-fh-aggregate-type/p name desc
@deffnx {Syntax} define-fh-aggregate-type/pp name desc
The first form generates an FY aggregate type based on a bytestructure
descriptor.  The second and third forms will build, in addition,
pointer-to type and pointer-to-pointer-to type.  The primary form
will generate and export the following:
@table @code
@item type
a Guile (vtable) struct representing the type
@item type?
a predicate to test an object to be of type
@item make
a procedure to wrap based on args provided to the @code{bytestructure}
procedure
@item wrap
same as @code{make} with one bytevector argument
@item unwrap
a procedure to produce a Scheme bytevector
@end table
@end deffn

The following shows that we can store a procedure as a bogus
bytevector.
@example
(use-modules ((system foreign) #:prefix ffi:))
(define (foo arg) arg)
(define foo-ptr (ffi:procedure->pointer ffi:int foo (list ffi:int)))
(define foo-bv (ffi:pointer->bytevector foo-ptr (ffi:sizeof '*)))
(define foo-bv-ptr (ffi:bytevector->pointer foo-bv))
(define foo-echo (ffi:pointer->procedure ffi:int foo-bv-ptr (list ffi:int)))
@end example
@noindent
But we won't use this.

@deffn {Syntax} define-fh-enum-type name sv-map
Generate an enum type.  Exports wrap, unwrap, type? but no make.
@end deffn

@deffn {Syntax} define-fh-pointer-type name [desc]
Generate a pointer type.  With (bytestructure @code{bs:pointer})
descriptor @var{desc} generates a bytestructe-based type.  Otherwise,
generates a Guile FFI pointer based type.
@end deffn


@subsection Function Argument Return Types 

Here are the FFI simple types:
@verbatim
  short unsigned-short int unsigned-int long unsigned-long
  int8 uint8  int16 uint16 int32 uint32 uint64
  size_t ssize_t ptrdiff_t
  float double
  void
@end verbatim

Here are the BS simple types:
@verbatim
  short unsigned-short int unsigned-int long unsigned-long
  long-long unsigned-long-long
  int8 uint8  int16 uint16 int32 uint32 uint64
  size_t ssize_t ptrdiff_t intptr_t uintptr_t
  float double complex64 complex128
@end verbatim

The C standard says
@quote
A declaration of a parameter as ‘‘function returning type’’ shall be
adjusted to ‘‘pointer to function returning type.’’
@end quote
I'm guessing this goes for struct fields as well.

C says bitfields are (signed) int, unsigned int, or _Bool.

C says if function parameter declared as arrays should be interpreted
as pointers.

@example


@subsection Library Variables

Access to externs is provide through access procedure:
@example
;; C header says: extern int foo_errno;
;; So we use:
(foo_errno)
@end example

@section Miscellaneous Notes

@subsection Unwrapping and Wrapping

For functions we use @emph{unwrappers} and @emph{wrappers}.  Arguments
to a function are unwrapped before being passed to the routine
generated by @code{pointer->procedure}.  The end user will nominally not be
using these procedures.  If an argument is a pointer
to a type with a typedef (e.g., a struct type) then the type unwrapper
is called
@example
((fht-unwrap <type>) arg) => ~arg
@end example
@noindent
If the argument is not associated with a defined type (e.g., enums)
then the associated unwrapper will be called:
@example
(unwrap-enum-foo arg) => ~arg
(unwrap~float arg) => ~arg
OR
(unwrap-enum-foo 'FOO_TRUE) => 1
(unwrap~float 1) => 1.0
@end example

In @path{ffi-help.scm}, the code generator, we convert structs, unions and
their associated typedefs to defined types, but enums and enum
typedefs are only provided with unwrappers and wrappers.

@subsection Other

User is responsible for calling string->pointer and pointer->string.

By definition: wrap is c->scm; unwrap is scm->c.
 
@code{define-ffi-module} options:
@table @code
@item #:decl-filter proc
@item #:inc-filter proc
@item #:include expr
expr is string or list or procecure that evaluates to string or list
@item #:library expr
expr is string or list or procecure that evaluates to string or list
@item #:pkg-config string
@item #:renamer proc
procdure
@end table


@section Work to Go 

@table @asis
@item 02
if need foo_t pointer then I gen wrapper for foo_t* but add
foo_t to *wrappers* so if I later run into need for foo_t may be prob
@item 03
allow user to specify #:renamer (lambda (n) "make_goo" => "make-goo")
@item 04
Now the hard part if we want to reference other ffi-modules for types
or other c-routines.  Say ffi-module foo defines foo_t
now in ffi-module bar we want to reference, but redefine, foo_t
@example
(define-ffi-module (cairo cairo) ...)
(define-ffi-module (cairo cairo-svg) #:use-ffi-module (cairo cairo)
@end example
@item 05
Should setters for @code{bs:struct} enum fields check for symbolic
arg?
@item 06
Use guardians for @code{cairo_destroy} and
@code{cairo_surface_destroy}?
@item 07
What about vectors? If @code{foo(foo_t x[]},
@enumerate
@item user must make vector of foo_t
@item ffi-module author should generate a make-foo_t-vector procedure
@end enumerate
@end table

@subsection Completed
@table @asis
@item 01
@example
enum-wrap 0 => 'CAIRO_STATUS_SUCCESS
enum-unwrap 'CAIRO_STATUS_SUCCESS => 0
@end example
@end table

@section Administrative Items

@subsection Copyright

Copyright (C) 2017 -- Matthew R. Wette.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included with the distribution as COPYING.DOC.

@bye
@c --- last line ---
