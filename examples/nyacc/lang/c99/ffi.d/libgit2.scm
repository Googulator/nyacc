;; auto-generated by ffi-help.scm

(define-module (libgit2)
  #:use-module (system ffi-help-rt)
  #:use-module ((system foreign) #:prefix ffi:)
  #:use-module (bytestructures guile)
  )
(dynamic-link "git2")

;; extern int git_annotated_commit_from_ref(git_annotated_commit **out, 
;;     git_repository *repo, const git_reference *ref);
(define git_annotated_commit_from_ref
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_annotated_commit_from_ref"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (out repo ref)
      (let ((~out (unwrap~pointer out)))
        (~f ~out repo ref)))))
(export git_annotated_commit_from_ref)

;; extern int git_annotated_commit_from_fetchhead(git_annotated_commit **out, 
;;     git_repository *repo, const char *branch_name, const char *remote_url, 
;;     const git_oid *id);
(define git_annotated_commit_from_fetchhead
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_annotated_commit_from_fetchhead"
                (dynamic-link))
              (list '* '* '* '* '*))))
    (lambda (out repo branch_name remote_url id)
      (let ((~out (unwrap~pointer out))
            (~branch_name (unwrap~pointer branch_name))
            (~remote_url (unwrap~pointer remote_url)))
        (~f ~out repo ~branch_name ~remote_url id)))))
(export git_annotated_commit_from_fetchhead)

;; extern int git_annotated_commit_lookup(git_annotated_commit **out, 
;;     git_repository *repo, const git_oid *id);
(define git_annotated_commit_lookup
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_annotated_commit_lookup"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (out repo id)
      (let ((~out (unwrap~pointer out)))
        (~f ~out repo id)))))
(export git_annotated_commit_lookup)

;; extern int git_annotated_commit_from_revspec(git_annotated_commit **out, 
;;     git_repository *repo, const char *revspec);
(define git_annotated_commit_from_revspec
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_annotated_commit_from_revspec"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (out repo revspec)
      (let ((~out (unwrap~pointer out))
            (~revspec (unwrap~pointer revspec)))
        (~f ~out repo ~revspec)))))
(export git_annotated_commit_from_revspec)

;; extern const git_oid *git_annotated_commit_id(const git_annotated_commit *
;;     commit);
(define git_annotated_commit_id
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "git_annotated_commit_id"
                (dynamic-link))
              (list '*))))
    (lambda (commit) (let () (~f commit)))))
(export git_annotated_commit_id)

;; extern void git_annotated_commit_free(git_annotated_commit *commit);
(define git_annotated_commit_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "git_annotated_commit_free"
                (dynamic-link))
              (list '*))))
    (lambda (commit) (let () (~f commit)))))
(export git_annotated_commit_free)

;; typedef enum {
;;   GIT_ATTR_UNSPECIFIED_T = 0,
;;   GIT_ATTR_TRUE_T,
;;   GIT_ATTR_FALSE_T,
;;   GIT_ATTR_VALUE_T,
;; } git_attr_t;
(define-fh-enum git_attr_t
  '((GIT_ATTR_UNSPECIFIED_T . 0)
    (GIT_ATTR_TRUE_T . 1)
    (GIT_ATTR_FALSE_T . 2)
    (GIT_ATTR_VALUE_T . 3))
  )

;; extern git_attr_t git_attr_value(const char *attr);
(define git_attr_value
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_attr_value" (dynamic-link))
              (list '*))))
    (lambda (attr)
      (let ((~attr (unwrap~pointer attr)))
        (wrap-git_attr_t (~f ~attr))))))
(export git_attr_value)

;; extern int git_attr_get(const char **value_out, git_repository *repo, 
;;     uint32_t flags, const char *path, const char *name);
(define git_attr_get
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_attr_get" (dynamic-link))
              (list '* '* ffi:uint32 '* '*))))
    (lambda (value_out repo flags path name)
      (let ((~value_out (unwrap~pointer value_out))
            (~flags (unwrap-uint32_t flags))
            (~path (unwrap~pointer path))
            (~name (unwrap~pointer name)))
        (~f ~value_out repo ~flags ~path ~name)))))
(export git_attr_get)

;; extern int git_attr_get_many(const char **values_out, git_repository *repo
;;     , uint32_t flags, const char *path, size_t num_attr, const char **names
;;     );
(define git_attr_get_many
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_attr_get_many" (dynamic-link))
              (list '* '* ffi:uint32 '* ffi:size_t '*))))
    (lambda (values_out repo flags path num_attr names)
      (let ((~values_out (unwrap~pointer values_out))
            (~flags (unwrap-uint32_t flags))
            (~path (unwrap~pointer path))
            (~num_attr (unwrap-size_t num_attr))
            (~names (unwrap~pointer names)))
        (~f ~values_out
            repo
            ~flags
            ~path
            ~num_attr
            ~names)))))
(export git_attr_get_many)

;; typedef int (*git_attr_foreach_cb)(const char *name, const char *value, 
;;     void *payload);
(define-fh-function/p git_attr_foreach_cb
  ffi:int (list (quote *) (quote *) (quote *)))

;; extern int git_attr_foreach(git_repository *repo, uint32_t flags, const 
;;     char *path, git_attr_foreach_cb callback, void *payload);
(define git_attr_foreach
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_attr_foreach" (dynamic-link))
              (list '* ffi:uint32 '* '* '*))))
    (lambda (repo flags path callback payload)
      (let ((~flags (unwrap-uint32_t flags))
            (~path (unwrap~pointer path))
            (~callback (unwrap-git_attr_foreach_cb callback))
            (~payload (unwrap~pointer payload)))
        (~f repo ~flags ~path ~callback ~payload)))))
(export git_attr_foreach)

;; extern void git_attr_cache_flush(git_repository *repo);
(define git_attr_cache_flush
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "git_attr_cache_flush"
                (dynamic-link))
              (list '*))))
    (lambda (repo) (let () (~f repo)))))
(export git_attr_cache_flush)

;; extern int git_attr_add_macro(git_repository *repo, const char *name, const
;;      char *values);
(define git_attr_add_macro
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_attr_add_macro"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (repo name values)
      (let ((~name (unwrap~pointer name))
            (~values (unwrap~pointer values)))
        (~f repo ~name ~values)))))
(export git_attr_add_macro)

;; extern int git_blob_lookup(git_blob **blob, git_repository *repo, const 
;;     git_oid *id);
(define git_blob_lookup
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_blob_lookup" (dynamic-link))
              (list '* '* '*))))
    (lambda (blob repo id)
      (let ((~blob (unwrap~pointer blob)))
        (~f ~blob repo id)))))
(export git_blob_lookup)

;; extern int git_blob_lookup_prefix(git_blob **blob, git_repository *repo, 
;;     const git_oid *id, size_t len);
(define git_blob_lookup_prefix
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_blob_lookup_prefix"
                (dynamic-link))
              (list '* '* '* ffi:size_t))))
    (lambda (blob repo id len)
      (let ((~blob (unwrap~pointer blob))
            (~len (unwrap-size_t len)))
        (~f ~blob repo id ~len)))))
(export git_blob_lookup_prefix)

;; extern void git_blob_free(git_blob *blob);
(define git_blob_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "git_blob_free" (dynamic-link))
              (list '*))))
    (lambda (blob) (let () (~f blob)))))
(export git_blob_free)

;; extern const git_oid *git_blob_id(const git_blob *blob);
(define git_blob_id
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "git_blob_id" (dynamic-link))
              (list '*))))
    (lambda (blob) (let () (~f blob)))))
(export git_blob_id)

;; extern git_repository *git_blob_owner(const git_blob *blob);
(define git_blob_owner
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "git_blob_owner" (dynamic-link))
              (list '*))))
    (lambda (blob) (let () (~f blob)))))
(export git_blob_owner)

;; extern const void *git_blob_rawcontent(const git_blob *blob);
(define git_blob_rawcontent
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "git_blob_rawcontent"
                (dynamic-link))
              (list '*))))
    (lambda (blob) (let () (~f blob)))))
(export git_blob_rawcontent)

;; extern git_off_t git_blob_rawsize(const git_blob *blob);
(define git_blob_rawsize
  (let ((~f (ffi:pointer->procedure
              ffi:int64
              (dynamic-func "git_blob_rawsize" (dynamic-link))
              (list '*))))
    (lambda (blob) (let () (wrap-int64_t (~f blob))))))
(export git_blob_rawsize)

;; extern int git_blob_filtered_content(git_buf *out, git_blob *blob, const 
;;     char *as_path, int check_for_binary_data);
(define git_blob_filtered_content
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_blob_filtered_content"
                (dynamic-link))
              (list '* '* '* ffi:int))))
    (lambda (out blob as_path check_for_binary_data)
      (let ((~as_path (unwrap~pointer as_path))
            (~check_for_binary_data
              (unwrap~fixed check_for_binary_data)))
        (~f out blob ~as_path ~check_for_binary_data)))))
(export git_blob_filtered_content)

;; extern int git_blob_create_fromworkdir(git_oid *id, git_repository *repo, 
;;     const char *relative_path);
(define git_blob_create_fromworkdir
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_blob_create_fromworkdir"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (id repo relative_path)
      (let ((~relative_path (unwrap~pointer relative_path)))
        (~f id repo ~relative_path)))))
(export git_blob_create_fromworkdir)

;; extern int git_blob_create_fromdisk(git_oid *id, git_repository *repo, 
;;     const char *path);
(define git_blob_create_fromdisk
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_blob_create_fromdisk"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (id repo path)
      (let ((~path (unwrap~pointer path)))
        (~f id repo ~path)))))
(export git_blob_create_fromdisk)

;; extern int git_blob_create_fromstream(git_writestream **out, git_repository
;;      *repo, const char *hintpath);
(define git_blob_create_fromstream
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_blob_create_fromstream"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (out repo hintpath)
      (let ((~out (unwrap~pointer out))
            (~hintpath (unwrap~pointer hintpath)))
        (~f ~out repo ~hintpath)))))
(export git_blob_create_fromstream)

;; extern int git_blob_create_fromstream_commit(git_oid *out, git_writestream 
;;     *stream);
(define git_blob_create_fromstream_commit
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_blob_create_fromstream_commit"
                (dynamic-link))
              (list '* '*))))
    (lambda (out stream) (let () (~f out stream)))))
(export git_blob_create_fromstream_commit)

;; extern int git_blob_create_frombuffer(git_oid *id, git_repository *repo, 
;;     const void *buffer, size_t len);
(define git_blob_create_frombuffer
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_blob_create_frombuffer"
                (dynamic-link))
              (list '* '* '* ffi:size_t))))
    (lambda (id repo buffer len)
      (let ((~buffer (unwrap~pointer buffer))
            (~len (unwrap-size_t len)))
        (~f id repo ~buffer ~len)))))
(export git_blob_create_frombuffer)

;; extern int git_blob_is_binary(const git_blob *blob);
(define git_blob_is_binary
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_blob_is_binary"
                (dynamic-link))
              (list '*))))
    (lambda (blob) (let () (~f blob)))))
(export git_blob_is_binary)

;; extern int git_blob_dup(git_blob **out, git_blob *source);
(define git_blob_dup
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_blob_dup" (dynamic-link))
              (list '* '*))))
    (lambda (out source)
      (let ((~out (unwrap~pointer out)))
        (~f ~out source)))))
(export git_blob_dup)

;; typedef enum {
;;   GIT_BLAME_NORMAL = 0,
;;   GIT_BLAME_TRACK_COPIES_SAME_FILE = 1<<0,
;;   GIT_BLAME_TRACK_COPIES_SAME_COMMIT_MOVES = 1<<1,
;;   GIT_BLAME_TRACK_COPIES_SAME_COMMIT_COPIES = 1<<2,
;;   GIT_BLAME_TRACK_COPIES_ANY_COMMIT_COPIES = 1<<3,
;;   GIT_BLAME_FIRST_PARENT = 1<<4,
;; } git_blame_flag_t;
(define-fh-enum git_blame_flag_t
  '((GIT_BLAME_NORMAL . 0)
    (GIT_BLAME_TRACK_COPIES_SAME_FILE . 1)
    (GIT_BLAME_TRACK_COPIES_SAME_COMMIT_MOVES . 2)
    (GIT_BLAME_TRACK_COPIES_SAME_COMMIT_COPIES . 4)
    (GIT_BLAME_TRACK_COPIES_ANY_COMMIT_COPIES . 8)
    (GIT_BLAME_FIRST_PARENT . 16))
  )

;; typedef struct git_blame_options {
;;   unsigned int version;
;;   uint32_t flags;
;;   uint16_t min_match_characters;
;;   git_oid newest_commit;
;;   git_oid oldest_commit;
;;   size_t min_line;
;;   size_t max_line;
;; } git_blame_options;
(define git_blame_options-desc
  (bs:struct
    (list `(version ,unsigned-int)
          `(flags ,uint32_t-desc)
          `(min_match_characters ,uint16_t-desc)
          `(newest_commit
             ,(bs:struct (list `(id ,(bs:vector 20 #f)))))
          `(oldest_commit
             ,(bs:struct (list `(id ,(bs:vector 20 #f)))))
          `(min_line ,size_t-desc)
          `(max_line ,size_t-desc))))
(export git_blame_options-desc)
(define-fh-compound-type/p git_blame_options git_blame_options-desc)
(define struct-git_blame_options git_blame_options)

;; extern int git_blame_init_options(git_blame_options *opts, unsigned int 
;;     version);
(define git_blame_init_options
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_blame_init_options"
                (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (opts version)
      (let ((~opts (unwrap-git_blame_options* opts))
            (~version (unwrap~fixed version)))
        (~f ~opts ~version)))))
(export git_blame_init_options)

;; typedef struct git_blame_hunk {
;;   size_t lines_in_hunk;
;;   git_oid final_commit_id;
;;   size_t final_start_line_number;
;;   git_signature *final_signature;
;;   git_oid orig_commit_id;
;;   const char *orig_path;
;;   size_t orig_start_line_number;
;;   git_signature *orig_signature;
;;   char boundary;
;; } git_blame_hunk;
(define git_blame_hunk-desc
  (bs:struct
    (list `(lines_in_hunk ,size_t-desc)
          `(final_commit_id
             ,(bs:struct (list `(id ,(bs:vector 20 #f)))))
          `(final_start_line_number ,size_t-desc)
          `(final_signature ,(bs:pointer intptr_t))
          `(orig_commit_id
             ,(bs:struct (list `(id ,(bs:vector 20 #f)))))
          `(orig_path ,(bs:pointer int))
          `(orig_start_line_number ,size_t-desc)
          `(orig_signature ,(bs:pointer intptr_t))
          `(boundary ,int))))
(export git_blame_hunk-desc)
(define-fh-compound-type/p git_blame_hunk git_blame_hunk-desc)
(define struct-git_blame_hunk git_blame_hunk)

;; typedef struct git_blame git_blame;
(define-fh-pointer-type git_blame*)

;; extern uint32_t git_blame_get_hunk_count(git_blame *blame);
(define git_blame_get_hunk_count
  (let ((~f (ffi:pointer->procedure
              ffi:uint32
              (dynamic-func
                "git_blame_get_hunk_count"
                (dynamic-link))
              (list '*))))
    (lambda (blame)
      (let ((~blame (unwrap-git_blame* blame)))
        (wrap-uint32_t (~f ~blame))))))
(export git_blame_get_hunk_count)

;; extern const git_blame_hunk *git_blame_get_hunk_byindex(git_blame *blame, 
;;     uint32_t index);
(define git_blame_get_hunk_byindex
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "git_blame_get_hunk_byindex"
                (dynamic-link))
              (list '* ffi:uint32))))
    (lambda (blame index)
      (let ((~blame (unwrap-git_blame* blame))
            (~index (unwrap-uint32_t index)))
        (wrap-git_blame_hunk* (~f ~blame ~index))))))
(export git_blame_get_hunk_byindex)

;; extern const git_blame_hunk *git_blame_get_hunk_byline(git_blame *blame, 
;;     size_t lineno);
(define git_blame_get_hunk_byline
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "git_blame_get_hunk_byline"
                (dynamic-link))
              (list '* ffi:size_t))))
    (lambda (blame lineno)
      (let ((~blame (unwrap-git_blame* blame))
            (~lineno (unwrap-size_t lineno)))
        (wrap-git_blame_hunk* (~f ~blame ~lineno))))))
(export git_blame_get_hunk_byline)

;; extern int git_blame_file(git_blame **out, git_repository *repo, const char
;;      *path, git_blame_options *options);
(define git_blame_file
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_blame_file" (dynamic-link))
              (list '* '* '* '*))))
    (lambda (out repo path options)
      (let ((~out (unwrap~pointer out))
            (~path (unwrap~pointer path))
            (~options (unwrap-git_blame_options* options)))
        (~f ~out repo ~path ~options)))))
(export git_blame_file)

;; extern int git_blame_buffer(git_blame **out, git_blame *reference, const 
;;     char *buffer, size_t buffer_len);
(define git_blame_buffer
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_blame_buffer" (dynamic-link))
              (list '* '* '* ffi:size_t))))
    (lambda (out reference buffer buffer_len)
      (let ((~out (unwrap~pointer out))
            (~reference (unwrap-git_blame* reference))
            (~buffer (unwrap~pointer buffer))
            (~buffer_len (unwrap-size_t buffer_len)))
        (~f ~out ~reference ~buffer ~buffer_len)))))
(export git_blame_buffer)

;; extern void git_blame_free(git_blame *blame);
(define git_blame_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "git_blame_free" (dynamic-link))
              (list '*))))
    (lambda (blame)
      (let ((~blame (unwrap-git_blame* blame)))
        (~f ~blame)))))
(export git_blame_free)

;; extern int git_branch_create(git_reference **out, git_repository *repo, 
;;     const char *branch_name, const git_commit *target, int force);
(define git_branch_create
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_branch_create" (dynamic-link))
              (list '* '* '* '* ffi:int))))
    (lambda (out repo branch_name target force)
      (let ((~out (unwrap~pointer out))
            (~branch_name (unwrap~pointer branch_name))
            (~force (unwrap~fixed force)))
        (~f ~out repo ~branch_name target ~force)))))
(export git_branch_create)

;; extern int git_branch_create_from_annotated(git_reference **ref_out, 
;;     git_repository *repository, const char *branch_name, const 
;;     git_annotated_commit *commit, int force);
(define git_branch_create_from_annotated
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_branch_create_from_annotated"
                (dynamic-link))
              (list '* '* '* '* ffi:int))))
    (lambda (ref_out repository branch_name commit force)
      (let ((~ref_out (unwrap~pointer ref_out))
            (~branch_name (unwrap~pointer branch_name))
            (~force (unwrap~fixed force)))
        (~f ~ref_out
            repository
            ~branch_name
            commit
            ~force)))))
(export git_branch_create_from_annotated)

;; extern int git_branch_delete(git_reference *branch);
(define git_branch_delete
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_branch_delete" (dynamic-link))
              (list '*))))
    (lambda (branch) (let () (~f branch)))))
(export git_branch_delete)

;; typedef struct git_branch_iterator git_branch_iterator;
(define-fh-pointer-type git_branch_iterator*)

;; extern int git_branch_iterator_new(git_branch_iterator **out, 
;;     git_repository *repo, git_branch_t list_flags);
(define git_branch_iterator_new
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_branch_iterator_new"
                (dynamic-link))
              (list '* '* ffi:int))))
    (lambda (out repo list_flags)
      (let ((~out (unwrap~pointer out))
            (~list_flags (unwrap-git_branch_t list_flags)))
        (~f ~out repo ~list_flags)))))
(export git_branch_iterator_new)

;; extern int git_branch_next(git_reference **out, git_branch_t *out_type, 
;;     git_branch_iterator *iter);
(define git_branch_next
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_branch_next" (dynamic-link))
              (list '* '* '*))))
    (lambda (out out_type iter)
      (let ((~out (unwrap~pointer out))
            (~iter (unwrap-git_branch_iterator* iter)))
        (~f ~out out_type ~iter)))))
(export git_branch_next)

;; extern void git_branch_iterator_free(git_branch_iterator *iter);
(define git_branch_iterator_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "git_branch_iterator_free"
                (dynamic-link))
              (list '*))))
    (lambda (iter)
      (let ((~iter (unwrap-git_branch_iterator* iter)))
        (~f ~iter)))))
(export git_branch_iterator_free)

;; extern int git_branch_move(git_reference **out, git_reference *branch, 
;;     const char *new_branch_name, int force);
(define git_branch_move
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_branch_move" (dynamic-link))
              (list '* '* '* ffi:int))))
    (lambda (out branch new_branch_name force)
      (let ((~out (unwrap~pointer out))
            (~new_branch_name
              (unwrap~pointer new_branch_name))
            (~force (unwrap~fixed force)))
        (~f ~out branch ~new_branch_name ~force)))))
(export git_branch_move)

;; extern int git_branch_lookup(git_reference **out, git_repository *repo, 
;;     const char *branch_name, git_branch_t branch_type);
(define git_branch_lookup
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_branch_lookup" (dynamic-link))
              (list '* '* '* ffi:int))))
    (lambda (out repo branch_name branch_type)
      (let ((~out (unwrap~pointer out))
            (~branch_name (unwrap~pointer branch_name))
            (~branch_type (unwrap-git_branch_t branch_type)))
        (~f ~out repo ~branch_name ~branch_type)))))
(export git_branch_lookup)

;; extern int git_branch_name(const char **out, const git_reference *ref);
(define git_branch_name
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_branch_name" (dynamic-link))
              (list '* '*))))
    (lambda (out ref)
      (let ((~out (unwrap~pointer out))) (~f ~out ref)))))
(export git_branch_name)

;; extern int git_branch_upstream(git_reference **out, const git_reference *
;;     branch);
(define git_branch_upstream
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_branch_upstream"
                (dynamic-link))
              (list '* '*))))
    (lambda (out branch)
      (let ((~out (unwrap~pointer out)))
        (~f ~out branch)))))
(export git_branch_upstream)

;; extern int git_branch_set_upstream(git_reference *branch, const char *
;;     upstream_name);
(define git_branch_set_upstream
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_branch_set_upstream"
                (dynamic-link))
              (list '* '*))))
    (lambda (branch upstream_name)
      (let ((~upstream_name (unwrap~pointer upstream_name)))
        (~f branch ~upstream_name)))))
(export git_branch_set_upstream)

;; extern int git_branch_upstream_name(git_buf *out, git_repository *repo, 
;;     const char *refname);
(define git_branch_upstream_name
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_branch_upstream_name"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (out repo refname)
      (let ((~refname (unwrap~pointer refname)))
        (~f out repo ~refname)))))
(export git_branch_upstream_name)

;; extern int git_branch_is_head(const git_reference *branch);
(define git_branch_is_head
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_branch_is_head"
                (dynamic-link))
              (list '*))))
    (lambda (branch) (let () (~f branch)))))
(export git_branch_is_head)

;; extern int git_branch_is_checked_out(const git_reference *branch);
(define git_branch_is_checked_out
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_branch_is_checked_out"
                (dynamic-link))
              (list '*))))
    (lambda (branch) (let () (~f branch)))))
(export git_branch_is_checked_out)

;; extern int git_branch_remote_name(git_buf *out, git_repository *repo, const
;;      char *canonical_branch_name);
(define git_branch_remote_name
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_branch_remote_name"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (out repo canonical_branch_name)
      (let ((~canonical_branch_name
              (unwrap~pointer canonical_branch_name)))
        (~f out repo ~canonical_branch_name)))))
(export git_branch_remote_name)

;; extern int git_branch_upstream_remote(git_buf *buf, git_repository *repo, 
;;     const char *refname);
(define git_branch_upstream_remote
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_branch_upstream_remote"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (buf repo refname)
      (let ((~refname (unwrap~pointer refname)))
        (~f buf repo ~refname)))))
(export git_branch_upstream_remote)

;; typedef enum {
;;   GIT_CHECKOUT_NONE = 0,
;;   GIT_CHECKOUT_SAFE = 1u<<0,
;;   GIT_CHECKOUT_FORCE = 1u<<1,
;;   GIT_CHECKOUT_RECREATE_MISSING = 1u<<2,
;;   GIT_CHECKOUT_ALLOW_CONFLICTS = 1u<<4,
;;   GIT_CHECKOUT_REMOVE_UNTRACKED = 1u<<5,
;;   GIT_CHECKOUT_REMOVE_IGNORED = 1u<<6,
;;   GIT_CHECKOUT_UPDATE_ONLY = 1u<<7,
;;   GIT_CHECKOUT_DONT_UPDATE_INDEX = 1u<<8,
;;   GIT_CHECKOUT_NO_REFRESH = 1u<<9,
;;   GIT_CHECKOUT_SKIP_UNMERGED = 1u<<10,
;;   GIT_CHECKOUT_USE_OURS = 1u<<11,
;;   GIT_CHECKOUT_USE_THEIRS = 1u<<12,
;;   GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH = 1u<<13,
;;   GIT_CHECKOUT_SKIP_LOCKED_DIRECTORIES = 1u<<18,
;;   GIT_CHECKOUT_DONT_OVERWRITE_IGNORED = 1u<<19,
;;   GIT_CHECKOUT_CONFLICT_STYLE_MERGE = 1u<<20,
;;   GIT_CHECKOUT_CONFLICT_STYLE_DIFF3 = 1u<<21,
;;   GIT_CHECKOUT_DONT_REMOVE_EXISTING = 1u<<22,
;;   GIT_CHECKOUT_DONT_WRITE_INDEX = 1u<<23,
;;   GIT_CHECKOUT_UPDATE_SUBMODULES = 1u<<16,
;;   GIT_CHECKOUT_UPDATE_SUBMODULES_IF_CHANGED = 1u<<17,
;; } git_checkout_strategy_t;
(define-fh-enum git_checkout_strategy_t
  '((GIT_CHECKOUT_NONE . 0)
    (GIT_CHECKOUT_SAFE . 1)
    (GIT_CHECKOUT_FORCE . 2)
    (GIT_CHECKOUT_RECREATE_MISSING . 4)
    (GIT_CHECKOUT_ALLOW_CONFLICTS . 16)
    (GIT_CHECKOUT_REMOVE_UNTRACKED . 32)
    (GIT_CHECKOUT_REMOVE_IGNORED . 64)
    (GIT_CHECKOUT_UPDATE_ONLY . 128)
    (GIT_CHECKOUT_DONT_UPDATE_INDEX . 256)
    (GIT_CHECKOUT_NO_REFRESH . 512)
    (GIT_CHECKOUT_SKIP_UNMERGED . 1024)
    (GIT_CHECKOUT_USE_OURS . 2048)
    (GIT_CHECKOUT_USE_THEIRS . 4096)
    (GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH . 8192)
    (GIT_CHECKOUT_SKIP_LOCKED_DIRECTORIES . 262144)
    (GIT_CHECKOUT_DONT_OVERWRITE_IGNORED . 524288)
    (GIT_CHECKOUT_CONFLICT_STYLE_MERGE . 1048576)
    (GIT_CHECKOUT_CONFLICT_STYLE_DIFF3 . 2097152)
    (GIT_CHECKOUT_DONT_REMOVE_EXISTING . 4194304)
    (GIT_CHECKOUT_DONT_WRITE_INDEX . 8388608)
    (GIT_CHECKOUT_UPDATE_SUBMODULES . 65536)
    (GIT_CHECKOUT_UPDATE_SUBMODULES_IF_CHANGED
      .
      131072))
  )

;; typedef enum {
;;   GIT_CHECKOUT_NOTIFY_NONE = 0,
;;   GIT_CHECKOUT_NOTIFY_CONFLICT = 1u<<0,
;;   GIT_CHECKOUT_NOTIFY_DIRTY = 1u<<1,
;;   GIT_CHECKOUT_NOTIFY_UPDATED = 1u<<2,
;;   GIT_CHECKOUT_NOTIFY_UNTRACKED = 1u<<3,
;;   GIT_CHECKOUT_NOTIFY_IGNORED = 1u<<4,
;;   GIT_CHECKOUT_NOTIFY_ALL = 0x0FFFFu,
;; } git_checkout_notify_t;
(define-fh-enum git_checkout_notify_t
  '((GIT_CHECKOUT_NOTIFY_NONE . 0)
    (GIT_CHECKOUT_NOTIFY_CONFLICT . 1)
    (GIT_CHECKOUT_NOTIFY_DIRTY . 2)
    (GIT_CHECKOUT_NOTIFY_UPDATED . 4)
    (GIT_CHECKOUT_NOTIFY_UNTRACKED . 8)
    (GIT_CHECKOUT_NOTIFY_IGNORED . 16)
    (GIT_CHECKOUT_NOTIFY_ALL . 65535))
  )

;; typedef struct {
;;   size_t mkdir_calls;
;;   size_t stat_calls;
;;   size_t chmod_calls;
;; } git_checkout_perfdata;
(define git_checkout_perfdata-desc
  (bs:struct
    (list `(mkdir_calls ,size_t-desc)
          `(stat_calls ,size_t-desc)
          `(chmod_calls ,size_t-desc))))
(export git_checkout_perfdata-desc)
(define-fh-compound-type/p git_checkout_perfdata git_checkout_perfdata-desc)

;; typedef int (*git_checkout_notify_cb)(git_checkout_notify_t why, const char
;;      *path, const git_diff_file *baseline, const git_diff_file *target, 
;;     const git_diff_file *workdir, void *payload);
(define-fh-function/p git_checkout_notify_cb
  ffi:int (list ffi:int (quote *) (quote *) (quote *) (quote *) (quote *)))

;; typedef void (*git_checkout_progress_cb)(const char *path, size_t 
;;     completed_steps, size_t total_steps, void *payload);
(define-fh-function/p git_checkout_progress_cb
  ffi:void (list (quote *) ffi:size_t ffi:size_t (quote *)))

;; typedef void (*git_checkout_perfdata_cb)(const git_checkout_perfdata *
;;     perfdata, void *payload);
(define-fh-function/p git_checkout_perfdata_cb
  ffi:void (list (quote *) (quote *)))

;; typedef struct git_checkout_options {
;;   unsigned int version;
;;   unsigned int checkout_strategy; /**< default will be a dry run */
;;   int disable_filters; /**< don't apply filters like CRLF conversion */
;;   unsigned int dir_mode; /**< default is 0755 */
;;   unsigned int file_mode; 
;;       /**< default is 0644 or 0755 as dictated by blob */
;;   int file_open_flags; /**< default is O_CREAT | O_TRUNC | O_WRONLY */
;;   unsigned int notify_flags; /**< see `git_checkout_notify_t` above */
;;   git_checkout_notify_cb notify_cb;
;;   void *notify_payload;
;;   /** Optional callback to notify the consumer of checkout progress. */
;;   git_checkout_progress_cb progress_cb;
;;   void *progress_payload;
;;   /** When not zeroed out, array of fnmatch patterns specifying which
;;   	 *  paths should be taken into account, otherwise all files.  Use
;;   	 *  GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH to treat as simple list.
;;   	 */
;;   git_strarray paths;
;;   /** The expected content of the working directory; defaults to HEAD.
;;   	 *  If the working directory does not match this baseline information,
;;   	 *  that will produce a checkout conflict.
;;   	 */
;;   git_tree *baseline;
;;   /** Like `baseline` above, though expressed as an index.  This
;;   	 *  option overrides `baseline`.
;;   	 */
;;   git_index *baseline_index; 
;;       /**< expected content of workdir, expressed as an index. */
;;   const char *target_directory; 
;;       /**< alternative checkout path to workdir */
;;   const char *ancestor_label; 
;;       /**< the name of the common ancestor side of conflicts */
;;   const char *our_label; /**< the name of the "our" side of conflicts */
;;   const char *their_label; 
;;       /**< the name of the "their" side of conflicts */
;;   /** Optional callback to notify the consumer of performance data. */
;;   git_checkout_perfdata_cb perfdata_cb;
;;   void *perfdata_payload;
;; } git_checkout_options;
(define git_checkout_options-desc
  (bs:struct
    (list `(version ,unsigned-int)
          `(checkout_strategy ,unsigned-int)
          `(disable_filters ,int)
          `(dir_mode ,unsigned-int)
          `(file_mode ,unsigned-int)
          `(file_open_flags ,int)
          `(notify_flags ,unsigned-int)
          `(notify_cb ,git_checkout_notify_cb-desc)
          `(notify_payload ,(bs:pointer intptr_t))
          `(progress_cb ,git_checkout_progress_cb-desc)
          `(progress_payload ,(bs:pointer intptr_t))
          `(paths ,(bs:struct
                     (list `(strings ,(bs:pointer (bs:pointer int)))
                           `(count ,size_t-desc))))
          `(baseline ,(bs:pointer intptr_t))
          `(baseline_index ,(bs:pointer intptr_t))
          `(target_directory ,(bs:pointer int))
          `(ancestor_label ,(bs:pointer int))
          `(our_label ,(bs:pointer int))
          `(their_label ,(bs:pointer int))
          `(perfdata_cb ,git_checkout_perfdata_cb-desc)
          `(perfdata_payload ,(bs:pointer intptr_t)))))
(export git_checkout_options-desc)
(define-fh-compound-type/p git_checkout_options git_checkout_options-desc)
(define struct-git_checkout_options git_checkout_options)

;; extern int git_checkout_init_options(git_checkout_options *opts, 
;;     unsigned int version);
(define git_checkout_init_options
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_checkout_init_options"
                (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (opts version)
      (let ((~opts (unwrap-git_checkout_options* opts))
            (~version (unwrap~fixed version)))
        (~f ~opts ~version)))))
(export git_checkout_init_options)

;; extern int git_checkout_head(git_repository *repo, const 
;;     git_checkout_options *opts);
(define git_checkout_head
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_checkout_head" (dynamic-link))
              (list '* '*))))
    (lambda (repo opts)
      (let ((~opts (unwrap-git_checkout_options* opts)))
        (~f repo ~opts)))))
(export git_checkout_head)

;; extern int git_checkout_index(git_repository *repo, git_index *index, const
;;      git_checkout_options *opts);
(define git_checkout_index
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_checkout_index"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (repo index opts)
      (let ((~opts (unwrap-git_checkout_options* opts)))
        (~f repo index ~opts)))))
(export git_checkout_index)

;; extern int git_checkout_tree(git_repository *repo, const git_object *
;;     treeish, const git_checkout_options *opts);
(define git_checkout_tree
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_checkout_tree" (dynamic-link))
              (list '* '* '*))))
    (lambda (repo treeish opts)
      (let ((~opts (unwrap-git_checkout_options* opts)))
        (~f repo treeish ~opts)))))
(export git_checkout_tree)

;; typedef struct {
;;   unsigned int version;
;;   /** For merge commits, the "mainline" is treated as the parent. */
;;   unsigned int mainline;
;;   git_merge_options merge_opts; /**< Options for the merging */
;;   git_checkout_options checkout_opts; /**< Options for the checkout */
;; } git_cherrypick_options;
(define git_cherrypick_options-desc
  (bs:struct
    (list `(version ,unsigned-int)
          `(mainline ,unsigned-int)
          `(merge_opts
             ,(bs:struct
                (list `(version ,unsigned-int)
                      `(flags ,int)
                      `(rename_threshold ,unsigned-int)
                      `(target_limit ,unsigned-int)
                      `(metric
                         ,(bs:pointer
                            (bs:struct
                              (list `(file_signature ,(bs:pointer intptr_t))
                                    `(buffer_signature ,(bs:pointer intptr_t))
                                    `(free_signature ,(bs:pointer intptr_t))
                                    `(similarity ,(bs:pointer intptr_t))
                                    `(payload ,(bs:pointer intptr_t))))))
                      `(recursion_limit ,unsigned-int)
                      `(default_driver ,(bs:pointer int))
                      `(file_favor ,int)
                      `(file_flags ,int))))
          `(checkout_opts ,git_checkout_options-desc))))
(export git_cherrypick_options-desc)
(define-fh-compound-type/p git_cherrypick_options git_cherrypick_options-desc)

;; extern int git_cherrypick_init_options(git_cherrypick_options *opts, 
;;     unsigned int version);
(define git_cherrypick_init_options
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_cherrypick_init_options"
                (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (opts version)
      (let ((~opts (unwrap-git_cherrypick_options* opts))
            (~version (unwrap~fixed version)))
        (~f ~opts ~version)))))
(export git_cherrypick_init_options)

;; extern int git_cherrypick_commit(git_index **out, git_repository *repo, 
;;     git_commit *cherrypick_commit, git_commit *our_commit, unsigned int 
;;     mainline, const git_merge_options *merge_options);
(define git_cherrypick_commit
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_cherrypick_commit"
                (dynamic-link))
              (list '* '* '* '* ffi:unsigned-int '*))))
    (lambda (out
             repo
             cherrypick_commit
             our_commit
             mainline
             merge_options)
      (let ((~out (unwrap~pointer out))
            (~mainline (unwrap~fixed mainline)))
        (~f ~out
            repo
            cherrypick_commit
            our_commit
            ~mainline
            merge_options)))))
(export git_cherrypick_commit)

;; extern int git_cherrypick(git_repository *repo, git_commit *commit, const 
;;     git_cherrypick_options *cherrypick_options);
(define git_cherrypick
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_cherrypick" (dynamic-link))
              (list '* '* '*))))
    (lambda (repo commit cherrypick_options)
      (let ((~cherrypick_options
              (unwrap-git_cherrypick_options*
                cherrypick_options)))
        (~f repo commit ~cherrypick_options)))))
(export git_cherrypick)

;; typedef enum {
;;   GIT_CLONE_LOCAL_AUTO,
;;   GIT_CLONE_LOCAL,
;;   GIT_CLONE_NO_LOCAL,
;;   GIT_CLONE_LOCAL_NO_LINKS,
;; } git_clone_local_t;
(define-fh-enum git_clone_local_t
  '((GIT_CLONE_LOCAL_AUTO . 0)
    (GIT_CLONE_LOCAL . 1)
    (GIT_CLONE_NO_LOCAL . 2)
    (GIT_CLONE_LOCAL_NO_LINKS . 3))
  )

;; typedef int (*git_remote_create_cb)(git_remote **out, git_repository *repo
;;     , const char *name, const char *url, void *payload);
(define-fh-function/p git_remote_create_cb
  ffi:int (list (quote *) (quote *) (quote *) (quote *) (quote *)))

;; typedef int (*git_repository_create_cb)(git_repository **out, const char *
;;     path, int bare, void *payload);
(define-fh-function/p git_repository_create_cb
  ffi:int (list (quote *) (quote *) ffi:int (quote *)))

;; typedef struct git_clone_options {
;;   unsigned int version;
;;   /**
;;   	 * These options are passed to the checkout step. To disable
;;   	 * checkout, set the `checkout_strategy` to
;;   	 * `GIT_CHECKOUT_NONE`.
;;   	 */
;;   git_checkout_options checkout_opts;
;;   /**
;;   	 * Options which control the fetch, including callbacks.
;;   	 *
;;   	 * The callbacks are used for reporting fetch progress, and for acquiring
;;       
;;   	 * credentials in the event they are needed.
;;   	 */
;;   git_fetch_options fetch_opts;
;;   /**
;;   	 * Set to zero (false) to create a standard repo, or non-zero
;;   	 * for a bare repo
;;   	 */
;;   int bare;
;;   /**
;;   	 * Whether to use a fetch or copy the object database.
;;   	 */
;;   git_clone_local_t local;
;;   /**
;;   	 * The name of the branch to checkout. NULL means use the
;;   	 * remote's default branch.
;;   	 */
;;   const char *checkout_branch;
;;   /**
;;   	 * A callback used to create the new repository into which to
;;   	 * clone. If NULL, the 'bare' field will be used to determine
;;   	 * whether to create a bare repository.
;;   	 */
;;   git_repository_create_cb repository_cb;
;;   /**
;;   	 * An opaque payload to pass to the git_repository creation callback.
;;   	 * This parameter is ignored unless repository_cb is non-NULL.
;;   	 */
;;   void *repository_cb_payload;
;;   /**
;;   	 * A callback used to create the git_remote, prior to its being
;;   	 * used to perform the clone operation. See the documentation for
;;   	 * git_remote_create_cb for details. This parameter may be NULL,
;;   	 * indicating that git_clone should provide default behavior.
;;   	 */
;;   git_remote_create_cb remote_cb;
;;   /**
;;   	 * An opaque payload to pass to the git_remote creation callback.
;;   	 * This parameter is ignored unless remote_cb is non-NULL.
;;   	 */
;;   void *remote_cb_payload;
;; } git_clone_options;
(define git_clone_options-desc
  (bs:struct
    (list `(version ,unsigned-int)
          `(checkout_opts ,git_checkout_options-desc)
          `(fetch_opts
             ,(bs:struct
                (list `(version ,int)
                      `(callbacks
                         ,(bs:struct
                            (list `(version ,unsigned-int)
                                  `(sideband_progress
                                     ,git_transport_message_cb-desc)
                                  `(completion ,(bs:pointer intptr_t))
                                  `(credentials ,git_cred_acquire_cb-desc)
                                  `(certificate_check
                                     ,git_transport_certificate_check_cb-desc)
                                  `(transfer_progress
                                     ,git_transfer_progress_cb-desc)
                                  `(update_tips ,(bs:pointer intptr_t))
                                  `(pack_progress
                                     ,git_packbuilder_progress-desc)
                                  `(push_transfer_progress
                                     ,git_push_transfer_progress-desc)
                                  `(push_update_reference
                                     ,(bs:pointer intptr_t))
                                  `(push_negotiation
                                     ,git_push_negotiation-desc)
                                  `(transport ,git_transport_cb-desc)
                                  `(payload ,(bs:pointer intptr_t)))))
                      `(prune ,int)
                      `(update_fetchhead ,int)
                      `(download_tags ,int)
                      `(proxy_opts
                         ,(bs:struct
                            (list `(version ,unsigned-int)
                                  `(type ,int)
                                  `(url ,(bs:pointer int))
                                  `(credentials ,(bs:pointer intptr_t))
                                  `(certificate_check ,(bs:pointer intptr_t))
                                  `(payload ,(bs:pointer intptr_t)))))
                      `(custom_headers
                         ,(bs:struct
                            (list `(strings ,(bs:pointer (bs:pointer int)))
                                  `(count ,size_t-desc)))))))
          `(bare ,int)
          `(local ,git_clone_local_t-desc)
          `(checkout_branch ,(bs:pointer int))
          `(repository_cb ,git_repository_create_cb-desc)
          `(repository_cb_payload ,(bs:pointer intptr_t))
          `(remote_cb ,git_remote_create_cb-desc)
          `(remote_cb_payload ,(bs:pointer intptr_t)))))
(export git_clone_options-desc)
(define-fh-compound-type/p git_clone_options git_clone_options-desc)
(define struct-git_clone_options git_clone_options)

;; extern int git_clone_init_options(git_clone_options *opts, unsigned int 
;;     version);
(define git_clone_init_options
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_clone_init_options"
                (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (opts version)
      (let ((~opts (unwrap-git_clone_options* opts))
            (~version (unwrap~fixed version)))
        (~f ~opts ~version)))))
(export git_clone_init_options)

;; extern int git_clone(git_repository **out, const char *url, const char *
;;     local_path, const git_clone_options *options);
(define git_clone
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_clone" (dynamic-link))
              (list '* '* '* '*))))
    (lambda (out url local_path options)
      (let ((~out (unwrap~pointer out))
            (~url (unwrap~pointer url))
            (~local_path (unwrap~pointer local_path))
            (~options (unwrap-git_clone_options* options)))
        (~f ~out ~url ~local_path ~options)))))
(export git_clone)

;; extern int git_commit_lookup(git_commit **commit, git_repository *repo, 
;;     const git_oid *id);
(define git_commit_lookup
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_commit_lookup" (dynamic-link))
              (list '* '* '*))))
    (lambda (commit repo id)
      (let ((~commit (unwrap~pointer commit)))
        (~f ~commit repo id)))))
(export git_commit_lookup)

;; extern int git_commit_lookup_prefix(git_commit **commit, git_repository *
;;     repo, const git_oid *id, size_t len);
(define git_commit_lookup_prefix
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_commit_lookup_prefix"
                (dynamic-link))
              (list '* '* '* ffi:size_t))))
    (lambda (commit repo id len)
      (let ((~commit (unwrap~pointer commit))
            (~len (unwrap-size_t len)))
        (~f ~commit repo id ~len)))))
(export git_commit_lookup_prefix)

;; extern void git_commit_free(git_commit *commit);
(define git_commit_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "git_commit_free" (dynamic-link))
              (list '*))))
    (lambda (commit) (let () (~f commit)))))
(export git_commit_free)

;; extern const git_oid *git_commit_id(const git_commit *commit);
(define git_commit_id
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "git_commit_id" (dynamic-link))
              (list '*))))
    (lambda (commit) (let () (~f commit)))))
(export git_commit_id)

;; extern git_repository *git_commit_owner(const git_commit *commit);
(define git_commit_owner
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "git_commit_owner" (dynamic-link))
              (list '*))))
    (lambda (commit) (let () (~f commit)))))
(export git_commit_owner)

;; extern const char *git_commit_message_encoding(const git_commit *commit);
(define git_commit_message_encoding
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "git_commit_message_encoding"
                (dynamic-link))
              (list '*))))
    (lambda (commit) (let () (~f commit)))))
(export git_commit_message_encoding)

;; extern const char *git_commit_message(const git_commit *commit);
(define git_commit_message
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "git_commit_message"
                (dynamic-link))
              (list '*))))
    (lambda (commit) (let () (~f commit)))))
(export git_commit_message)

;; extern const char *git_commit_message_raw(const git_commit *commit);
(define git_commit_message_raw
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "git_commit_message_raw"
                (dynamic-link))
              (list '*))))
    (lambda (commit) (let () (~f commit)))))
(export git_commit_message_raw)

;; extern const char *git_commit_summary(git_commit *commit);
(define git_commit_summary
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "git_commit_summary"
                (dynamic-link))
              (list '*))))
    (lambda (commit) (let () (~f commit)))))
(export git_commit_summary)

;; extern const char *git_commit_body(git_commit *commit);
(define git_commit_body
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "git_commit_body" (dynamic-link))
              (list '*))))
    (lambda (commit) (let () (~f commit)))))
(export git_commit_body)

;; extern git_time_t git_commit_time(const git_commit *commit);
(define git_commit_time
  (let ((~f (ffi:pointer->procedure
              ffi:int64
              (dynamic-func "git_commit_time" (dynamic-link))
              (list '*))))
    (lambda (commit)
      (let () (wrap-int64_t (~f commit))))))
(export git_commit_time)

;; extern int git_commit_time_offset(const git_commit *commit);
(define git_commit_time_offset
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_commit_time_offset"
                (dynamic-link))
              (list '*))))
    (lambda (commit) (let () (~f commit)))))
(export git_commit_time_offset)

;; extern const git_signature *git_commit_committer(const git_commit *commit)
;;     ;
(define git_commit_committer
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "git_commit_committer"
                (dynamic-link))
              (list '*))))
    (lambda (commit) (let () (~f commit)))))
(export git_commit_committer)

;; extern const git_signature *git_commit_author(const git_commit *commit);
(define git_commit_author
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "git_commit_author" (dynamic-link))
              (list '*))))
    (lambda (commit) (let () (~f commit)))))
(export git_commit_author)

;; extern const char *git_commit_raw_header(const git_commit *commit);
(define git_commit_raw_header
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "git_commit_raw_header"
                (dynamic-link))
              (list '*))))
    (lambda (commit) (let () (~f commit)))))
(export git_commit_raw_header)

;; extern int git_commit_tree(git_tree **tree_out, const git_commit *commit);
(define git_commit_tree
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_commit_tree" (dynamic-link))
              (list '* '*))))
    (lambda (tree_out commit)
      (let ((~tree_out (unwrap~pointer tree_out)))
        (~f ~tree_out commit)))))
(export git_commit_tree)

;; extern const git_oid *git_commit_tree_id(const git_commit *commit);
(define git_commit_tree_id
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "git_commit_tree_id"
                (dynamic-link))
              (list '*))))
    (lambda (commit) (let () (~f commit)))))
(export git_commit_tree_id)

;; extern unsigned int git_commit_parentcount(const git_commit *commit);
(define git_commit_parentcount
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func
                "git_commit_parentcount"
                (dynamic-link))
              (list '*))))
    (lambda (commit) (let () (~f commit)))))
(export git_commit_parentcount)

;; extern int git_commit_parent(git_commit **out, const git_commit *commit, 
;;     unsigned int n);
(define git_commit_parent
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_commit_parent" (dynamic-link))
              (list '* '* ffi:unsigned-int))))
    (lambda (out commit n)
      (let ((~out (unwrap~pointer out))
            (~n (unwrap~fixed n)))
        (~f ~out commit ~n)))))
(export git_commit_parent)

;; extern const git_oid *git_commit_parent_id(const git_commit *commit, 
;;     unsigned int n);
(define git_commit_parent_id
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "git_commit_parent_id"
                (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (commit n)
      (let ((~n (unwrap~fixed n))) (~f commit ~n)))))
(export git_commit_parent_id)

;; extern int git_commit_nth_gen_ancestor(git_commit **ancestor, const 
;;     git_commit *commit, unsigned int n);
(define git_commit_nth_gen_ancestor
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_commit_nth_gen_ancestor"
                (dynamic-link))
              (list '* '* ffi:unsigned-int))))
    (lambda (ancestor commit n)
      (let ((~ancestor (unwrap~pointer ancestor))
            (~n (unwrap~fixed n)))
        (~f ~ancestor commit ~n)))))
(export git_commit_nth_gen_ancestor)

;; extern int git_commit_header_field(git_buf *out, const git_commit *commit, 
;;     const char *field);
(define git_commit_header_field
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_commit_header_field"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (out commit field)
      (let ((~field (unwrap~pointer field)))
        (~f out commit ~field)))))
(export git_commit_header_field)

;; extern int git_commit_extract_signature(git_buf *signature, git_buf *
;;     signed_data, git_repository *repo, git_oid *commit_id, const char *
;;     field);
(define git_commit_extract_signature
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_commit_extract_signature"
                (dynamic-link))
              (list '* '* '* '* '*))))
    (lambda (signature signed_data repo commit_id field)
      (let ((~field (unwrap~pointer field)))
        (~f signature signed_data repo commit_id ~field)))))
(export git_commit_extract_signature)

;; extern int git_commit_create(git_oid *id, git_repository *repo, const char 
;;     *update_ref, const git_signature *author, const git_signature *
;;     committer, const char *message_encoding, const char *message, const 
;;     git_tree *tree, size_t parent_count, const git_commit *parents[]);
(define git_commit_create
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_commit_create" (dynamic-link))
              (list '* '* '* '* '* '* '* '* ffi:size_t '*))))
    (lambda (id
             repo
             update_ref
             author
             committer
             message_encoding
             message
             tree
             parent_count
             parents)
      (let ((~update_ref (unwrap~pointer update_ref))
            (~message_encoding
              (unwrap~pointer message_encoding))
            (~message (unwrap~pointer message))
            (~parent_count (unwrap-size_t parent_count))
            (~parents (unwrap~array parents)))
        (~f id
            repo
            ~update_ref
            author
            committer
            ~message_encoding
            ~message
            tree
            ~parent_count
            ~parents)))))
(export git_commit_create)

;; extern int git_commit_create_v(git_oid *id, git_repository *repo, const 
;;     char *update_ref, const git_signature *author, const git_signature *
;;     committer, const char *message_encoding, const char *message, const 
;;     git_tree *tree, size_t parent_count, ...);
;; ... failed.

;; extern int git_commit_amend(git_oid *id, const git_commit *commit_to_amend
;;     , const char *update_ref, const git_signature *author, const 
;;     git_signature *committer, const char *message_encoding, const char *
;;     message, const git_tree *tree);
(define git_commit_amend
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_commit_amend" (dynamic-link))
              (list '* '* '* '* '* '* '* '*))))
    (lambda (id
             commit_to_amend
             update_ref
             author
             committer
             message_encoding
             message
             tree)
      (let ((~update_ref (unwrap~pointer update_ref))
            (~message_encoding
              (unwrap~pointer message_encoding))
            (~message (unwrap~pointer message)))
        (~f id
            commit_to_amend
            ~update_ref
            author
            committer
            ~message_encoding
            ~message
            tree)))))
(export git_commit_amend)

;; extern int git_commit_create_buffer(git_buf *out, git_repository *repo, 
;;     const git_signature *author, const git_signature *committer, const char
;;      *message_encoding, const char *message, const git_tree *tree, size_t 
;;     parent_count, const git_commit *parents[]);
(define git_commit_create_buffer
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_commit_create_buffer"
                (dynamic-link))
              (list '* '* '* '* '* '* '* ffi:size_t '*))))
    (lambda (out
             repo
             author
             committer
             message_encoding
             message
             tree
             parent_count
             parents)
      (let ((~message_encoding
              (unwrap~pointer message_encoding))
            (~message (unwrap~pointer message))
            (~parent_count (unwrap-size_t parent_count))
            (~parents (unwrap~array parents)))
        (~f out
            repo
            author
            committer
            ~message_encoding
            ~message
            tree
            ~parent_count
            ~parents)))))
(export git_commit_create_buffer)

;; extern int git_commit_create_with_signature(git_oid *out, git_repository *
;;     repo, const char *commit_content, const char *signature, const char *
;;     signature_field);
(define git_commit_create_with_signature
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_commit_create_with_signature"
                (dynamic-link))
              (list '* '* '* '* '*))))
    (lambda (out
             repo
             commit_content
             signature
             signature_field)
      (let ((~commit_content (unwrap~pointer commit_content))
            (~signature (unwrap~pointer signature))
            (~signature_field
              (unwrap~pointer signature_field)))
        (~f out
            repo
            ~commit_content
            ~signature
            ~signature_field)))))
(export git_commit_create_with_signature)

;; extern int git_commit_dup(git_commit **out, git_commit *source);
(define git_commit_dup
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_commit_dup" (dynamic-link))
              (list '* '*))))
    (lambda (out source)
      (let ((~out (unwrap~pointer out)))
        (~f ~out source)))))
(export git_commit_dup)

;; typedef enum {
;;   GIT_CONFIG_LEVEL_PROGRAMDATA = 1,
;;   GIT_CONFIG_LEVEL_SYSTEM = 2,
;;   GIT_CONFIG_LEVEL_XDG = 3,
;;   GIT_CONFIG_LEVEL_GLOBAL = 4,
;;   GIT_CONFIG_LEVEL_LOCAL = 5,
;;   GIT_CONFIG_LEVEL_APP = 6,
;;   GIT_CONFIG_HIGHEST_LEVEL = -1,
;; } git_config_level_t;
(define-fh-enum git_config_level_t
  '((GIT_CONFIG_LEVEL_PROGRAMDATA . 1)
    (GIT_CONFIG_LEVEL_SYSTEM . 2)
    (GIT_CONFIG_LEVEL_XDG . 3)
    (GIT_CONFIG_LEVEL_GLOBAL . 4)
    (GIT_CONFIG_LEVEL_LOCAL . 5)
    (GIT_CONFIG_LEVEL_APP . 6)
    (GIT_CONFIG_HIGHEST_LEVEL . -1))
  )

;; typedef struct git_config_entry {
;;   const char *name; /**< Name of the entry (normalised) */
;;   const char *value; /**< String value of the entry */
;;   git_config_level_t level; /**< Which config file this was found in */
;;   void (*free)(struct git_config_entry *entry); 
;;       /**< Free function for this entry */
;;   void *payload; 
;;       /**< Opaque value for the free function. Do not read or write */
;; } git_config_entry;
(define git_config_entry-desc
  (bs:struct
    (list `(name ,(bs:pointer int))
          `(value ,(bs:pointer int))
          `(level ,git_config_level_t-desc)
          `(free ,(bs:pointer intptr_t))
          `(payload ,(bs:pointer intptr_t)))))
(export git_config_entry-desc)
(define-fh-compound-type/p git_config_entry git_config_entry-desc)
(define struct-git_config_entry git_config_entry)

;; extern void git_config_entry_free(git_config_entry *);
(define git_config_entry_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "git_config_entry_free"
                (dynamic-link))
              (list '*))))
    (lambda (@774)
      (let ((~@774 (unwrap-git_config_entry* @774)))
        (~f ~@774)))))
(export git_config_entry_free)

;; typedef int (*git_config_foreach_cb)(const git_config_entry *, void *);
(define-fh-function/p git_config_foreach_cb
  ffi:int (list (quote *) (quote *)))

;; typedef struct git_config_iterator git_config_iterator;
(define-fh-pointer-type git_config_iterator*)

;; typedef enum {
;;   GIT_CVAR_FALSE = 0,
;;   GIT_CVAR_TRUE = 1,
;;   GIT_CVAR_INT32,
;;   GIT_CVAR_STRING,
;; } git_cvar_t;
(define-fh-enum git_cvar_t
  '((GIT_CVAR_FALSE . 0)
    (GIT_CVAR_TRUE . 1)
    (GIT_CVAR_INT32 . 2)
    (GIT_CVAR_STRING . 3))
  )

;; typedef struct {
;;   git_cvar_t cvar_type;
;;   const char *str_match;
;;   int map_value;
;; } git_cvar_map;
(define git_cvar_map-desc
  (bs:struct
    (list `(cvar_type ,git_cvar_t-desc)
          `(str_match ,(bs:pointer int))
          `(map_value ,int))))
(export git_cvar_map-desc)
(define-fh-compound-type/p git_cvar_map git_cvar_map-desc)

;; extern int git_config_find_global(git_buf *out);
(define git_config_find_global
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_config_find_global"
                (dynamic-link))
              (list '*))))
    (lambda (out) (let () (~f out)))))
(export git_config_find_global)

;; extern int git_config_find_xdg(git_buf *out);
(define git_config_find_xdg
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_config_find_xdg"
                (dynamic-link))
              (list '*))))
    (lambda (out) (let () (~f out)))))
(export git_config_find_xdg)

;; extern int git_config_find_system(git_buf *out);
(define git_config_find_system
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_config_find_system"
                (dynamic-link))
              (list '*))))
    (lambda (out) (let () (~f out)))))
(export git_config_find_system)

;; extern int git_config_find_programdata(git_buf *out);
(define git_config_find_programdata
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_config_find_programdata"
                (dynamic-link))
              (list '*))))
    (lambda (out) (let () (~f out)))))
(export git_config_find_programdata)

;; extern int git_config_open_default(git_config **out);
(define git_config_open_default
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_config_open_default"
                (dynamic-link))
              (list '*))))
    (lambda (out)
      (let ((~out (unwrap~pointer out))) (~f ~out)))))
(export git_config_open_default)

;; extern int git_config_new(git_config **out);
(define git_config_new
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_config_new" (dynamic-link))
              (list '*))))
    (lambda (out)
      (let ((~out (unwrap~pointer out))) (~f ~out)))))
(export git_config_new)

;; extern int git_config_add_file_ondisk(git_config *cfg, const char *path, 
;;     git_config_level_t level, int force);
(define git_config_add_file_ondisk
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_config_add_file_ondisk"
                (dynamic-link))
              (list '* '* ffi:int ffi:int))))
    (lambda (cfg path level force)
      (let ((~path (unwrap~pointer path))
            (~level (unwrap-git_config_level_t level))
            (~force (unwrap~fixed force)))
        (~f cfg ~path ~level ~force)))))
(export git_config_add_file_ondisk)

;; extern int git_config_open_ondisk(git_config **out, const char *path);
(define git_config_open_ondisk
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_config_open_ondisk"
                (dynamic-link))
              (list '* '*))))
    (lambda (out path)
      (let ((~out (unwrap~pointer out))
            (~path (unwrap~pointer path)))
        (~f ~out ~path)))))
(export git_config_open_ondisk)

;; extern int git_config_open_level(git_config **out, const git_config *parent
;;     , git_config_level_t level);
(define git_config_open_level
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_config_open_level"
                (dynamic-link))
              (list '* '* ffi:int))))
    (lambda (out parent level)
      (let ((~out (unwrap~pointer out))
            (~level (unwrap-git_config_level_t level)))
        (~f ~out parent ~level)))))
(export git_config_open_level)

;; extern int git_config_open_global(git_config **out, git_config *config);
(define git_config_open_global
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_config_open_global"
                (dynamic-link))
              (list '* '*))))
    (lambda (out config)
      (let ((~out (unwrap~pointer out)))
        (~f ~out config)))))
(export git_config_open_global)

;; extern int git_config_snapshot(git_config **out, git_config *config);
(define git_config_snapshot
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_config_snapshot"
                (dynamic-link))
              (list '* '*))))
    (lambda (out config)
      (let ((~out (unwrap~pointer out)))
        (~f ~out config)))))
(export git_config_snapshot)

;; extern void git_config_free(git_config *cfg);
(define git_config_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "git_config_free" (dynamic-link))
              (list '*))))
    (lambda (cfg) (let () (~f cfg)))))
(export git_config_free)

;; extern int git_config_get_entry(git_config_entry **out, const git_config *
;;     cfg, const char *name);
(define git_config_get_entry
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_config_get_entry"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (out cfg name)
      (let ((~out (unwrap~pointer out))
            (~name (unwrap~pointer name)))
        (~f ~out cfg ~name)))))
(export git_config_get_entry)

;; extern int git_config_get_int32(int32_t *out, const git_config *cfg, const 
;;     char *name);
(define git_config_get_int32
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_config_get_int32"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (out cfg name)
      (let ((~out (unwrap~pointer out))
            (~name (unwrap~pointer name)))
        (~f ~out cfg ~name)))))
(export git_config_get_int32)

;; extern int git_config_get_int64(int64_t *out, const git_config *cfg, const 
;;     char *name);
(define git_config_get_int64
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_config_get_int64"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (out cfg name)
      (let ((~out (unwrap~pointer out))
            (~name (unwrap~pointer name)))
        (~f ~out cfg ~name)))))
(export git_config_get_int64)

;; extern int git_config_get_bool(int *out, const git_config *cfg, const char 
;;     *name);
(define git_config_get_bool
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_config_get_bool"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (out cfg name)
      (let ((~out (unwrap~pointer out))
            (~name (unwrap~pointer name)))
        (~f ~out cfg ~name)))))
(export git_config_get_bool)

;; extern int git_config_get_path(git_buf *out, const git_config *cfg, const 
;;     char *name);
(define git_config_get_path
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_config_get_path"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (out cfg name)
      (let ((~name (unwrap~pointer name)))
        (~f out cfg ~name)))))
(export git_config_get_path)

;; extern int git_config_get_string(const char **out, const git_config *cfg, 
;;     const char *name);
(define git_config_get_string
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_config_get_string"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (out cfg name)
      (let ((~out (unwrap~pointer out))
            (~name (unwrap~pointer name)))
        (~f ~out cfg ~name)))))
(export git_config_get_string)

;; extern int git_config_get_string_buf(git_buf *out, const git_config *cfg, 
;;     const char *name);
(define git_config_get_string_buf
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_config_get_string_buf"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (out cfg name)
      (let ((~name (unwrap~pointer name)))
        (~f out cfg ~name)))))
(export git_config_get_string_buf)

;; extern int git_config_get_multivar_foreach(const git_config *cfg, const 
;;     char *name, const char *regexp, git_config_foreach_cb callback, void *
;;     payload);
(define git_config_get_multivar_foreach
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_config_get_multivar_foreach"
                (dynamic-link))
              (list '* '* '* '* '*))))
    (lambda (cfg name regexp callback payload)
      (let ((~name (unwrap~pointer name))
            (~regexp (unwrap~pointer regexp))
            (~callback
              (unwrap-git_config_foreach_cb callback))
            (~payload (unwrap~pointer payload)))
        (~f cfg ~name ~regexp ~callback ~payload)))))
(export git_config_get_multivar_foreach)

;; extern int git_config_multivar_iterator_new(git_config_iterator **out, 
;;     const git_config *cfg, const char *name, const char *regexp);
(define git_config_multivar_iterator_new
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_config_multivar_iterator_new"
                (dynamic-link))
              (list '* '* '* '*))))
    (lambda (out cfg name regexp)
      (let ((~out (unwrap~pointer out))
            (~name (unwrap~pointer name))
            (~regexp (unwrap~pointer regexp)))
        (~f ~out cfg ~name ~regexp)))))
(export git_config_multivar_iterator_new)

;; extern int git_config_next(git_config_entry **entry, git_config_iterator *
;;     iter);
(define git_config_next
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_config_next" (dynamic-link))
              (list '* '*))))
    (lambda (entry iter)
      (let ((~entry (unwrap~pointer entry))
            (~iter (unwrap-git_config_iterator* iter)))
        (~f ~entry ~iter)))))
(export git_config_next)

;; extern void git_config_iterator_free(git_config_iterator *iter);
(define git_config_iterator_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "git_config_iterator_free"
                (dynamic-link))
              (list '*))))
    (lambda (iter)
      (let ((~iter (unwrap-git_config_iterator* iter)))
        (~f ~iter)))))
(export git_config_iterator_free)

;; extern int git_config_set_int32(git_config *cfg, const char *name, int32_t 
;;     value);
(define git_config_set_int32
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_config_set_int32"
                (dynamic-link))
              (list '* '* ffi:int32))))
    (lambda (cfg name value)
      (let ((~name (unwrap~pointer name))
            (~value (unwrap-int32_t value)))
        (~f cfg ~name ~value)))))
(export git_config_set_int32)

;; extern int git_config_set_int64(git_config *cfg, const char *name, int64_t 
;;     value);
(define git_config_set_int64
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_config_set_int64"
                (dynamic-link))
              (list '* '* ffi:int64))))
    (lambda (cfg name value)
      (let ((~name (unwrap~pointer name))
            (~value (unwrap-int64_t value)))
        (~f cfg ~name ~value)))))
(export git_config_set_int64)

;; extern int git_config_set_bool(git_config *cfg, const char *name, int value
;;     );
(define git_config_set_bool
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_config_set_bool"
                (dynamic-link))
              (list '* '* ffi:int))))
    (lambda (cfg name value)
      (let ((~name (unwrap~pointer name))
            (~value (unwrap~fixed value)))
        (~f cfg ~name ~value)))))
(export git_config_set_bool)

;; extern int git_config_set_string(git_config *cfg, const char *name, const 
;;     char *value);
(define git_config_set_string
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_config_set_string"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (cfg name value)
      (let ((~name (unwrap~pointer name))
            (~value (unwrap~pointer value)))
        (~f cfg ~name ~value)))))
(export git_config_set_string)

;; extern int git_config_set_multivar(git_config *cfg, const char *name, const
;;      char *regexp, const char *value);
(define git_config_set_multivar
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_config_set_multivar"
                (dynamic-link))
              (list '* '* '* '*))))
    (lambda (cfg name regexp value)
      (let ((~name (unwrap~pointer name))
            (~regexp (unwrap~pointer regexp))
            (~value (unwrap~pointer value)))
        (~f cfg ~name ~regexp ~value)))))
(export git_config_set_multivar)

;; extern int git_config_delete_entry(git_config *cfg, const char *name);
(define git_config_delete_entry
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_config_delete_entry"
                (dynamic-link))
              (list '* '*))))
    (lambda (cfg name)
      (let ((~name (unwrap~pointer name)))
        (~f cfg ~name)))))
(export git_config_delete_entry)

;; extern int git_config_delete_multivar(git_config *cfg, const char *name, 
;;     const char *regexp);
(define git_config_delete_multivar
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_config_delete_multivar"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (cfg name regexp)
      (let ((~name (unwrap~pointer name))
            (~regexp (unwrap~pointer regexp)))
        (~f cfg ~name ~regexp)))))
(export git_config_delete_multivar)

;; extern int git_config_foreach(const git_config *cfg, git_config_foreach_cb 
;;     callback, void *payload);
(define git_config_foreach
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_config_foreach"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (cfg callback payload)
      (let ((~callback
              (unwrap-git_config_foreach_cb callback))
            (~payload (unwrap~pointer payload)))
        (~f cfg ~callback ~payload)))))
(export git_config_foreach)

;; extern int git_config_iterator_new(git_config_iterator **out, const 
;;     git_config *cfg);
(define git_config_iterator_new
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_config_iterator_new"
                (dynamic-link))
              (list '* '*))))
    (lambda (out cfg)
      (let ((~out (unwrap~pointer out))) (~f ~out cfg)))))
(export git_config_iterator_new)

;; extern int git_config_iterator_glob_new(git_config_iterator **out, const 
;;     git_config *cfg, const char *regexp);
(define git_config_iterator_glob_new
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_config_iterator_glob_new"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (out cfg regexp)
      (let ((~out (unwrap~pointer out))
            (~regexp (unwrap~pointer regexp)))
        (~f ~out cfg ~regexp)))))
(export git_config_iterator_glob_new)

;; extern int git_config_foreach_match(const git_config *cfg, const char *
;;     regexp, git_config_foreach_cb callback, void *payload);
(define git_config_foreach_match
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_config_foreach_match"
                (dynamic-link))
              (list '* '* '* '*))))
    (lambda (cfg regexp callback payload)
      (let ((~regexp (unwrap~pointer regexp))
            (~callback
              (unwrap-git_config_foreach_cb callback))
            (~payload (unwrap~pointer payload)))
        (~f cfg ~regexp ~callback ~payload)))))
(export git_config_foreach_match)

;; extern int git_config_get_mapped(int *out, const git_config *cfg, const 
;;     char *name, const git_cvar_map *maps, size_t map_n);
(define git_config_get_mapped
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_config_get_mapped"
                (dynamic-link))
              (list '* '* '* '* ffi:size_t))))
    (lambda (out cfg name maps map_n)
      (let ((~out (unwrap~pointer out))
            (~name (unwrap~pointer name))
            (~maps (unwrap-git_cvar_map* maps))
            (~map_n (unwrap-size_t map_n)))
        (~f ~out cfg ~name ~maps ~map_n)))))
(export git_config_get_mapped)

;; extern int git_config_lookup_map_value(int *out, const git_cvar_map *maps, 
;;     size_t map_n, const char *value);
(define git_config_lookup_map_value
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_config_lookup_map_value"
                (dynamic-link))
              (list '* '* ffi:size_t '*))))
    (lambda (out maps map_n value)
      (let ((~out (unwrap~pointer out))
            (~maps (unwrap-git_cvar_map* maps))
            (~map_n (unwrap-size_t map_n))
            (~value (unwrap~pointer value)))
        (~f ~out ~maps ~map_n ~value)))))
(export git_config_lookup_map_value)

;; extern int git_config_parse_bool(int *out, const char *value);
(define git_config_parse_bool
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_config_parse_bool"
                (dynamic-link))
              (list '* '*))))
    (lambda (out value)
      (let ((~out (unwrap~pointer out))
            (~value (unwrap~pointer value)))
        (~f ~out ~value)))))
(export git_config_parse_bool)

;; extern int git_config_parse_int32(int32_t *out, const char *value);
(define git_config_parse_int32
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_config_parse_int32"
                (dynamic-link))
              (list '* '*))))
    (lambda (out value)
      (let ((~out (unwrap~pointer out))
            (~value (unwrap~pointer value)))
        (~f ~out ~value)))))
(export git_config_parse_int32)

;; extern int git_config_parse_int64(int64_t *out, const char *value);
(define git_config_parse_int64
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_config_parse_int64"
                (dynamic-link))
              (list '* '*))))
    (lambda (out value)
      (let ((~out (unwrap~pointer out))
            (~value (unwrap~pointer value)))
        (~f ~out ~value)))))
(export git_config_parse_int64)

;; extern int git_config_parse_path(git_buf *out, const char *value);
(define git_config_parse_path
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_config_parse_path"
                (dynamic-link))
              (list '* '*))))
    (lambda (out value)
      (let ((~value (unwrap~pointer value)))
        (~f out ~value)))))
(export git_config_parse_path)

;; extern int git_config_backend_foreach_match(git_config_backend *backend, 
;;     const char *regexp, git_config_foreach_cb callback, void *payload);
(define git_config_backend_foreach_match
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_config_backend_foreach_match"
                (dynamic-link))
              (list '* '* '* '*))))
    (lambda (backend regexp callback payload)
      (let ((~regexp (unwrap~pointer regexp))
            (~callback
              (unwrap-git_config_foreach_cb callback))
            (~payload (unwrap~pointer payload)))
        (~f backend ~regexp ~callback ~payload)))))
(export git_config_backend_foreach_match)

;; extern int git_config_lock(git_transaction **tx, git_config *cfg);
(define git_config_lock
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_config_lock" (dynamic-link))
              (list '* '*))))
    (lambda (tx cfg)
      (let ((~tx (unwrap~pointer tx))) (~f ~tx cfg)))))
(export git_config_lock)

;; typedef enum {
;;   GIT_DESCRIBE_DEFAULT,
;;   GIT_DESCRIBE_TAGS,
;;   GIT_DESCRIBE_ALL,
;; } git_describe_strategy_t;
(define-fh-enum git_describe_strategy_t
  '((GIT_DESCRIBE_DEFAULT . 0)
    (GIT_DESCRIBE_TAGS . 1)
    (GIT_DESCRIBE_ALL . 2))
  )

;; typedef struct git_describe_options {
;;   unsigned int version;
;;   unsigned int max_candidates_tags; /**< default: 10 */
;;   unsigned int describe_strategy; /**< default: GIT_DESCRIBE_DEFAULT */
;;   const char *pattern;
;;   /**
;;   	 * When calculating the distance from the matching tag or
;;   	 * reference, only walk down the first-parent ancestry.
;;   	 */
;;   int only_follow_first_parent;
;;   /**
;;   	 * If no matching tag or reference is found, the describe
;;   	 * operation would normally fail. If this option is set, it
;;   	 * will instead fall back to showing the full id of the
;;   	 * commit.
;;   	 */
;;   int show_commit_oid_as_fallback;
;; } git_describe_options;
(define git_describe_options-desc
  (bs:struct
    (list `(version ,unsigned-int)
          `(max_candidates_tags ,unsigned-int)
          `(describe_strategy ,unsigned-int)
          `(pattern ,(bs:pointer int))
          `(only_follow_first_parent ,int)
          `(show_commit_oid_as_fallback ,int))))
(export git_describe_options-desc)
(define-fh-compound-type/p git_describe_options git_describe_options-desc)
(define struct-git_describe_options git_describe_options)

;; extern int git_describe_init_options(git_describe_options *opts, 
;;     unsigned int version);
(define git_describe_init_options
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_describe_init_options"
                (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (opts version)
      (let ((~opts (unwrap-git_describe_options* opts))
            (~version (unwrap~fixed version)))
        (~f ~opts ~version)))))
(export git_describe_init_options)

;; typedef struct {
;;   unsigned int version;
;;   /**
;;   	 * Size of the abbreviated commit id to use. This value is the
;;   	 * lower bound for the length of the abbreviated string. The
;;   	 * default is 7.
;;   	 */
;;   unsigned int abbreviated_size;
;;   /**
;;   	 * Set to use the long format even when a shorter name could be used.
;;   	 */
;;   int always_use_long_format;
;;   /**
;;   	 * If the workdir is dirty and this is set, this string will
;;   	 * be appended to the description string.
;;   	 */
;;   const char *dirty_suffix;
;; } git_describe_format_options;
(define git_describe_format_options-desc
  (bs:struct
    (list `(version ,unsigned-int)
          `(abbreviated_size ,unsigned-int)
          `(always_use_long_format ,int)
          `(dirty_suffix ,(bs:pointer int)))))
(export git_describe_format_options-desc)
(define-fh-compound-type/p git_describe_format_options git_describe_format_options-desc)

;; extern int git_describe_init_format_options(git_describe_format_options *
;;     opts, unsigned int version);
(define git_describe_init_format_options
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_describe_init_format_options"
                (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (opts version)
      (let ((~opts (unwrap-git_describe_format_options* opts))
            (~version (unwrap~fixed version)))
        (~f ~opts ~version)))))
(export git_describe_init_format_options)

;; typedef struct git_describe_result git_describe_result;
(define-fh-pointer-type git_describe_result*)

;; extern int git_describe_commit(git_describe_result **result, git_object *
;;     committish, git_describe_options *opts);
(define git_describe_commit
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_describe_commit"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (result committish opts)
      (let ((~result (unwrap~pointer result))
            (~opts (unwrap-git_describe_options* opts)))
        (~f ~result committish ~opts)))))
(export git_describe_commit)

;; extern int git_describe_workdir(git_describe_result **out, git_repository *
;;     repo, git_describe_options *opts);
(define git_describe_workdir
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_describe_workdir"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (out repo opts)
      (let ((~out (unwrap~pointer out))
            (~opts (unwrap-git_describe_options* opts)))
        (~f ~out repo ~opts)))))
(export git_describe_workdir)

;; extern int git_describe_format(git_buf *out, const git_describe_result *
;;     result, const git_describe_format_options *opts);
(define git_describe_format
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_describe_format"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (out result opts)
      (let ((~result (unwrap-git_describe_result* result))
            (~opts (unwrap-git_describe_format_options* opts)))
        (~f out ~result ~opts)))))
(export git_describe_format)

;; extern void git_describe_result_free(git_describe_result *result);
(define git_describe_result_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "git_describe_result_free"
                (dynamic-link))
              (list '*))))
    (lambda (result)
      (let ((~result (unwrap-git_describe_result* result)))
        (~f ~result)))))
(export git_describe_result_free)

;; typedef enum {
;;   GIT_OK = 0,
;;   GIT_ERROR = -1,
;;   GIT_ENOTFOUND = -3,
;;   GIT_EEXISTS = -4,
;;   GIT_EAMBIGUOUS = -5,
;;   GIT_EBUFS = -6,
;;   GIT_EUSER = -7,
;;   GIT_EBAREREPO = -8,
;;   GIT_EUNBORNBRANCH = -9,
;;   GIT_EUNMERGED = -10,
;;   GIT_ENONFASTFORWARD = -11,
;;   GIT_EINVALIDSPEC = -12,
;;   GIT_ECONFLICT = -13,
;;   GIT_ELOCKED = -14,
;;   GIT_EMODIFIED = -15,
;;   GIT_EAUTH = -16,
;;   GIT_ECERTIFICATE = -17,
;;   GIT_EAPPLIED = -18,
;;   GIT_EPEEL = -19,
;;   GIT_EEOF = -20,
;;   GIT_EINVALID = -21,
;;   GIT_EUNCOMMITTED = -22,
;;   GIT_EDIRECTORY = -23,
;;   GIT_EMERGECONFLICT = -24,
;;   GIT_PASSTHROUGH = -30,
;;   GIT_ITEROVER = -31,
;;   GIT_RETRY = -32,
;;   GIT_EMISMATCH = -33,
;; } git_error_code;
(define-fh-enum git_error_code
  '((GIT_OK . 0)
    (GIT_ERROR . -1)
    (GIT_ENOTFOUND . -3)
    (GIT_EEXISTS . -4)
    (GIT_EAMBIGUOUS . -5)
    (GIT_EBUFS . -6)
    (GIT_EUSER . -7)
    (GIT_EBAREREPO . -8)
    (GIT_EUNBORNBRANCH . -9)
    (GIT_EUNMERGED . -10)
    (GIT_ENONFASTFORWARD . -11)
    (GIT_EINVALIDSPEC . -12)
    (GIT_ECONFLICT . -13)
    (GIT_ELOCKED . -14)
    (GIT_EMODIFIED . -15)
    (GIT_EAUTH . -16)
    (GIT_ECERTIFICATE . -17)
    (GIT_EAPPLIED . -18)
    (GIT_EPEEL . -19)
    (GIT_EEOF . -20)
    (GIT_EINVALID . -21)
    (GIT_EUNCOMMITTED . -22)
    (GIT_EDIRECTORY . -23)
    (GIT_EMERGECONFLICT . -24)
    (GIT_PASSTHROUGH . -30)
    (GIT_ITEROVER . -31)
    (GIT_RETRY . -32)
    (GIT_EMISMATCH . -33))
  )

;; typedef struct {
;;   char *message;
;;   int klass;
;; } git_error;
(define git_error-desc
  (bs:struct
    (list `(message ,(bs:pointer int)) `(klass ,int))))
(export git_error-desc)
(define-fh-compound-type/p git_error git_error-desc)

;; typedef enum {
;;   GITERR_NONE = 0,
;;   GITERR_NOMEMORY,
;;   GITERR_OS,
;;   GITERR_INVALID,
;;   GITERR_REFERENCE,
;;   GITERR_ZLIB,
;;   GITERR_REPOSITORY,
;;   GITERR_CONFIG,
;;   GITERR_REGEX,
;;   GITERR_ODB,
;;   GITERR_INDEX,
;;   GITERR_OBJECT,
;;   GITERR_NET,
;;   GITERR_TAG,
;;   GITERR_TREE,
;;   GITERR_INDEXER,
;;   GITERR_SSL,
;;   GITERR_SUBMODULE,
;;   GITERR_THREAD,
;;   GITERR_STASH,
;;   GITERR_CHECKOUT,
;;   GITERR_FETCHHEAD,
;;   GITERR_MERGE,
;;   GITERR_SSH,
;;   GITERR_FILTER,
;;   GITERR_REVERT,
;;   GITERR_CALLBACK,
;;   GITERR_CHERRYPICK,
;;   GITERR_DESCRIBE,
;;   GITERR_REBASE,
;;   GITERR_FILESYSTEM,
;;   GITERR_PATCH,
;;   GITERR_WORKTREE,
;;   GITERR_SHA1,
;; } git_error_t;
(define-fh-enum git_error_t
  '((GITERR_NONE . 0)
    (GITERR_NOMEMORY . 1)
    (GITERR_OS . 2)
    (GITERR_INVALID . 3)
    (GITERR_REFERENCE . 4)
    (GITERR_ZLIB . 5)
    (GITERR_REPOSITORY . 6)
    (GITERR_CONFIG . 7)
    (GITERR_REGEX . 8)
    (GITERR_ODB . 9)
    (GITERR_INDEX . 10)
    (GITERR_OBJECT . 11)
    (GITERR_NET . 12)
    (GITERR_TAG . 13)
    (GITERR_TREE . 14)
    (GITERR_INDEXER . 15)
    (GITERR_SSL . 16)
    (GITERR_SUBMODULE . 17)
    (GITERR_THREAD . 18)
    (GITERR_STASH . 19)
    (GITERR_CHECKOUT . 20)
    (GITERR_FETCHHEAD . 21)
    (GITERR_MERGE . 22)
    (GITERR_SSH . 23)
    (GITERR_FILTER . 24)
    (GITERR_REVERT . 25)
    (GITERR_CALLBACK . 26)
    (GITERR_CHERRYPICK . 27)
    (GITERR_DESCRIBE . 28)
    (GITERR_REBASE . 29)
    (GITERR_FILESYSTEM . 30)
    (GITERR_PATCH . 31)
    (GITERR_WORKTREE . 32)
    (GITERR_SHA1 . 33))
  )

;; extern const git_error *giterr_last(void);
(define giterr_last
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "giterr_last" (dynamic-link))
              (list))))
    (lambda () (let () (wrap-git_error* (~f))))))
(export giterr_last)

;; extern void giterr_clear(void);
(define giterr_clear
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "giterr_clear" (dynamic-link))
              (list))))
    (lambda () (let () (~f)))))
(export giterr_clear)

;; extern void giterr_set_str(int error_class, const char *string);
(define giterr_set_str
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "giterr_set_str" (dynamic-link))
              (list ffi:int '*))))
    (lambda (error_class string)
      (let ((~error_class (unwrap~fixed error_class))
            (~string (unwrap~pointer string)))
        (~f ~error_class ~string)))))
(export giterr_set_str)

;; extern void giterr_set_oom(void);
(define giterr_set_oom
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "giterr_set_oom" (dynamic-link))
              (list))))
    (lambda () (let () (~f)))))
(export giterr_set_oom)

;; typedef enum {
;;   GIT_FILTER_TO_WORKTREE = 0,
;;   GIT_FILTER_SMUDGE = GIT_FILTER_TO_WORKTREE,
;;   GIT_FILTER_TO_ODB = 1,
;;   GIT_FILTER_CLEAN = GIT_FILTER_TO_ODB,
;; } git_filter_mode_t;
(define-fh-enum git_filter_mode_t
  '((GIT_FILTER_TO_WORKTREE . 0)
    (GIT_FILTER_SMUDGE . 0)
    (GIT_FILTER_TO_ODB . 1)
    (GIT_FILTER_CLEAN . 0))
  )

;; typedef enum {
;;   GIT_FILTER_DEFAULT = 0u,
;;   GIT_FILTER_ALLOW_UNSAFE = 1u<<0,
;; } git_filter_flag_t;
(define-fh-enum git_filter_flag_t
  '((GIT_FILTER_DEFAULT . 0)
    (GIT_FILTER_ALLOW_UNSAFE . 1))
  )

;; typedef struct git_filter git_filter;
(define-fh-pointer-type git_filter*)

;; typedef struct git_filter_list git_filter_list;
(define-fh-pointer-type git_filter_list*)

;; extern int git_filter_list_load(git_filter_list **filters, git_repository *
;;     repo, git_blob *blob, const char *path, git_filter_mode_t mode, 
;;     uint32_t flags);
(define git_filter_list_load
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_filter_list_load"
                (dynamic-link))
              (list '* '* '* '* ffi:int ffi:uint32))))
    (lambda (filters repo blob path mode flags)
      (let ((~filters (unwrap~pointer filters))
            (~path (unwrap~pointer path))
            (~mode (unwrap-git_filter_mode_t mode))
            (~flags (unwrap-uint32_t flags)))
        (~f ~filters repo blob ~path ~mode ~flags)))))
(export git_filter_list_load)

;; extern int git_filter_list_contains(git_filter_list *filters, const char *
;;     name);
(define git_filter_list_contains
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_filter_list_contains"
                (dynamic-link))
              (list '* '*))))
    (lambda (filters name)
      (let ((~filters (unwrap-git_filter_list* filters))
            (~name (unwrap~pointer name)))
        (~f ~filters ~name)))))
(export git_filter_list_contains)

;; extern int git_filter_list_apply_to_data(git_buf *out, git_filter_list *
;;     filters, git_buf *in);
(define git_filter_list_apply_to_data
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_filter_list_apply_to_data"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (out filters in)
      (let ((~filters (unwrap-git_filter_list* filters)))
        (~f out ~filters in)))))
(export git_filter_list_apply_to_data)

;; extern int git_filter_list_apply_to_file(git_buf *out, git_filter_list *
;;     filters, git_repository *repo, const char *path);
(define git_filter_list_apply_to_file
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_filter_list_apply_to_file"
                (dynamic-link))
              (list '* '* '* '*))))
    (lambda (out filters repo path)
      (let ((~filters (unwrap-git_filter_list* filters))
            (~path (unwrap~pointer path)))
        (~f out ~filters repo ~path)))))
(export git_filter_list_apply_to_file)

;; extern int git_filter_list_apply_to_blob(git_buf *out, git_filter_list *
;;     filters, git_blob *blob);
(define git_filter_list_apply_to_blob
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_filter_list_apply_to_blob"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (out filters blob)
      (let ((~filters (unwrap-git_filter_list* filters)))
        (~f out ~filters blob)))))
(export git_filter_list_apply_to_blob)

;; extern int git_filter_list_stream_data(git_filter_list *filters, git_buf *
;;     data, git_writestream *target);
(define git_filter_list_stream_data
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_filter_list_stream_data"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (filters data target)
      (let ((~filters (unwrap-git_filter_list* filters)))
        (~f ~filters data target)))))
(export git_filter_list_stream_data)

;; extern int git_filter_list_stream_file(git_filter_list *filters, 
;;     git_repository *repo, const char *path, git_writestream *target);
(define git_filter_list_stream_file
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_filter_list_stream_file"
                (dynamic-link))
              (list '* '* '* '*))))
    (lambda (filters repo path target)
      (let ((~filters (unwrap-git_filter_list* filters))
            (~path (unwrap~pointer path)))
        (~f ~filters repo ~path target)))))
(export git_filter_list_stream_file)

;; extern int git_filter_list_stream_blob(git_filter_list *filters, git_blob *
;;     blob, git_writestream *target);
(define git_filter_list_stream_blob
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_filter_list_stream_blob"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (filters blob target)
      (let ((~filters (unwrap-git_filter_list* filters)))
        (~f ~filters blob target)))))
(export git_filter_list_stream_blob)

;; extern void git_filter_list_free(git_filter_list *filters);
(define git_filter_list_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "git_filter_list_free"
                (dynamic-link))
              (list '*))))
    (lambda (filters)
      (let ((~filters (unwrap-git_filter_list* filters)))
        (~f ~filters)))))
(export git_filter_list_free)

;; extern int git_libgit2_init(void);
(define git_libgit2_init
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_libgit2_init" (dynamic-link))
              (list))))
    (lambda () (let () (~f)))))
(export git_libgit2_init)

;; extern int git_libgit2_shutdown(void);
(define git_libgit2_shutdown
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_libgit2_shutdown"
                (dynamic-link))
              (list))))
    (lambda () (let () (~f)))))
(export git_libgit2_shutdown)

;; extern int git_graph_ahead_behind(size_t *ahead, size_t *behind, 
;;     git_repository *repo, const git_oid *local, const git_oid *upstream);
(define git_graph_ahead_behind
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_graph_ahead_behind"
                (dynamic-link))
              (list '* '* '* '* '*))))
    (lambda (ahead behind repo local upstream)
      (let ((~ahead (unwrap~pointer ahead))
            (~behind (unwrap~pointer behind)))
        (~f ~ahead ~behind repo local upstream)))))
(export git_graph_ahead_behind)

;; extern int git_graph_descendant_of(git_repository *repo, const git_oid *
;;     commit, const git_oid *ancestor);
(define git_graph_descendant_of
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_graph_descendant_of"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (repo commit ancestor)
      (let () (~f repo commit ancestor)))))
(export git_graph_descendant_of)

;; extern int git_ignore_add_rule(git_repository *repo, const char *rules);
(define git_ignore_add_rule
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_ignore_add_rule"
                (dynamic-link))
              (list '* '*))))
    (lambda (repo rules)
      (let ((~rules (unwrap~pointer rules)))
        (~f repo ~rules)))))
(export git_ignore_add_rule)

;; extern int git_ignore_clear_internal_rules(git_repository *repo);
(define git_ignore_clear_internal_rules
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_ignore_clear_internal_rules"
                (dynamic-link))
              (list '*))))
    (lambda (repo) (let () (~f repo)))))
(export git_ignore_clear_internal_rules)

;; extern int git_ignore_path_is_ignored(int *ignored, git_repository *repo, 
;;     const char *path);
(define git_ignore_path_is_ignored
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_ignore_path_is_ignored"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (ignored repo path)
      (let ((~ignored (unwrap~pointer ignored))
            (~path (unwrap~pointer path)))
        (~f ~ignored repo ~path)))))
(export git_ignore_path_is_ignored)

;; extern int git_message_prettify(git_buf *out, const char *message, int 
;;     strip_comments, char comment_char);
(define git_message_prettify
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_message_prettify"
                (dynamic-link))
              (list '* '* ffi:int ffi:int))))
    (lambda (out message strip_comments comment_char)
      (let ((~message (unwrap~pointer message))
            (~strip_comments (unwrap~fixed strip_comments))
            (~comment_char (unwrap~fixed comment_char)))
        (~f out ~message ~strip_comments ~comment_char)))))
(export git_message_prettify)

;; typedef int (*git_note_foreach_cb)(const git_oid *blob_id, const git_oid *
;;     annotated_object_id, void *payload);
(define-fh-function/p git_note_foreach_cb
  ffi:int (list (quote *) (quote *) (quote *)))

;; typedef struct git_iterator git_note_iterator;
(define-fh-pointer-type git_note_iterator*)

;; extern int git_note_iterator_new(git_note_iterator **out, git_repository *
;;     repo, const char *notes_ref);
(define git_note_iterator_new
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_note_iterator_new"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (out repo notes_ref)
      (let ((~out (unwrap~pointer out))
            (~notes_ref (unwrap~pointer notes_ref)))
        (~f ~out repo ~notes_ref)))))
(export git_note_iterator_new)

;; extern void git_note_iterator_free(git_note_iterator *it);
(define git_note_iterator_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "git_note_iterator_free"
                (dynamic-link))
              (list '*))))
    (lambda (it)
      (let ((~it (unwrap-git_note_iterator* it)))
        (~f ~it)))))
(export git_note_iterator_free)

;; extern int git_note_next(git_oid *note_id, git_oid *annotated_id, 
;;     git_note_iterator *it);
(define git_note_next
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_note_next" (dynamic-link))
              (list '* '* '*))))
    (lambda (note_id annotated_id it)
      (let ((~it (unwrap-git_note_iterator* it)))
        (~f note_id annotated_id ~it)))))
(export git_note_next)

;; extern int git_note_read(git_note **out, git_repository *repo, const char *
;;     notes_ref, const git_oid *oid);
(define git_note_read
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_note_read" (dynamic-link))
              (list '* '* '* '*))))
    (lambda (out repo notes_ref oid)
      (let ((~out (unwrap~pointer out))
            (~notes_ref (unwrap~pointer notes_ref)))
        (~f ~out repo ~notes_ref oid)))))
(export git_note_read)

;; extern const git_signature *git_note_author(const git_note *note);
(define git_note_author
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "git_note_author" (dynamic-link))
              (list '*))))
    (lambda (note) (let () (~f note)))))
(export git_note_author)

;; extern const git_signature *git_note_committer(const git_note *note);
(define git_note_committer
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "git_note_committer"
                (dynamic-link))
              (list '*))))
    (lambda (note) (let () (~f note)))))
(export git_note_committer)

;; extern const char *git_note_message(const git_note *note);
(define git_note_message
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "git_note_message" (dynamic-link))
              (list '*))))
    (lambda (note) (let () (~f note)))))
(export git_note_message)

;; extern const git_oid *git_note_id(const git_note *note);
(define git_note_id
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "git_note_id" (dynamic-link))
              (list '*))))
    (lambda (note) (let () (~f note)))))
(export git_note_id)

;; extern int git_note_create(git_oid *out, git_repository *repo, const char *
;;     notes_ref, const git_signature *author, const git_signature *committer
;;     , const git_oid *oid, const char *note, int force);
(define git_note_create
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_note_create" (dynamic-link))
              (list '* '* '* '* '* '* '* ffi:int))))
    (lambda (out
             repo
             notes_ref
             author
             committer
             oid
             note
             force)
      (let ((~notes_ref (unwrap~pointer notes_ref))
            (~note (unwrap~pointer note))
            (~force (unwrap~fixed force)))
        (~f out
            repo
            ~notes_ref
            author
            committer
            oid
            ~note
            ~force)))))
(export git_note_create)

;; extern int git_note_remove(git_repository *repo, const char *notes_ref, 
;;     const git_signature *author, const git_signature *committer, const 
;;     git_oid *oid);
(define git_note_remove
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_note_remove" (dynamic-link))
              (list '* '* '* '* '*))))
    (lambda (repo notes_ref author committer oid)
      (let ((~notes_ref (unwrap~pointer notes_ref)))
        (~f repo ~notes_ref author committer oid)))))
(export git_note_remove)

;; extern void git_note_free(git_note *note);
(define git_note_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "git_note_free" (dynamic-link))
              (list '*))))
    (lambda (note) (let () (~f note)))))
(export git_note_free)

;; extern int git_note_default_ref(git_buf *out, git_repository *repo);
(define git_note_default_ref
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_note_default_ref"
                (dynamic-link))
              (list '* '*))))
    (lambda (out repo) (let () (~f out repo)))))
(export git_note_default_ref)

;; extern int git_note_foreach(git_repository *repo, const char *notes_ref, 
;;     git_note_foreach_cb note_cb, void *payload);
(define git_note_foreach
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_note_foreach" (dynamic-link))
              (list '* '* '* '*))))
    (lambda (repo notes_ref note_cb payload)
      (let ((~notes_ref (unwrap~pointer notes_ref))
            (~note_cb (unwrap-git_note_foreach_cb note_cb))
            (~payload (unwrap~pointer payload)))
        (~f repo ~notes_ref ~note_cb ~payload)))))
(export git_note_foreach)

;; typedef int (*git_odb_foreach_cb)(const git_oid *id, void *payload);
(define-fh-function/p git_odb_foreach_cb
  ffi:int (list (quote *) (quote *)))

;; extern int git_odb_new(git_odb **out);
(define git_odb_new
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_odb_new" (dynamic-link))
              (list '*))))
    (lambda (out)
      (let ((~out (unwrap~pointer out))) (~f ~out)))))
(export git_odb_new)

;; extern int git_odb_open(git_odb **out, const char *objects_dir);
(define git_odb_open
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_odb_open" (dynamic-link))
              (list '* '*))))
    (lambda (out objects_dir)
      (let ((~out (unwrap~pointer out))
            (~objects_dir (unwrap~pointer objects_dir)))
        (~f ~out ~objects_dir)))))
(export git_odb_open)

;; extern int git_odb_add_disk_alternate(git_odb *odb, const char *path);
(define git_odb_add_disk_alternate
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_odb_add_disk_alternate"
                (dynamic-link))
              (list '* '*))))
    (lambda (odb path)
      (let ((~path (unwrap~pointer path)))
        (~f odb ~path)))))
(export git_odb_add_disk_alternate)

;; extern void git_odb_free(git_odb *db);
(define git_odb_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "git_odb_free" (dynamic-link))
              (list '*))))
    (lambda (db) (let () (~f db)))))
(export git_odb_free)

;; extern int git_odb_read(git_odb_object **out, git_odb *db, const git_oid *
;;     id);
(define git_odb_read
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_odb_read" (dynamic-link))
              (list '* '* '*))))
    (lambda (out db id)
      (let ((~out (unwrap~pointer out)))
        (~f ~out db id)))))
(export git_odb_read)

;; extern int git_odb_read_prefix(git_odb_object **out, git_odb *db, const 
;;     git_oid *short_id, size_t len);
(define git_odb_read_prefix
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_odb_read_prefix"
                (dynamic-link))
              (list '* '* '* ffi:size_t))))
    (lambda (out db short_id len)
      (let ((~out (unwrap~pointer out))
            (~len (unwrap-size_t len)))
        (~f ~out db short_id ~len)))))
(export git_odb_read_prefix)

;; extern int git_odb_read_header(size_t *len_out, git_otype *type_out, 
;;     git_odb *db, const git_oid *id);
(define git_odb_read_header
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_odb_read_header"
                (dynamic-link))
              (list '* '* '* '*))))
    (lambda (len_out type_out db id)
      (let ((~len_out (unwrap~pointer len_out)))
        (~f ~len_out type_out db id)))))
(export git_odb_read_header)

;; extern int git_odb_exists(git_odb *db, const git_oid *id);
(define git_odb_exists
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_odb_exists" (dynamic-link))
              (list '* '*))))
    (lambda (db id) (let () (~f db id)))))
(export git_odb_exists)

;; extern int git_odb_exists_prefix(git_oid *out, git_odb *db, const git_oid *
;;     short_id, size_t len);
(define git_odb_exists_prefix
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_odb_exists_prefix"
                (dynamic-link))
              (list '* '* '* ffi:size_t))))
    (lambda (out db short_id len)
      (let ((~len (unwrap-size_t len)))
        (~f out db short_id ~len)))))
(export git_odb_exists_prefix)

;; typedef struct git_odb_expand_id {
;;   /** The object ID to expand */
;;   git_oid id;
;;   /**
;;   	 * The length of the object ID (in nibbles, or packets of 4 bits; the
;;   	 * number of hex characters)
;;   	 * */
;;   unsigned short length;
;;   /**
;;   	 * The (optional) type of the object to search for; leave as `0` or set
;;   	 * to `GIT_OBJ_ANY` to query for any object matching the ID.
;;   	 */
;;   git_otype type;
;; } git_odb_expand_id;
(define git_odb_expand_id-desc
  (bs:struct
    (list `(id ,(bs:struct (list `(id ,(bs:vector 20 #f)))))
          `(length ,unsigned-short)
          `(type ,int))))
(export git_odb_expand_id-desc)
(define-fh-compound-type/p git_odb_expand_id git_odb_expand_id-desc)
(define struct-git_odb_expand_id git_odb_expand_id)

;; extern int git_odb_expand_ids(git_odb *db, git_odb_expand_id *ids, size_t 
;;     count);
(define git_odb_expand_ids
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_odb_expand_ids"
                (dynamic-link))
              (list '* '* ffi:size_t))))
    (lambda (db ids count)
      (let ((~ids (unwrap-git_odb_expand_id* ids))
            (~count (unwrap-size_t count)))
        (~f db ~ids ~count)))))
(export git_odb_expand_ids)

;; extern int git_odb_refresh(struct git_odb *db);
(define git_odb_refresh
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_odb_refresh" (dynamic-link))
              (list '*))))
    (lambda (db)
      (let ((~db (pointer-address db))) (~f ~db)))))
(export git_odb_refresh)

;; extern int git_odb_foreach(git_odb *db, git_odb_foreach_cb cb, void *
;;     payload);
(define git_odb_foreach
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_odb_foreach" (dynamic-link))
              (list '* '* '*))))
    (lambda (db cb payload)
      (let ((~cb (unwrap-git_odb_foreach_cb cb))
            (~payload (unwrap~pointer payload)))
        (~f db ~cb ~payload)))))
(export git_odb_foreach)

;; extern int git_odb_write(git_oid *out, git_odb *odb, const void *data, 
;;     size_t len, git_otype type);
(define git_odb_write
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_odb_write" (dynamic-link))
              (list '* '* '* ffi:size_t ffi:int))))
    (lambda (out odb data len type)
      (let ((~data (unwrap~pointer data))
            (~len (unwrap-size_t len))
            (~type (unwrap-git_otype type)))
        (~f out odb ~data ~len ~type)))))
(export git_odb_write)

;; extern int git_odb_open_wstream(git_odb_stream **out, git_odb *db, 
;;     git_off_t size, git_otype type);
(define git_odb_open_wstream
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_odb_open_wstream"
                (dynamic-link))
              (list '* '* ffi:int64 ffi:int))))
    (lambda (out db size type)
      (let ((~out (unwrap~pointer out))
            (~size (unwrap-git_off_t size))
            (~type (unwrap-git_otype type)))
        (~f ~out db ~size ~type)))))
(export git_odb_open_wstream)

;; extern int git_odb_stream_write(git_odb_stream *stream, const char *buffer
;;     , size_t len);
(define git_odb_stream_write
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_odb_stream_write"
                (dynamic-link))
              (list '* '* ffi:size_t))))
    (lambda (stream buffer len)
      (let ((~buffer (unwrap~pointer buffer))
            (~len (unwrap-size_t len)))
        (~f stream ~buffer ~len)))))
(export git_odb_stream_write)

;; extern int git_odb_stream_finalize_write(git_oid *out, git_odb_stream *
;;     stream);
(define git_odb_stream_finalize_write
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_odb_stream_finalize_write"
                (dynamic-link))
              (list '* '*))))
    (lambda (out stream) (let () (~f out stream)))))
(export git_odb_stream_finalize_write)

;; extern int git_odb_stream_read(git_odb_stream *stream, char *buffer, size_t
;;      len);
(define git_odb_stream_read
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_odb_stream_read"
                (dynamic-link))
              (list '* '* ffi:size_t))))
    (lambda (stream buffer len)
      (let ((~buffer (unwrap~pointer buffer))
            (~len (unwrap-size_t len)))
        (~f stream ~buffer ~len)))))
(export git_odb_stream_read)

;; extern void git_odb_stream_free(git_odb_stream *stream);
(define git_odb_stream_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "git_odb_stream_free"
                (dynamic-link))
              (list '*))))
    (lambda (stream) (let () (~f stream)))))
(export git_odb_stream_free)

;; extern int git_odb_open_rstream(git_odb_stream **out, git_odb *db, const 
;;     git_oid *oid);
(define git_odb_open_rstream
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_odb_open_rstream"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (out db oid)
      (let ((~out (unwrap~pointer out)))
        (~f ~out db oid)))))
(export git_odb_open_rstream)

;; extern int git_odb_write_pack(git_odb_writepack **out, git_odb *db, 
;;     git_transfer_progress_cb progress_cb, void *progress_payload);
(define git_odb_write_pack
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_odb_write_pack"
                (dynamic-link))
              (list '* '* '* '*))))
    (lambda (out db progress_cb progress_payload)
      (let ((~out (unwrap~pointer out))
            (~progress_cb
              (unwrap-git_transfer_progress_cb progress_cb))
            (~progress_payload
              (unwrap~pointer progress_payload)))
        (~f ~out db ~progress_cb ~progress_payload)))))
(export git_odb_write_pack)

;; extern int git_odb_hash(git_oid *out, const void *data, size_t len, 
;;     git_otype type);
(define git_odb_hash
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_odb_hash" (dynamic-link))
              (list '* '* ffi:size_t ffi:int))))
    (lambda (out data len type)
      (let ((~data (unwrap~pointer data))
            (~len (unwrap-size_t len))
            (~type (unwrap-git_otype type)))
        (~f out ~data ~len ~type)))))
(export git_odb_hash)

;; extern int git_odb_hashfile(git_oid *out, const char *path, git_otype type)
;;     ;
(define git_odb_hashfile
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_odb_hashfile" (dynamic-link))
              (list '* '* ffi:int))))
    (lambda (out path type)
      (let ((~path (unwrap~pointer path))
            (~type (unwrap-git_otype type)))
        (~f out ~path ~type)))))
(export git_odb_hashfile)

;; extern int git_odb_object_dup(git_odb_object **dest, git_odb_object *source
;;     );
(define git_odb_object_dup
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_odb_object_dup"
                (dynamic-link))
              (list '* '*))))
    (lambda (dest source)
      (let ((~dest (unwrap~pointer dest)))
        (~f ~dest source)))))
(export git_odb_object_dup)

;; extern void git_odb_object_free(git_odb_object *object);
(define git_odb_object_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "git_odb_object_free"
                (dynamic-link))
              (list '*))))
    (lambda (object) (let () (~f object)))))
(export git_odb_object_free)

;; extern const git_oid *git_odb_object_id(git_odb_object *object);
(define git_odb_object_id
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "git_odb_object_id" (dynamic-link))
              (list '*))))
    (lambda (object) (let () (~f object)))))
(export git_odb_object_id)

;; extern const void *git_odb_object_data(git_odb_object *object);
(define git_odb_object_data
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "git_odb_object_data"
                (dynamic-link))
              (list '*))))
    (lambda (object) (let () (~f object)))))
(export git_odb_object_data)

;; extern size_t git_odb_object_size(git_odb_object *object);
(define git_odb_object_size
  (let ((~f (ffi:pointer->procedure
              ffi:size_t
              (dynamic-func
                "git_odb_object_size"
                (dynamic-link))
              (list '*))))
    (lambda (object)
      (let () (wrap-size_t (~f object))))))
(export git_odb_object_size)

;; extern git_otype git_odb_object_type(git_odb_object *object);
(define git_odb_object_type
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_odb_object_type"
                (dynamic-link))
              (list '*))))
    (lambda (object) (let () (~f object)))))
(export git_odb_object_type)

;; extern int git_odb_add_backend(git_odb *odb, git_odb_backend *backend, int 
;;     priority);
(define git_odb_add_backend
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_odb_add_backend"
                (dynamic-link))
              (list '* '* ffi:int))))
    (lambda (odb backend priority)
      (let ((~priority (unwrap~fixed priority)))
        (~f odb backend ~priority)))))
(export git_odb_add_backend)

;; extern int git_odb_add_alternate(git_odb *odb, git_odb_backend *backend, 
;;     int priority);
(define git_odb_add_alternate
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_odb_add_alternate"
                (dynamic-link))
              (list '* '* ffi:int))))
    (lambda (odb backend priority)
      (let ((~priority (unwrap~fixed priority)))
        (~f odb backend ~priority)))))
(export git_odb_add_alternate)

;; extern size_t git_odb_num_backends(git_odb *odb);
(define git_odb_num_backends
  (let ((~f (ffi:pointer->procedure
              ffi:size_t
              (dynamic-func
                "git_odb_num_backends"
                (dynamic-link))
              (list '*))))
    (lambda (odb) (let () (wrap-size_t (~f odb))))))
(export git_odb_num_backends)

;; extern int git_odb_get_backend(git_odb_backend **out, git_odb *odb, size_t 
;;     pos);
(define git_odb_get_backend
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_odb_get_backend"
                (dynamic-link))
              (list '* '* ffi:size_t))))
    (lambda (out odb pos)
      (let ((~out (unwrap~pointer out))
            (~pos (unwrap-size_t pos)))
        (~f ~out odb ~pos)))))
(export git_odb_get_backend)

;; extern int git_odb_backend_pack(git_odb_backend **out, const char *
;;     objects_dir);
(define git_odb_backend_pack
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_odb_backend_pack"
                (dynamic-link))
              (list '* '*))))
    (lambda (out objects_dir)
      (let ((~out (unwrap~pointer out))
            (~objects_dir (unwrap~pointer objects_dir)))
        (~f ~out ~objects_dir)))))
(export git_odb_backend_pack)

;; extern int git_odb_backend_loose(git_odb_backend **out, const char *
;;     objects_dir, int compression_level, int do_fsync, unsigned int dir_mode
;;     , unsigned int file_mode);
(define git_odb_backend_loose
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_odb_backend_loose"
                (dynamic-link))
              (list '*
                    '*
                    ffi:int
                    ffi:int
                    ffi:unsigned-int
                    ffi:unsigned-int))))
    (lambda (out
             objects_dir
             compression_level
             do_fsync
             dir_mode
             file_mode)
      (let ((~out (unwrap~pointer out))
            (~objects_dir (unwrap~pointer objects_dir))
            (~compression_level
              (unwrap~fixed compression_level))
            (~do_fsync (unwrap~fixed do_fsync))
            (~dir_mode (unwrap~fixed dir_mode))
            (~file_mode (unwrap~fixed file_mode)))
        (~f ~out
            ~objects_dir
            ~compression_level
            ~do_fsync
            ~dir_mode
            ~file_mode)))))
(export git_odb_backend_loose)

;; extern int git_odb_backend_one_pack(git_odb_backend **out, const char *
;;     index_file);
(define git_odb_backend_one_pack
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_odb_backend_one_pack"
                (dynamic-link))
              (list '* '*))))
    (lambda (out index_file)
      (let ((~out (unwrap~pointer out))
            (~index_file (unwrap~pointer index_file)))
        (~f ~out ~index_file)))))
(export git_odb_backend_one_pack)

;; typedef enum {
;;   GIT_STREAM_RDONLY = 1<<1,
;;   GIT_STREAM_WRONLY = 1<<2,
;;   GIT_STREAM_RW = GIT_STREAM_RDONLY | GIT_STREAM_WRONLY,
;; } git_odb_stream_t;
(define-fh-enum git_odb_stream_t
  '((GIT_STREAM_RDONLY . 2)
    (GIT_STREAM_WRONLY . 4)
    (GIT_STREAM_RW . 0))
  )

;; struct git_odb_stream {
;;   git_odb_backend *backend;
;;   unsigned int mode;
;;   void *hash_ctx;
;;   git_off_t declared_size;
;;   git_off_t received_bytes;
;;   /**
;;   	 * Write at most `len` bytes into `buffer` and advance the stream.
;;   	 */
;;   int (*read)(git_odb_stream *stream, char *buffer, size_t len);
;;   /**
;;   	 * Write `len` bytes from `buffer` into the stream.
;;   	 */
;;   int (*write)(git_odb_stream *stream, const char *buffer, size_t len);
;;   /**
;;   	 * Store the contents of the stream as an object with the id
;;   	 * specified in `oid`.
;;   	 *
;;   	 * This method might not be invoked if:
;;   	 * - an error occurs earlier with the `write` callback,
;;   	 * - the object referred to by `oid` already exists in any backend, or
;;   	 * - the final number of received bytes differs from the size declared
;;   	 *   with `git_odb_open_wstream()`
;;   	 */
;;   int (*finalize_write)(git_odb_stream *stream, const git_oid *oid);
;;   /**
;;   	 * Free the stream's memory.
;;   	 *
;;   	 * This method might be called without a call to `finalize_write` if
;;   	 * an error occurs or if the object is already present in the ODB.
;;   	 */
;;   void (*free)(git_odb_stream *stream);
;; };
;; ... failed.

;; struct git_odb_writepack {
;;   git_odb_backend *backend;
;;   int (*append)(git_odb_writepack *writepack, const void *data, size_t size
;;       , git_transfer_progress *stats);
;;   int (*commit)(git_odb_writepack *writepack, git_transfer_progress *stats)
;;       ;
;;   void (*free)(git_odb_writepack *writepack);
;; };
;; ... failed.

;; typedef struct git_patch git_patch;
(define-fh-pointer-type git_patch*)

;; extern int git_patch_from_diff(git_patch **out, git_diff *diff, size_t idx)
;;     ;
(define git_patch_from_diff
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_patch_from_diff"
                (dynamic-link))
              (list '* '* ffi:size_t))))
    (lambda (out diff idx)
      (let ((~out (unwrap~pointer out))
            (~idx (unwrap-size_t idx)))
        (~f ~out diff ~idx)))))
(export git_patch_from_diff)

;; extern int git_patch_from_blobs(git_patch **out, const git_blob *old_blob, 
;;     const char *old_as_path, const git_blob *new_blob, const char *
;;     new_as_path, const git_diff_options *opts);
(define git_patch_from_blobs
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_patch_from_blobs"
                (dynamic-link))
              (list '* '* '* '* '* '*))))
    (lambda (out
             old_blob
             old_as_path
             new_blob
             new_as_path
             opts)
      (let ((~out (unwrap~pointer out))
            (~old_as_path (unwrap~pointer old_as_path))
            (~new_as_path (unwrap~pointer new_as_path)))
        (~f ~out
            old_blob
            ~old_as_path
            new_blob
            ~new_as_path
            opts)))))
(export git_patch_from_blobs)

;; extern int git_patch_from_blob_and_buffer(git_patch **out, const git_blob *
;;     old_blob, const char *old_as_path, const char *buffer, size_t 
;;     buffer_len, const char *buffer_as_path, const git_diff_options *opts);
(define git_patch_from_blob_and_buffer
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_patch_from_blob_and_buffer"
                (dynamic-link))
              (list '* '* '* '* ffi:size_t '* '*))))
    (lambda (out
             old_blob
             old_as_path
             buffer
             buffer_len
             buffer_as_path
             opts)
      (let ((~out (unwrap~pointer out))
            (~old_as_path (unwrap~pointer old_as_path))
            (~buffer (unwrap~pointer buffer))
            (~buffer_len (unwrap-size_t buffer_len))
            (~buffer_as_path (unwrap~pointer buffer_as_path)))
        (~f ~out
            old_blob
            ~old_as_path
            ~buffer
            ~buffer_len
            ~buffer_as_path
            opts)))))
(export git_patch_from_blob_and_buffer)

;; extern int git_patch_from_buffers(git_patch **out, const void *old_buffer, 
;;     size_t old_len, const char *old_as_path, const char *new_buffer, size_t
;;      new_len, const char *new_as_path, const git_diff_options *opts);
(define git_patch_from_buffers
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_patch_from_buffers"
                (dynamic-link))
              (list '* '* ffi:size_t '* '* ffi:size_t '* '*))))
    (lambda (out
             old_buffer
             old_len
             old_as_path
             new_buffer
             new_len
             new_as_path
             opts)
      (let ((~out (unwrap~pointer out))
            (~old_buffer (unwrap~pointer old_buffer))
            (~old_len (unwrap-size_t old_len))
            (~old_as_path (unwrap~pointer old_as_path))
            (~new_buffer (unwrap~pointer new_buffer))
            (~new_len (unwrap-size_t new_len))
            (~new_as_path (unwrap~pointer new_as_path)))
        (~f ~out
            ~old_buffer
            ~old_len
            ~old_as_path
            ~new_buffer
            ~new_len
            ~new_as_path
            opts)))))
(export git_patch_from_buffers)

;; extern void git_patch_free(git_patch *patch);
(define git_patch_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "git_patch_free" (dynamic-link))
              (list '*))))
    (lambda (patch)
      (let ((~patch (unwrap-git_patch* patch)))
        (~f ~patch)))))
(export git_patch_free)

;; extern const git_diff_delta *git_patch_get_delta(const git_patch *patch);
(define git_patch_get_delta
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "git_patch_get_delta"
                (dynamic-link))
              (list '*))))
    (lambda (patch)
      (let ((~patch (unwrap-git_patch* patch)))
        (~f ~patch)))))
(export git_patch_get_delta)

;; extern size_t git_patch_num_hunks(const git_patch *patch);
(define git_patch_num_hunks
  (let ((~f (ffi:pointer->procedure
              ffi:size_t
              (dynamic-func
                "git_patch_num_hunks"
                (dynamic-link))
              (list '*))))
    (lambda (patch)
      (let ((~patch (unwrap-git_patch* patch)))
        (wrap-size_t (~f ~patch))))))
(export git_patch_num_hunks)

;; extern int git_patch_line_stats(size_t *total_context, size_t *
;;     total_additions, size_t *total_deletions, const git_patch *patch);
(define git_patch_line_stats
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_patch_line_stats"
                (dynamic-link))
              (list '* '* '* '*))))
    (lambda (total_context
             total_additions
             total_deletions
             patch)
      (let ((~total_context (unwrap~pointer total_context))
            (~total_additions
              (unwrap~pointer total_additions))
            (~total_deletions
              (unwrap~pointer total_deletions))
            (~patch (unwrap-git_patch* patch)))
        (~f ~total_context
            ~total_additions
            ~total_deletions
            ~patch)))))
(export git_patch_line_stats)

;; extern int git_patch_get_hunk(const git_diff_hunk **out, size_t *
;;     lines_in_hunk, git_patch *patch, size_t hunk_idx);
(define git_patch_get_hunk
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_patch_get_hunk"
                (dynamic-link))
              (list '* '* '* ffi:size_t))))
    (lambda (out lines_in_hunk patch hunk_idx)
      (let ((~out (unwrap~pointer out))
            (~lines_in_hunk (unwrap~pointer lines_in_hunk))
            (~patch (unwrap-git_patch* patch))
            (~hunk_idx (unwrap-size_t hunk_idx)))
        (~f ~out ~lines_in_hunk ~patch ~hunk_idx)))))
(export git_patch_get_hunk)

;; extern int git_patch_num_lines_in_hunk(const git_patch *patch, size_t 
;;     hunk_idx);
(define git_patch_num_lines_in_hunk
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_patch_num_lines_in_hunk"
                (dynamic-link))
              (list '* ffi:size_t))))
    (lambda (patch hunk_idx)
      (let ((~patch (unwrap-git_patch* patch))
            (~hunk_idx (unwrap-size_t hunk_idx)))
        (~f ~patch ~hunk_idx)))))
(export git_patch_num_lines_in_hunk)

;; extern int git_patch_get_line_in_hunk(const git_diff_line **out, git_patch 
;;     *patch, size_t hunk_idx, size_t line_of_hunk);
(define git_patch_get_line_in_hunk
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_patch_get_line_in_hunk"
                (dynamic-link))
              (list '* '* ffi:size_t ffi:size_t))))
    (lambda (out patch hunk_idx line_of_hunk)
      (let ((~out (unwrap~pointer out))
            (~patch (unwrap-git_patch* patch))
            (~hunk_idx (unwrap-size_t hunk_idx))
            (~line_of_hunk (unwrap-size_t line_of_hunk)))
        (~f ~out ~patch ~hunk_idx ~line_of_hunk)))))
(export git_patch_get_line_in_hunk)

;; extern size_t git_patch_size(git_patch *patch, int include_context, int 
;;     include_hunk_headers, int include_file_headers);
(define git_patch_size
  (let ((~f (ffi:pointer->procedure
              ffi:size_t
              (dynamic-func "git_patch_size" (dynamic-link))
              (list '* ffi:int ffi:int ffi:int))))
    (lambda (patch
             include_context
             include_hunk_headers
             include_file_headers)
      (let ((~patch (unwrap-git_patch* patch))
            (~include_context (unwrap~fixed include_context))
            (~include_hunk_headers
              (unwrap~fixed include_hunk_headers))
            (~include_file_headers
              (unwrap~fixed include_file_headers)))
        (wrap-size_t
          (~f ~patch
              ~include_context
              ~include_hunk_headers
              ~include_file_headers))))))
(export git_patch_size)

;; extern int git_patch_print(git_patch *patch, git_diff_line_cb print_cb, 
;;     void *payload);
(define git_patch_print
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_patch_print" (dynamic-link))
              (list '* '* '*))))
    (lambda (patch print_cb payload)
      (let ((~patch (unwrap-git_patch* patch))
            (~print_cb (unwrap-git_diff_line_cb print_cb))
            (~payload (unwrap~pointer payload)))
        (~f ~patch ~print_cb ~payload)))))
(export git_patch_print)

;; extern int git_patch_to_buf(git_buf *out, git_patch *patch);
(define git_patch_to_buf
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_patch_to_buf" (dynamic-link))
              (list '* '*))))
    (lambda (out patch)
      (let ((~patch (unwrap-git_patch* patch)))
        (~f out ~patch)))))
(export git_patch_to_buf)

;; typedef struct git_pathspec git_pathspec;
(define-fh-pointer-type git_pathspec*)

;; typedef struct git_pathspec_match_list git_pathspec_match_list;
(define-fh-pointer-type git_pathspec_match_list*)

;; typedef enum {
;;   GIT_PATHSPEC_DEFAULT = 0,
;;   GIT_PATHSPEC_IGNORE_CASE = 1u<<0,
;;   GIT_PATHSPEC_USE_CASE = 1u<<1,
;;   GIT_PATHSPEC_NO_GLOB = 1u<<2,
;;   GIT_PATHSPEC_NO_MATCH_ERROR = 1u<<3,
;;   GIT_PATHSPEC_FIND_FAILURES = 1u<<4,
;;   GIT_PATHSPEC_FAILURES_ONLY = 1u<<5,
;; } git_pathspec_flag_t;
(define-fh-enum git_pathspec_flag_t
  '((GIT_PATHSPEC_DEFAULT . 0)
    (GIT_PATHSPEC_IGNORE_CASE . 1)
    (GIT_PATHSPEC_USE_CASE . 2)
    (GIT_PATHSPEC_NO_GLOB . 4)
    (GIT_PATHSPEC_NO_MATCH_ERROR . 8)
    (GIT_PATHSPEC_FIND_FAILURES . 16)
    (GIT_PATHSPEC_FAILURES_ONLY . 32))
  )

;; extern int git_pathspec_new(git_pathspec **out, const git_strarray *
;;     pathspec);
(define git_pathspec_new
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_pathspec_new" (dynamic-link))
              (list '* '*))))
    (lambda (out pathspec)
      (let ((~out (unwrap~pointer out)))
        (~f ~out pathspec)))))
(export git_pathspec_new)

;; extern void git_pathspec_free(git_pathspec *ps);
(define git_pathspec_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "git_pathspec_free" (dynamic-link))
              (list '*))))
    (lambda (ps)
      (let ((~ps (unwrap-git_pathspec* ps))) (~f ~ps)))))
(export git_pathspec_free)

;; extern int git_pathspec_matches_path(const git_pathspec *ps, uint32_t flags
;;     , const char *path);
(define git_pathspec_matches_path
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_pathspec_matches_path"
                (dynamic-link))
              (list '* ffi:uint32 '*))))
    (lambda (ps flags path)
      (let ((~ps (unwrap-git_pathspec* ps))
            (~flags (unwrap-uint32_t flags))
            (~path (unwrap~pointer path)))
        (~f ~ps ~flags ~path)))))
(export git_pathspec_matches_path)

;; extern int git_pathspec_match_workdir(git_pathspec_match_list **out, 
;;     git_repository *repo, uint32_t flags, git_pathspec *ps);
(define git_pathspec_match_workdir
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_pathspec_match_workdir"
                (dynamic-link))
              (list '* '* ffi:uint32 '*))))
    (lambda (out repo flags ps)
      (let ((~out (unwrap~pointer out))
            (~flags (unwrap-uint32_t flags))
            (~ps (unwrap-git_pathspec* ps)))
        (~f ~out repo ~flags ~ps)))))
(export git_pathspec_match_workdir)

;; extern int git_pathspec_match_index(git_pathspec_match_list **out, 
;;     git_index *index, uint32_t flags, git_pathspec *ps);
(define git_pathspec_match_index
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_pathspec_match_index"
                (dynamic-link))
              (list '* '* ffi:uint32 '*))))
    (lambda (out index flags ps)
      (let ((~out (unwrap~pointer out))
            (~flags (unwrap-uint32_t flags))
            (~ps (unwrap-git_pathspec* ps)))
        (~f ~out index ~flags ~ps)))))
(export git_pathspec_match_index)

;; extern int git_pathspec_match_tree(git_pathspec_match_list **out, git_tree 
;;     *tree, uint32_t flags, git_pathspec *ps);
(define git_pathspec_match_tree
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_pathspec_match_tree"
                (dynamic-link))
              (list '* '* ffi:uint32 '*))))
    (lambda (out tree flags ps)
      (let ((~out (unwrap~pointer out))
            (~flags (unwrap-uint32_t flags))
            (~ps (unwrap-git_pathspec* ps)))
        (~f ~out tree ~flags ~ps)))))
(export git_pathspec_match_tree)

;; extern int git_pathspec_match_diff(git_pathspec_match_list **out, git_diff 
;;     *diff, uint32_t flags, git_pathspec *ps);
(define git_pathspec_match_diff
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_pathspec_match_diff"
                (dynamic-link))
              (list '* '* ffi:uint32 '*))))
    (lambda (out diff flags ps)
      (let ((~out (unwrap~pointer out))
            (~flags (unwrap-uint32_t flags))
            (~ps (unwrap-git_pathspec* ps)))
        (~f ~out diff ~flags ~ps)))))
(export git_pathspec_match_diff)

;; extern void git_pathspec_match_list_free(git_pathspec_match_list *m);
(define git_pathspec_match_list_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "git_pathspec_match_list_free"
                (dynamic-link))
              (list '*))))
    (lambda (m)
      (let ((~m (unwrap-git_pathspec_match_list* m)))
        (~f ~m)))))
(export git_pathspec_match_list_free)

;; extern size_t git_pathspec_match_list_entrycount(const 
;;     git_pathspec_match_list *m);
(define git_pathspec_match_list_entrycount
  (let ((~f (ffi:pointer->procedure
              ffi:size_t
              (dynamic-func
                "git_pathspec_match_list_entrycount"
                (dynamic-link))
              (list '*))))
    (lambda (m)
      (let ((~m (unwrap-git_pathspec_match_list* m)))
        (wrap-size_t (~f ~m))))))
(export git_pathspec_match_list_entrycount)

;; extern const char *git_pathspec_match_list_entry(const 
;;     git_pathspec_match_list *m, size_t pos);
(define git_pathspec_match_list_entry
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "git_pathspec_match_list_entry"
                (dynamic-link))
              (list '* ffi:size_t))))
    (lambda (m pos)
      (let ((~m (unwrap-git_pathspec_match_list* m))
            (~pos (unwrap-size_t pos)))
        (~f ~m ~pos)))))
(export git_pathspec_match_list_entry)

;; extern const git_diff_delta *git_pathspec_match_list_diff_entry(const 
;;     git_pathspec_match_list *m, size_t pos);
(define git_pathspec_match_list_diff_entry
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "git_pathspec_match_list_diff_entry"
                (dynamic-link))
              (list '* ffi:size_t))))
    (lambda (m pos)
      (let ((~m (unwrap-git_pathspec_match_list* m))
            (~pos (unwrap-size_t pos)))
        (~f ~m ~pos)))))
(export git_pathspec_match_list_diff_entry)

;; extern size_t git_pathspec_match_list_failed_entrycount(const 
;;     git_pathspec_match_list *m);
(define git_pathspec_match_list_failed_entrycount
  (let ((~f (ffi:pointer->procedure
              ffi:size_t
              (dynamic-func
                "git_pathspec_match_list_failed_entrycount"
                (dynamic-link))
              (list '*))))
    (lambda (m)
      (let ((~m (unwrap-git_pathspec_match_list* m)))
        (wrap-size_t (~f ~m))))))
(export git_pathspec_match_list_failed_entrycount)

;; extern const char *git_pathspec_match_list_failed_entry(const 
;;     git_pathspec_match_list *m, size_t pos);
(define git_pathspec_match_list_failed_entry
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "git_pathspec_match_list_failed_entry"
                (dynamic-link))
              (list '* ffi:size_t))))
    (lambda (m pos)
      (let ((~m (unwrap-git_pathspec_match_list* m))
            (~pos (unwrap-size_t pos)))
        (~f ~m ~pos)))))
(export git_pathspec_match_list_failed_entry)

;; typedef struct {
;;   unsigned int version;
;;   /**
;;   	 * Used by `git_rebase_init`, this will instruct other clients working
;;   	 * on this rebase that you want a quiet rebase experience, which they
;;   	 * may choose to provide in an application-specific manner.  This has no
;;       
;;   	 * effect upon libgit2 directly, but is provided for interoperability
;;   	 * between Git tools.
;;   	 */
;;   int quiet;
;;   /**
;;   	 * Used by `git_rebase_init`, this will begin an in-memory rebase,
;;   	 * which will allow callers to step through the rebase operations and
;;   	 * commit the rebased changes, but will not rewind HEAD or update the
;;   	 * repository to be in a rebasing state.  This will not interfere with
;;   	 * the working directory (if there is one).
;;   	 */
;;   int inmemory;
;;   /**
;;   	 * Used by `git_rebase_finish`, this is the name of the notes reference
;;   	 * used to rewrite notes for rebased commits when finishing the rebase;
;;   	 * if NULL, the contents of the configuration option `notes.rewriteRef`
;;   	 * is examined, unless the configuration option `notes.rewrite.rebase`
;;   	 * is set to false.  If `notes.rewriteRef` is also NULL, notes will
;;   	 * not be rewritten.
;;   	 */
;;   const char *rewrite_notes_ref;
;;   /**
;;   	 * Options to control how trees are merged during `git_rebase_next`.
;;   	 */
;;   git_merge_options merge_options;
;;   /**
;;   	 * Options to control how files are written during `git_rebase_init`,
;;   	 * `git_rebase_next` and `git_rebase_abort`.  Note that a minimum
;;   	 * strategy of `GIT_CHECKOUT_SAFE` is defaulted in `init` and `next`,
;;   	 * and a minimum strategy of `GIT_CHECKOUT_FORCE` is defaulted in
;;   	 * `abort` to match git semantics.
;;   	 */
;;   git_checkout_options checkout_options;
;; } git_rebase_options;
(define git_rebase_options-desc
  (bs:struct
    (list `(version ,unsigned-int)
          `(quiet ,int)
          `(inmemory ,int)
          `(rewrite_notes_ref ,(bs:pointer int))
          `(merge_options
             ,(bs:struct
                (list `(version ,unsigned-int)
                      `(flags ,int)
                      `(rename_threshold ,unsigned-int)
                      `(target_limit ,unsigned-int)
                      `(metric
                         ,(bs:pointer
                            (bs:struct
                              (list `(file_signature ,(bs:pointer intptr_t))
                                    `(buffer_signature ,(bs:pointer intptr_t))
                                    `(free_signature ,(bs:pointer intptr_t))
                                    `(similarity ,(bs:pointer intptr_t))
                                    `(payload ,(bs:pointer intptr_t))))))
                      `(recursion_limit ,unsigned-int)
                      `(default_driver ,(bs:pointer int))
                      `(file_favor ,int)
                      `(file_flags ,int))))
          `(checkout_options ,git_checkout_options-desc))))
(export git_rebase_options-desc)
(define-fh-compound-type/p git_rebase_options git_rebase_options-desc)

;; typedef enum {
;;   GIT_REBASE_OPERATION_PICK = 0,
;;   GIT_REBASE_OPERATION_REWORD,
;;   GIT_REBASE_OPERATION_EDIT,
;;   GIT_REBASE_OPERATION_SQUASH,
;;   GIT_REBASE_OPERATION_FIXUP,
;;   GIT_REBASE_OPERATION_EXEC,
;; } git_rebase_operation_t;
(define-fh-enum git_rebase_operation_t
  '((GIT_REBASE_OPERATION_PICK . 0)
    (GIT_REBASE_OPERATION_REWORD . 1)
    (GIT_REBASE_OPERATION_EDIT . 2)
    (GIT_REBASE_OPERATION_SQUASH . 3)
    (GIT_REBASE_OPERATION_FIXUP . 4)
    (GIT_REBASE_OPERATION_EXEC . 5))
  )

;; typedef struct {
;;   /** The type of rebase operation. */
;;   git_rebase_operation_t type;
;;   /**
;;   	 * The commit ID being cherry-picked.  This will be populated for
;;   	 * all operations except those of type `GIT_REBASE_OPERATION_EXEC`.
;;   	 */
;;   const git_oid id;
;;   /**
;;   	 * The executable the user has requested be run.  This will only
;;   	 * be populated for operations of type `GIT_REBASE_OPERATION_EXEC`.
;;   	 */
;;   const char *exec;
;; } git_rebase_operation;
(define git_rebase_operation-desc
  (bs:struct
    (list `(type ,git_rebase_operation_t-desc)
          `(id ,(bs:struct (list `(id ,(bs:vector 20 #f)))))
          `(exec ,(bs:pointer int)))))
(export git_rebase_operation-desc)
(define-fh-compound-type/p git_rebase_operation git_rebase_operation-desc)

;; extern int git_rebase_init_options(git_rebase_options *opts, unsigned int 
;;     version);
(define git_rebase_init_options
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_rebase_init_options"
                (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (opts version)
      (let ((~opts (unwrap-git_rebase_options* opts))
            (~version (unwrap~fixed version)))
        (~f ~opts ~version)))))
(export git_rebase_init_options)

;; extern int git_rebase_init(git_rebase **out, git_repository *repo, const 
;;     git_annotated_commit *branch, const git_annotated_commit *upstream, 
;;     const git_annotated_commit *onto, const git_rebase_options *opts);
(define git_rebase_init
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_rebase_init" (dynamic-link))
              (list '* '* '* '* '* '*))))
    (lambda (out repo branch upstream onto opts)
      (let ((~out (unwrap~pointer out))
            (~opts (unwrap-git_rebase_options* opts)))
        (~f ~out repo branch upstream onto ~opts)))))
(export git_rebase_init)

;; extern int git_rebase_open(git_rebase **out, git_repository *repo, const 
;;     git_rebase_options *opts);
(define git_rebase_open
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_rebase_open" (dynamic-link))
              (list '* '* '*))))
    (lambda (out repo opts)
      (let ((~out (unwrap~pointer out))
            (~opts (unwrap-git_rebase_options* opts)))
        (~f ~out repo ~opts)))))
(export git_rebase_open)

;; extern size_t git_rebase_operation_entrycount(git_rebase *rebase);
(define git_rebase_operation_entrycount
  (let ((~f (ffi:pointer->procedure
              ffi:size_t
              (dynamic-func
                "git_rebase_operation_entrycount"
                (dynamic-link))
              (list '*))))
    (lambda (rebase)
      (let () (wrap-size_t (~f rebase))))))
(export git_rebase_operation_entrycount)

;; extern size_t git_rebase_operation_current(git_rebase *rebase);
(define git_rebase_operation_current
  (let ((~f (ffi:pointer->procedure
              ffi:size_t
              (dynamic-func
                "git_rebase_operation_current"
                (dynamic-link))
              (list '*))))
    (lambda (rebase)
      (let () (wrap-size_t (~f rebase))))))
(export git_rebase_operation_current)

;; extern git_rebase_operation *git_rebase_operation_byindex(git_rebase *
;;     rebase, size_t idx);
(define git_rebase_operation_byindex
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "git_rebase_operation_byindex"
                (dynamic-link))
              (list '* ffi:size_t))))
    (lambda (rebase idx)
      (let ((~idx (unwrap-size_t idx)))
        (wrap-git_rebase_operation* (~f rebase ~idx))))))
(export git_rebase_operation_byindex)

;; extern int git_rebase_next(git_rebase_operation **operation, git_rebase *
;;     rebase);
(define git_rebase_next
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_rebase_next" (dynamic-link))
              (list '* '*))))
    (lambda (operation rebase)
      (let ((~operation (unwrap~pointer operation)))
        (~f ~operation rebase)))))
(export git_rebase_next)

;; extern int git_rebase_inmemory_index(git_index **index, git_rebase *rebase)
;;     ;
(define git_rebase_inmemory_index
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_rebase_inmemory_index"
                (dynamic-link))
              (list '* '*))))
    (lambda (index rebase)
      (let ((~index (unwrap~pointer index)))
        (~f ~index rebase)))))
(export git_rebase_inmemory_index)

;; extern int git_rebase_commit(git_oid *id, git_rebase *rebase, const 
;;     git_signature *author, const git_signature *committer, const char *
;;     message_encoding, const char *message);
(define git_rebase_commit
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_rebase_commit" (dynamic-link))
              (list '* '* '* '* '* '*))))
    (lambda (id
             rebase
             author
             committer
             message_encoding
             message)
      (let ((~message_encoding
              (unwrap~pointer message_encoding))
            (~message (unwrap~pointer message)))
        (~f id
            rebase
            author
            committer
            ~message_encoding
            ~message)))))
(export git_rebase_commit)

;; extern int git_rebase_abort(git_rebase *rebase);
(define git_rebase_abort
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_rebase_abort" (dynamic-link))
              (list '*))))
    (lambda (rebase) (let () (~f rebase)))))
(export git_rebase_abort)

;; extern int git_rebase_finish(git_rebase *rebase, const git_signature *
;;     signature);
(define git_rebase_finish
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_rebase_finish" (dynamic-link))
              (list '* '*))))
    (lambda (rebase signature)
      (let () (~f rebase signature)))))
(export git_rebase_finish)

;; extern void git_rebase_free(git_rebase *rebase);
(define git_rebase_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "git_rebase_free" (dynamic-link))
              (list '*))))
    (lambda (rebase) (let () (~f rebase)))))
(export git_rebase_free)

;; extern int git_refdb_new(git_refdb **out, git_repository *repo);
(define git_refdb_new
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_refdb_new" (dynamic-link))
              (list '* '*))))
    (lambda (out repo)
      (let ((~out (unwrap~pointer out)))
        (~f ~out repo)))))
(export git_refdb_new)

;; extern int git_refdb_open(git_refdb **out, git_repository *repo);
(define git_refdb_open
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_refdb_open" (dynamic-link))
              (list '* '*))))
    (lambda (out repo)
      (let ((~out (unwrap~pointer out)))
        (~f ~out repo)))))
(export git_refdb_open)

;; extern int git_refdb_compress(git_refdb *refdb);
(define git_refdb_compress
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_refdb_compress"
                (dynamic-link))
              (list '*))))
    (lambda (refdb) (let () (~f refdb)))))
(export git_refdb_compress)

;; extern void git_refdb_free(git_refdb *refdb);
(define git_refdb_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "git_refdb_free" (dynamic-link))
              (list '*))))
    (lambda (refdb) (let () (~f refdb)))))
(export git_refdb_free)

;; extern int git_reflog_read(git_reflog **out, git_repository *repo, const 
;;     char *name);
(define git_reflog_read
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_reflog_read" (dynamic-link))
              (list '* '* '*))))
    (lambda (out repo name)
      (let ((~out (unwrap~pointer out))
            (~name (unwrap~pointer name)))
        (~f ~out repo ~name)))))
(export git_reflog_read)

;; extern int git_reflog_write(git_reflog *reflog);
(define git_reflog_write
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_reflog_write" (dynamic-link))
              (list '*))))
    (lambda (reflog) (let () (~f reflog)))))
(export git_reflog_write)

;; extern int git_reflog_append(git_reflog *reflog, const git_oid *id, const 
;;     git_signature *committer, const char *msg);
(define git_reflog_append
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_reflog_append" (dynamic-link))
              (list '* '* '* '*))))
    (lambda (reflog id committer msg)
      (let ((~msg (unwrap~pointer msg)))
        (~f reflog id committer ~msg)))))
(export git_reflog_append)

;; extern int git_reflog_rename(git_repository *repo, const char *old_name, 
;;     const char *name);
(define git_reflog_rename
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_reflog_rename" (dynamic-link))
              (list '* '* '*))))
    (lambda (repo old_name name)
      (let ((~old_name (unwrap~pointer old_name))
            (~name (unwrap~pointer name)))
        (~f repo ~old_name ~name)))))
(export git_reflog_rename)

;; extern int git_reflog_delete(git_repository *repo, const char *name);
(define git_reflog_delete
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_reflog_delete" (dynamic-link))
              (list '* '*))))
    (lambda (repo name)
      (let ((~name (unwrap~pointer name)))
        (~f repo ~name)))))
(export git_reflog_delete)

;; extern size_t git_reflog_entrycount(git_reflog *reflog);
(define git_reflog_entrycount
  (let ((~f (ffi:pointer->procedure
              ffi:size_t
              (dynamic-func
                "git_reflog_entrycount"
                (dynamic-link))
              (list '*))))
    (lambda (reflog)
      (let () (wrap-size_t (~f reflog))))))
(export git_reflog_entrycount)

;; extern const git_reflog_entry *git_reflog_entry_byindex(const git_reflog *
;;     reflog, size_t idx);
(define git_reflog_entry_byindex
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "git_reflog_entry_byindex"
                (dynamic-link))
              (list '* ffi:size_t))))
    (lambda (reflog idx)
      (let ((~idx (unwrap-size_t idx)))
        (~f reflog ~idx)))))
(export git_reflog_entry_byindex)

;; extern int git_reflog_drop(git_reflog *reflog, size_t idx, int 
;;     rewrite_previous_entry);
(define git_reflog_drop
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_reflog_drop" (dynamic-link))
              (list '* ffi:size_t ffi:int))))
    (lambda (reflog idx rewrite_previous_entry)
      (let ((~idx (unwrap-size_t idx))
            (~rewrite_previous_entry
              (unwrap~fixed rewrite_previous_entry)))
        (~f reflog ~idx ~rewrite_previous_entry)))))
(export git_reflog_drop)

;; extern const git_oid *git_reflog_entry_id_old(const git_reflog_entry *entry
;;     );
(define git_reflog_entry_id_old
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "git_reflog_entry_id_old"
                (dynamic-link))
              (list '*))))
    (lambda (entry) (let () (~f entry)))))
(export git_reflog_entry_id_old)

;; extern const git_oid *git_reflog_entry_id_new(const git_reflog_entry *entry
;;     );
(define git_reflog_entry_id_new
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "git_reflog_entry_id_new"
                (dynamic-link))
              (list '*))))
    (lambda (entry) (let () (~f entry)))))
(export git_reflog_entry_id_new)

;; extern const git_signature *git_reflog_entry_committer(const 
;;     git_reflog_entry *entry);
(define git_reflog_entry_committer
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "git_reflog_entry_committer"
                (dynamic-link))
              (list '*))))
    (lambda (entry) (let () (~f entry)))))
(export git_reflog_entry_committer)

;; extern const char *git_reflog_entry_message(const git_reflog_entry *entry)
;;     ;
(define git_reflog_entry_message
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "git_reflog_entry_message"
                (dynamic-link))
              (list '*))))
    (lambda (entry) (let () (~f entry)))))
(export git_reflog_entry_message)

;; extern void git_reflog_free(git_reflog *reflog);
(define git_reflog_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "git_reflog_free" (dynamic-link))
              (list '*))))
    (lambda (reflog) (let () (~f reflog)))))
(export git_reflog_free)

;; typedef enum {
;;   GIT_RESET_SOFT = 1,
;;   GIT_RESET_MIXED = 2,
;;   GIT_RESET_HARD = 3,
;; } git_reset_t;
(define-fh-enum git_reset_t
  '((GIT_RESET_SOFT . 1)
    (GIT_RESET_MIXED . 2)
    (GIT_RESET_HARD . 3))
  )

;; extern int git_reset(git_repository *repo, git_object *target, git_reset_t 
;;     reset_type, const git_checkout_options *checkout_opts);
(define git_reset
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_reset" (dynamic-link))
              (list '* '* ffi:int '*))))
    (lambda (repo target reset_type checkout_opts)
      (let ((~reset_type (unwrap-git_reset_t reset_type))
            (~checkout_opts
              (unwrap-git_checkout_options* checkout_opts)))
        (~f repo target ~reset_type ~checkout_opts)))))
(export git_reset)

;; extern int git_reset_from_annotated(git_repository *repo, 
;;     git_annotated_commit *commit, git_reset_t reset_type, const 
;;     git_checkout_options *checkout_opts);
(define git_reset_from_annotated
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_reset_from_annotated"
                (dynamic-link))
              (list '* '* ffi:int '*))))
    (lambda (repo commit reset_type checkout_opts)
      (let ((~reset_type (unwrap-git_reset_t reset_type))
            (~checkout_opts
              (unwrap-git_checkout_options* checkout_opts)))
        (~f repo commit ~reset_type ~checkout_opts)))))
(export git_reset_from_annotated)

;; extern int git_reset_default(git_repository *repo, git_object *target, 
;;     git_strarray *pathspecs);
(define git_reset_default
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_reset_default" (dynamic-link))
              (list '* '* '*))))
    (lambda (repo target pathspecs)
      (let () (~f repo target pathspecs)))))
(export git_reset_default)

;; typedef struct {
;;   unsigned int version;
;;   /** For merge commits, the "mainline" is treated as the parent. */
;;   unsigned int mainline;
;;   git_merge_options merge_opts; /**< Options for the merging */
;;   git_checkout_options checkout_opts; /**< Options for the checkout */
;; } git_revert_options;
(define git_revert_options-desc
  (bs:struct
    (list `(version ,unsigned-int)
          `(mainline ,unsigned-int)
          `(merge_opts
             ,(bs:struct
                (list `(version ,unsigned-int)
                      `(flags ,int)
                      `(rename_threshold ,unsigned-int)
                      `(target_limit ,unsigned-int)
                      `(metric
                         ,(bs:pointer
                            (bs:struct
                              (list `(file_signature ,(bs:pointer intptr_t))
                                    `(buffer_signature ,(bs:pointer intptr_t))
                                    `(free_signature ,(bs:pointer intptr_t))
                                    `(similarity ,(bs:pointer intptr_t))
                                    `(payload ,(bs:pointer intptr_t))))))
                      `(recursion_limit ,unsigned-int)
                      `(default_driver ,(bs:pointer int))
                      `(file_favor ,int)
                      `(file_flags ,int))))
          `(checkout_opts ,git_checkout_options-desc))))
(export git_revert_options-desc)
(define-fh-compound-type/p git_revert_options git_revert_options-desc)

;; extern int git_revert_init_options(git_revert_options *opts, unsigned int 
;;     version);
(define git_revert_init_options
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_revert_init_options"
                (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (opts version)
      (let ((~opts (unwrap-git_revert_options* opts))
            (~version (unwrap~fixed version)))
        (~f ~opts ~version)))))
(export git_revert_init_options)

;; extern int git_revert_commit(git_index **out, git_repository *repo, 
;;     git_commit *revert_commit, git_commit *our_commit, unsigned int 
;;     mainline, const git_merge_options *merge_options);
(define git_revert_commit
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_revert_commit" (dynamic-link))
              (list '* '* '* '* ffi:unsigned-int '*))))
    (lambda (out
             repo
             revert_commit
             our_commit
             mainline
             merge_options)
      (let ((~out (unwrap~pointer out))
            (~mainline (unwrap~fixed mainline)))
        (~f ~out
            repo
            revert_commit
            our_commit
            ~mainline
            merge_options)))))
(export git_revert_commit)

;; extern int git_revert(git_repository *repo, git_commit *commit, const 
;;     git_revert_options *given_opts);
(define git_revert
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_revert" (dynamic-link))
              (list '* '* '*))))
    (lambda (repo commit given_opts)
      (let ((~given_opts
              (unwrap-git_revert_options* given_opts)))
        (~f repo commit ~given_opts)))))
(export git_revert)

;; extern int git_revparse_single(git_object **out, git_repository *repo, 
;;     const char *spec);
(define git_revparse_single
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_revparse_single"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (out repo spec)
      (let ((~out (unwrap~pointer out))
            (~spec (unwrap~pointer spec)))
        (~f ~out repo ~spec)))))
(export git_revparse_single)

;; extern int git_revparse_ext(git_object **object_out, git_reference **
;;     reference_out, git_repository *repo, const char *spec);
(define git_revparse_ext
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_revparse_ext" (dynamic-link))
              (list '* '* '* '*))))
    (lambda (object_out reference_out repo spec)
      (let ((~object_out (unwrap~pointer object_out))
            (~reference_out (unwrap~pointer reference_out))
            (~spec (unwrap~pointer spec)))
        (~f ~object_out ~reference_out repo ~spec)))))
(export git_revparse_ext)

;; typedef enum {
;;   GIT_REVPARSE_SINGLE = 1<<0,
;;   GIT_REVPARSE_RANGE = 1<<1,
;;   GIT_REVPARSE_MERGE_BASE = 1<<2,
;; } git_revparse_mode_t;
(define-fh-enum git_revparse_mode_t
  '((GIT_REVPARSE_SINGLE . 1)
    (GIT_REVPARSE_RANGE . 2)
    (GIT_REVPARSE_MERGE_BASE . 4))
  )

;; typedef struct {
;;   /** The left element of the revspec; must be freed by the user */
;;   git_object *from;
;;   /** The right element of the revspec; must be freed by the user */
;;   git_object *to;
;;   /** The intent of the revspec (i.e. `git_revparse_mode_t` flags) */
;;   unsigned int flags;
;; } git_revspec;
(define git_revspec-desc
  (bs:struct
    (list `(from ,(bs:pointer intptr_t))
          `(to ,(bs:pointer intptr_t))
          `(flags ,unsigned-int))))
(export git_revspec-desc)
(define-fh-compound-type/p git_revspec git_revspec-desc)

;; extern int git_revparse(git_revspec *revspec, git_repository *repo, const 
;;     char *spec);
(define git_revparse
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_revparse" (dynamic-link))
              (list '* '* '*))))
    (lambda (revspec repo spec)
      (let ((~revspec (unwrap-git_revspec* revspec))
            (~spec (unwrap~pointer spec)))
        (~f ~revspec repo ~spec)))))
(export git_revparse)

;; typedef enum {
;;   GIT_SORT_NONE = 0,
;;   GIT_SORT_TOPOLOGICAL = 1<<0,
;;   GIT_SORT_TIME = 1<<1,
;;   GIT_SORT_REVERSE = 1<<2,
;; } git_sort_t;
(define-fh-enum git_sort_t
  '((GIT_SORT_NONE . 0)
    (GIT_SORT_TOPOLOGICAL . 1)
    (GIT_SORT_TIME . 2)
    (GIT_SORT_REVERSE . 4))
  )

;; extern int git_revwalk_new(git_revwalk **out, git_repository *repo);
(define git_revwalk_new
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_revwalk_new" (dynamic-link))
              (list '* '*))))
    (lambda (out repo)
      (let ((~out (unwrap~pointer out)))
        (~f ~out repo)))))
(export git_revwalk_new)

;; extern void git_revwalk_reset(git_revwalk *walker);
(define git_revwalk_reset
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "git_revwalk_reset" (dynamic-link))
              (list '*))))
    (lambda (walker) (let () (~f walker)))))
(export git_revwalk_reset)

;; extern int git_revwalk_push(git_revwalk *walk, const git_oid *id);
(define git_revwalk_push
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_revwalk_push" (dynamic-link))
              (list '* '*))))
    (lambda (walk id) (let () (~f walk id)))))
(export git_revwalk_push)

;; extern int git_revwalk_push_glob(git_revwalk *walk, const char *glob);
(define git_revwalk_push_glob
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_revwalk_push_glob"
                (dynamic-link))
              (list '* '*))))
    (lambda (walk glob)
      (let ((~glob (unwrap~pointer glob)))
        (~f walk ~glob)))))
(export git_revwalk_push_glob)

;; extern int git_revwalk_push_head(git_revwalk *walk);
(define git_revwalk_push_head
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_revwalk_push_head"
                (dynamic-link))
              (list '*))))
    (lambda (walk) (let () (~f walk)))))
(export git_revwalk_push_head)

;; extern int git_revwalk_hide(git_revwalk *walk, const git_oid *commit_id);
(define git_revwalk_hide
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_revwalk_hide" (dynamic-link))
              (list '* '*))))
    (lambda (walk commit_id)
      (let () (~f walk commit_id)))))
(export git_revwalk_hide)

;; extern int git_revwalk_hide_glob(git_revwalk *walk, const char *glob);
(define git_revwalk_hide_glob
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_revwalk_hide_glob"
                (dynamic-link))
              (list '* '*))))
    (lambda (walk glob)
      (let ((~glob (unwrap~pointer glob)))
        (~f walk ~glob)))))
(export git_revwalk_hide_glob)

;; extern int git_revwalk_hide_head(git_revwalk *walk);
(define git_revwalk_hide_head
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_revwalk_hide_head"
                (dynamic-link))
              (list '*))))
    (lambda (walk) (let () (~f walk)))))
(export git_revwalk_hide_head)

;; extern int git_revwalk_push_ref(git_revwalk *walk, const char *refname);
(define git_revwalk_push_ref
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_revwalk_push_ref"
                (dynamic-link))
              (list '* '*))))
    (lambda (walk refname)
      (let ((~refname (unwrap~pointer refname)))
        (~f walk ~refname)))))
(export git_revwalk_push_ref)

;; extern int git_revwalk_hide_ref(git_revwalk *walk, const char *refname);
(define git_revwalk_hide_ref
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_revwalk_hide_ref"
                (dynamic-link))
              (list '* '*))))
    (lambda (walk refname)
      (let ((~refname (unwrap~pointer refname)))
        (~f walk ~refname)))))
(export git_revwalk_hide_ref)

;; extern int git_revwalk_next(git_oid *out, git_revwalk *walk);
(define git_revwalk_next
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_revwalk_next" (dynamic-link))
              (list '* '*))))
    (lambda (out walk) (let () (~f out walk)))))
(export git_revwalk_next)

;; extern void git_revwalk_sorting(git_revwalk *walk, unsigned int sort_mode)
;;     ;
(define git_revwalk_sorting
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "git_revwalk_sorting"
                (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (walk sort_mode)
      (let ((~sort_mode (unwrap~fixed sort_mode)))
        (~f walk ~sort_mode)))))
(export git_revwalk_sorting)

;; extern int git_revwalk_push_range(git_revwalk *walk, const char *range);
(define git_revwalk_push_range
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_revwalk_push_range"
                (dynamic-link))
              (list '* '*))))
    (lambda (walk range)
      (let ((~range (unwrap~pointer range)))
        (~f walk ~range)))))
(export git_revwalk_push_range)

;; extern void git_revwalk_simplify_first_parent(git_revwalk *walk);
(define git_revwalk_simplify_first_parent
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "git_revwalk_simplify_first_parent"
                (dynamic-link))
              (list '*))))
    (lambda (walk) (let () (~f walk)))))
(export git_revwalk_simplify_first_parent)

;; extern void git_revwalk_free(git_revwalk *walk);
(define git_revwalk_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "git_revwalk_free" (dynamic-link))
              (list '*))))
    (lambda (walk) (let () (~f walk)))))
(export git_revwalk_free)

;; extern git_repository *git_revwalk_repository(git_revwalk *walk);
(define git_revwalk_repository
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "git_revwalk_repository"
                (dynamic-link))
              (list '*))))
    (lambda (walk) (let () (~f walk)))))
(export git_revwalk_repository)

;; typedef int (*git_revwalk_hide_cb)(const git_oid *commit_id, void *payload)
;;     ;
(define-fh-function/p git_revwalk_hide_cb
  ffi:int (list (quote *) (quote *)))

;; extern int git_revwalk_add_hide_cb(git_revwalk *walk, git_revwalk_hide_cb 
;;     hide_cb, void *payload);
(define git_revwalk_add_hide_cb
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_revwalk_add_hide_cb"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (walk hide_cb payload)
      (let ((~hide_cb (unwrap-git_revwalk_hide_cb hide_cb))
            (~payload (unwrap~pointer payload)))
        (~f walk ~hide_cb ~payload)))))
(export git_revwalk_add_hide_cb)

;; extern int git_signature_new(git_signature **out, const char *name, const 
;;     char *email, git_time_t time, int offset);
(define git_signature_new
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_signature_new" (dynamic-link))
              (list '* '* '* ffi:int64 ffi:int))))
    (lambda (out name email time offset)
      (let ((~out (unwrap~pointer out))
            (~name (unwrap~pointer name))
            (~email (unwrap~pointer email))
            (~time (unwrap-git_time_t time))
            (~offset (unwrap~fixed offset)))
        (~f ~out ~name ~email ~time ~offset)))))
(export git_signature_new)

;; extern int git_signature_now(git_signature **out, const char *name, const 
;;     char *email);
(define git_signature_now
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_signature_now" (dynamic-link))
              (list '* '* '*))))
    (lambda (out name email)
      (let ((~out (unwrap~pointer out))
            (~name (unwrap~pointer name))
            (~email (unwrap~pointer email)))
        (~f ~out ~name ~email)))))
(export git_signature_now)

;; extern int git_signature_default(git_signature **out, git_repository *repo)
;;     ;
(define git_signature_default
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_signature_default"
                (dynamic-link))
              (list '* '*))))
    (lambda (out repo)
      (let ((~out (unwrap~pointer out)))
        (~f ~out repo)))))
(export git_signature_default)

;; extern int git_signature_from_buffer(git_signature **out, const char *buf)
;;     ;
(define git_signature_from_buffer
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_signature_from_buffer"
                (dynamic-link))
              (list '* '*))))
    (lambda (out buf)
      (let ((~out (unwrap~pointer out))
            (~buf (unwrap~pointer buf)))
        (~f ~out ~buf)))))
(export git_signature_from_buffer)

;; extern int git_signature_dup(git_signature **dest, const git_signature *sig
;;     );
(define git_signature_dup
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_signature_dup" (dynamic-link))
              (list '* '*))))
    (lambda (dest sig)
      (let ((~dest (unwrap~pointer dest)))
        (~f ~dest sig)))))
(export git_signature_dup)

;; extern void git_signature_free(git_signature *sig);
(define git_signature_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "git_signature_free"
                (dynamic-link))
              (list '*))))
    (lambda (sig) (let () (~f sig)))))
(export git_signature_free)

;; typedef enum {
;;   GIT_STASH_DEFAULT = 0,
;;   GIT_STASH_KEEP_INDEX = 1<<0,
;;   GIT_STASH_INCLUDE_UNTRACKED = 1<<1,
;;   GIT_STASH_INCLUDE_IGNORED = 1<<2,
;; } git_stash_flags;
(define-fh-enum git_stash_flags
  '((GIT_STASH_DEFAULT . 0)
    (GIT_STASH_KEEP_INDEX . 1)
    (GIT_STASH_INCLUDE_UNTRACKED . 2)
    (GIT_STASH_INCLUDE_IGNORED . 4))
  )

;; extern int git_stash_save(git_oid *out, git_repository *repo, const 
;;     git_signature *stasher, const char *message, uint32_t flags);
(define git_stash_save
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_stash_save" (dynamic-link))
              (list '* '* '* '* ffi:uint32))))
    (lambda (out repo stasher message flags)
      (let ((~message (unwrap~pointer message))
            (~flags (unwrap-uint32_t flags)))
        (~f out repo stasher ~message ~flags)))))
(export git_stash_save)

;; typedef enum {
;;   GIT_STASH_APPLY_DEFAULT = 0,
;;   GIT_STASH_APPLY_REINSTATE_INDEX = 1<<0,
;; } git_stash_apply_flags;
(define-fh-enum git_stash_apply_flags
  '((GIT_STASH_APPLY_DEFAULT . 0)
    (GIT_STASH_APPLY_REINSTATE_INDEX . 1))
  )

;; typedef enum {
;;   GIT_STASH_APPLY_PROGRESS_NONE = 0,
;;   GIT_STASH_APPLY_PROGRESS_LOADING_STASH,
;;   GIT_STASH_APPLY_PROGRESS_ANALYZE_INDEX,
;;   GIT_STASH_APPLY_PROGRESS_ANALYZE_MODIFIED,
;;   GIT_STASH_APPLY_PROGRESS_ANALYZE_UNTRACKED,
;;   GIT_STASH_APPLY_PROGRESS_CHECKOUT_UNTRACKED,
;;   GIT_STASH_APPLY_PROGRESS_CHECKOUT_MODIFIED,
;;   GIT_STASH_APPLY_PROGRESS_DONE,
;; } git_stash_apply_progress_t;
(define-fh-enum git_stash_apply_progress_t
  '((GIT_STASH_APPLY_PROGRESS_NONE . 0)
    (GIT_STASH_APPLY_PROGRESS_LOADING_STASH . 1)
    (GIT_STASH_APPLY_PROGRESS_ANALYZE_INDEX . 2)
    (GIT_STASH_APPLY_PROGRESS_ANALYZE_MODIFIED . 3)
    (GIT_STASH_APPLY_PROGRESS_ANALYZE_UNTRACKED . 4)
    (GIT_STASH_APPLY_PROGRESS_CHECKOUT_UNTRACKED . 5)
    (GIT_STASH_APPLY_PROGRESS_CHECKOUT_MODIFIED . 6)
    (GIT_STASH_APPLY_PROGRESS_DONE . 7))
  )

;; typedef int (*git_stash_apply_progress_cb)(git_stash_apply_progress_t 
;;     progress, void *payload);
(define-fh-function/p git_stash_apply_progress_cb
  ffi:int (list ffi:int (quote *)))

;; typedef struct git_stash_apply_options {
;;   unsigned int version;
;;   /** See `git_stash_apply_flags_t`, above. */
;;   git_stash_apply_flags flags;
;;   /** Options to use when writing files to the working directory. */
;;   git_checkout_options checkout_options;
;;   /** Optional callback to notify the consumer of application progress. */
;;   git_stash_apply_progress_cb progress_cb;
;;   void *progress_payload;
;; } git_stash_apply_options;
(define git_stash_apply_options-desc
  (bs:struct
    (list `(version ,unsigned-int)
          `(flags ,git_stash_apply_flags-desc)
          `(checkout_options ,git_checkout_options-desc)
          `(progress_cb ,git_stash_apply_progress_cb-desc)
          `(progress_payload ,(bs:pointer intptr_t)))))
(export git_stash_apply_options-desc)
(define-fh-compound-type/p git_stash_apply_options git_stash_apply_options-desc)
(define struct-git_stash_apply_options git_stash_apply_options)

;; extern int git_stash_apply_init_options(git_stash_apply_options *opts, 
;;     unsigned int version);
(define git_stash_apply_init_options
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_stash_apply_init_options"
                (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (opts version)
      (let ((~opts (unwrap-git_stash_apply_options* opts))
            (~version (unwrap~fixed version)))
        (~f ~opts ~version)))))
(export git_stash_apply_init_options)

;; extern int git_stash_apply(git_repository *repo, size_t index, const 
;;     git_stash_apply_options *options);
(define git_stash_apply
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_stash_apply" (dynamic-link))
              (list '* ffi:size_t '*))))
    (lambda (repo index options)
      (let ((~index (unwrap-size_t index))
            (~options
              (unwrap-git_stash_apply_options* options)))
        (~f repo ~index ~options)))))
(export git_stash_apply)

;; typedef int (*git_stash_cb)(size_t index, const char *message, const 
;;     git_oid *stash_id, void *payload);
(define-fh-function/p git_stash_cb
  ffi:int (list ffi:size_t (quote *) (quote *) (quote *)))

;; extern int git_stash_foreach(git_repository *repo, git_stash_cb callback, 
;;     void *payload);
(define git_stash_foreach
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_stash_foreach" (dynamic-link))
              (list '* '* '*))))
    (lambda (repo callback payload)
      (let ((~callback (unwrap-git_stash_cb callback))
            (~payload (unwrap~pointer payload)))
        (~f repo ~callback ~payload)))))
(export git_stash_foreach)

;; extern int git_stash_drop(git_repository *repo, size_t index);
(define git_stash_drop
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_stash_drop" (dynamic-link))
              (list '* ffi:size_t))))
    (lambda (repo index)
      (let ((~index (unwrap-size_t index)))
        (~f repo ~index)))))
(export git_stash_drop)

;; extern int git_stash_pop(git_repository *repo, size_t index, const 
;;     git_stash_apply_options *options);
(define git_stash_pop
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_stash_pop" (dynamic-link))
              (list '* ffi:size_t '*))))
    (lambda (repo index options)
      (let ((~index (unwrap-size_t index))
            (~options
              (unwrap-git_stash_apply_options* options)))
        (~f repo ~index ~options)))))
(export git_stash_pop)

;; typedef enum {
;;   GIT_STATUS_CURRENT = 0,
;;   GIT_STATUS_INDEX_NEW = 1u<<0,
;;   GIT_STATUS_INDEX_MODIFIED = 1u<<1,
;;   GIT_STATUS_INDEX_DELETED = 1u<<2,
;;   GIT_STATUS_INDEX_RENAMED = 1u<<3,
;;   GIT_STATUS_INDEX_TYPECHANGE = 1u<<4,
;;   GIT_STATUS_WT_NEW = 1u<<7,
;;   GIT_STATUS_WT_MODIFIED = 1u<<8,
;;   GIT_STATUS_WT_DELETED = 1u<<9,
;;   GIT_STATUS_WT_TYPECHANGE = 1u<<10,
;;   GIT_STATUS_WT_RENAMED = 1u<<11,
;;   GIT_STATUS_WT_UNREADABLE = 1u<<12,
;;   GIT_STATUS_IGNORED = 1u<<14,
;;   GIT_STATUS_CONFLICTED = 1u<<15,
;; } git_status_t;
(define-fh-enum git_status_t
  '((GIT_STATUS_CURRENT . 0)
    (GIT_STATUS_INDEX_NEW . 1)
    (GIT_STATUS_INDEX_MODIFIED . 2)
    (GIT_STATUS_INDEX_DELETED . 4)
    (GIT_STATUS_INDEX_RENAMED . 8)
    (GIT_STATUS_INDEX_TYPECHANGE . 16)
    (GIT_STATUS_WT_NEW . 128)
    (GIT_STATUS_WT_MODIFIED . 256)
    (GIT_STATUS_WT_DELETED . 512)
    (GIT_STATUS_WT_TYPECHANGE . 1024)
    (GIT_STATUS_WT_RENAMED . 2048)
    (GIT_STATUS_WT_UNREADABLE . 4096)
    (GIT_STATUS_IGNORED . 16384)
    (GIT_STATUS_CONFLICTED . 32768))
  )

;; typedef int (*git_status_cb)(const char *path, unsigned int status_flags, 
;;     void *payload);
(define-fh-function/p git_status_cb
  ffi:int (list (quote *) ffi:unsigned-int (quote *)))

;; typedef enum {
;;   GIT_STATUS_SHOW_INDEX_AND_WORKDIR = 0,
;;   GIT_STATUS_SHOW_INDEX_ONLY = 1,
;;   GIT_STATUS_SHOW_WORKDIR_ONLY = 2,
;; } git_status_show_t;
(define-fh-enum git_status_show_t
  '((GIT_STATUS_SHOW_INDEX_AND_WORKDIR . 0)
    (GIT_STATUS_SHOW_INDEX_ONLY . 1)
    (GIT_STATUS_SHOW_WORKDIR_ONLY . 2))
  )

;; typedef enum {
;;   GIT_STATUS_OPT_INCLUDE_UNTRACKED = 1u<<0,
;;   GIT_STATUS_OPT_INCLUDE_IGNORED = 1u<<1,
;;   GIT_STATUS_OPT_INCLUDE_UNMODIFIED = 1u<<2,
;;   GIT_STATUS_OPT_EXCLUDE_SUBMODULES = 1u<<3,
;;   GIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS = 1u<<4,
;;   GIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH = 1u<<5,
;;   GIT_STATUS_OPT_RECURSE_IGNORED_DIRS = 1u<<6,
;;   GIT_STATUS_OPT_RENAMES_HEAD_TO_INDEX = 1u<<7,
;;   GIT_STATUS_OPT_RENAMES_INDEX_TO_WORKDIR = 1u<<8,
;;   GIT_STATUS_OPT_SORT_CASE_SENSITIVELY = 1u<<9,
;;   GIT_STATUS_OPT_SORT_CASE_INSENSITIVELY = 1u<<10,
;;   GIT_STATUS_OPT_RENAMES_FROM_REWRITES = 1u<<11,
;;   GIT_STATUS_OPT_NO_REFRESH = 1u<<12,
;;   GIT_STATUS_OPT_UPDATE_INDEX = 1u<<13,
;;   GIT_STATUS_OPT_INCLUDE_UNREADABLE = 1u<<14,
;;   GIT_STATUS_OPT_INCLUDE_UNREADABLE_AS_UNTRACKED = 1u<<15,
;; } git_status_opt_t;
(define-fh-enum git_status_opt_t
  '((GIT_STATUS_OPT_INCLUDE_UNTRACKED . 1)
    (GIT_STATUS_OPT_INCLUDE_IGNORED . 2)
    (GIT_STATUS_OPT_INCLUDE_UNMODIFIED . 4)
    (GIT_STATUS_OPT_EXCLUDE_SUBMODULES . 8)
    (GIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS . 16)
    (GIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH . 32)
    (GIT_STATUS_OPT_RECURSE_IGNORED_DIRS . 64)
    (GIT_STATUS_OPT_RENAMES_HEAD_TO_INDEX . 128)
    (GIT_STATUS_OPT_RENAMES_INDEX_TO_WORKDIR . 256)
    (GIT_STATUS_OPT_SORT_CASE_SENSITIVELY . 512)
    (GIT_STATUS_OPT_SORT_CASE_INSENSITIVELY . 1024)
    (GIT_STATUS_OPT_RENAMES_FROM_REWRITES . 2048)
    (GIT_STATUS_OPT_NO_REFRESH . 4096)
    (GIT_STATUS_OPT_UPDATE_INDEX . 8192)
    (GIT_STATUS_OPT_INCLUDE_UNREADABLE . 16384)
    (GIT_STATUS_OPT_INCLUDE_UNREADABLE_AS_UNTRACKED
      .
      32768))
  )

;; typedef struct {
;;   unsigned int version;
;;   git_status_show_t show;
;;   unsigned int flags;
;;   git_strarray pathspec;
;; } git_status_options;
(define git_status_options-desc
  (bs:struct
    (list `(version ,unsigned-int)
          `(show ,git_status_show_t-desc)
          `(flags ,unsigned-int)
          `(pathspec
             ,(bs:struct
                (list `(strings ,(bs:pointer (bs:pointer int)))
                      `(count ,size_t-desc)))))))
(export git_status_options-desc)
(define-fh-compound-type/p git_status_options git_status_options-desc)

;; extern int git_status_init_options(git_status_options *opts, unsigned int 
;;     version);
(define git_status_init_options
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_status_init_options"
                (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (opts version)
      (let ((~opts (unwrap-git_status_options* opts))
            (~version (unwrap~fixed version)))
        (~f ~opts ~version)))))
(export git_status_init_options)

;; typedef struct {
;;   git_status_t status;
;;   git_diff_delta *head_to_index;
;;   git_diff_delta *index_to_workdir;
;; } git_status_entry;
(define git_status_entry-desc
  (bs:struct
    (list `(status ,git_status_t-desc)
          `(head_to_index ,(bs:pointer intptr_t))
          `(index_to_workdir ,(bs:pointer intptr_t)))))
(export git_status_entry-desc)
(define-fh-compound-type/p git_status_entry git_status_entry-desc)

;; extern int git_status_foreach(git_repository *repo, git_status_cb callback
;;     , void *payload);
(define git_status_foreach
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_status_foreach"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (repo callback payload)
      (let ((~callback (unwrap-git_status_cb callback))
            (~payload (unwrap~pointer payload)))
        (~f repo ~callback ~payload)))))
(export git_status_foreach)

;; extern int git_status_foreach_ext(git_repository *repo, const 
;;     git_status_options *opts, git_status_cb callback, void *payload);
(define git_status_foreach_ext
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_status_foreach_ext"
                (dynamic-link))
              (list '* '* '* '*))))
    (lambda (repo opts callback payload)
      (let ((~opts (unwrap-git_status_options* opts))
            (~callback (unwrap-git_status_cb callback))
            (~payload (unwrap~pointer payload)))
        (~f repo ~opts ~callback ~payload)))))
(export git_status_foreach_ext)

;; extern int git_status_file(unsigned int *status_flags, git_repository *repo
;;     , const char *path);
(define git_status_file
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_status_file" (dynamic-link))
              (list '* '* '*))))
    (lambda (status_flags repo path)
      (let ((~status_flags (unwrap~pointer status_flags))
            (~path (unwrap~pointer path)))
        (~f ~status_flags repo ~path)))))
(export git_status_file)

;; extern int git_status_list_new(git_status_list **out, git_repository *repo
;;     , const git_status_options *opts);
(define git_status_list_new
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_status_list_new"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (out repo opts)
      (let ((~out (unwrap~pointer out))
            (~opts (unwrap-git_status_options* opts)))
        (~f ~out repo ~opts)))))
(export git_status_list_new)

;; extern size_t git_status_list_entrycount(git_status_list *statuslist);
(define git_status_list_entrycount
  (let ((~f (ffi:pointer->procedure
              ffi:size_t
              (dynamic-func
                "git_status_list_entrycount"
                (dynamic-link))
              (list '*))))
    (lambda (statuslist)
      (let () (wrap-size_t (~f statuslist))))))
(export git_status_list_entrycount)

;; extern const git_status_entry *git_status_byindex(git_status_list *
;;     statuslist, size_t idx);
(define git_status_byindex
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "git_status_byindex"
                (dynamic-link))
              (list '* ffi:size_t))))
    (lambda (statuslist idx)
      (let ((~idx (unwrap-size_t idx)))
        (wrap-git_status_entry* (~f statuslist ~idx))))))
(export git_status_byindex)

;; extern void git_status_list_free(git_status_list *statuslist);
(define git_status_list_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "git_status_list_free"
                (dynamic-link))
              (list '*))))
    (lambda (statuslist) (let () (~f statuslist)))))
(export git_status_list_free)

;; extern int git_status_should_ignore(int *ignored, git_repository *repo, 
;;     const char *path);
(define git_status_should_ignore
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_status_should_ignore"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (ignored repo path)
      (let ((~ignored (unwrap~pointer ignored))
            (~path (unwrap~pointer path)))
        (~f ~ignored repo ~path)))))
(export git_status_should_ignore)

;; typedef enum {
;;   GIT_SUBMODULE_STATUS_IN_HEAD = 1u<<0,
;;   GIT_SUBMODULE_STATUS_IN_INDEX = 1u<<1,
;;   GIT_SUBMODULE_STATUS_IN_CONFIG = 1u<<2,
;;   GIT_SUBMODULE_STATUS_IN_WD = 1u<<3,
;;   GIT_SUBMODULE_STATUS_INDEX_ADDED = 1u<<4,
;;   GIT_SUBMODULE_STATUS_INDEX_DELETED = 1u<<5,
;;   GIT_SUBMODULE_STATUS_INDEX_MODIFIED = 1u<<6,
;;   GIT_SUBMODULE_STATUS_WD_UNINITIALIZED = 1u<<7,
;;   GIT_SUBMODULE_STATUS_WD_ADDED = 1u<<8,
;;   GIT_SUBMODULE_STATUS_WD_DELETED = 1u<<9,
;;   GIT_SUBMODULE_STATUS_WD_MODIFIED = 1u<<10,
;;   GIT_SUBMODULE_STATUS_WD_INDEX_MODIFIED = 1u<<11,
;;   GIT_SUBMODULE_STATUS_WD_WD_MODIFIED = 1u<<12,
;;   GIT_SUBMODULE_STATUS_WD_UNTRACKED = 1u<<13,
;; } git_submodule_status_t;
(define-fh-enum git_submodule_status_t
  '((GIT_SUBMODULE_STATUS_IN_HEAD . 1)
    (GIT_SUBMODULE_STATUS_IN_INDEX . 2)
    (GIT_SUBMODULE_STATUS_IN_CONFIG . 4)
    (GIT_SUBMODULE_STATUS_IN_WD . 8)
    (GIT_SUBMODULE_STATUS_INDEX_ADDED . 16)
    (GIT_SUBMODULE_STATUS_INDEX_DELETED . 32)
    (GIT_SUBMODULE_STATUS_INDEX_MODIFIED . 64)
    (GIT_SUBMODULE_STATUS_WD_UNINITIALIZED . 128)
    (GIT_SUBMODULE_STATUS_WD_ADDED . 256)
    (GIT_SUBMODULE_STATUS_WD_DELETED . 512)
    (GIT_SUBMODULE_STATUS_WD_MODIFIED . 1024)
    (GIT_SUBMODULE_STATUS_WD_INDEX_MODIFIED . 2048)
    (GIT_SUBMODULE_STATUS_WD_WD_MODIFIED . 4096)
    (GIT_SUBMODULE_STATUS_WD_UNTRACKED . 8192))
  )

;; typedef int (*git_submodule_cb)(git_submodule *sm, const char *name, void *
;;     payload);
(define-fh-function/p git_submodule_cb
  ffi:int (list (quote *) (quote *) (quote *)))

;; typedef struct git_submodule_update_options {
;;   unsigned int version;
;;   /**
;;   	 * These options are passed to the checkout step. To disable
;;   	 * checkout, set the `checkout_strategy` to
;;   	 * `GIT_CHECKOUT_NONE`. Generally you will want the use
;;   	 * GIT_CHECKOUT_SAFE to update files in the working
;;   	 * directory. 
;;   	 */
;;   git_checkout_options checkout_opts;
;;   /**
;;   	 * Options which control the fetch, including callbacks.
;;   	 *
;;   	 * The callbacks to use for reporting fetch progress, and for acquiring
;;   	 * credentials in the event they are needed.
;;   	 */
;;   git_fetch_options fetch_opts;
;;   /**
;;   	 * Allow fetching from the submodule's default remote if the target
;;   	 * commit isn't found. Enabled by default.
;;   	 */
;;   int allow_fetch;
;; } git_submodule_update_options;
(define git_submodule_update_options-desc
  (bs:struct
    (list `(version ,unsigned-int)
          `(checkout_opts ,git_checkout_options-desc)
          `(fetch_opts
             ,(bs:struct
                (list `(version ,int)
                      `(callbacks
                         ,(bs:struct
                            (list `(version ,unsigned-int)
                                  `(sideband_progress
                                     ,git_transport_message_cb-desc)
                                  `(completion ,(bs:pointer intptr_t))
                                  `(credentials ,git_cred_acquire_cb-desc)
                                  `(certificate_check
                                     ,git_transport_certificate_check_cb-desc)
                                  `(transfer_progress
                                     ,git_transfer_progress_cb-desc)
                                  `(update_tips ,(bs:pointer intptr_t))
                                  `(pack_progress
                                     ,git_packbuilder_progress-desc)
                                  `(push_transfer_progress
                                     ,git_push_transfer_progress-desc)
                                  `(push_update_reference
                                     ,(bs:pointer intptr_t))
                                  `(push_negotiation
                                     ,git_push_negotiation-desc)
                                  `(transport ,git_transport_cb-desc)
                                  `(payload ,(bs:pointer intptr_t)))))
                      `(prune ,int)
                      `(update_fetchhead ,int)
                      `(download_tags ,int)
                      `(proxy_opts
                         ,(bs:struct
                            (list `(version ,unsigned-int)
                                  `(type ,int)
                                  `(url ,(bs:pointer int))
                                  `(credentials ,(bs:pointer intptr_t))
                                  `(certificate_check ,(bs:pointer intptr_t))
                                  `(payload ,(bs:pointer intptr_t)))))
                      `(custom_headers
                         ,(bs:struct
                            (list `(strings ,(bs:pointer (bs:pointer int)))
                                  `(count ,size_t-desc)))))))
          `(allow_fetch ,int))))
(export git_submodule_update_options-desc)
(define-fh-compound-type/p git_submodule_update_options git_submodule_update_options-desc)
(define struct-git_submodule_update_options git_submodule_update_options)

;; extern int git_submodule_update_init_options(git_submodule_update_options *
;;     opts, unsigned int version);
(define git_submodule_update_init_options
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_submodule_update_init_options"
                (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (opts version)
      (let ((~opts (unwrap-git_submodule_update_options* opts))
            (~version (unwrap~fixed version)))
        (~f ~opts ~version)))))
(export git_submodule_update_init_options)

;; extern int git_submodule_update(git_submodule *submodule, int init, 
;;     git_submodule_update_options *options);
(define git_submodule_update
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_submodule_update"
                (dynamic-link))
              (list '* ffi:int '*))))
    (lambda (submodule init options)
      (let ((~init (unwrap~fixed init))
            (~options
              (unwrap-git_submodule_update_options* options)))
        (~f submodule ~init ~options)))))
(export git_submodule_update)

;; extern int git_submodule_lookup(git_submodule **out, git_repository *repo, 
;;     const char *name);
(define git_submodule_lookup
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_submodule_lookup"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (out repo name)
      (let ((~out (unwrap~pointer out))
            (~name (unwrap~pointer name)))
        (~f ~out repo ~name)))))
(export git_submodule_lookup)

;; extern void git_submodule_free(git_submodule *submodule);
(define git_submodule_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "git_submodule_free"
                (dynamic-link))
              (list '*))))
    (lambda (submodule) (let () (~f submodule)))))
(export git_submodule_free)

;; extern int git_submodule_foreach(git_repository *repo, git_submodule_cb 
;;     callback, void *payload);
(define git_submodule_foreach
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_submodule_foreach"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (repo callback payload)
      (let ((~callback (unwrap-git_submodule_cb callback))
            (~payload (unwrap~pointer payload)))
        (~f repo ~callback ~payload)))))
(export git_submodule_foreach)

;; extern int git_submodule_add_setup(git_submodule **out, git_repository *
;;     repo, const char *url, const char *path, int use_gitlink);
(define git_submodule_add_setup
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_submodule_add_setup"
                (dynamic-link))
              (list '* '* '* '* ffi:int))))
    (lambda (out repo url path use_gitlink)
      (let ((~out (unwrap~pointer out))
            (~url (unwrap~pointer url))
            (~path (unwrap~pointer path))
            (~use_gitlink (unwrap~fixed use_gitlink)))
        (~f ~out repo ~url ~path ~use_gitlink)))))
(export git_submodule_add_setup)

;; extern int git_submodule_add_finalize(git_submodule *submodule);
(define git_submodule_add_finalize
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_submodule_add_finalize"
                (dynamic-link))
              (list '*))))
    (lambda (submodule) (let () (~f submodule)))))
(export git_submodule_add_finalize)

;; extern int git_submodule_add_to_index(git_submodule *submodule, int 
;;     write_index);
(define git_submodule_add_to_index
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_submodule_add_to_index"
                (dynamic-link))
              (list '* ffi:int))))
    (lambda (submodule write_index)
      (let ((~write_index (unwrap~fixed write_index)))
        (~f submodule ~write_index)))))
(export git_submodule_add_to_index)

;; extern git_repository *git_submodule_owner(git_submodule *submodule);
(define git_submodule_owner
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "git_submodule_owner"
                (dynamic-link))
              (list '*))))
    (lambda (submodule) (let () (~f submodule)))))
(export git_submodule_owner)

;; extern const char *git_submodule_name(git_submodule *submodule);
(define git_submodule_name
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "git_submodule_name"
                (dynamic-link))
              (list '*))))
    (lambda (submodule) (let () (~f submodule)))))
(export git_submodule_name)

;; extern const char *git_submodule_path(git_submodule *submodule);
(define git_submodule_path
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "git_submodule_path"
                (dynamic-link))
              (list '*))))
    (lambda (submodule) (let () (~f submodule)))))
(export git_submodule_path)

;; extern const char *git_submodule_url(git_submodule *submodule);
(define git_submodule_url
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "git_submodule_url" (dynamic-link))
              (list '*))))
    (lambda (submodule) (let () (~f submodule)))))
(export git_submodule_url)

;; extern int git_submodule_resolve_url(git_buf *out, git_repository *repo, 
;;     const char *url);
(define git_submodule_resolve_url
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_submodule_resolve_url"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (out repo url)
      (let ((~url (unwrap~pointer url)))
        (~f out repo ~url)))))
(export git_submodule_resolve_url)

;; extern const char *git_submodule_branch(git_submodule *submodule);
(define git_submodule_branch
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "git_submodule_branch"
                (dynamic-link))
              (list '*))))
    (lambda (submodule) (let () (~f submodule)))))
(export git_submodule_branch)

;; extern int git_submodule_set_branch(git_repository *repo, const char *name
;;     , const char *branch);
(define git_submodule_set_branch
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_submodule_set_branch"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (repo name branch)
      (let ((~name (unwrap~pointer name))
            (~branch (unwrap~pointer branch)))
        (~f repo ~name ~branch)))))
(export git_submodule_set_branch)

;; extern int git_submodule_set_url(git_repository *repo, const char *name, 
;;     const char *url);
(define git_submodule_set_url
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_submodule_set_url"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (repo name url)
      (let ((~name (unwrap~pointer name))
            (~url (unwrap~pointer url)))
        (~f repo ~name ~url)))))
(export git_submodule_set_url)

;; extern const git_oid *git_submodule_index_id(git_submodule *submodule);
(define git_submodule_index_id
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "git_submodule_index_id"
                (dynamic-link))
              (list '*))))
    (lambda (submodule) (let () (~f submodule)))))
(export git_submodule_index_id)

;; extern const git_oid *git_submodule_head_id(git_submodule *submodule);
(define git_submodule_head_id
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "git_submodule_head_id"
                (dynamic-link))
              (list '*))))
    (lambda (submodule) (let () (~f submodule)))))
(export git_submodule_head_id)

;; extern const git_oid *git_submodule_wd_id(git_submodule *submodule);
(define git_submodule_wd_id
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "git_submodule_wd_id"
                (dynamic-link))
              (list '*))))
    (lambda (submodule) (let () (~f submodule)))))
(export git_submodule_wd_id)

;; extern git_submodule_ignore_t git_submodule_ignore(git_submodule *submodule
;;     );
(define git_submodule_ignore
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_submodule_ignore"
                (dynamic-link))
              (list '*))))
    (lambda (submodule) (let () (~f submodule)))))
(export git_submodule_ignore)

;; extern int git_submodule_set_ignore(git_repository *repo, const char *name
;;     , git_submodule_ignore_t ignore);
(define git_submodule_set_ignore
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_submodule_set_ignore"
                (dynamic-link))
              (list '* '* ffi:int))))
    (lambda (repo name ignore)
      (let ((~name (unwrap~pointer name))
            (~ignore (unwrap-git_submodule_ignore_t ignore)))
        (~f repo ~name ~ignore)))))
(export git_submodule_set_ignore)

;; extern git_submodule_update_t git_submodule_update_strategy(git_submodule *
;;     submodule);
(define git_submodule_update_strategy
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_submodule_update_strategy"
                (dynamic-link))
              (list '*))))
    (lambda (submodule) (let () (~f submodule)))))
(export git_submodule_update_strategy)

;; extern int git_submodule_set_update(git_repository *repo, const char *name
;;     , git_submodule_update_t update);
(define git_submodule_set_update
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_submodule_set_update"
                (dynamic-link))
              (list '* '* ffi:int))))
    (lambda (repo name update)
      (let ((~name (unwrap~pointer name))
            (~update (unwrap-git_submodule_update_t update)))
        (~f repo ~name ~update)))))
(export git_submodule_set_update)

;; extern git_submodule_recurse_t git_submodule_fetch_recurse_submodules(
;;     git_submodule *submodule);
(define git_submodule_fetch_recurse_submodules
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_submodule_fetch_recurse_submodules"
                (dynamic-link))
              (list '*))))
    (lambda (submodule) (let () (~f submodule)))))
(export git_submodule_fetch_recurse_submodules)

;; extern int git_submodule_set_fetch_recurse_submodules(git_repository *repo
;;     , const char *name, git_submodule_recurse_t fetch_recurse_submodules);
(define git_submodule_set_fetch_recurse_submodules
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_submodule_set_fetch_recurse_submodules"
                (dynamic-link))
              (list '* '* ffi:int))))
    (lambda (repo name fetch_recurse_submodules)
      (let ((~name (unwrap~pointer name))
            (~fetch_recurse_submodules
              (unwrap-git_submodule_recurse_t
                fetch_recurse_submodules)))
        (~f repo ~name ~fetch_recurse_submodules)))))
(export git_submodule_set_fetch_recurse_submodules)

;; extern int git_submodule_init(git_submodule *submodule, int overwrite);
(define git_submodule_init
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_submodule_init"
                (dynamic-link))
              (list '* ffi:int))))
    (lambda (submodule overwrite)
      (let ((~overwrite (unwrap~fixed overwrite)))
        (~f submodule ~overwrite)))))
(export git_submodule_init)

;; extern int git_submodule_repo_init(git_repository **out, const 
;;     git_submodule *sm, int use_gitlink);
(define git_submodule_repo_init
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_submodule_repo_init"
                (dynamic-link))
              (list '* '* ffi:int))))
    (lambda (out sm use_gitlink)
      (let ((~out (unwrap~pointer out))
            (~use_gitlink (unwrap~fixed use_gitlink)))
        (~f ~out sm ~use_gitlink)))))
(export git_submodule_repo_init)

;; extern int git_submodule_sync(git_submodule *submodule);
(define git_submodule_sync
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_submodule_sync"
                (dynamic-link))
              (list '*))))
    (lambda (submodule) (let () (~f submodule)))))
(export git_submodule_sync)

;; extern int git_submodule_open(git_repository **repo, git_submodule *
;;     submodule);
(define git_submodule_open
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_submodule_open"
                (dynamic-link))
              (list '* '*))))
    (lambda (repo submodule)
      (let ((~repo (unwrap~pointer repo)))
        (~f ~repo submodule)))))
(export git_submodule_open)

;; extern int git_submodule_reload(git_submodule *submodule, int force);
(define git_submodule_reload
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_submodule_reload"
                (dynamic-link))
              (list '* ffi:int))))
    (lambda (submodule force)
      (let ((~force (unwrap~fixed force)))
        (~f submodule ~force)))))
(export git_submodule_reload)

;; extern int git_submodule_status(unsigned int *status, git_repository *repo
;;     , const char *name, git_submodule_ignore_t ignore);
(define git_submodule_status
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_submodule_status"
                (dynamic-link))
              (list '* '* '* ffi:int))))
    (lambda (status repo name ignore)
      (let ((~status (unwrap~pointer status))
            (~name (unwrap~pointer name))
            (~ignore (unwrap-git_submodule_ignore_t ignore)))
        (~f ~status repo ~name ~ignore)))))
(export git_submodule_status)

;; extern int git_submodule_location(unsigned int *location_status, 
;;     git_submodule *submodule);
(define git_submodule_location
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_submodule_location"
                (dynamic-link))
              (list '* '*))))
    (lambda (location_status submodule)
      (let ((~location_status
              (unwrap~pointer location_status)))
        (~f ~location_status submodule)))))
(export git_submodule_location)

;; extern int git_tag_lookup(git_tag **out, git_repository *repo, const 
;;     git_oid *id);
(define git_tag_lookup
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_tag_lookup" (dynamic-link))
              (list '* '* '*))))
    (lambda (out repo id)
      (let ((~out (unwrap~pointer out)))
        (~f ~out repo id)))))
(export git_tag_lookup)

;; extern int git_tag_lookup_prefix(git_tag **out, git_repository *repo, const
;;      git_oid *id, size_t len);
(define git_tag_lookup_prefix
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_tag_lookup_prefix"
                (dynamic-link))
              (list '* '* '* ffi:size_t))))
    (lambda (out repo id len)
      (let ((~out (unwrap~pointer out))
            (~len (unwrap-size_t len)))
        (~f ~out repo id ~len)))))
(export git_tag_lookup_prefix)

;; extern void git_tag_free(git_tag *tag);
(define git_tag_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "git_tag_free" (dynamic-link))
              (list '*))))
    (lambda (tag) (let () (~f tag)))))
(export git_tag_free)

;; extern const git_oid *git_tag_id(const git_tag *tag);
(define git_tag_id
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "git_tag_id" (dynamic-link))
              (list '*))))
    (lambda (tag) (let () (~f tag)))))
(export git_tag_id)

;; extern git_repository *git_tag_owner(const git_tag *tag);
(define git_tag_owner
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "git_tag_owner" (dynamic-link))
              (list '*))))
    (lambda (tag) (let () (~f tag)))))
(export git_tag_owner)

;; extern int git_tag_target(git_object **target_out, const git_tag *tag);
(define git_tag_target
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_tag_target" (dynamic-link))
              (list '* '*))))
    (lambda (target_out tag)
      (let ((~target_out (unwrap~pointer target_out)))
        (~f ~target_out tag)))))
(export git_tag_target)

;; extern const git_oid *git_tag_target_id(const git_tag *tag);
(define git_tag_target_id
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "git_tag_target_id" (dynamic-link))
              (list '*))))
    (lambda (tag) (let () (~f tag)))))
(export git_tag_target_id)

;; extern git_otype git_tag_target_type(const git_tag *tag);
(define git_tag_target_type
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_tag_target_type"
                (dynamic-link))
              (list '*))))
    (lambda (tag) (let () (~f tag)))))
(export git_tag_target_type)

;; extern const char *git_tag_name(const git_tag *tag);
(define git_tag_name
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "git_tag_name" (dynamic-link))
              (list '*))))
    (lambda (tag) (let () (~f tag)))))
(export git_tag_name)

;; extern const git_signature *git_tag_tagger(const git_tag *tag);
(define git_tag_tagger
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "git_tag_tagger" (dynamic-link))
              (list '*))))
    (lambda (tag) (let () (~f tag)))))
(export git_tag_tagger)

;; extern const char *git_tag_message(const git_tag *tag);
(define git_tag_message
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "git_tag_message" (dynamic-link))
              (list '*))))
    (lambda (tag) (let () (~f tag)))))
(export git_tag_message)

;; extern int git_tag_create(git_oid *oid, git_repository *repo, const char *
;;     tag_name, const git_object *target, const git_signature *tagger, const 
;;     char *message, int force);
(define git_tag_create
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_tag_create" (dynamic-link))
              (list '* '* '* '* '* '* ffi:int))))
    (lambda (oid repo tag_name target tagger message force)
      (let ((~tag_name (unwrap~pointer tag_name))
            (~message (unwrap~pointer message))
            (~force (unwrap~fixed force)))
        (~f oid
            repo
            ~tag_name
            target
            tagger
            ~message
            ~force)))))
(export git_tag_create)

;; extern int git_tag_annotation_create(git_oid *oid, git_repository *repo, 
;;     const char *tag_name, const git_object *target, const git_signature *
;;     tagger, const char *message);
(define git_tag_annotation_create
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_tag_annotation_create"
                (dynamic-link))
              (list '* '* '* '* '* '*))))
    (lambda (oid repo tag_name target tagger message)
      (let ((~tag_name (unwrap~pointer tag_name))
            (~message (unwrap~pointer message)))
        (~f oid repo ~tag_name target tagger ~message)))))
(export git_tag_annotation_create)

;; extern int git_tag_create_frombuffer(git_oid *oid, git_repository *repo, 
;;     const char *buffer, int force);
(define git_tag_create_frombuffer
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_tag_create_frombuffer"
                (dynamic-link))
              (list '* '* '* ffi:int))))
    (lambda (oid repo buffer force)
      (let ((~buffer (unwrap~pointer buffer))
            (~force (unwrap~fixed force)))
        (~f oid repo ~buffer ~force)))))
(export git_tag_create_frombuffer)

;; extern int git_tag_create_lightweight(git_oid *oid, git_repository *repo, 
;;     const char *tag_name, const git_object *target, int force);
(define git_tag_create_lightweight
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_tag_create_lightweight"
                (dynamic-link))
              (list '* '* '* '* ffi:int))))
    (lambda (oid repo tag_name target force)
      (let ((~tag_name (unwrap~pointer tag_name))
            (~force (unwrap~fixed force)))
        (~f oid repo ~tag_name target ~force)))))
(export git_tag_create_lightweight)

;; extern int git_tag_delete(git_repository *repo, const char *tag_name);
(define git_tag_delete
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_tag_delete" (dynamic-link))
              (list '* '*))))
    (lambda (repo tag_name)
      (let ((~tag_name (unwrap~pointer tag_name)))
        (~f repo ~tag_name)))))
(export git_tag_delete)

;; extern int git_tag_list(git_strarray *tag_names, git_repository *repo);
(define git_tag_list
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_tag_list" (dynamic-link))
              (list '* '*))))
    (lambda (tag_names repo)
      (let () (~f tag_names repo)))))
(export git_tag_list)

;; extern int git_tag_list_match(git_strarray *tag_names, const char *pattern
;;     , git_repository *repo);
(define git_tag_list_match
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_tag_list_match"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (tag_names pattern repo)
      (let ((~pattern (unwrap~pointer pattern)))
        (~f tag_names ~pattern repo)))))
(export git_tag_list_match)

;; typedef int (*git_tag_foreach_cb)(const char *name, git_oid *oid, void *
;;     payload);
(define-fh-function/p git_tag_foreach_cb
  ffi:int (list (quote *) (quote *) (quote *)))

;; extern int git_tag_foreach(git_repository *repo, git_tag_foreach_cb 
;;     callback, void *payload);
(define git_tag_foreach
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_tag_foreach" (dynamic-link))
              (list '* '* '*))))
    (lambda (repo callback payload)
      (let ((~callback (unwrap-git_tag_foreach_cb callback))
            (~payload (unwrap~pointer payload)))
        (~f repo ~callback ~payload)))))
(export git_tag_foreach)

;; extern int git_tag_peel(git_object **tag_target_out, const git_tag *tag);
(define git_tag_peel
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_tag_peel" (dynamic-link))
              (list '* '*))))
    (lambda (tag_target_out tag)
      (let ((~tag_target_out (unwrap~pointer tag_target_out)))
        (~f ~tag_target_out tag)))))
(export git_tag_peel)

;; extern int git_tag_dup(git_tag **out, git_tag *source);
(define git_tag_dup
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "git_tag_dup" (dynamic-link))
              (list '* '*))))
    (lambda (out source)
      (let ((~out (unwrap~pointer out)))
        (~f ~out source)))))
(export git_tag_dup)

;; extern int git_transaction_new(git_transaction **out, git_repository *repo)
;;     ;
(define git_transaction_new
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_transaction_new"
                (dynamic-link))
              (list '* '*))))
    (lambda (out repo)
      (let ((~out (unwrap~pointer out)))
        (~f ~out repo)))))
(export git_transaction_new)

;; extern int git_transaction_lock_ref(git_transaction *tx, const char *
;;     refname);
(define git_transaction_lock_ref
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_transaction_lock_ref"
                (dynamic-link))
              (list '* '*))))
    (lambda (tx refname)
      (let ((~refname (unwrap~pointer refname)))
        (~f tx ~refname)))))
(export git_transaction_lock_ref)

;; extern int git_transaction_set_target(git_transaction *tx, const char *
;;     refname, const git_oid *target, const git_signature *sig, const char *
;;     msg);
(define git_transaction_set_target
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_transaction_set_target"
                (dynamic-link))
              (list '* '* '* '* '*))))
    (lambda (tx refname target sig msg)
      (let ((~refname (unwrap~pointer refname))
            (~msg (unwrap~pointer msg)))
        (~f tx ~refname target sig ~msg)))))
(export git_transaction_set_target)

;; extern int git_transaction_set_symbolic_target(git_transaction *tx, const 
;;     char *refname, const char *target, const git_signature *sig, const char
;;      *msg);
(define git_transaction_set_symbolic_target
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_transaction_set_symbolic_target"
                (dynamic-link))
              (list '* '* '* '* '*))))
    (lambda (tx refname target sig msg)
      (let ((~refname (unwrap~pointer refname))
            (~target (unwrap~pointer target))
            (~msg (unwrap~pointer msg)))
        (~f tx ~refname ~target sig ~msg)))))
(export git_transaction_set_symbolic_target)

;; extern int git_transaction_set_reflog(git_transaction *tx, const char *
;;     refname, const git_reflog *reflog);
(define git_transaction_set_reflog
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_transaction_set_reflog"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (tx refname reflog)
      (let ((~refname (unwrap~pointer refname)))
        (~f tx ~refname reflog)))))
(export git_transaction_set_reflog)

;; extern int git_transaction_remove(git_transaction *tx, const char *refname)
;;     ;
(define git_transaction_remove
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_transaction_remove"
                (dynamic-link))
              (list '* '*))))
    (lambda (tx refname)
      (let ((~refname (unwrap~pointer refname)))
        (~f tx ~refname)))))
(export git_transaction_remove)

;; extern int git_transaction_commit(git_transaction *tx);
(define git_transaction_commit
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "git_transaction_commit"
                (dynamic-link))
              (list '*))))
    (lambda (tx) (let () (~f tx)))))
(export git_transaction_commit)

;; extern void git_transaction_free(git_transaction *tx);
(define git_transaction_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "git_transaction_free"
                (dynamic-link))
              (list '*))))
    (lambda (tx) (let () (~f tx)))))
(export git_transaction_free)

;; access to enum symbols and #define'd constants:
(define libgit2-symbol-val
  (let ((sym-tab
          '((_CLOCK_THREAD_CPUTIME_ID . 16)
            (_CLOCK_PROCESS_CPUTIME_ID . 12)
            (_CLOCK_UPTIME_RAW_APPROX . 9)
            (_CLOCK_UPTIME_RAW . 8)
            (_CLOCK_MONOTONIC_RAW_APPROX . 5)
            (_CLOCK_MONOTONIC_RAW . 4)
            (_CLOCK_MONOTONIC . 6)
            (_CLOCK_REALTIME . 0)
            (P_PGID . 2)
            (P_PID . 1)
            (P_ALL . 0)
            (GIT_FEATURE_NSEC . 8)
            (GIT_FEATURE_SSH . 4)
            (GIT_FEATURE_HTTPS . 2)
            (GIT_FEATURE_THREADS . 1)
            (GIT_OPT_ENABLE_STRICT_HASH_VERIFICATION . 22)
            (GIT_OPT_SET_WINDOWS_SHAREMODE . 21)
            (GIT_OPT_GET_WINDOWS_SHAREMODE . 20)
            (GIT_OPT_ENABLE_FSYNC_GITDIR . 19)
            (GIT_OPT_ENABLE_OFS_DELTA . 18)
            (GIT_OPT_GET_USER_AGENT . 17)
            (GIT_OPT_SET_SSL_CIPHERS . 16)
            (GIT_OPT_ENABLE_STRICT_SYMBOLIC_REF_CREATION
              .
              15)
            (GIT_OPT_ENABLE_STRICT_OBJECT_CREATION . 14)
            (GIT_OPT_SET_USER_AGENT . 13)
            (GIT_OPT_SET_SSL_CERT_LOCATIONS . 12)
            (GIT_OPT_SET_TEMPLATE_PATH . 11)
            (GIT_OPT_GET_TEMPLATE_PATH . 10)
            (GIT_OPT_GET_CACHED_MEMORY . 9)
            (GIT_OPT_ENABLE_CACHING . 8)
            (GIT_OPT_SET_CACHE_MAX_SIZE . 7)
            (GIT_OPT_SET_CACHE_OBJECT_LIMIT . 6)
            (GIT_OPT_SET_SEARCH_PATH . 5)
            (GIT_OPT_GET_SEARCH_PATH . 4)
            (GIT_OPT_SET_MWINDOW_MAPPED_LIMIT . 3)
            (GIT_OPT_GET_MWINDOW_MAPPED_LIMIT . 2)
            (GIT_OPT_SET_MWINDOW_SIZE . 1)
            (GIT_OPT_GET_MWINDOW_SIZE . 0)
            (GIT_OBJ_REF_DELTA . 7)
            (GIT_OBJ_OFS_DELTA . 6)
            (GIT_OBJ__EXT2 . 5)
            (GIT_OBJ_TAG . 4)
            (GIT_OBJ_BLOB . 3)
            (GIT_OBJ_TREE . 2)
            (GIT_OBJ_COMMIT . 1)
            (GIT_OBJ__EXT1 . 0)
            (GIT_OBJ_BAD . -1)
            (GIT_OBJ_ANY . -2)
            (GIT_REF_LISTALL . 0)
            (GIT_REF_SYMBOLIC . 2)
            (GIT_REF_OID . 1)
            (GIT_REF_INVALID . 0)
            (GIT_BRANCH_ALL . 0)
            (GIT_BRANCH_REMOTE . 2)
            (GIT_BRANCH_LOCAL . 1)
            (GIT_FILEMODE_COMMIT . 57344)
            (GIT_FILEMODE_LINK . 40960)
            (GIT_FILEMODE_BLOB_EXECUTABLE . 33261)
            (GIT_FILEMODE_BLOB . 33188)
            (GIT_FILEMODE_TREE . 16384)
            (GIT_FILEMODE_UNREADABLE . 0)
            (GIT_CERT_STRARRAY . 3)
            (GIT_CERT_HOSTKEY_LIBSSH2 . 2)
            (GIT_CERT_X509 . 1)
            (GIT_CERT_NONE . 0)
            (GIT_SUBMODULE_UPDATE_DEFAULT . 0)
            (GIT_SUBMODULE_UPDATE_NONE . 4)
            (GIT_SUBMODULE_UPDATE_MERGE . 3)
            (GIT_SUBMODULE_UPDATE_REBASE . 2)
            (GIT_SUBMODULE_UPDATE_CHECKOUT . 1)
            (GIT_SUBMODULE_IGNORE_ALL . 4)
            (GIT_SUBMODULE_IGNORE_DIRTY . 3)
            (GIT_SUBMODULE_IGNORE_UNTRACKED . 2)
            (GIT_SUBMODULE_IGNORE_NONE . 1)
            (GIT_SUBMODULE_IGNORE_UNSPECIFIED . -1)
            (GIT_SUBMODULE_RECURSE_ONDEMAND . 2)
            (GIT_SUBMODULE_RECURSE_YES . 1)
            (GIT_SUBMODULE_RECURSE_NO . 0)
            (GIT_REPOSITORY_OPEN_FROM_ENV . 16)
            (GIT_REPOSITORY_OPEN_NO_DOTGIT . 8)
            (GIT_REPOSITORY_OPEN_BARE . 4)
            (GIT_REPOSITORY_OPEN_CROSS_FS . 2)
            (GIT_REPOSITORY_OPEN_NO_SEARCH . 1)
            (GIT_REPOSITORY_INIT_RELATIVE_GITLINK . 64)
            (GIT_REPOSITORY_INIT_EXTERNAL_TEMPLATE . 32)
            (GIT_REPOSITORY_INIT_MKPATH . 16)
            (GIT_REPOSITORY_INIT_MKDIR . 8)
            (GIT_REPOSITORY_INIT_NO_DOTGIT_DIR . 4)
            (GIT_REPOSITORY_INIT_NO_REINIT . 2)
            (GIT_REPOSITORY_INIT_BARE . 1)
            (GIT_REPOSITORY_INIT_SHARED_ALL . 1535)
            (GIT_REPOSITORY_INIT_SHARED_GROUP . 1533)
            (GIT_REPOSITORY_INIT_SHARED_UMASK . 0)
            (GIT_REPOSITORY_ITEM_WORKTREES . 13)
            (GIT_REPOSITORY_ITEM_MODULES . 12)
            (GIT_REPOSITORY_ITEM_LOGS . 11)
            (GIT_REPOSITORY_ITEM_HOOKS . 10)
            (GIT_REPOSITORY_ITEM_INFO . 9)
            (GIT_REPOSITORY_ITEM_CONFIG . 8)
            (GIT_REPOSITORY_ITEM_REMOTES . 7)
            (GIT_REPOSITORY_ITEM_PACKED_REFS . 6)
            (GIT_REPOSITORY_ITEM_REFS . 5)
            (GIT_REPOSITORY_ITEM_OBJECTS . 4)
            (GIT_REPOSITORY_ITEM_INDEX . 3)
            (GIT_REPOSITORY_ITEM_COMMONDIR . 2)
            (GIT_REPOSITORY_ITEM_WORKDIR . 1)
            (GIT_REPOSITORY_ITEM_GITDIR . 0)
            (GIT_REPOSITORY_STATE_APPLY_MAILBOX_OR_REBASE
              .
              11)
            (GIT_REPOSITORY_STATE_APPLY_MAILBOX . 10)
            (GIT_REPOSITORY_STATE_REBASE_MERGE . 9)
            (GIT_REPOSITORY_STATE_REBASE_INTERACTIVE . 8)
            (GIT_REPOSITORY_STATE_REBASE . 7)
            (GIT_REPOSITORY_STATE_BISECT . 6)
            (GIT_REPOSITORY_STATE_CHERRYPICK_SEQUENCE . 5)
            (GIT_REPOSITORY_STATE_CHERRYPICK . 4)
            (GIT_REPOSITORY_STATE_REVERT_SEQUENCE . 3)
            (GIT_REPOSITORY_STATE_REVERT . 2)
            (GIT_REPOSITORY_STATE_MERGE . 1)
            (GIT_REPOSITORY_STATE_NONE . 0)
            (GIT_ATTR_VALUE_T . 3)
            (GIT_ATTR_FALSE_T . 2)
            (GIT_ATTR_TRUE_T . 1)
            (GIT_ATTR_UNSPECIFIED_T . 0)
            (GIT_BLAME_FIRST_PARENT . 16)
            (GIT_BLAME_TRACK_COPIES_ANY_COMMIT_COPIES . 8)
            (GIT_BLAME_TRACK_COPIES_SAME_COMMIT_COPIES . 4)
            (GIT_BLAME_TRACK_COPIES_SAME_COMMIT_MOVES . 2)
            (GIT_BLAME_TRACK_COPIES_SAME_FILE . 1)
            (GIT_BLAME_NORMAL . 0)
            (GIT_TREEWALK_POST . 1)
            (GIT_TREEWALK_PRE . 0)
            (GIT_TREE_UPDATE_REMOVE . 1)
            (GIT_TREE_UPDATE_UPSERT . 0)
            (GIT_REF_FORMAT_REFSPEC_SHORTHAND . 4)
            (GIT_REF_FORMAT_REFSPEC_PATTERN . 2)
            (GIT_REF_FORMAT_ALLOW_ONELEVEL . 1)
            (GIT_REF_FORMAT_NORMAL . 0)
            (GIT_DIFF_SHOW_BINARY . 1073741824)
            (GIT_DIFF_MINIMAL . 536870912)
            (GIT_DIFF_PATIENCE . 268435456)
            (GIT_DIFF_SHOW_UNMODIFIED . 67108864)
            (GIT_DIFF_SHOW_UNTRACKED_CONTENT . 33554432)
            (GIT_DIFF_IGNORE_WHITESPACE_EOL . 16777216)
            (GIT_DIFF_IGNORE_WHITESPACE_CHANGE . 8388608)
            (GIT_DIFF_IGNORE_WHITESPACE . 4194304)
            (GIT_DIFF_FORCE_BINARY . 2097152)
            (GIT_DIFF_FORCE_TEXT . 1048576)
            (GIT_DIFF_INCLUDE_UNREADABLE_AS_UNTRACKED
              .
              131072)
            (GIT_DIFF_INCLUDE_UNREADABLE . 65536)
            (GIT_DIFF_UPDATE_INDEX . 32768)
            (GIT_DIFF_ENABLE_FAST_UNTRACKED_DIRS . 16384)
            (GIT_DIFF_SKIP_BINARY_CHECK . 8192)
            (GIT_DIFF_DISABLE_PATHSPEC_MATCH . 4096)
            (GIT_DIFF_INCLUDE_CASECHANGE . 2048)
            (GIT_DIFF_IGNORE_CASE . 1024)
            (GIT_DIFF_IGNORE_SUBMODULES . 512)
            (GIT_DIFF_IGNORE_FILEMODE . 256)
            (GIT_DIFF_INCLUDE_TYPECHANGE_TREES . 128)
            (GIT_DIFF_INCLUDE_TYPECHANGE . 64)
            (GIT_DIFF_INCLUDE_UNMODIFIED . 32)
            (GIT_DIFF_RECURSE_UNTRACKED_DIRS . 16)
            (GIT_DIFF_INCLUDE_UNTRACKED . 8)
            (GIT_DIFF_RECURSE_IGNORED_DIRS . 4)
            (GIT_DIFF_INCLUDE_IGNORED . 2)
            (GIT_DIFF_REVERSE . 1)
            (GIT_DIFF_NORMAL . 0)
            (GIT_DIFF_FLAG_EXISTS . 8)
            (GIT_DIFF_FLAG_VALID_ID . 4)
            (GIT_DIFF_FLAG_NOT_BINARY . 2)
            (GIT_DIFF_FLAG_BINARY . 1)
            (GIT_DELTA_CONFLICTED . 10)
            (GIT_DELTA_UNREADABLE . 9)
            (GIT_DELTA_TYPECHANGE . 8)
            (GIT_DELTA_UNTRACKED . 7)
            (GIT_DELTA_IGNORED . 6)
            (GIT_DELTA_COPIED . 5)
            (GIT_DELTA_RENAMED . 4)
            (GIT_DELTA_MODIFIED . 3)
            (GIT_DELTA_DELETED . 2)
            (GIT_DELTA_ADDED . 1)
            (GIT_DELTA_UNMODIFIED . 0)
            (GIT_DIFF_BINARY_DELTA . 2)
            (GIT_DIFF_BINARY_LITERAL . 1)
            (GIT_DIFF_BINARY_NONE . 0)
            (GIT_DIFF_LINE_BINARY . 66)
            (GIT_DIFF_LINE_HUNK_HDR . 72)
            (GIT_DIFF_LINE_FILE_HDR . 70)
            (GIT_DIFF_LINE_DEL_EOFNL . 60)
            (GIT_DIFF_LINE_ADD_EOFNL . 62)
            (GIT_DIFF_LINE_CONTEXT_EOFNL . 61)
            (GIT_DIFF_LINE_DELETION . 45)
            (GIT_DIFF_LINE_ADDITION . 43)
            (GIT_DIFF_LINE_CONTEXT . 32)
            (GIT_DIFF_FIND_REMOVE_UNMODIFIED . 65536)
            (GIT_DIFF_BREAK_REWRITES_FOR_RENAMES_ONLY
              .
              32768)
            (GIT_DIFF_FIND_EXACT_MATCH_ONLY . 16384)
            (GIT_DIFF_FIND_DONT_IGNORE_WHITESPACE . 8192)
            (GIT_DIFF_FIND_IGNORE_WHITESPACE . 4096)
            (GIT_DIFF_FIND_IGNORE_LEADING_WHITESPACE . 0)
            (GIT_DIFF_FIND_ALL . 255)
            (GIT_DIFF_FIND_FOR_UNTRACKED . 64)
            (GIT_DIFF_FIND_AND_BREAK_REWRITES . 0)
            (GIT_DIFF_BREAK_REWRITES . 32)
            (GIT_DIFF_FIND_REWRITES . 16)
            (GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED . 8)
            (GIT_DIFF_FIND_COPIES . 4)
            (GIT_DIFF_FIND_RENAMES_FROM_REWRITES . 2)
            (GIT_DIFF_FIND_RENAMES . 1)
            (GIT_DIFF_FIND_BY_CONFIG . 0)
            (GIT_DIFF_FORMAT_NAME_STATUS . 5)
            (GIT_DIFF_FORMAT_NAME_ONLY . 4)
            (GIT_DIFF_FORMAT_RAW . 3)
            (GIT_DIFF_FORMAT_PATCH_HEADER . 2)
            (GIT_DIFF_FORMAT_PATCH . 1)
            (GIT_DIFF_STATS_INCLUDE_SUMMARY . 8)
            (GIT_DIFF_STATS_NUMBER . 4)
            (GIT_DIFF_STATS_SHORT . 2)
            (GIT_DIFF_STATS_FULL . 1)
            (GIT_DIFF_STATS_NONE . 0)
            (GIT_DIFF_FORMAT_EMAIL_EXCLUDE_SUBJECT_PATCH_MARKER
              .
              1)
            (GIT_DIFF_FORMAT_EMAIL_NONE . 0)
            (GIT_CHECKOUT_UPDATE_SUBMODULES_IF_CHANGED
              .
              131072)
            (GIT_CHECKOUT_UPDATE_SUBMODULES . 65536)
            (GIT_CHECKOUT_DONT_WRITE_INDEX . 8388608)
            (GIT_CHECKOUT_DONT_REMOVE_EXISTING . 4194304)
            (GIT_CHECKOUT_CONFLICT_STYLE_DIFF3 . 2097152)
            (GIT_CHECKOUT_CONFLICT_STYLE_MERGE . 1048576)
            (GIT_CHECKOUT_DONT_OVERWRITE_IGNORED . 524288)
            (GIT_CHECKOUT_SKIP_LOCKED_DIRECTORIES . 262144)
            (GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH . 8192)
            (GIT_CHECKOUT_USE_THEIRS . 4096)
            (GIT_CHECKOUT_USE_OURS . 2048)
            (GIT_CHECKOUT_SKIP_UNMERGED . 1024)
            (GIT_CHECKOUT_NO_REFRESH . 512)
            (GIT_CHECKOUT_DONT_UPDATE_INDEX . 256)
            (GIT_CHECKOUT_UPDATE_ONLY . 128)
            (GIT_CHECKOUT_REMOVE_IGNORED . 64)
            (GIT_CHECKOUT_REMOVE_UNTRACKED . 32)
            (GIT_CHECKOUT_ALLOW_CONFLICTS . 16)
            (GIT_CHECKOUT_RECREATE_MISSING . 4)
            (GIT_CHECKOUT_FORCE . 2)
            (GIT_CHECKOUT_SAFE . 1)
            (GIT_CHECKOUT_NONE . 0)
            (GIT_CHECKOUT_NOTIFY_ALL . 65535)
            (GIT_CHECKOUT_NOTIFY_IGNORED . 16)
            (GIT_CHECKOUT_NOTIFY_UNTRACKED . 8)
            (GIT_CHECKOUT_NOTIFY_UPDATED . 4)
            (GIT_CHECKOUT_NOTIFY_DIRTY . 2)
            (GIT_CHECKOUT_NOTIFY_CONFLICT . 1)
            (GIT_CHECKOUT_NOTIFY_NONE . 0)
            (GIT_IDXENTRY_VALID . 32768)
            (GIT_IDXENTRY_EXTENDED . 16384)
            (GIT_IDXENTRY_NEW_SKIP_WORKTREE . 512)
            (GIT_IDXENTRY_UNPACKED . 256)
            (GIT_IDXENTRY_CONFLICTED . 128)
            (GIT_IDXENTRY_WT_REMOVE . 64)
            (GIT_IDXENTRY_UNHASHED . 32)
            (GIT_IDXENTRY_HASHED . 16)
            (GIT_IDXENTRY_ADDED . 8)
            (GIT_IDXENTRY_UPTODATE . 4)
            (GIT_IDXENTRY_REMOVE . 2)
            (GIT_IDXENTRY_UPDATE . 1)
            (GIT_IDXENTRY_EXTENDED_FLAGS . 0)
            (GIT_IDXENTRY_EXTENDED2 . 32768)
            (GIT_IDXENTRY_SKIP_WORKTREE . 16384)
            (GIT_IDXENTRY_INTENT_TO_ADD . 8192)
            (GIT_INDEXCAP_FROM_OWNER . -1)
            (GIT_INDEXCAP_NO_SYMLINKS . 4)
            (GIT_INDEXCAP_NO_FILEMODE . 2)
            (GIT_INDEXCAP_IGNORE_CASE . 1)
            (GIT_INDEX_ADD_CHECK_PATHSPEC . 4)
            (GIT_INDEX_ADD_DISABLE_PATHSPEC_MATCH . 2)
            (GIT_INDEX_ADD_FORCE . 1)
            (GIT_INDEX_ADD_DEFAULT . 0)
            (GIT_INDEX_STAGE_THEIRS . 3)
            (GIT_INDEX_STAGE_OURS . 2)
            (GIT_INDEX_STAGE_ANCESTOR . 1)
            (GIT_INDEX_STAGE_NORMAL . 0)
            (GIT_INDEX_STAGE_ANY . -1)
            (GIT_MERGE_NO_RECURSIVE . 8)
            (GIT_MERGE_SKIP_REUC . 4)
            (GIT_MERGE_FAIL_ON_CONFLICT . 2)
            (GIT_MERGE_FIND_RENAMES . 1)
            (GIT_MERGE_FILE_FAVOR_UNION . 3)
            (GIT_MERGE_FILE_FAVOR_THEIRS . 2)
            (GIT_MERGE_FILE_FAVOR_OURS . 1)
            (GIT_MERGE_FILE_FAVOR_NORMAL . 0)
            (GIT_MERGE_FILE_DIFF_MINIMAL . 128)
            (GIT_MERGE_FILE_DIFF_PATIENCE . 64)
            (GIT_MERGE_FILE_IGNORE_WHITESPACE_EOL . 32)
            (GIT_MERGE_FILE_IGNORE_WHITESPACE_CHANGE . 16)
            (GIT_MERGE_FILE_IGNORE_WHITESPACE . 8)
            (GIT_MERGE_FILE_SIMPLIFY_ALNUM . 4)
            (GIT_MERGE_FILE_STYLE_DIFF3 . 2)
            (GIT_MERGE_FILE_STYLE_MERGE . 1)
            (GIT_MERGE_FILE_DEFAULT . 0)
            (GIT_MERGE_ANALYSIS_UNBORN . 8)
            (GIT_MERGE_ANALYSIS_FASTFORWARD . 4)
            (GIT_MERGE_ANALYSIS_UP_TO_DATE . 2)
            (GIT_MERGE_ANALYSIS_NORMAL . 1)
            (GIT_MERGE_ANALYSIS_NONE . 0)
            (GIT_MERGE_PREFERENCE_FASTFORWARD_ONLY . 2)
            (GIT_MERGE_PREFERENCE_NO_FASTFORWARD . 1)
            (GIT_MERGE_PREFERENCE_NONE . 0)
            (GIT_DIRECTION_PUSH . 1)
            (GIT_DIRECTION_FETCH . 0)
            (GIT_CERT_SSH_SHA1 . 2)
            (GIT_CERT_SSH_MD5 . 1)
            (GIT_CREDTYPE_SSH_MEMORY . 64)
            (GIT_CREDTYPE_USERNAME . 32)
            (GIT_CREDTYPE_SSH_INTERACTIVE . 16)
            (GIT_CREDTYPE_DEFAULT . 8)
            (GIT_CREDTYPE_SSH_CUSTOM . 4)
            (GIT_CREDTYPE_SSH_KEY . 2)
            (GIT_CREDTYPE_USERPASS_PLAINTEXT . 1)
            (GIT_PACKBUILDER_DELTAFICATION . 1)
            (GIT_PACKBUILDER_ADDING_OBJECTS . 0)
            (GIT_PROXY_SPECIFIED . 2)
            (GIT_PROXY_AUTO . 1)
            (GIT_PROXY_NONE . 0)
            (GIT_REMOTE_COMPLETION_ERROR . 2)
            (GIT_REMOTE_COMPLETION_INDEXING . 1)
            (GIT_REMOTE_COMPLETION_DOWNLOAD . 0)
            (GIT_FETCH_NO_PRUNE . 2)
            (GIT_FETCH_PRUNE . 1)
            (GIT_FETCH_PRUNE_UNSPECIFIED . 0)
            (GIT_REMOTE_DOWNLOAD_TAGS_ALL . 3)
            (GIT_REMOTE_DOWNLOAD_TAGS_NONE . 2)
            (GIT_REMOTE_DOWNLOAD_TAGS_AUTO . 1)
            (GIT_REMOTE_DOWNLOAD_TAGS_UNSPECIFIED . 0)
            (GIT_CLONE_LOCAL_NO_LINKS . 3)
            (GIT_CLONE_NO_LOCAL . 2)
            (GIT_CLONE_LOCAL . 1)
            (GIT_CLONE_LOCAL_AUTO . 0)
            (GIT_CONFIG_HIGHEST_LEVEL . -1)
            (GIT_CONFIG_LEVEL_APP . 6)
            (GIT_CONFIG_LEVEL_LOCAL . 5)
            (GIT_CONFIG_LEVEL_GLOBAL . 4)
            (GIT_CONFIG_LEVEL_XDG . 3)
            (GIT_CONFIG_LEVEL_SYSTEM . 2)
            (GIT_CONFIG_LEVEL_PROGRAMDATA . 1)
            (GIT_CVAR_STRING . 3)
            (GIT_CVAR_INT32 . 2)
            (GIT_CVAR_TRUE . 1)
            (GIT_CVAR_FALSE . 0)
            (GIT_DESCRIBE_ALL . 2)
            (GIT_DESCRIBE_TAGS . 1)
            (GIT_DESCRIBE_DEFAULT . 0)
            (GIT_EMISMATCH . -33)
            (GIT_RETRY . -32)
            (GIT_ITEROVER . -31)
            (GIT_PASSTHROUGH . -30)
            (GIT_EMERGECONFLICT . -24)
            (GIT_EDIRECTORY . -23)
            (GIT_EUNCOMMITTED . -22)
            (GIT_EINVALID . -21)
            (GIT_EEOF . -20)
            (GIT_EPEEL . -19)
            (GIT_EAPPLIED . -18)
            (GIT_ECERTIFICATE . -17)
            (GIT_EAUTH . -16)
            (GIT_EMODIFIED . -15)
            (GIT_ELOCKED . -14)
            (GIT_ECONFLICT . -13)
            (GIT_EINVALIDSPEC . -12)
            (GIT_ENONFASTFORWARD . -11)
            (GIT_EUNMERGED . -10)
            (GIT_EUNBORNBRANCH . -9)
            (GIT_EBAREREPO . -8)
            (GIT_EUSER . -7)
            (GIT_EBUFS . -6)
            (GIT_EAMBIGUOUS . -5)
            (GIT_EEXISTS . -4)
            (GIT_ENOTFOUND . -3)
            (GIT_ERROR . -1)
            (GIT_OK . 0)
            (GITERR_SHA1 . 33)
            (GITERR_WORKTREE . 32)
            (GITERR_PATCH . 31)
            (GITERR_FILESYSTEM . 30)
            (GITERR_REBASE . 29)
            (GITERR_DESCRIBE . 28)
            (GITERR_CHERRYPICK . 27)
            (GITERR_CALLBACK . 26)
            (GITERR_REVERT . 25)
            (GITERR_FILTER . 24)
            (GITERR_SSH . 23)
            (GITERR_MERGE . 22)
            (GITERR_FETCHHEAD . 21)
            (GITERR_CHECKOUT . 20)
            (GITERR_STASH . 19)
            (GITERR_THREAD . 18)
            (GITERR_SUBMODULE . 17)
            (GITERR_SSL . 16)
            (GITERR_INDEXER . 15)
            (GITERR_TREE . 14)
            (GITERR_TAG . 13)
            (GITERR_NET . 12)
            (GITERR_OBJECT . 11)
            (GITERR_INDEX . 10)
            (GITERR_ODB . 9)
            (GITERR_REGEX . 8)
            (GITERR_CONFIG . 7)
            (GITERR_REPOSITORY . 6)
            (GITERR_ZLIB . 5)
            (GITERR_REFERENCE . 4)
            (GITERR_INVALID . 3)
            (GITERR_OS . 2)
            (GITERR_NOMEMORY . 1)
            (GITERR_NONE . 0)
            (GIT_FILTER_CLEAN . 0)
            (GIT_FILTER_TO_ODB . 1)
            (GIT_FILTER_SMUDGE . 0)
            (GIT_FILTER_TO_WORKTREE . 0)
            (GIT_FILTER_ALLOW_UNSAFE . 1)
            (GIT_FILTER_DEFAULT . 0)
            (GIT_STREAM_RW . 0)
            (GIT_STREAM_WRONLY . 4)
            (GIT_STREAM_RDONLY . 2)
            (GIT_PATHSPEC_FAILURES_ONLY . 32)
            (GIT_PATHSPEC_FIND_FAILURES . 16)
            (GIT_PATHSPEC_NO_MATCH_ERROR . 8)
            (GIT_PATHSPEC_NO_GLOB . 4)
            (GIT_PATHSPEC_USE_CASE . 2)
            (GIT_PATHSPEC_IGNORE_CASE . 1)
            (GIT_PATHSPEC_DEFAULT . 0)
            (GIT_REBASE_OPERATION_EXEC . 5)
            (GIT_REBASE_OPERATION_FIXUP . 4)
            (GIT_REBASE_OPERATION_SQUASH . 3)
            (GIT_REBASE_OPERATION_EDIT . 2)
            (GIT_REBASE_OPERATION_REWORD . 1)
            (GIT_REBASE_OPERATION_PICK . 0)
            (GIT_RESET_HARD . 3)
            (GIT_RESET_MIXED . 2)
            (GIT_RESET_SOFT . 1)
            (GIT_REVPARSE_MERGE_BASE . 4)
            (GIT_REVPARSE_RANGE . 2)
            (GIT_REVPARSE_SINGLE . 1)
            (GIT_SORT_REVERSE . 4)
            (GIT_SORT_TIME . 2)
            (GIT_SORT_TOPOLOGICAL . 1)
            (GIT_SORT_NONE . 0)
            (GIT_STASH_INCLUDE_IGNORED . 4)
            (GIT_STASH_INCLUDE_UNTRACKED . 2)
            (GIT_STASH_KEEP_INDEX . 1)
            (GIT_STASH_DEFAULT . 0)
            (GIT_STASH_APPLY_REINSTATE_INDEX . 1)
            (GIT_STASH_APPLY_DEFAULT . 0)
            (GIT_STASH_APPLY_PROGRESS_DONE . 7)
            (GIT_STASH_APPLY_PROGRESS_CHECKOUT_MODIFIED . 6)
            (GIT_STASH_APPLY_PROGRESS_CHECKOUT_UNTRACKED . 5)
            (GIT_STASH_APPLY_PROGRESS_ANALYZE_UNTRACKED . 4)
            (GIT_STASH_APPLY_PROGRESS_ANALYZE_MODIFIED . 3)
            (GIT_STASH_APPLY_PROGRESS_ANALYZE_INDEX . 2)
            (GIT_STASH_APPLY_PROGRESS_LOADING_STASH . 1)
            (GIT_STASH_APPLY_PROGRESS_NONE . 0)
            (GIT_STATUS_CONFLICTED . 32768)
            (GIT_STATUS_IGNORED . 16384)
            (GIT_STATUS_WT_UNREADABLE . 4096)
            (GIT_STATUS_WT_RENAMED . 2048)
            (GIT_STATUS_WT_TYPECHANGE . 1024)
            (GIT_STATUS_WT_DELETED . 512)
            (GIT_STATUS_WT_MODIFIED . 256)
            (GIT_STATUS_WT_NEW . 128)
            (GIT_STATUS_INDEX_TYPECHANGE . 16)
            (GIT_STATUS_INDEX_RENAMED . 8)
            (GIT_STATUS_INDEX_DELETED . 4)
            (GIT_STATUS_INDEX_MODIFIED . 2)
            (GIT_STATUS_INDEX_NEW . 1)
            (GIT_STATUS_CURRENT . 0)
            (GIT_STATUS_SHOW_WORKDIR_ONLY . 2)
            (GIT_STATUS_SHOW_INDEX_ONLY . 1)
            (GIT_STATUS_SHOW_INDEX_AND_WORKDIR . 0)
            (GIT_STATUS_OPT_INCLUDE_UNREADABLE_AS_UNTRACKED
              .
              32768)
            (GIT_STATUS_OPT_INCLUDE_UNREADABLE . 16384)
            (GIT_STATUS_OPT_UPDATE_INDEX . 8192)
            (GIT_STATUS_OPT_NO_REFRESH . 4096)
            (GIT_STATUS_OPT_RENAMES_FROM_REWRITES . 2048)
            (GIT_STATUS_OPT_SORT_CASE_INSENSITIVELY . 1024)
            (GIT_STATUS_OPT_SORT_CASE_SENSITIVELY . 512)
            (GIT_STATUS_OPT_RENAMES_INDEX_TO_WORKDIR . 256)
            (GIT_STATUS_OPT_RENAMES_HEAD_TO_INDEX . 128)
            (GIT_STATUS_OPT_RECURSE_IGNORED_DIRS . 64)
            (GIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH . 32)
            (GIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS . 16)
            (GIT_STATUS_OPT_EXCLUDE_SUBMODULES . 8)
            (GIT_STATUS_OPT_INCLUDE_UNMODIFIED . 4)
            (GIT_STATUS_OPT_INCLUDE_IGNORED . 2)
            (GIT_STATUS_OPT_INCLUDE_UNTRACKED . 1)
            (GIT_SUBMODULE_STATUS_WD_UNTRACKED . 8192)
            (GIT_SUBMODULE_STATUS_WD_WD_MODIFIED . 4096)
            (GIT_SUBMODULE_STATUS_WD_INDEX_MODIFIED . 2048)
            (GIT_SUBMODULE_STATUS_WD_MODIFIED . 1024)
            (GIT_SUBMODULE_STATUS_WD_DELETED . 512)
            (GIT_SUBMODULE_STATUS_WD_ADDED . 256)
            (GIT_SUBMODULE_STATUS_WD_UNINITIALIZED . 128)
            (GIT_SUBMODULE_STATUS_INDEX_MODIFIED . 64)
            (GIT_SUBMODULE_STATUS_INDEX_DELETED . 32)
            (GIT_SUBMODULE_STATUS_INDEX_ADDED . 16)
            (GIT_SUBMODULE_STATUS_IN_WD . 8)
            (GIT_SUBMODULE_STATUS_IN_CONFIG . 4)
            (GIT_SUBMODULE_STATUS_IN_INDEX . 2)
            (GIT_SUBMODULE_STATUS_IN_HEAD . 1)
            (GIT_ATTR_CHECK_FILE_THEN_INDEX . 0)
            (GIT_ATTR_CHECK_INDEX_THEN_FILE . 1)
            (GIT_ATTR_CHECK_INDEX_ONLY . 2)
            (GIT_BLAME_OPTIONS_VERSION . 1)
            (GIT_CHECKOUT_OPTIONS_VERSION . 1)
            (GIT_CHERRYPICK_OPTIONS_VERSION . 1)
            (GIT_CLONE_OPTIONS_VERSION . 1)
            (GIT_DESCRIBE_DEFAULT_MAX_CANDIDATES_TAGS . 10)
            (GIT_DESCRIBE_DEFAULT_ABBREVIATED_SIZE . 7)
            (GIT_DESCRIBE_OPTIONS_VERSION . 1)
            (GIT_DESCRIBE_FORMAT_OPTIONS_VERSION . 1)
            (GIT_REBASE_OPTIONS_VERSION . 1)
            (GIT_REVERT_OPTIONS_VERSION . 1)
            (GIT_STASH_APPLY_OPTIONS_VERSION . 1)
            (GIT_STATUS_OPTIONS_VERSION . 1)
            (GIT_SUBMODULE_STATUS__IN_FLAGS . 15)
            (GIT_SUBMODULE_STATUS__INDEX_FLAGS . 112)
            (GIT_SUBMODULE_STATUS__WD_FLAGS . 16256)
            (GIT_SUBMODULE_UPDATE_OPTIONS_VERSION . 1)
            (LIBGIT2_VERSION . "0.26.0")
            (LIBGIT2_VER_MAJOR . 0)
            (LIBGIT2_VER_MINOR . 26)
            (LIBGIT2_VER_REVISION . 0)
            (LIBGIT2_VER_PATCH . 0)
            (LIBGIT2_SOVERSION . 26))))
    (lambda (k) (assq-ref sym-tab k))))
(export libgit2-symbol-val)

(define (unwrap-enum obj)
  (cond ((number? obj) obj)
        ((symbol? obj) (libgit2-symbol-val obj))
        ((fh-object? obj) (struct-ref obj 0))
        (else (error "type mismatch"))))

(define libgit2-types
  '("git_tag_foreach_cb" (struct . "git_submodule_update_options") 
    "git_submodule_update_options" "git_submodule_cb" "git_submodule_status_t"
    "git_status_entry" "git_status_options" "git_status_opt_t" 
    "git_status_show_t" "git_status_cb" "git_status_t" "git_stash_cb" (struct 
    . "git_stash_apply_options") "git_stash_apply_options" 
    "git_stash_apply_progress_cb" "git_stash_apply_progress_t" 
    "git_stash_apply_flags" "git_stash_flags" "git_revwalk_hide_cb" 
    "git_sort_t" "git_revspec" "git_revparse_mode_t" "git_revert_options" 
    "git_reset_t" "git_rebase_operation" "git_rebase_operation_t" 
    "git_rebase_options" "git_pathspec_flag_t" "git_pathspec_match_list" 
    "git_pathspec" "git_patch" (struct . "git_odb_writepack") (struct . 
    "git_odb_stream") "git_odb_stream_t" (struct . "git_odb_expand_id") 
    "git_odb_expand_id" "git_odb_foreach_cb" "git_note_iterator" 
    "git_note_foreach_cb" "git_filter_list" "git_filter" "git_filter_flag_t" 
    "git_filter_mode_t" "git_error_t" "git_error" "git_error_code" 
    "git_describe_result" "git_describe_format_options" (struct . 
    "git_describe_options") "git_describe_options" "git_describe_strategy_t" 
    "git_cvar_map" "git_cvar_t" "git_config_iterator" "git_config_foreach_cb" 
    (struct . "git_config_entry") "git_config_entry" "git_config_level_t" (
    struct . "git_clone_options") "git_clone_options" 
    "git_repository_create_cb" "git_remote_create_cb" "git_clone_local_t" 
    "git_cherrypick_options" (struct . "git_checkout_options") 
    "git_checkout_options" "git_checkout_perfdata_cb" 
    "git_checkout_progress_cb" "git_checkout_notify_cb" 
    "git_checkout_perfdata" "git_checkout_notify_t" "git_checkout_strategy_t" 
    "git_branch_iterator" "git_blame" (struct . "git_blame_hunk") 
    "git_blame_hunk" (struct . "git_blame_options") "git_blame_options" 
    "git_blame_flag_t" "git_attr_foreach_cb" "git_attr_t"))
(export libgit2-types)

;; --- last line ---
