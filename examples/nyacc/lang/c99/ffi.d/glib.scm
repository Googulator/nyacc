;; auto-generated by ffi-help.scm

(define-module (glib)
  #:use-module (system ffi-help-rt)
  #:use-module ((system foreign) #:prefix ffi:)
  #:use-module (bytestructures guile)
  )
(dynamic-link "libintl")
(dynamic-link "libglib-2.0")
(define void intptr_t)
(define echo-decls #f)

;; typedef char gchar;
(define gchar-desc int)
(export gchar-desc)
(define unwrap-gchar unwrap~fixed)
(define wrap-gchar identity)

;; typedef short gshort;
(define gshort-desc short)
(export gshort-desc)
(define unwrap-gshort unwrap~fixed)
(define wrap-gshort identity)

;; typedef long glong;
(define glong-desc long)
(export glong-desc)
(define unwrap-glong unwrap~fixed)
(define wrap-glong identity)

;; typedef int gint;
(define gint-desc int)
(export gint-desc)
(define unwrap-gint unwrap~fixed)
(define wrap-gint identity)

;; typedef gint gboolean;
(define unwrap-gboolean unwrap-gint)
(define wrap-gboolean wrap-gint)
(define gboolean-desc gint-desc)

;; typedef unsigned char guchar;
(define guchar-desc unsigned char-desc)
(export guchar-desc)
(define unwrap-guchar unwrap~fixed)
(define wrap-guchar identity)

;; typedef unsigned short gushort;
(define gushort-desc unsigned-short)
(export gushort-desc)
(define unwrap-gushort unwrap~fixed)
(define wrap-gushort identity)

;; typedef unsigned long gulong;
(define gulong-desc unsigned-long)
(export gulong-desc)
(define unwrap-gulong unwrap~fixed)
(define wrap-gulong identity)

;; typedef unsigned int guint;
(define guint-desc unsigned-int)
(export guint-desc)
(define unwrap-guint unwrap~fixed)
(define wrap-guint identity)

;; typedef float gfloat;
(define gfloat-desc float)
(define unwrap-gfloat unwrap~float)
(define wrap-gfloat identity)

;; typedef double gdouble;
(define gdouble-desc double)
(define unwrap-gdouble unwrap~float)
(define wrap-gdouble identity)

;; typedef void *gpointer;
(define gpointer-desc (bs:pointer void))
(export gpointer-desc)
(define-fh-pointer-type gpointer gpointer-desc

;; typedef const void *gconstpointer;
(define gconstpointer-desc (bs:pointer void))
(export gconstpointer-desc)
(define-fh-pointer-type gconstpointer gconstpointer-desc

;; typedef gint (*GCompareFunc)(gconstpointer a, gconstpointer b);
(define-fh-function/p GCompareFunc
  ffi:int (list (quote *) (quote *)))

;; typedef gint (*GCompareDataFunc)(gconstpointer a, gconstpointer b, gpointer 
;;     user_data);
(define-fh-function/p GCompareDataFunc
  ffi:int (list (quote *) (quote *) (quote *)))

;; typedef gboolean (*GEqualFunc)(gconstpointer a, gconstpointer b);
(define-fh-function/p GEqualFunc
  ffi:int (list (quote *) (quote *)))

;; typedef void (*GDestroyNotify)(gpointer data);
(define-fh-function/p GDestroyNotify
  ffi:void (list (quote *)))

;; typedef void (*GFunc)(gpointer data, gpointer user_data);
(define-fh-function/p GFunc
  ffi:void (list (quote *) (quote *)))

;; typedef guint (*GHashFunc)(gconstpointer key);
(define-fh-function/p GHashFunc
  ffi:unsigned-int (list (quote *)))

;; typedef void (*GHFunc)(gpointer key, gpointer value, gpointer user_data);
(define-fh-function/p GHFunc
  ffi:void (list (quote *) (quote *) (quote *)))

;; typedef void (*GFreeFunc)(gpointer data);
(define-fh-function/p GFreeFunc
  ffi:void (list (quote *)))

;; typedef const gchar *(*GTranslateFunc)(const gchar *str, gpointer data);
(define-fh-function/p
  GTranslateFunc
  '*
  (list '* '*))

;; typedef union _GDoubleIEEE754 GDoubleIEEE754;
;; union _GDoubleIEEE754 {
;;   gdouble v_double;
;;   struct {
;;     guint mantissa_low : 32;
;;     guint mantissa_high : 20;
;;     guint biased_exponent : 11;
;;     guint sign : 1;
;;   } mpn;
;; };
(define GDoubleIEEE754-desc
  (bs:union
    (list `(v_double ,gdouble-desc)
          `(mpn ,(bs:struct
                   (list `(mantissa_low ,guint-desc)
                         `(mantissa_high ,guint-desc)
                         `(biased_exponent ,guint-desc)
                         `(sign ,guint-desc)))))))
(export GDoubleIEEE754-desc)
(define-fh-compound-type/p GDoubleIEEE754 GDoubleIEEE754-desc)
(define union-_GDoubleIEEE754 GDoubleIEEE754)

;; typedef union _GFloatIEEE754 GFloatIEEE754;
;; union _GFloatIEEE754 {
;;   gfloat v_float;
;;   struct {
;;     guint mantissa : 23;
;;     guint biased_exponent : 8;
;;     guint sign : 1;
;;   } mpn;
;; };
(define GFloatIEEE754-desc
  (bs:union
    (list `(v_float ,gfloat-desc)
          `(mpn ,(bs:struct
                   (list `(mantissa ,guint-desc)
                         `(biased_exponent ,guint-desc)
                         `(sign ,guint-desc)))))))
(export GFloatIEEE754-desc)
(define-fh-compound-type/p GFloatIEEE754 GFloatIEEE754-desc)
(define union-_GFloatIEEE754 GFloatIEEE754)

;; typedef struct _GTimeVal GTimeVal;
(define GTimeVal-desc void)
(define GTimeVal*-desc (bs:pointer (delay GTimeVal-desc)))
(define-fh-pointer-type GTimeVal* GTimeVal*-desc)

;; struct _GTimeVal {
;;   glong tv_sec;
;;   glong tv_usec;
;; };
(define struct-_GTimeVal-desc
  (bs:struct
    (list `(tv_sec ,glong-desc)
          `(tv_usec ,glong-desc))))
(export struct-_GTimeVal-desc)
(define-fh-compound-type/p struct-_GTimeVal struct-_GTimeVal-desc)
(set! GTimeVal-desc struct-_GTimeVal-desc)
(define-fh-compound-type GTimeVal GTimeVal-desc)

;; typedef struct _GBytes GBytes;
(define GBytes-desc void)
(define GBytes*-desc (bs:pointer GBytes-desc))
(define-fh-pointer-type GBytes* GBytes*-desc)

;; typedef struct _GArray GArray;
(define GArray-desc void)
(define GArray*-desc (bs:pointer (delay GArray-desc)))
(define-fh-pointer-type GArray* GArray*-desc)

;; typedef struct _GByteArray GByteArray;
(define GByteArray-desc void)
(define GByteArray*-desc (bs:pointer (delay GByteArray-desc)))
(define-fh-pointer-type GByteArray* GByteArray*-desc)

;; typedef struct _GPtrArray GPtrArray;
(define GPtrArray-desc void)
(define GPtrArray*-desc (bs:pointer (delay GPtrArray-desc)))
(define-fh-pointer-type GPtrArray* GPtrArray*-desc)

;; struct _GArray {
;;   gchar *data;
;;   guint len;
;; };
(define struct-_GArray-desc
  (bs:struct
    (list `(data ,(bs:pointer gchar*-desc))
          `(len ,guint-desc))))
(export struct-_GArray-desc)
(define-fh-compound-type/p struct-_GArray struct-_GArray-desc)
(set! GArray-desc struct-_GArray-desc)
(define-fh-compound-type GArray GArray-desc)

;; struct _GByteArray {
;;   guint8 *data;
;;   guint len;
;; };
(define struct-_GByteArray-desc
  (bs:struct
    (list `(data ,(bs:pointer void))
          `(len ,guint-desc))))
(export struct-_GByteArray-desc)
(define-fh-compound-type/p struct-_GByteArray struct-_GByteArray-desc)
(set! GByteArray-desc struct-_GByteArray-desc)
(define-fh-compound-type GByteArray GByteArray-desc)

;; struct _GPtrArray {
;;   gpointer *pdata;
;;   guint len;
;; };
(define struct-_GPtrArray-desc
  (bs:struct
    (list `(pdata ,(bs:pointer gpointer*-desc))
          `(len ,guint-desc))))
(export struct-_GPtrArray-desc)
(define-fh-compound-type/p struct-_GPtrArray struct-_GPtrArray-desc)
(set! GPtrArray-desc struct-_GPtrArray-desc)
(define-fh-compound-type GPtrArray GPtrArray-desc)

;; extern GArray *g_array_new(gboolean zero_terminated, gboolean clear_, guint 
;;     element_size);
(define g_array_new
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_array_new" (dynamic-link))
              (list ffi:int ffi:int ffi:unsigned-int))))
    (lambda (zero_terminated clear_ element_size)
      (let ((~zero_terminated
              (unwrap-gboolean zero_terminated))
            (~clear_ (unwrap-gboolean clear_))
            (~element_size (unwrap-guint element_size)))
        (wrap-GArray*
          (~f ~zero_terminated ~clear_ ~element_size))))))
(export g_array_new)

;; extern GArray *g_array_sized_new(gboolean zero_terminated, gboolean clear_, 
;;     guint element_size, guint reserved_size);
(define g_array_sized_new
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_array_sized_new" (dynamic-link))
              (list ffi:int
                    ffi:int
                    ffi:unsigned-int
                    ffi:unsigned-int))))
    (lambda (zero_terminated
             clear_
             element_size
             reserved_size)
      (let ((~zero_terminated
              (unwrap-gboolean zero_terminated))
            (~clear_ (unwrap-gboolean clear_))
            (~element_size (unwrap-guint element_size))
            (~reserved_size (unwrap-guint reserved_size)))
        (wrap-GArray*
          (~f ~zero_terminated
              ~clear_
              ~element_size
              ~reserved_size))))))
(export g_array_sized_new)

;; extern gchar *g_array_free(GArray *array, gboolean free_segment);
(define g_array_free
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_array_free" (dynamic-link))
              (list '* ffi:int))))
    (lambda (array free_segment)
      (let ((~array (unwrap-GArray* array))
            (~free_segment (unwrap-gboolean free_segment)))
        (wrap-gchar* (~f ~array ~free_segment))))))
(export g_array_free)

;; extern GArray *g_array_ref(GArray *array);
(define g_array_ref
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_array_ref" (dynamic-link))
              (list '*))))
    (lambda (array)
      (let ((~array (unwrap-GArray* array)))
        (wrap-GArray* (~f ~array))))))
(export g_array_ref)

;; extern void g_array_unref(GArray *array);
(define g_array_unref
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_array_unref" (dynamic-link))
              (list '*))))
    (lambda (array)
      (let ((~array (unwrap-GArray* array)))
        (~f ~array)))))
(export g_array_unref)

;; extern guint g_array_get_element_size(GArray *array);
(define g_array_get_element_size
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func
                "g_array_get_element_size"
                (dynamic-link))
              (list '*))))
    (lambda (array)
      (let ((~array (unwrap-GArray* array)))
        (wrap-guint (~f ~array))))))
(export g_array_get_element_size)

;; extern GArray *g_array_append_vals(GArray *array, gconstpointer data, guint 
;;     len);
(define g_array_append_vals
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_array_append_vals"
                (dynamic-link))
              (list '* '* ffi:unsigned-int))))
    (lambda (array data len)
      (let ((~array (unwrap-GArray* array))
            (~data (unwrap-gconstpointer data))
            (~len (unwrap-guint len)))
        (wrap-GArray* (~f ~array ~data ~len))))))
(export g_array_append_vals)

;; extern GArray *g_array_prepend_vals(GArray *array, gconstpointer data, guint
;;      len);
(define g_array_prepend_vals
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_array_prepend_vals"
                (dynamic-link))
              (list '* '* ffi:unsigned-int))))
    (lambda (array data len)
      (let ((~array (unwrap-GArray* array))
            (~data (unwrap-gconstpointer data))
            (~len (unwrap-guint len)))
        (wrap-GArray* (~f ~array ~data ~len))))))
(export g_array_prepend_vals)

;; extern GArray *g_array_insert_vals(GArray *array, guint index_, 
;;     gconstpointer data, guint len);
(define g_array_insert_vals
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_array_insert_vals"
                (dynamic-link))
              (list '* ffi:unsigned-int '* ffi:unsigned-int))))
    (lambda (array index_ data len)
      (let ((~array (unwrap-GArray* array))
            (~index_ (unwrap-guint index_))
            (~data (unwrap-gconstpointer data))
            (~len (unwrap-guint len)))
        (wrap-GArray* (~f ~array ~index_ ~data ~len))))))
(export g_array_insert_vals)

;; extern GArray *g_array_set_size(GArray *array, guint length);
(define g_array_set_size
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_array_set_size" (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (array length)
      (let ((~array (unwrap-GArray* array))
            (~length (unwrap-guint length)))
        (wrap-GArray* (~f ~array ~length))))))
(export g_array_set_size)

;; extern GArray *g_array_remove_index(GArray *array, guint index_);
(define g_array_remove_index
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_array_remove_index"
                (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (array index_)
      (let ((~array (unwrap-GArray* array))
            (~index_ (unwrap-guint index_)))
        (wrap-GArray* (~f ~array ~index_))))))
(export g_array_remove_index)

;; extern GArray *g_array_remove_index_fast(GArray *array, guint index_);
(define g_array_remove_index_fast
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_array_remove_index_fast"
                (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (array index_)
      (let ((~array (unwrap-GArray* array))
            (~index_ (unwrap-guint index_)))
        (wrap-GArray* (~f ~array ~index_))))))
(export g_array_remove_index_fast)

;; extern GArray *g_array_remove_range(GArray *array, guint index_, guint 
;;     length);
(define g_array_remove_range
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_array_remove_range"
                (dynamic-link))
              (list '* ffi:unsigned-int ffi:unsigned-int))))
    (lambda (array index_ length)
      (let ((~array (unwrap-GArray* array))
            (~index_ (unwrap-guint index_))
            (~length (unwrap-guint length)))
        (wrap-GArray* (~f ~array ~index_ ~length))))))
(export g_array_remove_range)

;; extern void g_array_sort(GArray *array, GCompareFunc compare_func);
;; ... failed.

;; extern void g_array_sort_with_data(GArray *array, GCompareDataFunc 
;;     compare_func, gpointer user_data);
;; ... failed.

;; extern void g_array_set_clear_func(GArray *array, GDestroyNotify clear_func)
;;     ;
(define g_array_set_clear_func
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_array_set_clear_func"
                (dynamic-link))
              (list '* '*))))
    (lambda (array clear_func)
      (let ((~array (unwrap-GArray* array))
            (~clear_func
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               clear_func)))
        (~f ~array ~clear_func)))))
(export g_array_set_clear_func)

;; extern GPtrArray *g_ptr_array_new(void);
(define g_ptr_array_new
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_ptr_array_new" (dynamic-link))
              (list))))
    (lambda () (let () (wrap-GPtrArray* (~f))))))
(export g_ptr_array_new)

;; extern GPtrArray *g_ptr_array_new_with_free_func(GDestroyNotify 
;;     element_free_func);
(define g_ptr_array_new_with_free_func
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_ptr_array_new_with_free_func"
                (dynamic-link))
              (list '*))))
    (lambda (element_free_func)
      (let ((~element_free_func
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               element_free_func)))
        (wrap-GPtrArray* (~f ~element_free_func))))))
(export g_ptr_array_new_with_free_func)

;; extern GPtrArray *g_ptr_array_sized_new(guint reserved_size);
(define g_ptr_array_sized_new
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_ptr_array_sized_new"
                (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (reserved_size)
      (let ((~reserved_size (unwrap-guint reserved_size)))
        (wrap-GPtrArray* (~f ~reserved_size))))))
(export g_ptr_array_sized_new)

;; extern GPtrArray *g_ptr_array_new_full(guint reserved_size, GDestroyNotify 
;;     element_free_func);
(define g_ptr_array_new_full
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_ptr_array_new_full"
                (dynamic-link))
              (list ffi:unsigned-int '*))))
    (lambda (reserved_size element_free_func)
      (let ((~reserved_size (unwrap-guint reserved_size))
            (~element_free_func
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               element_free_func)))
        (wrap-GPtrArray*
          (~f ~reserved_size ~element_free_func))))))
(export g_ptr_array_new_full)

;; extern gpointer *g_ptr_array_free(GPtrArray *array, gboolean free_seg);
(define g_ptr_array_free
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_ptr_array_free" (dynamic-link))
              (list '* ffi:int))))
    (lambda (array free_seg)
      (let ((~array (unwrap-GPtrArray* array))
            (~free_seg (unwrap-gboolean free_seg)))
        (wrap-gpointer* (~f ~array ~free_seg))))))
(export g_ptr_array_free)

;; extern GPtrArray *g_ptr_array_ref(GPtrArray *array);
(define g_ptr_array_ref
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_ptr_array_ref" (dynamic-link))
              (list '*))))
    (lambda (array)
      (let ((~array (unwrap-GPtrArray* array)))
        (wrap-GPtrArray* (~f ~array))))))
(export g_ptr_array_ref)

;; extern void g_ptr_array_unref(GPtrArray *array);
(define g_ptr_array_unref
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_ptr_array_unref" (dynamic-link))
              (list '*))))
    (lambda (array)
      (let ((~array (unwrap-GPtrArray* array)))
        (~f ~array)))))
(export g_ptr_array_unref)

;; extern void g_ptr_array_set_free_func(GPtrArray *array, GDestroyNotify 
;;     element_free_func);
(define g_ptr_array_set_free_func
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_ptr_array_set_free_func"
                (dynamic-link))
              (list '* '*))))
    (lambda (array element_free_func)
      (let ((~array (unwrap-GPtrArray* array))
            (~element_free_func
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               element_free_func)))
        (~f ~array ~element_free_func)))))
(export g_ptr_array_set_free_func)

;; extern void g_ptr_array_set_size(GPtrArray *array, gint length);
(define g_ptr_array_set_size
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_ptr_array_set_size"
                (dynamic-link))
              (list '* ffi:int))))
    (lambda (array length)
      (let ((~array (unwrap-GPtrArray* array))
            (~length (unwrap-gint length)))
        (~f ~array ~length)))))
(export g_ptr_array_set_size)

;; extern gpointer g_ptr_array_remove_index(GPtrArray *array, guint index_);
(define g_ptr_array_remove_index
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_ptr_array_remove_index"
                (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (array index_)
      (let ((~array (unwrap-GPtrArray* array))
            (~index_ (unwrap-guint index_)))
        (wrap-gpointer (~f ~array ~index_))))))
(export g_ptr_array_remove_index)

;; extern gpointer g_ptr_array_remove_index_fast(GPtrArray *array, guint index_
;;     );
(define g_ptr_array_remove_index_fast
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_ptr_array_remove_index_fast"
                (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (array index_)
      (let ((~array (unwrap-GPtrArray* array))
            (~index_ (unwrap-guint index_)))
        (wrap-gpointer (~f ~array ~index_))))))
(export g_ptr_array_remove_index_fast)

;; extern gboolean g_ptr_array_remove(GPtrArray *array, gpointer data);
(define g_ptr_array_remove
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_ptr_array_remove"
                (dynamic-link))
              (list '* '*))))
    (lambda (array data)
      (let ((~array (unwrap-GPtrArray* array))
            (~data (unwrap-gpointer data)))
        (wrap-gboolean (~f ~array ~data))))))
(export g_ptr_array_remove)

;; extern gboolean g_ptr_array_remove_fast(GPtrArray *array, gpointer data);
(define g_ptr_array_remove_fast
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_ptr_array_remove_fast"
                (dynamic-link))
              (list '* '*))))
    (lambda (array data)
      (let ((~array (unwrap-GPtrArray* array))
            (~data (unwrap-gpointer data)))
        (wrap-gboolean (~f ~array ~data))))))
(export g_ptr_array_remove_fast)

;; extern GPtrArray *g_ptr_array_remove_range(GPtrArray *array, guint index_, 
;;     guint length);
(define g_ptr_array_remove_range
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_ptr_array_remove_range"
                (dynamic-link))
              (list '* ffi:unsigned-int ffi:unsigned-int))))
    (lambda (array index_ length)
      (let ((~array (unwrap-GPtrArray* array))
            (~index_ (unwrap-guint index_))
            (~length (unwrap-guint length)))
        (wrap-GPtrArray* (~f ~array ~index_ ~length))))))
(export g_ptr_array_remove_range)

;; extern void g_ptr_array_add(GPtrArray *array, gpointer data);
(define g_ptr_array_add
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_ptr_array_add" (dynamic-link))
              (list '* '*))))
    (lambda (array data)
      (let ((~array (unwrap-GPtrArray* array))
            (~data (unwrap-gpointer data)))
        (~f ~array ~data)))))
(export g_ptr_array_add)

;; extern void g_ptr_array_insert(GPtrArray *array, gint index_, gpointer data)
;;     ;
(define g_ptr_array_insert
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_ptr_array_insert"
                (dynamic-link))
              (list '* ffi:int '*))))
    (lambda (array index_ data)
      (let ((~array (unwrap-GPtrArray* array))
            (~index_ (unwrap-gint index_))
            (~data (unwrap-gpointer data)))
        (~f ~array ~index_ ~data)))))
(export g_ptr_array_insert)

;; extern void g_ptr_array_sort(GPtrArray *array, GCompareFunc compare_func);
;; ... failed.

;; extern void g_ptr_array_sort_with_data(GPtrArray *array, GCompareDataFunc 
;;     compare_func, gpointer user_data);
;; ... failed.

;; extern void g_ptr_array_foreach(GPtrArray *array, GFunc func, gpointer 
;;     user_data);
(define g_ptr_array_foreach
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_ptr_array_foreach"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (array func user_data)
      (let ((~array (unwrap-GPtrArray* array))
            (~func ((make-ftn-arg-unwrapper ffi:void (list '* '*))
                    func))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~array ~func ~user_data)))))
(export g_ptr_array_foreach)

;; extern GByteArray *g_byte_array_new(void);
(define g_byte_array_new
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_byte_array_new" (dynamic-link))
              (list))))
    (lambda () (let () (wrap-GByteArray* (~f))))))
(export g_byte_array_new)

;; extern GByteArray *g_byte_array_new_take(guint8 *data, gsize len);
(define g_byte_array_new_take
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_byte_array_new_take"
                (dynamic-link))
              (list '* ffi:unsigned-long))))
    (lambda (data len)
      (let ((~data (unwrap~pointer data))
            (~len (unwrap~fixed len)))
        (wrap-GByteArray* (~f ~data ~len))))))
(export g_byte_array_new_take)

;; extern GByteArray *g_byte_array_sized_new(guint reserved_size);
(define g_byte_array_sized_new
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_byte_array_sized_new"
                (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (reserved_size)
      (let ((~reserved_size (unwrap-guint reserved_size)))
        (wrap-GByteArray* (~f ~reserved_size))))))
(export g_byte_array_sized_new)

;; extern guint8 *g_byte_array_free(GByteArray *array, gboolean free_segment);
(define g_byte_array_free
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_byte_array_free" (dynamic-link))
              (list '* ffi:int))))
    (lambda (array free_segment)
      (let ((~array (unwrap-GByteArray* array))
            (~free_segment (unwrap-gboolean free_segment)))
        (~f ~array ~free_segment)))))
(export g_byte_array_free)

;; extern GBytes *g_byte_array_free_to_bytes(GByteArray *array);
(define g_byte_array_free_to_bytes
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_byte_array_free_to_bytes"
                (dynamic-link))
              (list '*))))
    (lambda (array)
      (let ((~array (unwrap-GByteArray* array)))
        (wrap-GBytes* (~f ~array))))))
(export g_byte_array_free_to_bytes)

;; extern GByteArray *g_byte_array_ref(GByteArray *array);
(define g_byte_array_ref
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_byte_array_ref" (dynamic-link))
              (list '*))))
    (lambda (array)
      (let ((~array (unwrap-GByteArray* array)))
        (wrap-GByteArray* (~f ~array))))))
(export g_byte_array_ref)

;; extern void g_byte_array_unref(GByteArray *array);
(define g_byte_array_unref
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_byte_array_unref"
                (dynamic-link))
              (list '*))))
    (lambda (array)
      (let ((~array (unwrap-GByteArray* array)))
        (~f ~array)))))
(export g_byte_array_unref)

;; extern GByteArray *g_byte_array_append(GByteArray *array, const guint8 *data
;;     , guint len);
(define g_byte_array_append
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_byte_array_append"
                (dynamic-link))
              (list '* '* ffi:unsigned-int))))
    (lambda (array data len)
      (let ((~array (unwrap-GByteArray* array))
            (~data (unwrap~pointer data))
            (~len (unwrap-guint len)))
        (wrap-GByteArray* (~f ~array ~data ~len))))))
(export g_byte_array_append)

;; extern GByteArray *g_byte_array_prepend(GByteArray *array, const guint8 *
;;     data, guint len);
(define g_byte_array_prepend
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_byte_array_prepend"
                (dynamic-link))
              (list '* '* ffi:unsigned-int))))
    (lambda (array data len)
      (let ((~array (unwrap-GByteArray* array))
            (~data (unwrap~pointer data))
            (~len (unwrap-guint len)))
        (wrap-GByteArray* (~f ~array ~data ~len))))))
(export g_byte_array_prepend)

;; extern GByteArray *g_byte_array_set_size(GByteArray *array, guint length);
(define g_byte_array_set_size
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_byte_array_set_size"
                (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (array length)
      (let ((~array (unwrap-GByteArray* array))
            (~length (unwrap-guint length)))
        (wrap-GByteArray* (~f ~array ~length))))))
(export g_byte_array_set_size)

;; extern GByteArray *g_byte_array_remove_index(GByteArray *array, guint index_
;;     );
(define g_byte_array_remove_index
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_byte_array_remove_index"
                (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (array index_)
      (let ((~array (unwrap-GByteArray* array))
            (~index_ (unwrap-guint index_)))
        (wrap-GByteArray* (~f ~array ~index_))))))
(export g_byte_array_remove_index)

;; extern GByteArray *g_byte_array_remove_index_fast(GByteArray *array, guint 
;;     index_);
(define g_byte_array_remove_index_fast
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_byte_array_remove_index_fast"
                (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (array index_)
      (let ((~array (unwrap-GByteArray* array))
            (~index_ (unwrap-guint index_)))
        (wrap-GByteArray* (~f ~array ~index_))))))
(export g_byte_array_remove_index_fast)

;; extern GByteArray *g_byte_array_remove_range(GByteArray *array, guint index_
;;     , guint length);
(define g_byte_array_remove_range
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_byte_array_remove_range"
                (dynamic-link))
              (list '* ffi:unsigned-int ffi:unsigned-int))))
    (lambda (array index_ length)
      (let ((~array (unwrap-GByteArray* array))
            (~index_ (unwrap-guint index_))
            (~length (unwrap-guint length)))
        (wrap-GByteArray* (~f ~array ~index_ ~length))))))
(export g_byte_array_remove_range)

;; extern void g_byte_array_sort(GByteArray *array, GCompareFunc compare_func)
;;     ;
;; ... failed.

;; extern void g_byte_array_sort_with_data(GByteArray *array, GCompareDataFunc 
;;     compare_func, gpointer user_data);
;; ... failed.

;; extern gint g_atomic_int_get(const volatile gint *atomic);
(define g_atomic_int_get
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_atomic_int_get" (dynamic-link))
              (list '*))))
    (lambda (atomic)
      (let ((~atomic (unwrap-gint* atomic)))
        (wrap-gint (~f ~atomic))))))
(export g_atomic_int_get)

;; extern void g_atomic_int_set(volatile gint *atomic, gint newval);
(define g_atomic_int_set
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_atomic_int_set" (dynamic-link))
              (list '* ffi:int))))
    (lambda (atomic newval)
      (let ((~atomic (unwrap-gint* atomic))
            (~newval (unwrap-gint newval)))
        (~f ~atomic ~newval)))))
(export g_atomic_int_set)

;; extern void g_atomic_int_inc(volatile gint *atomic);
(define g_atomic_int_inc
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_atomic_int_inc" (dynamic-link))
              (list '*))))
    (lambda (atomic)
      (let ((~atomic (unwrap-gint* atomic)))
        (~f ~atomic)))))
(export g_atomic_int_inc)

;; extern gboolean g_atomic_int_dec_and_test(volatile gint *atomic);
(define g_atomic_int_dec_and_test
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_atomic_int_dec_and_test"
                (dynamic-link))
              (list '*))))
    (lambda (atomic)
      (let ((~atomic (unwrap-gint* atomic)))
        (wrap-gboolean (~f ~atomic))))))
(export g_atomic_int_dec_and_test)

;; extern gboolean g_atomic_int_compare_and_exchange(volatile gint *atomic, 
;;     gint oldval, gint newval);
(define g_atomic_int_compare_and_exchange
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_atomic_int_compare_and_exchange"
                (dynamic-link))
              (list '* ffi:int ffi:int))))
    (lambda (atomic oldval newval)
      (let ((~atomic (unwrap-gint* atomic))
            (~oldval (unwrap-gint oldval))
            (~newval (unwrap-gint newval)))
        (wrap-gboolean (~f ~atomic ~oldval ~newval))))))
(export g_atomic_int_compare_and_exchange)

;; extern gint g_atomic_int_add(volatile gint *atomic, gint val);
(define g_atomic_int_add
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_atomic_int_add" (dynamic-link))
              (list '* ffi:int))))
    (lambda (atomic val)
      (let ((~atomic (unwrap-gint* atomic))
            (~val (unwrap-gint val)))
        (wrap-gint (~f ~atomic ~val))))))
(export g_atomic_int_add)

;; extern guint g_atomic_int_and(volatile guint *atomic, guint val);
(define g_atomic_int_and
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func "g_atomic_int_and" (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (atomic val)
      (let ((~atomic (unwrap-guint* atomic))
            (~val (unwrap-guint val)))
        (wrap-guint (~f ~atomic ~val))))))
(export g_atomic_int_and)

;; extern guint g_atomic_int_or(volatile guint *atomic, guint val);
(define g_atomic_int_or
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func "g_atomic_int_or" (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (atomic val)
      (let ((~atomic (unwrap-guint* atomic))
            (~val (unwrap-guint val)))
        (wrap-guint (~f ~atomic ~val))))))
(export g_atomic_int_or)

;; extern guint g_atomic_int_xor(volatile guint *atomic, guint val);
(define g_atomic_int_xor
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func "g_atomic_int_xor" (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (atomic val)
      (let ((~atomic (unwrap-guint* atomic))
            (~val (unwrap-guint val)))
        (wrap-guint (~f ~atomic ~val))))))
(export g_atomic_int_xor)

;; extern gpointer g_atomic_pointer_get(const volatile void *atomic);
(define g_atomic_pointer_get
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_atomic_pointer_get"
                (dynamic-link))
              (list '*))))
    (lambda (atomic)
      (let ((~atomic (unwrap~pointer atomic)))
        (wrap-gpointer (~f ~atomic))))))
(export g_atomic_pointer_get)

;; extern void g_atomic_pointer_set(volatile void *atomic, gpointer newval);
(define g_atomic_pointer_set
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_atomic_pointer_set"
                (dynamic-link))
              (list '* '*))))
    (lambda (atomic newval)
      (let ((~atomic (unwrap~pointer atomic))
            (~newval (unwrap-gpointer newval)))
        (~f ~atomic ~newval)))))
(export g_atomic_pointer_set)

;; extern gboolean g_atomic_pointer_compare_and_exchange(volatile void *atomic
;;     , gpointer oldval, gpointer newval);
(define g_atomic_pointer_compare_and_exchange
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_atomic_pointer_compare_and_exchange"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (atomic oldval newval)
      (let ((~atomic (unwrap~pointer atomic))
            (~oldval (unwrap-gpointer oldval))
            (~newval (unwrap-gpointer newval)))
        (wrap-gboolean (~f ~atomic ~oldval ~newval))))))
(export g_atomic_pointer_compare_and_exchange)

;; extern gssize g_atomic_pointer_add(volatile void *atomic, gssize val);
;; ... failed.

;; extern gsize g_atomic_pointer_and(volatile void *atomic, gsize val);
(define g_atomic_pointer_and
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-long
              (dynamic-func
                "g_atomic_pointer_and"
                (dynamic-link))
              (list '* ffi:unsigned-long))))
    (lambda (atomic val)
      (let ((~atomic (unwrap~pointer atomic))
            (~val (unwrap~fixed val)))
        (~f ~atomic ~val)))))
(export g_atomic_pointer_and)

;; extern gsize g_atomic_pointer_or(volatile void *atomic, gsize val);
(define g_atomic_pointer_or
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-long
              (dynamic-func
                "g_atomic_pointer_or"
                (dynamic-link))
              (list '* ffi:unsigned-long))))
    (lambda (atomic val)
      (let ((~atomic (unwrap~pointer atomic))
            (~val (unwrap~fixed val)))
        (~f ~atomic ~val)))))
(export g_atomic_pointer_or)

;; extern gsize g_atomic_pointer_xor(volatile void *atomic, gsize val);
(define g_atomic_pointer_xor
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-long
              (dynamic-func
                "g_atomic_pointer_xor"
                (dynamic-link))
              (list '* ffi:unsigned-long))))
    (lambda (atomic val)
      (let ((~atomic (unwrap~pointer atomic))
            (~val (unwrap~fixed val)))
        (~f ~atomic ~val)))))
(export g_atomic_pointer_xor)

;; extern gint g_atomic_int_exchange_and_add(volatile gint *atomic, gint val);
(define g_atomic_int_exchange_and_add
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_atomic_int_exchange_and_add"
                (dynamic-link))
              (list '* ffi:int))))
    (lambda (atomic val)
      (let ((~atomic (unwrap-gint* atomic))
            (~val (unwrap-gint val)))
        (wrap-gint (~f ~atomic ~val))))))
(export g_atomic_int_exchange_and_add)

;; typedef guint32 GQuark;
(define GQuark-desc unsigned-int)
(export GQuark-desc)
(define unwrap-GQuark unwrap~fixed)
(define wrap-GQuark identity)

;; extern GQuark g_quark_try_string(const gchar *string);
(define g_quark_try_string
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func
                "g_quark_try_string"
                (dynamic-link))
              (list '*))))
    (lambda (string)
      (let ((~string (unwrap-gchar* string)))
        (wrap-GQuark (~f ~string))))))
(export g_quark_try_string)

;; extern GQuark g_quark_from_static_string(const gchar *string);
(define g_quark_from_static_string
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func
                "g_quark_from_static_string"
                (dynamic-link))
              (list '*))))
    (lambda (string)
      (let ((~string (unwrap-gchar* string)))
        (wrap-GQuark (~f ~string))))))
(export g_quark_from_static_string)

;; extern GQuark g_quark_from_string(const gchar *string);
(define g_quark_from_string
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func
                "g_quark_from_string"
                (dynamic-link))
              (list '*))))
    (lambda (string)
      (let ((~string (unwrap-gchar* string)))
        (wrap-GQuark (~f ~string))))))
(export g_quark_from_string)

;; extern const gchar *g_quark_to_string(GQuark quark);
(define g_quark_to_string
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_quark_to_string" (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (quark)
      (let ((~quark (unwrap-GQuark quark)))
        (wrap-gchar* (~f ~quark))))))
(export g_quark_to_string)

;; extern const gchar *g_intern_string(const gchar *string);
(define g_intern_string
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_intern_string" (dynamic-link))
              (list '*))))
    (lambda (string)
      (let ((~string (unwrap-gchar* string)))
        (wrap-gchar* (~f ~string))))))
(export g_intern_string)

;; extern const gchar *g_intern_static_string(const gchar *string);
(define g_intern_static_string
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_intern_static_string"
                (dynamic-link))
              (list '*))))
    (lambda (string)
      (let ((~string (unwrap-gchar* string)))
        (wrap-gchar* (~f ~string))))))
(export g_intern_static_string)

;; typedef struct _GError GError;
(define GError-desc void)
(define GError*-desc (bs:pointer (delay GError-desc)))
(define-fh-pointer-type GError* GError*-desc)

;; struct _GError {
;;   GQuark domain;
;;   gint code;
;;   gchar *message;
;; };
(define struct-_GError-desc
  (bs:struct
    (list `(domain ,GQuark-desc)
          `(code ,gint-desc)
          `(message ,(bs:pointer gchar*-desc)))))
(export struct-_GError-desc)
(define-fh-compound-type/p struct-_GError struct-_GError-desc)
(set! GError-desc struct-_GError-desc)
(define-fh-compound-type GError GError-desc)

;; extern GError *g_error_new(GQuark domain, gint code, const gchar *format, 
;;     ...);
;; ... failed.

;; extern GError *g_error_new_literal(GQuark domain, gint code, const gchar *
;;     message);
(define g_error_new_literal
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_error_new_literal"
                (dynamic-link))
              (list ffi:unsigned-int ffi:int '*))))
    (lambda (domain code message)
      (let ((~domain (unwrap-GQuark domain))
            (~code (unwrap-gint code))
            (~message (unwrap-gchar* message)))
        (wrap-GError* (~f ~domain ~code ~message))))))
(export g_error_new_literal)

;; extern GError *g_error_new_valist(GQuark domain, gint code, const gchar *
;;     format, va_list args);
(define g_error_new_valist
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_error_new_valist"
                (dynamic-link))
              (list ffi:unsigned-int ffi:int '* '*))))
    (lambda (domain code format args)
      (let ((~domain (unwrap-GQuark domain))
            (~code (unwrap-gint code))
            (~format (unwrap-gchar* format))
            (~args (unwrap~pointer args)))
        (wrap-GError* (~f ~domain ~code ~format ~args))))))
(export g_error_new_valist)

;; extern void g_error_free(GError *error);
(define g_error_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_error_free" (dynamic-link))
              (list '*))))
    (lambda (error)
      (let ((~error (unwrap-GError* error)))
        (~f ~error)))))
(export g_error_free)

;; extern GError *g_error_copy(const GError *error);
(define g_error_copy
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_error_copy" (dynamic-link))
              (list '*))))
    (lambda (error)
      (let ((~error (unwrap-GError* error)))
        (wrap-GError* (~f ~error))))))
(export g_error_copy)

;; extern gboolean g_error_matches(const GError *error, GQuark domain, gint 
;;     code);
(define g_error_matches
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_error_matches" (dynamic-link))
              (list '* ffi:unsigned-int ffi:int))))
    (lambda (error domain code)
      (let ((~error (unwrap-GError* error))
            (~domain (unwrap-GQuark domain))
            (~code (unwrap-gint code)))
        (wrap-gboolean (~f ~error ~domain ~code))))))
(export g_error_matches)

;; extern void g_set_error(GError **err, GQuark domain, gint code, const gchar 
;;     *format, ...);
;; ... failed.

;; extern void g_set_error_literal(GError **err, GQuark domain, gint code, 
;;     const gchar *message);
(define g_set_error_literal
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_set_error_literal"
                (dynamic-link))
              (list '* ffi:unsigned-int ffi:int '*))))
    (lambda (err domain code message)
      (let ((~err (unwrap~pointer err))
            (~domain (unwrap-GQuark domain))
            (~code (unwrap-gint code))
            (~message (unwrap-gchar* message)))
        (~f ~err ~domain ~code ~message)))))
(export g_set_error_literal)

;; extern void g_propagate_error(GError **dest, GError *src);
(define g_propagate_error
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_propagate_error" (dynamic-link))
              (list '* '*))))
    (lambda (dest src)
      (let ((~dest (unwrap~pointer dest))
            (~src (unwrap-GError* src)))
        (~f ~dest ~src)))))
(export g_propagate_error)

;; extern void g_clear_error(GError **err);
(define g_clear_error
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_clear_error" (dynamic-link))
              (list '*))))
    (lambda (err)
      (let ((~err (unwrap~pointer err))) (~f ~err)))))
(export g_clear_error)

;; extern void g_prefix_error(GError **err, const gchar *format, ...);
;; ... failed.

;; extern void g_propagate_prefixed_error(GError **dest, GError *src, const 
;;     gchar *format, ...);
;; ... failed.

;; extern const gchar *g_get_user_name(void);
(define g_get_user_name
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_get_user_name" (dynamic-link))
              (list))))
    (lambda () (let () (wrap-gchar* (~f))))))
(export g_get_user_name)

;; extern const gchar *g_get_real_name(void);
(define g_get_real_name
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_get_real_name" (dynamic-link))
              (list))))
    (lambda () (let () (wrap-gchar* (~f))))))
(export g_get_real_name)

;; extern const gchar *g_get_home_dir(void);
(define g_get_home_dir
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_get_home_dir" (dynamic-link))
              (list))))
    (lambda () (let () (wrap-gchar* (~f))))))
(export g_get_home_dir)

;; extern const gchar *g_get_tmp_dir(void);
(define g_get_tmp_dir
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_get_tmp_dir" (dynamic-link))
              (list))))
    (lambda () (let () (wrap-gchar* (~f))))))
(export g_get_tmp_dir)

;; extern const gchar *g_get_host_name(void);
(define g_get_host_name
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_get_host_name" (dynamic-link))
              (list))))
    (lambda () (let () (wrap-gchar* (~f))))))
(export g_get_host_name)

;; extern const gchar *g_get_prgname(void);
(define g_get_prgname
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_get_prgname" (dynamic-link))
              (list))))
    (lambda () (let () (wrap-gchar* (~f))))))
(export g_get_prgname)

;; extern void g_set_prgname(const gchar *prgname);
(define g_set_prgname
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_set_prgname" (dynamic-link))
              (list '*))))
    (lambda (prgname)
      (let ((~prgname (unwrap-gchar* prgname)))
        (~f ~prgname)))))
(export g_set_prgname)

;; extern const gchar *g_get_application_name(void);
(define g_get_application_name
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_get_application_name"
                (dynamic-link))
              (list))))
    (lambda () (let () (wrap-gchar* (~f))))))
(export g_get_application_name)

;; extern void g_set_application_name(const gchar *application_name);
(define g_set_application_name
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_set_application_name"
                (dynamic-link))
              (list '*))))
    (lambda (application_name)
      (let ((~application_name
              (unwrap-gchar* application_name)))
        (~f ~application_name)))))
(export g_set_application_name)

;; extern void g_reload_user_special_dirs_cache(void);
(define g_reload_user_special_dirs_cache
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_reload_user_special_dirs_cache"
                (dynamic-link))
              (list))))
    (lambda () (let () (~f)))))
(export g_reload_user_special_dirs_cache)

;; extern const gchar *g_get_user_data_dir(void);
(define g_get_user_data_dir
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_get_user_data_dir"
                (dynamic-link))
              (list))))
    (lambda () (let () (wrap-gchar* (~f))))))
(export g_get_user_data_dir)

;; extern const gchar *g_get_user_config_dir(void);
(define g_get_user_config_dir
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_get_user_config_dir"
                (dynamic-link))
              (list))))
    (lambda () (let () (wrap-gchar* (~f))))))
(export g_get_user_config_dir)

;; extern const gchar *g_get_user_cache_dir(void);
(define g_get_user_cache_dir
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_get_user_cache_dir"
                (dynamic-link))
              (list))))
    (lambda () (let () (wrap-gchar* (~f))))))
(export g_get_user_cache_dir)

;; extern const gchar *const*g_get_system_data_dirs(void);
;; ... failed.

;; extern const gchar *const*g_get_system_config_dirs(void);
;; ... failed.

;; extern const gchar *g_get_user_runtime_dir(void);
(define g_get_user_runtime_dir
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_get_user_runtime_dir"
                (dynamic-link))
              (list))))
    (lambda () (let () (wrap-gchar* (~f))))))
(export g_get_user_runtime_dir)

;; typedef enum {
;;   G_USER_DIRECTORY_DESKTOP,
;;   G_USER_DIRECTORY_DOCUMENTS,
;;   G_USER_DIRECTORY_DOWNLOAD,
;;   G_USER_DIRECTORY_MUSIC,
;;   G_USER_DIRECTORY_PICTURES,
;;   G_USER_DIRECTORY_PUBLIC_SHARE,
;;   G_USER_DIRECTORY_TEMPLATES,
;;   G_USER_DIRECTORY_VIDEOS,
;;   G_USER_N_DIRECTORIES,
;; } GUserDirectory;
(define-fh-enum GUserDirectory
  '((G_USER_DIRECTORY_DESKTOP . 0)
    (G_USER_DIRECTORY_DOCUMENTS . 1)
    (G_USER_DIRECTORY_DOWNLOAD . 2)
    (G_USER_DIRECTORY_MUSIC . 3)
    (G_USER_DIRECTORY_PICTURES . 4)
    (G_USER_DIRECTORY_PUBLIC_SHARE . 5)
    (G_USER_DIRECTORY_TEMPLATES . 6)
    (G_USER_DIRECTORY_VIDEOS . 7)
    (G_USER_N_DIRECTORIES . 8))
  )

;; extern const gchar *g_get_user_special_dir(GUserDirectory directory);
(define g_get_user_special_dir
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_get_user_special_dir"
                (dynamic-link))
              (list ffi:int))))
    (lambda (directory)
      (let ((~directory (unwrap~fixed directory)))
        (wrap-gchar* (~f ~directory))))))
(export g_get_user_special_dir)

;; typedef struct _GDebugKey GDebugKey;
(define GDebugKey-desc void)
(define GDebugKey*-desc (bs:pointer (delay GDebugKey-desc)))
(define-fh-pointer-type GDebugKey* GDebugKey*-desc)

;; struct _GDebugKey {
;;   const gchar *key;
;;   guint value;
;; };
(define struct-_GDebugKey-desc
  (bs:struct
    (list `(key ,(bs:pointer gchar*-desc))
          `(value ,guint-desc))))
(export struct-_GDebugKey-desc)
(define-fh-compound-type/p struct-_GDebugKey struct-_GDebugKey-desc)
(set! GDebugKey-desc struct-_GDebugKey-desc)
(define-fh-compound-type GDebugKey GDebugKey-desc)

;; extern guint g_parse_debug_string(const gchar *string, const GDebugKey *keys
;;     , guint nkeys);
(define g_parse_debug_string
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func
                "g_parse_debug_string"
                (dynamic-link))
              (list '* '* ffi:unsigned-int))))
    (lambda (string keys nkeys)
      (let ((~string (unwrap-gchar* string))
            (~keys (unwrap-GDebugKey* keys))
            (~nkeys (unwrap-guint nkeys)))
        (wrap-guint (~f ~string ~keys ~nkeys))))))
(export g_parse_debug_string)

;; extern gint g_snprintf(gchar *string, gulong n, gchar const *format, ...);
;; ... failed.

;; extern gint g_vsnprintf(gchar *string, gulong n, gchar const *format, 
;;     va_list args);
(define g_vsnprintf
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_vsnprintf" (dynamic-link))
              (list '* ffi:unsigned-long '* '*))))
    (lambda (string n format args)
      (let ((~string (unwrap-gchar* string))
            (~n (unwrap-gulong n))
            (~format (unwrap-gchar* format))
            (~args (unwrap~pointer args)))
        (wrap-gint (~f ~string ~n ~format ~args))))))
(export g_vsnprintf)

;; extern void g_nullify_pointer(gpointer *nullify_location);
(define g_nullify_pointer
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_nullify_pointer" (dynamic-link))
              (list '*))))
    (lambda (nullify_location)
      (let ((~nullify_location
              (unwrap-gpointer* nullify_location)))
        (~f ~nullify_location)))))
(export g_nullify_pointer)

;; typedef enum {
;;   G_FORMAT_SIZE_DEFAULT = 0,
;;   G_FORMAT_SIZE_LONG_FORMAT = 1<<0,
;;   G_FORMAT_SIZE_IEC_UNITS = 1<<1,
;; } GFormatSizeFlags;
(define-fh-enum GFormatSizeFlags
  '((G_FORMAT_SIZE_DEFAULT . 0)
    (G_FORMAT_SIZE_LONG_FORMAT . 1)
    (G_FORMAT_SIZE_IEC_UNITS . 2))
  )

;; extern gchar *g_format_size_full(guint64 size, GFormatSizeFlags flags);
(define g_format_size_full
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_format_size_full"
                (dynamic-link))
              (list ffi:unsigned-long ffi:int))))
    (lambda (size flags)
      (let ((~size (unwrap~fixed size))
            (~flags (unwrap~fixed flags)))
        (wrap-gchar* (~f ~size ~flags))))))
(export g_format_size_full)

;; extern gchar *g_format_size(guint64 size);
(define g_format_size
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_format_size" (dynamic-link))
              (list ffi:unsigned-long))))
    (lambda (size)
      (let ((~size (unwrap~fixed size)))
        (wrap-gchar* (~f ~size))))))
(export g_format_size)

;; extern gchar *g_format_size_for_display(goffset size);
;; ... failed.

;; typedef void (*GVoidFunc)(void);
(define-fh-function/p GVoidFunc
  ffi:void (list ffi:void))

;; extern void g_atexit(GVoidFunc func);
(define g_atexit
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_atexit" (dynamic-link))
              (list '*))))
    (lambda (func)
      (let ((~func ((make-ftn-arg-unwrapper ffi:void (list ffi:void))
                    func)))
        (~f ~func)))))
(export g_atexit)

;; extern gchar *g_find_program_in_path(const gchar *program);
(define g_find_program_in_path
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_find_program_in_path"
                (dynamic-link))
              (list '*))))
    (lambda (program)
      (let ((~program (unwrap-gchar* program)))
        (wrap-gchar* (~f ~program))))))
(export g_find_program_in_path)

;; extern gint (g_bit_nth_lsf)(gulong mask, gint nth_bit);
;; ... failed.

;; extern gint (g_bit_nth_msf)(gulong mask, gint nth_bit);
;; ... failed.

;; extern guint (g_bit_storage)(gulong number);
;; ... failed.

;; extern GQuark g_thread_error_quark(void);
(define g_thread_error_quark
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func
                "g_thread_error_quark"
                (dynamic-link))
              (list))))
    (lambda () (let () (wrap-GQuark (~f))))))
(export g_thread_error_quark)

;; typedef enum {
;;   G_THREAD_ERROR_AGAIN,
;; } GThreadError;
(define-fh-enum GThreadError
  '((G_THREAD_ERROR_AGAIN . 0))
  )

;; typedef gpointer (*GThreadFunc)(gpointer data);
(define-fh-function/p GThreadFunc
  (quote *) (list (quote *)))

;; typedef struct _GThread GThread;
(define GThread-desc void)
(define GThread*-desc (bs:pointer (delay GThread-desc)))
(define-fh-pointer-type GThread* GThread*-desc)

;; typedef union _GMutex GMutex;
;; union _GMutex {
;;   /*< private >*/
;;   gpointer p;
;;   guint i[2];
;; };
(define GMutex-desc
  (bs:union
    (list `(p ,gpointer-desc)
          `(i ,(bs:vector 2 guint-desc)))))
(export GMutex-desc)
(define-fh-compound-type/p GMutex GMutex-desc)
(define union-_GMutex GMutex)

;; typedef struct _GRecMutex GRecMutex;
(define GRecMutex-desc void)
(define GRecMutex*-desc (bs:pointer (delay GRecMutex-desc)))
(define-fh-pointer-type GRecMutex* GRecMutex*-desc)

;; typedef struct _GRWLock GRWLock;
(define GRWLock-desc void)
(define GRWLock*-desc (bs:pointer (delay GRWLock-desc)))
(define-fh-pointer-type GRWLock* GRWLock*-desc)

;; typedef struct _GCond GCond;
(define GCond-desc void)
(define GCond*-desc (bs:pointer (delay GCond-desc)))
(define-fh-pointer-type GCond* GCond*-desc)

;; typedef struct _GPrivate GPrivate;
(define GPrivate-desc void)
(define GPrivate*-desc (bs:pointer (delay GPrivate-desc)))
(define-fh-pointer-type GPrivate* GPrivate*-desc)

;; typedef struct _GOnce GOnce;
(define GOnce-desc void)
(define GOnce*-desc (bs:pointer (delay GOnce-desc)))
(define-fh-pointer-type GOnce* GOnce*-desc)

;; struct _GRWLock {
;;   /*< private >*/
;;   gpointer p;
;;   guint i[2];
;; };
(define struct-_GRWLock-desc
  (bs:struct
    (list `(p ,gpointer-desc)
          `(i ,(bs:vector 2 guint-desc)))))
(export struct-_GRWLock-desc)
(define-fh-compound-type/p struct-_GRWLock struct-_GRWLock-desc)
(set! GRWLock-desc struct-_GRWLock-desc)
(define-fh-compound-type GRWLock GRWLock-desc)

;; struct _GCond {
;;   /*< private >*/
;;   gpointer p;
;;   guint i[2];
;; };
(define struct-_GCond-desc
  (bs:struct
    (list `(p ,gpointer-desc)
          `(i ,(bs:vector 2 guint-desc)))))
(export struct-_GCond-desc)
(define-fh-compound-type/p struct-_GCond struct-_GCond-desc)
(set! GCond-desc struct-_GCond-desc)
(define-fh-compound-type GCond GCond-desc)

;; struct _GRecMutex {
;;   /*< private >*/
;;   gpointer p;
;;   guint i[2];
;; };
(define struct-_GRecMutex-desc
  (bs:struct
    (list `(p ,gpointer-desc)
          `(i ,(bs:vector 2 guint-desc)))))
(export struct-_GRecMutex-desc)
(define-fh-compound-type/p struct-_GRecMutex struct-_GRecMutex-desc)
(set! GRecMutex-desc struct-_GRecMutex-desc)
(define-fh-compound-type GRecMutex GRecMutex-desc)

;; struct _GPrivate {
;;   /*< private >*/
;;   gpointer p;
;;   GDestroyNotify notify;
;;   gpointer future[2];
;; };
(define struct-_GPrivate-desc
  (bs:struct
    (list `(p ,gpointer-desc)
          `(notify ,(bs:pointer void))
          `(future ,(bs:vector 2 gpointer-desc)))))
(export struct-_GPrivate-desc)
(define-fh-compound-type/p struct-_GPrivate struct-_GPrivate-desc)
(set! GPrivate-desc struct-_GPrivate-desc)
(define-fh-compound-type GPrivate GPrivate-desc)

;; typedef enum {
;;   G_ONCE_STATUS_NOTCALLED,
;;   G_ONCE_STATUS_PROGRESS,
;;   G_ONCE_STATUS_READY,
;; } GOnceStatus;
(define-fh-enum GOnceStatus
  '((G_ONCE_STATUS_NOTCALLED . 0)
    (G_ONCE_STATUS_PROGRESS . 1)
    (G_ONCE_STATUS_READY . 2))
  )

;; struct _GOnce {
;;   volatile GOnceStatus status;
;;   volatile gpointer retval;
;; };
(define struct-_GOnce-desc
  (bs:struct
    (list `(status ,int) `(retval ,gpointer-desc))))
(export struct-_GOnce-desc)
(define-fh-compound-type/p struct-_GOnce struct-_GOnce-desc)
(set! GOnce-desc struct-_GOnce-desc)
(define-fh-compound-type GOnce GOnce-desc)

;; extern GThread *g_thread_ref(GThread *thread);
(define g_thread_ref
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_thread_ref" (dynamic-link))
              (list '*))))
    (lambda (thread)
      (let ((~thread (unwrap-GThread* thread)))
        (wrap-GThread* (~f ~thread))))))
(export g_thread_ref)

;; extern void g_thread_unref(GThread *thread);
(define g_thread_unref
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_thread_unref" (dynamic-link))
              (list '*))))
    (lambda (thread)
      (let ((~thread (unwrap-GThread* thread)))
        (~f ~thread)))))
(export g_thread_unref)

;; extern GThread *g_thread_new(const gchar *name, GThreadFunc func, gpointer 
;;     data);
;; ... failed.

;; extern GThread *g_thread_try_new(const gchar *name, GThreadFunc func, 
;;     gpointer data, GError **error);
;; ... failed.

;; extern GThread *g_thread_self(void);
(define g_thread_self
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_thread_self" (dynamic-link))
              (list))))
    (lambda () (let () (wrap-GThread* (~f))))))
(export g_thread_self)

;; extern void g_thread_exit(gpointer retval);
(define g_thread_exit
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_thread_exit" (dynamic-link))
              (list '*))))
    (lambda (retval)
      (let ((~retval (unwrap-gpointer retval)))
        (~f ~retval)))))
(export g_thread_exit)

;; extern gpointer g_thread_join(GThread *thread);
(define g_thread_join
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_thread_join" (dynamic-link))
              (list '*))))
    (lambda (thread)
      (let ((~thread (unwrap-GThread* thread)))
        (wrap-gpointer (~f ~thread))))))
(export g_thread_join)

;; extern void g_thread_yield(void);
(define g_thread_yield
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_thread_yield" (dynamic-link))
              (list))))
    (lambda () (let () (~f)))))
(export g_thread_yield)

;; extern void g_mutex_init(GMutex *mutex);
(define g_mutex_init
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_mutex_init" (dynamic-link))
              (list '*))))
    (lambda (mutex)
      (let ((~mutex (unwrap-GMutex* mutex)))
        (~f ~mutex)))))
(export g_mutex_init)

;; extern void g_mutex_clear(GMutex *mutex);
(define g_mutex_clear
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_mutex_clear" (dynamic-link))
              (list '*))))
    (lambda (mutex)
      (let ((~mutex (unwrap-GMutex* mutex)))
        (~f ~mutex)))))
(export g_mutex_clear)

;; extern void g_mutex_lock(GMutex *mutex);
(define g_mutex_lock
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_mutex_lock" (dynamic-link))
              (list '*))))
    (lambda (mutex)
      (let ((~mutex (unwrap-GMutex* mutex)))
        (~f ~mutex)))))
(export g_mutex_lock)

;; extern gboolean g_mutex_trylock(GMutex *mutex);
(define g_mutex_trylock
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_mutex_trylock" (dynamic-link))
              (list '*))))
    (lambda (mutex)
      (let ((~mutex (unwrap-GMutex* mutex)))
        (wrap-gboolean (~f ~mutex))))))
(export g_mutex_trylock)

;; extern void g_mutex_unlock(GMutex *mutex);
(define g_mutex_unlock
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_mutex_unlock" (dynamic-link))
              (list '*))))
    (lambda (mutex)
      (let ((~mutex (unwrap-GMutex* mutex)))
        (~f ~mutex)))))
(export g_mutex_unlock)

;; extern void g_rw_lock_init(GRWLock *rw_lock);
(define g_rw_lock_init
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_rw_lock_init" (dynamic-link))
              (list '*))))
    (lambda (rw_lock)
      (let ((~rw_lock (unwrap-GRWLock* rw_lock)))
        (~f ~rw_lock)))))
(export g_rw_lock_init)

;; extern void g_rw_lock_clear(GRWLock *rw_lock);
(define g_rw_lock_clear
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_rw_lock_clear" (dynamic-link))
              (list '*))))
    (lambda (rw_lock)
      (let ((~rw_lock (unwrap-GRWLock* rw_lock)))
        (~f ~rw_lock)))))
(export g_rw_lock_clear)

;; extern void g_rw_lock_writer_lock(GRWLock *rw_lock);
(define g_rw_lock_writer_lock
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_rw_lock_writer_lock"
                (dynamic-link))
              (list '*))))
    (lambda (rw_lock)
      (let ((~rw_lock (unwrap-GRWLock* rw_lock)))
        (~f ~rw_lock)))))
(export g_rw_lock_writer_lock)

;; extern gboolean g_rw_lock_writer_trylock(GRWLock *rw_lock);
(define g_rw_lock_writer_trylock
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_rw_lock_writer_trylock"
                (dynamic-link))
              (list '*))))
    (lambda (rw_lock)
      (let ((~rw_lock (unwrap-GRWLock* rw_lock)))
        (wrap-gboolean (~f ~rw_lock))))))
(export g_rw_lock_writer_trylock)

;; extern void g_rw_lock_writer_unlock(GRWLock *rw_lock);
(define g_rw_lock_writer_unlock
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_rw_lock_writer_unlock"
                (dynamic-link))
              (list '*))))
    (lambda (rw_lock)
      (let ((~rw_lock (unwrap-GRWLock* rw_lock)))
        (~f ~rw_lock)))))
(export g_rw_lock_writer_unlock)

;; extern void g_rw_lock_reader_lock(GRWLock *rw_lock);
(define g_rw_lock_reader_lock
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_rw_lock_reader_lock"
                (dynamic-link))
              (list '*))))
    (lambda (rw_lock)
      (let ((~rw_lock (unwrap-GRWLock* rw_lock)))
        (~f ~rw_lock)))))
(export g_rw_lock_reader_lock)

;; extern gboolean g_rw_lock_reader_trylock(GRWLock *rw_lock);
(define g_rw_lock_reader_trylock
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_rw_lock_reader_trylock"
                (dynamic-link))
              (list '*))))
    (lambda (rw_lock)
      (let ((~rw_lock (unwrap-GRWLock* rw_lock)))
        (wrap-gboolean (~f ~rw_lock))))))
(export g_rw_lock_reader_trylock)

;; extern void g_rw_lock_reader_unlock(GRWLock *rw_lock);
(define g_rw_lock_reader_unlock
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_rw_lock_reader_unlock"
                (dynamic-link))
              (list '*))))
    (lambda (rw_lock)
      (let ((~rw_lock (unwrap-GRWLock* rw_lock)))
        (~f ~rw_lock)))))
(export g_rw_lock_reader_unlock)

;; extern void g_rec_mutex_init(GRecMutex *rec_mutex);
(define g_rec_mutex_init
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_rec_mutex_init" (dynamic-link))
              (list '*))))
    (lambda (rec_mutex)
      (let ((~rec_mutex (unwrap-GRecMutex* rec_mutex)))
        (~f ~rec_mutex)))))
(export g_rec_mutex_init)

;; extern void g_rec_mutex_clear(GRecMutex *rec_mutex);
(define g_rec_mutex_clear
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_rec_mutex_clear" (dynamic-link))
              (list '*))))
    (lambda (rec_mutex)
      (let ((~rec_mutex (unwrap-GRecMutex* rec_mutex)))
        (~f ~rec_mutex)))))
(export g_rec_mutex_clear)

;; extern void g_rec_mutex_lock(GRecMutex *rec_mutex);
(define g_rec_mutex_lock
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_rec_mutex_lock" (dynamic-link))
              (list '*))))
    (lambda (rec_mutex)
      (let ((~rec_mutex (unwrap-GRecMutex* rec_mutex)))
        (~f ~rec_mutex)))))
(export g_rec_mutex_lock)

;; extern gboolean g_rec_mutex_trylock(GRecMutex *rec_mutex);
(define g_rec_mutex_trylock
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_rec_mutex_trylock"
                (dynamic-link))
              (list '*))))
    (lambda (rec_mutex)
      (let ((~rec_mutex (unwrap-GRecMutex* rec_mutex)))
        (wrap-gboolean (~f ~rec_mutex))))))
(export g_rec_mutex_trylock)

;; extern void g_rec_mutex_unlock(GRecMutex *rec_mutex);
(define g_rec_mutex_unlock
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_rec_mutex_unlock"
                (dynamic-link))
              (list '*))))
    (lambda (rec_mutex)
      (let ((~rec_mutex (unwrap-GRecMutex* rec_mutex)))
        (~f ~rec_mutex)))))
(export g_rec_mutex_unlock)

;; extern void g_cond_init(GCond *cond);
(define g_cond_init
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_cond_init" (dynamic-link))
              (list '*))))
    (lambda (cond)
      (let ((~cond (unwrap-GCond* cond))) (~f ~cond)))))
(export g_cond_init)

;; extern void g_cond_clear(GCond *cond);
(define g_cond_clear
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_cond_clear" (dynamic-link))
              (list '*))))
    (lambda (cond)
      (let ((~cond (unwrap-GCond* cond))) (~f ~cond)))))
(export g_cond_clear)

;; extern void g_cond_wait(GCond *cond, GMutex *mutex);
(define g_cond_wait
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_cond_wait" (dynamic-link))
              (list '* '*))))
    (lambda (cond mutex)
      (let ((~cond (unwrap-GCond* cond))
            (~mutex (unwrap-GMutex* mutex)))
        (~f ~cond ~mutex)))))
(export g_cond_wait)

;; extern void g_cond_signal(GCond *cond);
(define g_cond_signal
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_cond_signal" (dynamic-link))
              (list '*))))
    (lambda (cond)
      (let ((~cond (unwrap-GCond* cond))) (~f ~cond)))))
(export g_cond_signal)

;; extern void g_cond_broadcast(GCond *cond);
(define g_cond_broadcast
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_cond_broadcast" (dynamic-link))
              (list '*))))
    (lambda (cond)
      (let ((~cond (unwrap-GCond* cond))) (~f ~cond)))))
(export g_cond_broadcast)

;; extern gboolean g_cond_wait_until(GCond *cond, GMutex *mutex, gint64 
;;     end_time);
;; ... failed.

;; extern gpointer g_private_get(GPrivate *key);
(define g_private_get
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_private_get" (dynamic-link))
              (list '*))))
    (lambda (key)
      (let ((~key (unwrap-GPrivate* key)))
        (wrap-gpointer (~f ~key))))))
(export g_private_get)

;; extern void g_private_set(GPrivate *key, gpointer value);
(define g_private_set
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_private_set" (dynamic-link))
              (list '* '*))))
    (lambda (key value)
      (let ((~key (unwrap-GPrivate* key))
            (~value (unwrap-gpointer value)))
        (~f ~key ~value)))))
(export g_private_set)

;; extern void g_private_replace(GPrivate *key, gpointer value);
(define g_private_replace
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_private_replace" (dynamic-link))
              (list '* '*))))
    (lambda (key value)
      (let ((~key (unwrap-GPrivate* key))
            (~value (unwrap-gpointer value)))
        (~f ~key ~value)))))
(export g_private_replace)

;; extern gpointer g_once_impl(GOnce *once, GThreadFunc func, gpointer arg);
;; ... failed.

;; extern gboolean g_once_init_enter(volatile void *location);
(define g_once_init_enter
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_once_init_enter" (dynamic-link))
              (list '*))))
    (lambda (location)
      (let ((~location (unwrap~pointer location)))
        (wrap-gboolean (~f ~location))))))
(export g_once_init_enter)

;; extern void g_once_init_leave(volatile void *location, gsize result);
(define g_once_init_leave
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_once_init_leave" (dynamic-link))
              (list '* ffi:unsigned-long))))
    (lambda (location result)
      (let ((~location (unwrap~pointer location))
            (~result (unwrap~fixed result)))
        (~f ~location ~result)))))
(export g_once_init_leave)

;; extern guint g_get_num_processors(void);
(define g_get_num_processors
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func
                "g_get_num_processors"
                (dynamic-link))
              (list))))
    (lambda () (let () (wrap-guint (~f))))))
(export g_get_num_processors)

;; typedef void GMutexLocker;
;; ... failed.

;; typedef struct _GAsyncQueue GAsyncQueue;
(define GAsyncQueue-desc void)
(define GAsyncQueue*-desc (bs:pointer GAsyncQueue-desc))
(define-fh-pointer-type GAsyncQueue* GAsyncQueue*-desc)

;; extern GAsyncQueue *g_async_queue_new(void);
(define g_async_queue_new
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_async_queue_new" (dynamic-link))
              (list))))
    (lambda () (let () (wrap-GAsyncQueue* (~f))))))
(export g_async_queue_new)

;; extern GAsyncQueue *g_async_queue_new_full(GDestroyNotify item_free_func);
(define g_async_queue_new_full
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_async_queue_new_full"
                (dynamic-link))
              (list '*))))
    (lambda (item_free_func)
      (let ((~item_free_func
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               item_free_func)))
        (wrap-GAsyncQueue* (~f ~item_free_func))))))
(export g_async_queue_new_full)

;; extern void g_async_queue_lock(GAsyncQueue *queue);
(define g_async_queue_lock
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_async_queue_lock"
                (dynamic-link))
              (list '*))))
    (lambda (queue)
      (let ((~queue (unwrap-GAsyncQueue* queue)))
        (~f ~queue)))))
(export g_async_queue_lock)

;; extern void g_async_queue_unlock(GAsyncQueue *queue);
(define g_async_queue_unlock
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_async_queue_unlock"
                (dynamic-link))
              (list '*))))
    (lambda (queue)
      (let ((~queue (unwrap-GAsyncQueue* queue)))
        (~f ~queue)))))
(export g_async_queue_unlock)

;; extern GAsyncQueue *g_async_queue_ref(GAsyncQueue *queue);
(define g_async_queue_ref
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_async_queue_ref" (dynamic-link))
              (list '*))))
    (lambda (queue)
      (let ((~queue (unwrap-GAsyncQueue* queue)))
        (wrap-GAsyncQueue* (~f ~queue))))))
(export g_async_queue_ref)

;; extern void g_async_queue_unref(GAsyncQueue *queue);
(define g_async_queue_unref
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_async_queue_unref"
                (dynamic-link))
              (list '*))))
    (lambda (queue)
      (let ((~queue (unwrap-GAsyncQueue* queue)))
        (~f ~queue)))))
(export g_async_queue_unref)

;; extern void g_async_queue_ref_unlocked(GAsyncQueue *queue);
(define g_async_queue_ref_unlocked
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_async_queue_ref_unlocked"
                (dynamic-link))
              (list '*))))
    (lambda (queue)
      (let ((~queue (unwrap-GAsyncQueue* queue)))
        (~f ~queue)))))
(export g_async_queue_ref_unlocked)

;; extern void g_async_queue_unref_and_unlock(GAsyncQueue *queue);
(define g_async_queue_unref_and_unlock
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_async_queue_unref_and_unlock"
                (dynamic-link))
              (list '*))))
    (lambda (queue)
      (let ((~queue (unwrap-GAsyncQueue* queue)))
        (~f ~queue)))))
(export g_async_queue_unref_and_unlock)

;; extern void g_async_queue_push(GAsyncQueue *queue, gpointer data);
(define g_async_queue_push
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_async_queue_push"
                (dynamic-link))
              (list '* '*))))
    (lambda (queue data)
      (let ((~queue (unwrap-GAsyncQueue* queue))
            (~data (unwrap-gpointer data)))
        (~f ~queue ~data)))))
(export g_async_queue_push)

;; extern void g_async_queue_push_unlocked(GAsyncQueue *queue, gpointer data);
(define g_async_queue_push_unlocked
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_async_queue_push_unlocked"
                (dynamic-link))
              (list '* '*))))
    (lambda (queue data)
      (let ((~queue (unwrap-GAsyncQueue* queue))
            (~data (unwrap-gpointer data)))
        (~f ~queue ~data)))))
(export g_async_queue_push_unlocked)

;; extern void g_async_queue_push_sorted(GAsyncQueue *queue, gpointer data, 
;;     GCompareDataFunc func, gpointer user_data);
;; ... failed.

;; extern void g_async_queue_push_sorted_unlocked(GAsyncQueue *queue, gpointer 
;;     data, GCompareDataFunc func, gpointer user_data);
;; ... failed.

;; extern gpointer g_async_queue_pop(GAsyncQueue *queue);
(define g_async_queue_pop
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_async_queue_pop" (dynamic-link))
              (list '*))))
    (lambda (queue)
      (let ((~queue (unwrap-GAsyncQueue* queue)))
        (wrap-gpointer (~f ~queue))))))
(export g_async_queue_pop)

;; extern gpointer g_async_queue_pop_unlocked(GAsyncQueue *queue);
(define g_async_queue_pop_unlocked
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_async_queue_pop_unlocked"
                (dynamic-link))
              (list '*))))
    (lambda (queue)
      (let ((~queue (unwrap-GAsyncQueue* queue)))
        (wrap-gpointer (~f ~queue))))))
(export g_async_queue_pop_unlocked)

;; extern gpointer g_async_queue_try_pop(GAsyncQueue *queue);
(define g_async_queue_try_pop
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_async_queue_try_pop"
                (dynamic-link))
              (list '*))))
    (lambda (queue)
      (let ((~queue (unwrap-GAsyncQueue* queue)))
        (wrap-gpointer (~f ~queue))))))
(export g_async_queue_try_pop)

;; extern gpointer g_async_queue_try_pop_unlocked(GAsyncQueue *queue);
(define g_async_queue_try_pop_unlocked
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_async_queue_try_pop_unlocked"
                (dynamic-link))
              (list '*))))
    (lambda (queue)
      (let ((~queue (unwrap-GAsyncQueue* queue)))
        (wrap-gpointer (~f ~queue))))))
(export g_async_queue_try_pop_unlocked)

;; extern gpointer g_async_queue_timeout_pop(GAsyncQueue *queue, guint64 
;;     timeout);
(define g_async_queue_timeout_pop
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_async_queue_timeout_pop"
                (dynamic-link))
              (list '* ffi:unsigned-long))))
    (lambda (queue timeout)
      (let ((~queue (unwrap-GAsyncQueue* queue))
            (~timeout (unwrap~fixed timeout)))
        (wrap-gpointer (~f ~queue ~timeout))))))
(export g_async_queue_timeout_pop)

;; extern gpointer g_async_queue_timeout_pop_unlocked(GAsyncQueue *queue, 
;;     guint64 timeout);
(define g_async_queue_timeout_pop_unlocked
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_async_queue_timeout_pop_unlocked"
                (dynamic-link))
              (list '* ffi:unsigned-long))))
    (lambda (queue timeout)
      (let ((~queue (unwrap-GAsyncQueue* queue))
            (~timeout (unwrap~fixed timeout)))
        (wrap-gpointer (~f ~queue ~timeout))))))
(export g_async_queue_timeout_pop_unlocked)

;; extern gint g_async_queue_length(GAsyncQueue *queue);
(define g_async_queue_length
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_async_queue_length"
                (dynamic-link))
              (list '*))))
    (lambda (queue)
      (let ((~queue (unwrap-GAsyncQueue* queue)))
        (wrap-gint (~f ~queue))))))
(export g_async_queue_length)

;; extern gint g_async_queue_length_unlocked(GAsyncQueue *queue);
(define g_async_queue_length_unlocked
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_async_queue_length_unlocked"
                (dynamic-link))
              (list '*))))
    (lambda (queue)
      (let ((~queue (unwrap-GAsyncQueue* queue)))
        (wrap-gint (~f ~queue))))))
(export g_async_queue_length_unlocked)

;; extern void g_async_queue_sort(GAsyncQueue *queue, GCompareDataFunc func, 
;;     gpointer user_data);
;; ... failed.

;; extern void g_async_queue_sort_unlocked(GAsyncQueue *queue, GCompareDataFunc
;;      func, gpointer user_data);
;; ... failed.

;; extern gboolean g_async_queue_remove(GAsyncQueue *queue, gpointer item);
(define g_async_queue_remove
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_async_queue_remove"
                (dynamic-link))
              (list '* '*))))
    (lambda (queue item)
      (let ((~queue (unwrap-GAsyncQueue* queue))
            (~item (unwrap-gpointer item)))
        (wrap-gboolean (~f ~queue ~item))))))
(export g_async_queue_remove)

;; extern gboolean g_async_queue_remove_unlocked(GAsyncQueue *queue, gpointer 
;;     item);
(define g_async_queue_remove_unlocked
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_async_queue_remove_unlocked"
                (dynamic-link))
              (list '* '*))))
    (lambda (queue item)
      (let ((~queue (unwrap-GAsyncQueue* queue))
            (~item (unwrap-gpointer item)))
        (wrap-gboolean (~f ~queue ~item))))))
(export g_async_queue_remove_unlocked)

;; extern void g_async_queue_push_front(GAsyncQueue *queue, gpointer item);
(define g_async_queue_push_front
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_async_queue_push_front"
                (dynamic-link))
              (list '* '*))))
    (lambda (queue item)
      (let ((~queue (unwrap-GAsyncQueue* queue))
            (~item (unwrap-gpointer item)))
        (~f ~queue ~item)))))
(export g_async_queue_push_front)

;; extern void g_async_queue_push_front_unlocked(GAsyncQueue *queue, gpointer 
;;     item);
(define g_async_queue_push_front_unlocked
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_async_queue_push_front_unlocked"
                (dynamic-link))
              (list '* '*))))
    (lambda (queue item)
      (let ((~queue (unwrap-GAsyncQueue* queue))
            (~item (unwrap-gpointer item)))
        (~f ~queue ~item)))))
(export g_async_queue_push_front_unlocked)

;; extern gpointer g_async_queue_timed_pop(GAsyncQueue *queue, GTimeVal *
;;     end_time);
(define g_async_queue_timed_pop
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_async_queue_timed_pop"
                (dynamic-link))
              (list '* '*))))
    (lambda (queue end_time)
      (let ((~queue (unwrap-GAsyncQueue* queue))
            (~end_time (unwrap-GTimeVal* end_time)))
        (wrap-gpointer (~f ~queue ~end_time))))))
(export g_async_queue_timed_pop)

;; extern gpointer g_async_queue_timed_pop_unlocked(GAsyncQueue *queue, 
;;     GTimeVal *end_time);
(define g_async_queue_timed_pop_unlocked
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_async_queue_timed_pop_unlocked"
                (dynamic-link))
              (list '* '*))))
    (lambda (queue end_time)
      (let ((~queue (unwrap-GAsyncQueue* queue))
            (~end_time (unwrap-GTimeVal* end_time)))
        (wrap-gpointer (~f ~queue ~end_time))))))
(export g_async_queue_timed_pop_unlocked)

;; extern void g_on_error_query(const gchar *prg_name);
(define g_on_error_query
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_on_error_query" (dynamic-link))
              (list '*))))
    (lambda (prg_name)
      (let ((~prg_name (unwrap-gchar* prg_name)))
        (~f ~prg_name)))))
(export g_on_error_query)

;; extern void g_on_error_stack_trace(const gchar *prg_name);
(define g_on_error_stack_trace
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_on_error_stack_trace"
                (dynamic-link))
              (list '*))))
    (lambda (prg_name)
      (let ((~prg_name (unwrap-gchar* prg_name)))
        (~f ~prg_name)))))
(export g_on_error_stack_trace)

;; extern gsize g_base64_encode_step(const guchar *in, gsize len, gboolean 
;;     break_lines, gchar *out, gint *state, gint *save);
(define g_base64_encode_step
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-long
              (dynamic-func
                "g_base64_encode_step"
                (dynamic-link))
              (list '* ffi:unsigned-long ffi:int '* '* '*))))
    (lambda (in len break_lines out state save)
      (let ((~in (unwrap-guchar* in))
            (~len (unwrap~fixed len))
            (~break_lines (unwrap-gboolean break_lines))
            (~out (unwrap-gchar* out))
            (~state (unwrap-gint* state))
            (~save (unwrap-gint* save)))
        (~f ~in ~len ~break_lines ~out ~state ~save)))))
(export g_base64_encode_step)

;; extern gsize g_base64_encode_close(gboolean break_lines, gchar *out, gint *
;;     state, gint *save);
(define g_base64_encode_close
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-long
              (dynamic-func
                "g_base64_encode_close"
                (dynamic-link))
              (list ffi:int '* '* '*))))
    (lambda (break_lines out state save)
      (let ((~break_lines (unwrap-gboolean break_lines))
            (~out (unwrap-gchar* out))
            (~state (unwrap-gint* state))
            (~save (unwrap-gint* save)))
        (~f ~break_lines ~out ~state ~save)))))
(export g_base64_encode_close)

;; extern gchar *g_base64_encode(const guchar *data, gsize len);
(define g_base64_encode
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_base64_encode" (dynamic-link))
              (list '* ffi:unsigned-long))))
    (lambda (data len)
      (let ((~data (unwrap-guchar* data))
            (~len (unwrap~fixed len)))
        (wrap-gchar* (~f ~data ~len))))))
(export g_base64_encode)

;; extern gsize g_base64_decode_step(const gchar *in, gsize len, guchar *out, 
;;     gint *state, guint *save);
(define g_base64_decode_step
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-long
              (dynamic-func
                "g_base64_decode_step"
                (dynamic-link))
              (list '* ffi:unsigned-long '* '* '*))))
    (lambda (in len out state save)
      (let ((~in (unwrap-gchar* in))
            (~len (unwrap~fixed len))
            (~out (unwrap-guchar* out))
            (~state (unwrap-gint* state))
            (~save (unwrap-guint* save)))
        (~f ~in ~len ~out ~state ~save)))))
(export g_base64_decode_step)

;; extern guchar *g_base64_decode(const gchar *text, gsize *out_len);
(define g_base64_decode
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_base64_decode" (dynamic-link))
              (list '* '*))))
    (lambda (text out_len)
      (let ((~text (unwrap-gchar* text))
            (~out_len (unwrap~pointer out_len)))
        (wrap-guchar* (~f ~text ~out_len))))))
(export g_base64_decode)

;; extern guchar *g_base64_decode_inplace(gchar *text, gsize *out_len);
(define g_base64_decode_inplace
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_base64_decode_inplace"
                (dynamic-link))
              (list '* '*))))
    (lambda (text out_len)
      (let ((~text (unwrap-gchar* text))
            (~out_len (unwrap~pointer out_len)))
        (wrap-guchar* (~f ~text ~out_len))))))
(export g_base64_decode_inplace)

;; extern void g_bit_lock(volatile gint *address, gint lock_bit);
(define g_bit_lock
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_bit_lock" (dynamic-link))
              (list '* ffi:int))))
    (lambda (address lock_bit)
      (let ((~address (unwrap-gint* address))
            (~lock_bit (unwrap-gint lock_bit)))
        (~f ~address ~lock_bit)))))
(export g_bit_lock)

;; extern gboolean g_bit_trylock(volatile gint *address, gint lock_bit);
(define g_bit_trylock
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_bit_trylock" (dynamic-link))
              (list '* ffi:int))))
    (lambda (address lock_bit)
      (let ((~address (unwrap-gint* address))
            (~lock_bit (unwrap-gint lock_bit)))
        (wrap-gboolean (~f ~address ~lock_bit))))))
(export g_bit_trylock)

;; extern void g_bit_unlock(volatile gint *address, gint lock_bit);
(define g_bit_unlock
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_bit_unlock" (dynamic-link))
              (list '* ffi:int))))
    (lambda (address lock_bit)
      (let ((~address (unwrap-gint* address))
            (~lock_bit (unwrap-gint lock_bit)))
        (~f ~address ~lock_bit)))))
(export g_bit_unlock)

;; extern void g_pointer_bit_lock(volatile void *address, gint lock_bit);
(define g_pointer_bit_lock
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_pointer_bit_lock"
                (dynamic-link))
              (list '* ffi:int))))
    (lambda (address lock_bit)
      (let ((~address (unwrap~pointer address))
            (~lock_bit (unwrap-gint lock_bit)))
        (~f ~address ~lock_bit)))))
(export g_pointer_bit_lock)

;; extern gboolean g_pointer_bit_trylock(volatile void *address, gint lock_bit)
;;     ;
(define g_pointer_bit_trylock
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_pointer_bit_trylock"
                (dynamic-link))
              (list '* ffi:int))))
    (lambda (address lock_bit)
      (let ((~address (unwrap~pointer address))
            (~lock_bit (unwrap-gint lock_bit)))
        (wrap-gboolean (~f ~address ~lock_bit))))))
(export g_pointer_bit_trylock)

;; extern void g_pointer_bit_unlock(volatile void *address, gint lock_bit);
(define g_pointer_bit_unlock
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_pointer_bit_unlock"
                (dynamic-link))
              (list '* ffi:int))))
    (lambda (address lock_bit)
      (let ((~address (unwrap~pointer address))
            (~lock_bit (unwrap-gint lock_bit)))
        (~f ~address ~lock_bit)))))
(export g_pointer_bit_unlock)

;; typedef enum {
;;   G_BOOKMARK_FILE_ERROR_INVALID_URI,
;;   G_BOOKMARK_FILE_ERROR_INVALID_VALUE,
;;   G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED,
;;   G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,
;;   G_BOOKMARK_FILE_ERROR_READ,
;;   G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING,
;;   G_BOOKMARK_FILE_ERROR_WRITE,
;;   G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND,
;; } GBookmarkFileError;
(define-fh-enum GBookmarkFileError
  '((G_BOOKMARK_FILE_ERROR_INVALID_URI . 0)
    (G_BOOKMARK_FILE_ERROR_INVALID_VALUE . 1)
    (G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED . 2)
    (G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND . 3)
    (G_BOOKMARK_FILE_ERROR_READ . 4)
    (G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING . 5)
    (G_BOOKMARK_FILE_ERROR_WRITE . 6)
    (G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND . 7))
  )

;; extern GQuark g_bookmark_file_error_quark(void);
(define g_bookmark_file_error_quark
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func
                "g_bookmark_file_error_quark"
                (dynamic-link))
              (list))))
    (lambda () (let () (wrap-GQuark (~f))))))
(export g_bookmark_file_error_quark)

;; typedef struct _GBookmarkFile GBookmarkFile;
(define GBookmarkFile-desc void)
(define GBookmarkFile*-desc (bs:pointer GBookmarkFile-desc))
(define-fh-pointer-type GBookmarkFile* GBookmarkFile*-desc)

;; extern GBookmarkFile *g_bookmark_file_new(void);
(define g_bookmark_file_new
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_bookmark_file_new"
                (dynamic-link))
              (list))))
    (lambda () (let () (wrap-GBookmarkFile* (~f))))))
(export g_bookmark_file_new)

;; extern void g_bookmark_file_free(GBookmarkFile *bookmark);
(define g_bookmark_file_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_bookmark_file_free"
                (dynamic-link))
              (list '*))))
    (lambda (bookmark)
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark)))
        (~f ~bookmark)))))
(export g_bookmark_file_free)

;; extern gboolean g_bookmark_file_load_from_file(GBookmarkFile *bookmark, 
;;     const gchar *filename, GError **error);
(define g_bookmark_file_load_from_file
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_bookmark_file_load_from_file"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (bookmark filename error)
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~filename (unwrap-gchar* filename))
            (~error (unwrap~pointer error)))
        (wrap-gboolean (~f ~bookmark ~filename ~error))))))
(export g_bookmark_file_load_from_file)

;; extern gboolean g_bookmark_file_load_from_data(GBookmarkFile *bookmark, 
;;     const gchar *data, gsize length, GError **error);
(define g_bookmark_file_load_from_data
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_bookmark_file_load_from_data"
                (dynamic-link))
              (list '* '* ffi:unsigned-long '*))))
    (lambda (bookmark data length error)
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~data (unwrap-gchar* data))
            (~length (unwrap~fixed length))
            (~error (unwrap~pointer error)))
        (wrap-gboolean
          (~f ~bookmark ~data ~length ~error))))))
(export g_bookmark_file_load_from_data)

;; extern gboolean g_bookmark_file_load_from_data_dirs(GBookmarkFile *bookmark
;;     , const gchar *file, gchar **full_path, GError **error);
(define g_bookmark_file_load_from_data_dirs
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_bookmark_file_load_from_data_dirs"
                (dynamic-link))
              (list '* '* '* '*))))
    (lambda (bookmark file full_path error)
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~file (unwrap-gchar* file))
            (~full_path (unwrap~pointer full_path))
            (~error (unwrap~pointer error)))
        (wrap-gboolean
          (~f ~bookmark ~file ~full_path ~error))))))
(export g_bookmark_file_load_from_data_dirs)

;; extern gchar *g_bookmark_file_to_data(GBookmarkFile *bookmark, gsize *length
;;     , GError **error);
(define g_bookmark_file_to_data
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_bookmark_file_to_data"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (bookmark length error)
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~length (unwrap~pointer length))
            (~error (unwrap~pointer error)))
        (wrap-gchar* (~f ~bookmark ~length ~error))))))
(export g_bookmark_file_to_data)

;; extern gboolean g_bookmark_file_to_file(GBookmarkFile *bookmark, const gchar
;;      *filename, GError **error);
(define g_bookmark_file_to_file
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_bookmark_file_to_file"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (bookmark filename error)
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~filename (unwrap-gchar* filename))
            (~error (unwrap~pointer error)))
        (wrap-gboolean (~f ~bookmark ~filename ~error))))))
(export g_bookmark_file_to_file)

;; extern void g_bookmark_file_set_title(GBookmarkFile *bookmark, const gchar *
;;     uri, const gchar *title);
(define g_bookmark_file_set_title
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_bookmark_file_set_title"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (bookmark uri title)
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap-gchar* uri))
            (~title (unwrap-gchar* title)))
        (~f ~bookmark ~uri ~title)))))
(export g_bookmark_file_set_title)

;; extern gchar *g_bookmark_file_get_title(GBookmarkFile *bookmark, const gchar
;;      *uri, GError **error);
(define g_bookmark_file_get_title
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_bookmark_file_get_title"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (bookmark uri error)
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap-gchar* uri))
            (~error (unwrap~pointer error)))
        (wrap-gchar* (~f ~bookmark ~uri ~error))))))
(export g_bookmark_file_get_title)

;; extern void g_bookmark_file_set_description(GBookmarkFile *bookmark, const 
;;     gchar *uri, const gchar *description);
(define g_bookmark_file_set_description
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_bookmark_file_set_description"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (bookmark uri description)
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap-gchar* uri))
            (~description (unwrap-gchar* description)))
        (~f ~bookmark ~uri ~description)))))
(export g_bookmark_file_set_description)

;; extern gchar *g_bookmark_file_get_description(GBookmarkFile *bookmark, const
;;      gchar *uri, GError **error);
(define g_bookmark_file_get_description
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_bookmark_file_get_description"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (bookmark uri error)
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap-gchar* uri))
            (~error (unwrap~pointer error)))
        (wrap-gchar* (~f ~bookmark ~uri ~error))))))
(export g_bookmark_file_get_description)

;; extern void g_bookmark_file_set_mime_type(GBookmarkFile *bookmark, const 
;;     gchar *uri, const gchar *mime_type);
(define g_bookmark_file_set_mime_type
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_bookmark_file_set_mime_type"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (bookmark uri mime_type)
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap-gchar* uri))
            (~mime_type (unwrap-gchar* mime_type)))
        (~f ~bookmark ~uri ~mime_type)))))
(export g_bookmark_file_set_mime_type)

;; extern gchar *g_bookmark_file_get_mime_type(GBookmarkFile *bookmark, const 
;;     gchar *uri, GError **error);
(define g_bookmark_file_get_mime_type
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_bookmark_file_get_mime_type"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (bookmark uri error)
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap-gchar* uri))
            (~error (unwrap~pointer error)))
        (wrap-gchar* (~f ~bookmark ~uri ~error))))))
(export g_bookmark_file_get_mime_type)

;; extern void g_bookmark_file_set_groups(GBookmarkFile *bookmark, const gchar 
;;     *uri, const gchar **groups, gsize length);
(define g_bookmark_file_set_groups
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_bookmark_file_set_groups"
                (dynamic-link))
              (list '* '* '* ffi:unsigned-long))))
    (lambda (bookmark uri groups length)
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap-gchar* uri))
            (~groups (unwrap~pointer groups))
            (~length (unwrap~fixed length)))
        (~f ~bookmark ~uri ~groups ~length)))))
(export g_bookmark_file_set_groups)

;; extern void g_bookmark_file_add_group(GBookmarkFile *bookmark, const gchar *
;;     uri, const gchar *group);
(define g_bookmark_file_add_group
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_bookmark_file_add_group"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (bookmark uri group)
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap-gchar* uri))
            (~group (unwrap-gchar* group)))
        (~f ~bookmark ~uri ~group)))))
(export g_bookmark_file_add_group)

;; extern gboolean g_bookmark_file_has_group(GBookmarkFile *bookmark, const 
;;     gchar *uri, const gchar *group, GError **error);
(define g_bookmark_file_has_group
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_bookmark_file_has_group"
                (dynamic-link))
              (list '* '* '* '*))))
    (lambda (bookmark uri group error)
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap-gchar* uri))
            (~group (unwrap-gchar* group))
            (~error (unwrap~pointer error)))
        (wrap-gboolean (~f ~bookmark ~uri ~group ~error))))))
(export g_bookmark_file_has_group)

;; extern gchar **g_bookmark_file_get_groups(GBookmarkFile *bookmark, const 
;;     gchar *uri, gsize *length, GError **error);
;; ... failed.

;; extern void g_bookmark_file_add_application(GBookmarkFile *bookmark, const 
;;     gchar *uri, const gchar *name, const gchar *exec);
(define g_bookmark_file_add_application
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_bookmark_file_add_application"
                (dynamic-link))
              (list '* '* '* '*))))
    (lambda (bookmark uri name exec)
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap-gchar* uri))
            (~name (unwrap-gchar* name))
            (~exec (unwrap-gchar* exec)))
        (~f ~bookmark ~uri ~name ~exec)))))
(export g_bookmark_file_add_application)

;; extern gboolean g_bookmark_file_has_application(GBookmarkFile *bookmark, 
;;     const gchar *uri, const gchar *name, GError **error);
(define g_bookmark_file_has_application
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_bookmark_file_has_application"
                (dynamic-link))
              (list '* '* '* '*))))
    (lambda (bookmark uri name error)
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap-gchar* uri))
            (~name (unwrap-gchar* name))
            (~error (unwrap~pointer error)))
        (wrap-gboolean (~f ~bookmark ~uri ~name ~error))))))
(export g_bookmark_file_has_application)

;; extern gchar **g_bookmark_file_get_applications(GBookmarkFile *bookmark, 
;;     const gchar *uri, gsize *length, GError **error);
;; ... failed.

;; extern gboolean g_bookmark_file_set_app_info(GBookmarkFile *bookmark, const 
;;     gchar *uri, const gchar *name, const gchar *exec, gint count, time_t 
;;     stamp, GError **error);
(define g_bookmark_file_set_app_info
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_bookmark_file_set_app_info"
                (dynamic-link))
              (list '* '* '* '* ffi:int ffi:long '*))))
    (lambda (bookmark uri name exec count stamp error)
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap-gchar* uri))
            (~name (unwrap-gchar* name))
            (~exec (unwrap-gchar* exec))
            (~count (unwrap-gint count))
            (~stamp (unwrap~fixed stamp))
            (~error (unwrap~pointer error)))
        (wrap-gboolean
          (~f ~bookmark
              ~uri
              ~name
              ~exec
              ~count
              ~stamp
              ~error))))))
(export g_bookmark_file_set_app_info)

;; extern gboolean g_bookmark_file_get_app_info(GBookmarkFile *bookmark, const 
;;     gchar *uri, const gchar *name, gchar **exec, guint *count, time_t *stamp
;;     , GError **error);
(define g_bookmark_file_get_app_info
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_bookmark_file_get_app_info"
                (dynamic-link))
              (list '* '* '* '* '* '* '*))))
    (lambda (bookmark uri name exec count stamp error)
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap-gchar* uri))
            (~name (unwrap-gchar* name))
            (~exec (unwrap~pointer exec))
            (~count (unwrap-guint* count))
            (~stamp (unwrap~pointer stamp))
            (~error (unwrap~pointer error)))
        (wrap-gboolean
          (~f ~bookmark
              ~uri
              ~name
              ~exec
              ~count
              ~stamp
              ~error))))))
(export g_bookmark_file_get_app_info)

;; extern void g_bookmark_file_set_is_private(GBookmarkFile *bookmark, const 
;;     gchar *uri, gboolean is_private);
(define g_bookmark_file_set_is_private
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_bookmark_file_set_is_private"
                (dynamic-link))
              (list '* '* ffi:int))))
    (lambda (bookmark uri is_private)
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap-gchar* uri))
            (~is_private (unwrap-gboolean is_private)))
        (~f ~bookmark ~uri ~is_private)))))
(export g_bookmark_file_set_is_private)

;; extern gboolean g_bookmark_file_get_is_private(GBookmarkFile *bookmark, 
;;     const gchar *uri, GError **error);
(define g_bookmark_file_get_is_private
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_bookmark_file_get_is_private"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (bookmark uri error)
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap-gchar* uri))
            (~error (unwrap~pointer error)))
        (wrap-gboolean (~f ~bookmark ~uri ~error))))))
(export g_bookmark_file_get_is_private)

;; extern void g_bookmark_file_set_icon(GBookmarkFile *bookmark, const gchar *
;;     uri, const gchar *href, const gchar *mime_type);
(define g_bookmark_file_set_icon
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_bookmark_file_set_icon"
                (dynamic-link))
              (list '* '* '* '*))))
    (lambda (bookmark uri href mime_type)
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap-gchar* uri))
            (~href (unwrap-gchar* href))
            (~mime_type (unwrap-gchar* mime_type)))
        (~f ~bookmark ~uri ~href ~mime_type)))))
(export g_bookmark_file_set_icon)

;; extern gboolean g_bookmark_file_get_icon(GBookmarkFile *bookmark, const 
;;     gchar *uri, gchar **href, gchar **mime_type, GError **error);
(define g_bookmark_file_get_icon
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_bookmark_file_get_icon"
                (dynamic-link))
              (list '* '* '* '* '*))))
    (lambda (bookmark uri href mime_type error)
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap-gchar* uri))
            (~href (unwrap~pointer href))
            (~mime_type (unwrap~pointer mime_type))
            (~error (unwrap~pointer error)))
        (wrap-gboolean
          (~f ~bookmark ~uri ~href ~mime_type ~error))))))
(export g_bookmark_file_get_icon)

;; extern void g_bookmark_file_set_added(GBookmarkFile *bookmark, const gchar *
;;     uri, time_t added);
(define g_bookmark_file_set_added
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_bookmark_file_set_added"
                (dynamic-link))
              (list '* '* ffi:long))))
    (lambda (bookmark uri added)
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap-gchar* uri))
            (~added (unwrap~fixed added)))
        (~f ~bookmark ~uri ~added)))))
(export g_bookmark_file_set_added)

;; extern time_t g_bookmark_file_get_added(GBookmarkFile *bookmark, const gchar
;;      *uri, GError **error);
(define g_bookmark_file_get_added
  (let ((~f (ffi:pointer->procedure
              ffi:long
              (dynamic-func
                "g_bookmark_file_get_added"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (bookmark uri error)
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap-gchar* uri))
            (~error (unwrap~pointer error)))
        (~f ~bookmark ~uri ~error)))))
(export g_bookmark_file_get_added)

;; extern void g_bookmark_file_set_modified(GBookmarkFile *bookmark, const 
;;     gchar *uri, time_t modified);
(define g_bookmark_file_set_modified
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_bookmark_file_set_modified"
                (dynamic-link))
              (list '* '* ffi:long))))
    (lambda (bookmark uri modified)
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap-gchar* uri))
            (~modified (unwrap~fixed modified)))
        (~f ~bookmark ~uri ~modified)))))
(export g_bookmark_file_set_modified)

;; extern time_t g_bookmark_file_get_modified(GBookmarkFile *bookmark, const 
;;     gchar *uri, GError **error);
(define g_bookmark_file_get_modified
  (let ((~f (ffi:pointer->procedure
              ffi:long
              (dynamic-func
                "g_bookmark_file_get_modified"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (bookmark uri error)
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap-gchar* uri))
            (~error (unwrap~pointer error)))
        (~f ~bookmark ~uri ~error)))))
(export g_bookmark_file_get_modified)

;; extern void g_bookmark_file_set_visited(GBookmarkFile *bookmark, const gchar
;;      *uri, time_t visited);
(define g_bookmark_file_set_visited
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_bookmark_file_set_visited"
                (dynamic-link))
              (list '* '* ffi:long))))
    (lambda (bookmark uri visited)
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap-gchar* uri))
            (~visited (unwrap~fixed visited)))
        (~f ~bookmark ~uri ~visited)))))
(export g_bookmark_file_set_visited)

;; extern time_t g_bookmark_file_get_visited(GBookmarkFile *bookmark, const 
;;     gchar *uri, GError **error);
(define g_bookmark_file_get_visited
  (let ((~f (ffi:pointer->procedure
              ffi:long
              (dynamic-func
                "g_bookmark_file_get_visited"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (bookmark uri error)
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap-gchar* uri))
            (~error (unwrap~pointer error)))
        (~f ~bookmark ~uri ~error)))))
(export g_bookmark_file_get_visited)

;; extern gboolean g_bookmark_file_has_item(GBookmarkFile *bookmark, const 
;;     gchar *uri);
(define g_bookmark_file_has_item
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_bookmark_file_has_item"
                (dynamic-link))
              (list '* '*))))
    (lambda (bookmark uri)
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap-gchar* uri)))
        (wrap-gboolean (~f ~bookmark ~uri))))))
(export g_bookmark_file_has_item)

;; extern gint g_bookmark_file_get_size(GBookmarkFile *bookmark);
(define g_bookmark_file_get_size
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_bookmark_file_get_size"
                (dynamic-link))
              (list '*))))
    (lambda (bookmark)
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark)))
        (wrap-gint (~f ~bookmark))))))
(export g_bookmark_file_get_size)

;; extern gchar **g_bookmark_file_get_uris(GBookmarkFile *bookmark, gsize *
;;     length);
;; ... failed.

;; extern gboolean g_bookmark_file_remove_group(GBookmarkFile *bookmark, const 
;;     gchar *uri, const gchar *group, GError **error);
(define g_bookmark_file_remove_group
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_bookmark_file_remove_group"
                (dynamic-link))
              (list '* '* '* '*))))
    (lambda (bookmark uri group error)
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap-gchar* uri))
            (~group (unwrap-gchar* group))
            (~error (unwrap~pointer error)))
        (wrap-gboolean (~f ~bookmark ~uri ~group ~error))))))
(export g_bookmark_file_remove_group)

;; extern gboolean g_bookmark_file_remove_application(GBookmarkFile *bookmark, 
;;     const gchar *uri, const gchar *name, GError **error);
(define g_bookmark_file_remove_application
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_bookmark_file_remove_application"
                (dynamic-link))
              (list '* '* '* '*))))
    (lambda (bookmark uri name error)
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap-gchar* uri))
            (~name (unwrap-gchar* name))
            (~error (unwrap~pointer error)))
        (wrap-gboolean (~f ~bookmark ~uri ~name ~error))))))
(export g_bookmark_file_remove_application)

;; extern gboolean g_bookmark_file_remove_item(GBookmarkFile *bookmark, const 
;;     gchar *uri, GError **error);
(define g_bookmark_file_remove_item
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_bookmark_file_remove_item"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (bookmark uri error)
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap-gchar* uri))
            (~error (unwrap~pointer error)))
        (wrap-gboolean (~f ~bookmark ~uri ~error))))))
(export g_bookmark_file_remove_item)

;; extern gboolean g_bookmark_file_move_item(GBookmarkFile *bookmark, const 
;;     gchar *old_uri, const gchar *new_uri, GError **error);
(define g_bookmark_file_move_item
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_bookmark_file_move_item"
                (dynamic-link))
              (list '* '* '* '*))))
    (lambda (bookmark old_uri new_uri error)
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~old_uri (unwrap-gchar* old_uri))
            (~new_uri (unwrap-gchar* new_uri))
            (~error (unwrap~pointer error)))
        (wrap-gboolean
          (~f ~bookmark ~old_uri ~new_uri ~error))))))
(export g_bookmark_file_move_item)

;; extern GBytes *g_bytes_new(gconstpointer data, gsize size);
(define g_bytes_new
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_bytes_new" (dynamic-link))
              (list '* ffi:unsigned-long))))
    (lambda (data size)
      (let ((~data (unwrap-gconstpointer data))
            (~size (unwrap~fixed size)))
        (wrap-GBytes* (~f ~data ~size))))))
(export g_bytes_new)

;; extern GBytes *g_bytes_new_take(gpointer data, gsize size);
(define g_bytes_new_take
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_bytes_new_take" (dynamic-link))
              (list '* ffi:unsigned-long))))
    (lambda (data size)
      (let ((~data (unwrap-gpointer data))
            (~size (unwrap~fixed size)))
        (wrap-GBytes* (~f ~data ~size))))))
(export g_bytes_new_take)

;; extern GBytes *g_bytes_new_static(gconstpointer data, gsize size);
(define g_bytes_new_static
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_bytes_new_static"
                (dynamic-link))
              (list '* ffi:unsigned-long))))
    (lambda (data size)
      (let ((~data (unwrap-gconstpointer data))
            (~size (unwrap~fixed size)))
        (wrap-GBytes* (~f ~data ~size))))))
(export g_bytes_new_static)

;; extern GBytes *g_bytes_new_with_free_func(gconstpointer data, gsize size, 
;;     GDestroyNotify free_func, gpointer user_data);
(define g_bytes_new_with_free_func
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_bytes_new_with_free_func"
                (dynamic-link))
              (list '* ffi:unsigned-long '* '*))))
    (lambda (data size free_func user_data)
      (let ((~data (unwrap-gconstpointer data))
            (~size (unwrap~fixed size))
            (~free_func
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               free_func))
            (~user_data (unwrap-gpointer user_data)))
        (wrap-GBytes*
          (~f ~data ~size ~free_func ~user_data))))))
(export g_bytes_new_with_free_func)

;; extern GBytes *g_bytes_new_from_bytes(GBytes *bytes, gsize offset, gsize 
;;     length);
(define g_bytes_new_from_bytes
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_bytes_new_from_bytes"
                (dynamic-link))
              (list '* ffi:unsigned-long ffi:unsigned-long))))
    (lambda (bytes offset length)
      (let ((~bytes (unwrap-GBytes* bytes))
            (~offset (unwrap~fixed offset))
            (~length (unwrap~fixed length)))
        (wrap-GBytes* (~f ~bytes ~offset ~length))))))
(export g_bytes_new_from_bytes)

;; extern gconstpointer g_bytes_get_data(GBytes *bytes, gsize *size);
(define g_bytes_get_data
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_bytes_get_data" (dynamic-link))
              (list '* '*))))
    (lambda (bytes size)
      (let ((~bytes (unwrap-GBytes* bytes))
            (~size (unwrap~pointer size)))
        (wrap-gconstpointer (~f ~bytes ~size))))))
(export g_bytes_get_data)

;; extern gsize g_bytes_get_size(GBytes *bytes);
(define g_bytes_get_size
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-long
              (dynamic-func "g_bytes_get_size" (dynamic-link))
              (list '*))))
    (lambda (bytes)
      (let ((~bytes (unwrap-GBytes* bytes)))
        (~f ~bytes)))))
(export g_bytes_get_size)

;; extern GBytes *g_bytes_ref(GBytes *bytes);
(define g_bytes_ref
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_bytes_ref" (dynamic-link))
              (list '*))))
    (lambda (bytes)
      (let ((~bytes (unwrap-GBytes* bytes)))
        (wrap-GBytes* (~f ~bytes))))))
(export g_bytes_ref)

;; extern void g_bytes_unref(GBytes *bytes);
(define g_bytes_unref
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_bytes_unref" (dynamic-link))
              (list '*))))
    (lambda (bytes)
      (let ((~bytes (unwrap-GBytes* bytes)))
        (~f ~bytes)))))
(export g_bytes_unref)

;; extern gpointer g_bytes_unref_to_data(GBytes *bytes, gsize *size);
(define g_bytes_unref_to_data
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_bytes_unref_to_data"
                (dynamic-link))
              (list '* '*))))
    (lambda (bytes size)
      (let ((~bytes (unwrap-GBytes* bytes))
            (~size (unwrap~pointer size)))
        (wrap-gpointer (~f ~bytes ~size))))))
(export g_bytes_unref_to_data)

;; extern GByteArray *g_bytes_unref_to_array(GBytes *bytes);
(define g_bytes_unref_to_array
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_bytes_unref_to_array"
                (dynamic-link))
              (list '*))))
    (lambda (bytes)
      (let ((~bytes (unwrap-GBytes* bytes)))
        (wrap-GByteArray* (~f ~bytes))))))
(export g_bytes_unref_to_array)

;; extern guint g_bytes_hash(gconstpointer bytes);
(define g_bytes_hash
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func "g_bytes_hash" (dynamic-link))
              (list '*))))
    (lambda (bytes)
      (let ((~bytes (unwrap-gconstpointer bytes)))
        (wrap-guint (~f ~bytes))))))
(export g_bytes_hash)

;; extern gboolean g_bytes_equal(gconstpointer bytes1, gconstpointer bytes2);
(define g_bytes_equal
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_bytes_equal" (dynamic-link))
              (list '* '*))))
    (lambda (bytes1 bytes2)
      (let ((~bytes1 (unwrap-gconstpointer bytes1))
            (~bytes2 (unwrap-gconstpointer bytes2)))
        (wrap-gboolean (~f ~bytes1 ~bytes2))))))
(export g_bytes_equal)

;; extern gint g_bytes_compare(gconstpointer bytes1, gconstpointer bytes2);
(define g_bytes_compare
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_bytes_compare" (dynamic-link))
              (list '* '*))))
    (lambda (bytes1 bytes2)
      (let ((~bytes1 (unwrap-gconstpointer bytes1))
            (~bytes2 (unwrap-gconstpointer bytes2)))
        (wrap-gint (~f ~bytes1 ~bytes2))))))
(export g_bytes_compare)

;; extern gboolean g_get_charset(const char **charset);
(define g_get_charset
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_get_charset" (dynamic-link))
              (list '*))))
    (lambda (charset)
      (let ((~charset (unwrap~pointer charset)))
        (wrap-gboolean (~f ~charset))))))
(export g_get_charset)

;; extern gchar *g_get_codeset(void);
(define g_get_codeset
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_get_codeset" (dynamic-link))
              (list))))
    (lambda () (let () (wrap-gchar* (~f))))))
(export g_get_codeset)

;; extern const gchar *const*g_get_language_names(void);
;; ... failed.

;; extern gchar **g_get_locale_variants(const gchar *locale);
;; ... failed.

;; typedef enum {
;;   G_CHECKSUM_MD5,
;;   G_CHECKSUM_SHA1,
;;   G_CHECKSUM_SHA256,
;;   G_CHECKSUM_SHA512,
;;   G_CHECKSUM_SHA384,
;; } GChecksumType;
(define-fh-enum GChecksumType
  '((G_CHECKSUM_MD5 . 0)
    (G_CHECKSUM_SHA1 . 1)
    (G_CHECKSUM_SHA256 . 2)
    (G_CHECKSUM_SHA512 . 3)
    (G_CHECKSUM_SHA384 . 4))
  )

;; typedef struct _GChecksum GChecksum;
(define GChecksum-desc void)
(define GChecksum*-desc (bs:pointer GChecksum-desc))
(define-fh-pointer-type GChecksum* GChecksum*-desc)

;; extern gssize g_checksum_type_get_length(GChecksumType checksum_type);
;; ... failed.

;; extern GChecksum *g_checksum_new(GChecksumType checksum_type);
(define g_checksum_new
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_checksum_new" (dynamic-link))
              (list ffi:int))))
    (lambda (checksum_type)
      (let ((~checksum_type (unwrap~fixed checksum_type)))
        (wrap-GChecksum* (~f ~checksum_type))))))
(export g_checksum_new)

;; extern void g_checksum_reset(GChecksum *checksum);
(define g_checksum_reset
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_checksum_reset" (dynamic-link))
              (list '*))))
    (lambda (checksum)
      (let ((~checksum (unwrap-GChecksum* checksum)))
        (~f ~checksum)))))
(export g_checksum_reset)

;; extern GChecksum *g_checksum_copy(const GChecksum *checksum);
(define g_checksum_copy
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_checksum_copy" (dynamic-link))
              (list '*))))
    (lambda (checksum)
      (let ((~checksum (unwrap-GChecksum* checksum)))
        (wrap-GChecksum* (~f ~checksum))))))
(export g_checksum_copy)

;; extern void g_checksum_free(GChecksum *checksum);
(define g_checksum_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_checksum_free" (dynamic-link))
              (list '*))))
    (lambda (checksum)
      (let ((~checksum (unwrap-GChecksum* checksum)))
        (~f ~checksum)))))
(export g_checksum_free)

;; extern void g_checksum_update(GChecksum *checksum, const guchar *data, 
;;     gssize length);
;; ... failed.

;; extern const gchar *g_checksum_get_string(GChecksum *checksum);
(define g_checksum_get_string
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_checksum_get_string"
                (dynamic-link))
              (list '*))))
    (lambda (checksum)
      (let ((~checksum (unwrap-GChecksum* checksum)))
        (wrap-gchar* (~f ~checksum))))))
(export g_checksum_get_string)

;; extern void g_checksum_get_digest(GChecksum *checksum, guint8 *buffer, gsize
;;      *digest_len);
(define g_checksum_get_digest
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_checksum_get_digest"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (checksum buffer digest_len)
      (let ((~checksum (unwrap-GChecksum* checksum))
            (~buffer (unwrap~pointer buffer))
            (~digest_len (unwrap~pointer digest_len)))
        (~f ~checksum ~buffer ~digest_len)))))
(export g_checksum_get_digest)

;; extern gchar *g_compute_checksum_for_data(GChecksumType checksum_type, const
;;      guchar *data, gsize length);
(define g_compute_checksum_for_data
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_compute_checksum_for_data"
                (dynamic-link))
              (list ffi:int '* ffi:unsigned-long))))
    (lambda (checksum_type data length)
      (let ((~checksum_type (unwrap~fixed checksum_type))
            (~data (unwrap-guchar* data))
            (~length (unwrap~fixed length)))
        (wrap-gchar* (~f ~checksum_type ~data ~length))))))
(export g_compute_checksum_for_data)

;; extern gchar *g_compute_checksum_for_string(GChecksumType checksum_type, 
;;     const gchar *str, gssize length);
;; ... failed.

;; extern gchar *g_compute_checksum_for_bytes(GChecksumType checksum_type, 
;;     GBytes *data);
(define g_compute_checksum_for_bytes
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_compute_checksum_for_bytes"
                (dynamic-link))
              (list ffi:int '*))))
    (lambda (checksum_type data)
      (let ((~checksum_type (unwrap~fixed checksum_type))
            (~data (unwrap-GBytes* data)))
        (wrap-gchar* (~f ~checksum_type ~data))))))
(export g_compute_checksum_for_bytes)

;; typedef enum {
;;   G_CONVERT_ERROR_NO_CONVERSION,
;;   G_CONVERT_ERROR_ILLEGAL_SEQUENCE,
;;   G_CONVERT_ERROR_FAILED,
;;   G_CONVERT_ERROR_PARTIAL_INPUT,
;;   G_CONVERT_ERROR_BAD_URI,
;;   G_CONVERT_ERROR_NOT_ABSOLUTE_PATH,
;;   G_CONVERT_ERROR_NO_MEMORY,
;; } GConvertError;
(define-fh-enum GConvertError
  '((G_CONVERT_ERROR_NO_CONVERSION . 0)
    (G_CONVERT_ERROR_ILLEGAL_SEQUENCE . 1)
    (G_CONVERT_ERROR_FAILED . 2)
    (G_CONVERT_ERROR_PARTIAL_INPUT . 3)
    (G_CONVERT_ERROR_BAD_URI . 4)
    (G_CONVERT_ERROR_NOT_ABSOLUTE_PATH . 5)
    (G_CONVERT_ERROR_NO_MEMORY . 6))
  )

;; extern GQuark g_convert_error_quark(void);
(define g_convert_error_quark
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func
                "g_convert_error_quark"
                (dynamic-link))
              (list))))
    (lambda () (let () (wrap-GQuark (~f))))))
(export g_convert_error_quark)

;; typedef struct _GIConv *GIConv;
(define-fh-pointer-type GIConv)

;; extern GIConv g_iconv_open(const gchar *to_codeset, const gchar *
;;     from_codeset);
(define g_iconv_open
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_iconv_open" (dynamic-link))
              (list '* '*))))
    (lambda (to_codeset from_codeset)
      (let ((~to_codeset (unwrap-gchar* to_codeset))
            (~from_codeset (unwrap-gchar* from_codeset)))
        (~f ~to_codeset ~from_codeset)))))
(export g_iconv_open)

;; extern gsize g_iconv(GIConv converter, gchar **inbuf, gsize *inbytes_left, 
;;     gchar **outbuf, gsize *outbytes_left);
(define g_iconv
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-long
              (dynamic-func "g_iconv" (dynamic-link))
              (list '* '* '* '* '*))))
    (lambda (converter
             inbuf
             inbytes_left
             outbuf
             outbytes_left)
      (let ((~converter (unwrap~pointer converter))
            (~inbuf (unwrap~pointer inbuf))
            (~inbytes_left (unwrap~pointer inbytes_left))
            (~outbuf (unwrap~pointer outbuf))
            (~outbytes_left (unwrap~pointer outbytes_left)))
        (~f ~converter
            ~inbuf
            ~inbytes_left
            ~outbuf
            ~outbytes_left)))))
(export g_iconv)

;; extern gint g_iconv_close(GIConv converter);
(define g_iconv_close
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_iconv_close" (dynamic-link))
              (list '*))))
    (lambda (converter)
      (let ((~converter (unwrap~pointer converter)))
        (wrap-gint (~f ~converter))))))
(export g_iconv_close)

;; extern gchar *g_convert(const gchar *str, gssize len, const gchar *
;;     to_codeset, const gchar *from_codeset, gsize *bytes_read, gsize *
;;     bytes_written, GError **error);
;; ... failed.

;; extern gchar *g_convert_with_iconv(const gchar *str, gssize len, GIConv 
;;     converter, gsize *bytes_read, gsize *bytes_written, GError **error);
;; ... failed.

;; extern gchar *g_convert_with_fallback(const gchar *str, gssize len, const 
;;     gchar *to_codeset, const gchar *from_codeset, const gchar *fallback, 
;;     gsize *bytes_read, gsize *bytes_written, GError **error);
;; ... failed.

;; extern gchar *g_locale_to_utf8(const gchar *opsysstring, gssize len, gsize *
;;     bytes_read, gsize *bytes_written, GError **error);
;; ... failed.

;; extern gchar *g_locale_from_utf8(const gchar *utf8string, gssize len, gsize 
;;     *bytes_read, gsize *bytes_written, GError **error);
;; ... failed.

;; extern gchar *g_filename_to_utf8(const gchar *opsysstring, gssize len, gsize
;;      *bytes_read, gsize *bytes_written, GError **error);
;; ... failed.

;; extern gchar *g_filename_from_utf8(const gchar *utf8string, gssize len, 
;;     gsize *bytes_read, gsize *bytes_written, GError **error);
;; ... failed.

;; extern gchar *g_filename_from_uri(const gchar *uri, gchar **hostname, GError
;;      **error);
(define g_filename_from_uri
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_filename_from_uri"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (uri hostname error)
      (let ((~uri (unwrap-gchar* uri))
            (~hostname (unwrap~pointer hostname))
            (~error (unwrap~pointer error)))
        (wrap-gchar* (~f ~uri ~hostname ~error))))))
(export g_filename_from_uri)

;; extern gchar *g_filename_to_uri(const gchar *filename, const gchar *hostname
;;     , GError **error);
(define g_filename_to_uri
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_filename_to_uri" (dynamic-link))
              (list '* '* '*))))
    (lambda (filename hostname error)
      (let ((~filename (unwrap-gchar* filename))
            (~hostname (unwrap-gchar* hostname))
            (~error (unwrap~pointer error)))
        (wrap-gchar* (~f ~filename ~hostname ~error))))))
(export g_filename_to_uri)

;; extern gchar *g_filename_display_name(const gchar *filename);
(define g_filename_display_name
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_filename_display_name"
                (dynamic-link))
              (list '*))))
    (lambda (filename)
      (let ((~filename (unwrap-gchar* filename)))
        (wrap-gchar* (~f ~filename))))))
(export g_filename_display_name)

;; extern gboolean g_get_filename_charsets(const gchar ***charsets);
(define g_get_filename_charsets
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_get_filename_charsets"
                (dynamic-link))
              (list '*))))
    (lambda (charsets)
      (let ((~charsets (unwrap~pointer charsets)))
        (wrap-gboolean (~f ~charsets))))))
(export g_get_filename_charsets)

;; extern gchar *g_filename_display_basename(const gchar *filename);
(define g_filename_display_basename
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_filename_display_basename"
                (dynamic-link))
              (list '*))))
    (lambda (filename)
      (let ((~filename (unwrap-gchar* filename)))
        (wrap-gchar* (~f ~filename))))))
(export g_filename_display_basename)

;; extern gchar **g_uri_list_extract_uris(const gchar *uri_list);
;; ... failed.

;; typedef struct _GData GData;
(define GData-desc void)
(define GData*-desc (bs:pointer GData-desc))
(define-fh-pointer-type GData* GData*-desc)

;; typedef void (*GDataForeachFunc)(GQuark key_id, gpointer data, gpointer 
;;     user_data);
(define-fh-function/p GDataForeachFunc
  ffi:void (list ffi:unsigned-int (quote *) (quote *)))

;; extern void g_datalist_init(GData **datalist);
(define g_datalist_init
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_datalist_init" (dynamic-link))
              (list '*))))
    (lambda (datalist)
      (let ((~datalist (unwrap~pointer datalist)))
        (~f ~datalist)))))
(export g_datalist_init)

;; extern void g_datalist_clear(GData **datalist);
(define g_datalist_clear
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_datalist_clear" (dynamic-link))
              (list '*))))
    (lambda (datalist)
      (let ((~datalist (unwrap~pointer datalist)))
        (~f ~datalist)))))
(export g_datalist_clear)

;; extern gpointer g_datalist_id_get_data(GData **datalist, GQuark key_id);
(define g_datalist_id_get_data
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_datalist_id_get_data"
                (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (datalist key_id)
      (let ((~datalist (unwrap~pointer datalist))
            (~key_id (unwrap-GQuark key_id)))
        (wrap-gpointer (~f ~datalist ~key_id))))))
(export g_datalist_id_get_data)

;; extern void g_datalist_id_set_data_full(GData **datalist, GQuark key_id, 
;;     gpointer data, GDestroyNotify destroy_func);
(define g_datalist_id_set_data_full
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_datalist_id_set_data_full"
                (dynamic-link))
              (list '* ffi:unsigned-int '* '*))))
    (lambda (datalist key_id data destroy_func)
      (let ((~datalist (unwrap~pointer datalist))
            (~key_id (unwrap-GQuark key_id))
            (~data (unwrap-gpointer data))
            (~destroy_func
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               destroy_func)))
        (~f ~datalist ~key_id ~data ~destroy_func)))))
(export g_datalist_id_set_data_full)

;; typedef gpointer (*GDuplicateFunc)(gpointer data, gpointer user_data);
(define-fh-function/p GDuplicateFunc
  (quote *) (list (quote *) (quote *)))

;; extern gpointer g_datalist_id_dup_data(GData **datalist, GQuark key_id, 
;;     GDuplicateFunc dup_func, gpointer user_data);
;; ... failed.

;; extern gboolean g_datalist_id_replace_data(GData **datalist, GQuark key_id, 
;;     gpointer oldval, gpointer newval, GDestroyNotify destroy, GDestroyNotify
;;      *old_destroy);
(define g_datalist_id_replace_data
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_datalist_id_replace_data"
                (dynamic-link))
              (list '* ffi:unsigned-int '* '* '* '*))))
    (lambda (datalist
             key_id
             oldval
             newval
             destroy
             old_destroy)
      (let ((~datalist (unwrap~pointer datalist))
            (~key_id (unwrap-GQuark key_id))
            (~oldval (unwrap-gpointer oldval))
            (~newval (unwrap-gpointer newval))
            (~destroy
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               destroy))
            (~old_destroy (unwrap~pointer old_destroy)))
        (wrap-gboolean
          (~f ~datalist
              ~key_id
              ~oldval
              ~newval
              ~destroy
              ~old_destroy))))))
(export g_datalist_id_replace_data)

;; extern gpointer g_datalist_id_remove_no_notify(GData **datalist, GQuark 
;;     key_id);
(define g_datalist_id_remove_no_notify
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_datalist_id_remove_no_notify"
                (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (datalist key_id)
      (let ((~datalist (unwrap~pointer datalist))
            (~key_id (unwrap-GQuark key_id)))
        (wrap-gpointer (~f ~datalist ~key_id))))))
(export g_datalist_id_remove_no_notify)

;; extern void g_datalist_foreach(GData **datalist, GDataForeachFunc func, 
;;     gpointer user_data);
(define g_datalist_foreach
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_datalist_foreach"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (datalist func user_data)
      (let ((~datalist (unwrap~pointer datalist))
            (~func ((make-ftn-arg-unwrapper
                      ffi:void
                      (list ffi:unsigned-int '* '*))
                    func))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~datalist ~func ~user_data)))))
(export g_datalist_foreach)

;; extern void g_datalist_set_flags(GData **datalist, guint flags);
(define g_datalist_set_flags
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_datalist_set_flags"
                (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (datalist flags)
      (let ((~datalist (unwrap~pointer datalist))
            (~flags (unwrap-guint flags)))
        (~f ~datalist ~flags)))))
(export g_datalist_set_flags)

;; extern void g_datalist_unset_flags(GData **datalist, guint flags);
(define g_datalist_unset_flags
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_datalist_unset_flags"
                (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (datalist flags)
      (let ((~datalist (unwrap~pointer datalist))
            (~flags (unwrap-guint flags)))
        (~f ~datalist ~flags)))))
(export g_datalist_unset_flags)

;; extern guint g_datalist_get_flags(GData **datalist);
(define g_datalist_get_flags
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func
                "g_datalist_get_flags"
                (dynamic-link))
              (list '*))))
    (lambda (datalist)
      (let ((~datalist (unwrap~pointer datalist)))
        (wrap-guint (~f ~datalist))))))
(export g_datalist_get_flags)

;; extern void g_dataset_destroy(gconstpointer dataset_location);
(define g_dataset_destroy
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_dataset_destroy" (dynamic-link))
              (list '*))))
    (lambda (dataset_location)
      (let ((~dataset_location
              (unwrap-gconstpointer dataset_location)))
        (~f ~dataset_location)))))
(export g_dataset_destroy)

;; extern gpointer g_dataset_id_get_data(gconstpointer dataset_location, GQuark
;;      key_id);
(define g_dataset_id_get_data
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_dataset_id_get_data"
                (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (dataset_location key_id)
      (let ((~dataset_location
              (unwrap-gconstpointer dataset_location))
            (~key_id (unwrap-GQuark key_id)))
        (wrap-gpointer (~f ~dataset_location ~key_id))))))
(export g_dataset_id_get_data)

;; extern gpointer g_datalist_get_data(GData **datalist, const gchar *key);
(define g_datalist_get_data
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_datalist_get_data"
                (dynamic-link))
              (list '* '*))))
    (lambda (datalist key)
      (let ((~datalist (unwrap~pointer datalist))
            (~key (unwrap-gchar* key)))
        (wrap-gpointer (~f ~datalist ~key))))))
(export g_datalist_get_data)

;; extern void g_dataset_id_set_data_full(gconstpointer dataset_location, 
;;     GQuark key_id, gpointer data, GDestroyNotify destroy_func);
(define g_dataset_id_set_data_full
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_dataset_id_set_data_full"
                (dynamic-link))
              (list '* ffi:unsigned-int '* '*))))
    (lambda (dataset_location key_id data destroy_func)
      (let ((~dataset_location
              (unwrap-gconstpointer dataset_location))
            (~key_id (unwrap-GQuark key_id))
            (~data (unwrap-gpointer data))
            (~destroy_func
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               destroy_func)))
        (~f ~dataset_location
            ~key_id
            ~data
            ~destroy_func)))))
(export g_dataset_id_set_data_full)

;; extern gpointer g_dataset_id_remove_no_notify(gconstpointer dataset_location
;;     , GQuark key_id);
(define g_dataset_id_remove_no_notify
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_dataset_id_remove_no_notify"
                (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (dataset_location key_id)
      (let ((~dataset_location
              (unwrap-gconstpointer dataset_location))
            (~key_id (unwrap-GQuark key_id)))
        (wrap-gpointer (~f ~dataset_location ~key_id))))))
(export g_dataset_id_remove_no_notify)

;; extern void g_dataset_foreach(gconstpointer dataset_location, 
;;     GDataForeachFunc func, gpointer user_data);
(define g_dataset_foreach
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_dataset_foreach" (dynamic-link))
              (list '* '* '*))))
    (lambda (dataset_location func user_data)
      (let ((~dataset_location
              (unwrap-gconstpointer dataset_location))
            (~func ((make-ftn-arg-unwrapper
                      ffi:void
                      (list ffi:unsigned-int '* '*))
                    func))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~dataset_location ~func ~user_data)))))
(export g_dataset_foreach)

;; typedef gint32 GTime;
(define GTime-desc signed int-desc)
(export GTime-desc)
(define unwrap-GTime unwrap~fixed)
(define wrap-GTime identity)

;; typedef guint16 GDateYear;
(define GDateYear-desc unsigned-short)
(export GDateYear-desc)
(define unwrap-GDateYear unwrap~fixed)
(define wrap-GDateYear identity)

;; typedef guint8 GDateDay; /* day of the month */
(define GDateDay-desc unsigned char-desc)
(export GDateDay-desc)
(define unwrap-GDateDay unwrap~fixed)
(define wrap-GDateDay identity)

;; typedef struct _GDate GDate;
(define GDate-desc void)
(define GDate*-desc (bs:pointer (delay GDate-desc)))
(define-fh-pointer-type GDate* GDate*-desc)

;; typedef enum {
;;   G_DATE_DAY = 0,
;;   G_DATE_MONTH = 1,
;;   G_DATE_YEAR = 2,
;; } GDateDMY;
(define-fh-enum GDateDMY
  '((G_DATE_DAY . 0)
    (G_DATE_MONTH . 1)
    (G_DATE_YEAR . 2))
  )

;; typedef enum {
;;   G_DATE_BAD_WEEKDAY = 0,
;;   G_DATE_MONDAY = 1,
;;   G_DATE_TUESDAY = 2,
;;   G_DATE_WEDNESDAY = 3,
;;   G_DATE_THURSDAY = 4,
;;   G_DATE_FRIDAY = 5,
;;   G_DATE_SATURDAY = 6,
;;   G_DATE_SUNDAY = 7,
;; } GDateWeekday;
(define-fh-enum GDateWeekday
  '((G_DATE_BAD_WEEKDAY . 0)
    (G_DATE_MONDAY . 1)
    (G_DATE_TUESDAY . 2)
    (G_DATE_WEDNESDAY . 3)
    (G_DATE_THURSDAY . 4)
    (G_DATE_FRIDAY . 5)
    (G_DATE_SATURDAY . 6)
    (G_DATE_SUNDAY . 7))
  )

;; typedef enum {
;;   G_DATE_BAD_MONTH = 0,
;;   G_DATE_JANUARY = 1,
;;   G_DATE_FEBRUARY = 2,
;;   G_DATE_MARCH = 3,
;;   G_DATE_APRIL = 4,
;;   G_DATE_MAY = 5,
;;   G_DATE_JUNE = 6,
;;   G_DATE_JULY = 7,
;;   G_DATE_AUGUST = 8,
;;   G_DATE_SEPTEMBER = 9,
;;   G_DATE_OCTOBER = 10,
;;   G_DATE_NOVEMBER = 11,
;;   G_DATE_DECEMBER = 12,
;; } GDateMonth;
(define-fh-enum GDateMonth
  '((G_DATE_BAD_MONTH . 0)
    (G_DATE_JANUARY . 1)
    (G_DATE_FEBRUARY . 2)
    (G_DATE_MARCH . 3)
    (G_DATE_APRIL . 4)
    (G_DATE_MAY . 5)
    (G_DATE_JUNE . 6)
    (G_DATE_JULY . 7)
    (G_DATE_AUGUST . 8)
    (G_DATE_SEPTEMBER . 9)
    (G_DATE_OCTOBER . 10)
    (G_DATE_NOVEMBER . 11)
    (G_DATE_DECEMBER . 12))
  )

;; struct _GDate {
;;   guint julian_days : 32; /* julian days representation - we use a
;;    *  bitfield hoping that 64 bit platforms
;;    *  will pack this whole struct in one big
;;    *  int
;;    */
;;   guint julian : 1; /* julian is valid */
;;   guint dmy : 1; /* dmy is valid */
;;   /* DMY representation */
;;   guint day : 6;
;;   guint month : 4;
;;   guint year : 16;
;; };
(define struct-_GDate-desc
  (bs:struct
    (list `(julian_days ,guint-desc)
          `(julian ,guint-desc)
          `(dmy ,guint-desc)
          `(day ,guint-desc)
          `(month ,guint-desc)
          `(year ,guint-desc))))
(export struct-_GDate-desc)
(define-fh-compound-type/p struct-_GDate struct-_GDate-desc)
(set! GDate-desc struct-_GDate-desc)
(define-fh-compound-type GDate GDate-desc)

;; extern GDate *g_date_new(void);
(define g_date_new
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_date_new" (dynamic-link))
              (list))))
    (lambda () (let () (wrap-GDate* (~f))))))
(export g_date_new)

;; extern GDate *g_date_new_dmy(GDateDay day, GDateMonth month, GDateYear year)
;;     ;
(define g_date_new_dmy
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_date_new_dmy" (dynamic-link))
              (list ffi:unsigned-int
                    ffi:int
                    ffi:unsigned-short))))
    (lambda (day month year)
      (let ((~day (unwrap-GDateDay day))
            (~month (unwrap~fixed month))
            (~year (unwrap-GDateYear year)))
        (wrap-GDate* (~f ~day ~month ~year))))))
(export g_date_new_dmy)

;; extern GDate *g_date_new_julian(guint32 julian_day);
(define g_date_new_julian
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_date_new_julian" (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (julian_day)
      (let ((~julian_day (unwrap~fixed julian_day)))
        (wrap-GDate* (~f ~julian_day))))))
(export g_date_new_julian)

;; extern void g_date_free(GDate *date);
(define g_date_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_date_free" (dynamic-link))
              (list '*))))
    (lambda (date)
      (let ((~date (unwrap-GDate* date))) (~f ~date)))))
(export g_date_free)

;; extern gboolean g_date_valid(const GDate *date);
(define g_date_valid
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_date_valid" (dynamic-link))
              (list '*))))
    (lambda (date)
      (let ((~date (unwrap-GDate* date)))
        (wrap-gboolean (~f ~date))))))
(export g_date_valid)

;; extern gboolean g_date_valid_day(GDateDay day);
(define g_date_valid_day
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_date_valid_day" (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (day)
      (let ((~day (unwrap-GDateDay day)))
        (wrap-gboolean (~f ~day))))))
(export g_date_valid_day)

;; extern gboolean g_date_valid_month(GDateMonth month);
(define g_date_valid_month
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_date_valid_month"
                (dynamic-link))
              (list ffi:int))))
    (lambda (month)
      (let ((~month (unwrap~fixed month)))
        (wrap-gboolean (~f ~month))))))
(export g_date_valid_month)

;; extern gboolean g_date_valid_year(GDateYear year);
(define g_date_valid_year
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_date_valid_year" (dynamic-link))
              (list ffi:unsigned-short))))
    (lambda (year)
      (let ((~year (unwrap-GDateYear year)))
        (wrap-gboolean (~f ~year))))))
(export g_date_valid_year)

;; extern gboolean g_date_valid_weekday(GDateWeekday weekday);
(define g_date_valid_weekday
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_date_valid_weekday"
                (dynamic-link))
              (list ffi:int))))
    (lambda (weekday)
      (let ((~weekday (unwrap~fixed weekday)))
        (wrap-gboolean (~f ~weekday))))))
(export g_date_valid_weekday)

;; extern gboolean g_date_valid_julian(guint32 julian_date);
(define g_date_valid_julian
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_date_valid_julian"
                (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (julian_date)
      (let ((~julian_date (unwrap~fixed julian_date)))
        (wrap-gboolean (~f ~julian_date))))))
(export g_date_valid_julian)

;; extern gboolean g_date_valid_dmy(GDateDay day, GDateMonth month, GDateYear 
;;     year);
(define g_date_valid_dmy
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_date_valid_dmy" (dynamic-link))
              (list ffi:unsigned-int
                    ffi:int
                    ffi:unsigned-short))))
    (lambda (day month year)
      (let ((~day (unwrap-GDateDay day))
            (~month (unwrap~fixed month))
            (~year (unwrap-GDateYear year)))
        (wrap-gboolean (~f ~day ~month ~year))))))
(export g_date_valid_dmy)

;; extern GDateWeekday g_date_get_weekday(const GDate *date);
(define g_date_get_weekday
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_date_get_weekday"
                (dynamic-link))
              (list '*))))
    (lambda (date)
      (let ((~date (unwrap-GDate* date))) (~f ~date)))))
(export g_date_get_weekday)

;; extern GDateMonth g_date_get_month(const GDate *date);
(define g_date_get_month
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_date_get_month" (dynamic-link))
              (list '*))))
    (lambda (date)
      (let ((~date (unwrap-GDate* date))) (~f ~date)))))
(export g_date_get_month)

;; extern GDateYear g_date_get_year(const GDate *date);
(define g_date_get_year
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-short
              (dynamic-func "g_date_get_year" (dynamic-link))
              (list '*))))
    (lambda (date)
      (let ((~date (unwrap-GDate* date)))
        (wrap-GDateYear (~f ~date))))))
(export g_date_get_year)

;; extern GDateDay g_date_get_day(const GDate *date);
(define g_date_get_day
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func "g_date_get_day" (dynamic-link))
              (list '*))))
    (lambda (date)
      (let ((~date (unwrap-GDate* date)))
        (wrap-GDateDay (~f ~date))))))
(export g_date_get_day)

;; extern guint32 g_date_get_julian(const GDate *date);
(define g_date_get_julian
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func "g_date_get_julian" (dynamic-link))
              (list '*))))
    (lambda (date)
      (let ((~date (unwrap-GDate* date))) (~f ~date)))))
(export g_date_get_julian)

;; extern guint g_date_get_day_of_year(const GDate *date);
(define g_date_get_day_of_year
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func
                "g_date_get_day_of_year"
                (dynamic-link))
              (list '*))))
    (lambda (date)
      (let ((~date (unwrap-GDate* date)))
        (wrap-guint (~f ~date))))))
(export g_date_get_day_of_year)

;; extern guint g_date_get_monday_week_of_year(const GDate *date);
(define g_date_get_monday_week_of_year
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func
                "g_date_get_monday_week_of_year"
                (dynamic-link))
              (list '*))))
    (lambda (date)
      (let ((~date (unwrap-GDate* date)))
        (wrap-guint (~f ~date))))))
(export g_date_get_monday_week_of_year)

;; extern guint g_date_get_sunday_week_of_year(const GDate *date);
(define g_date_get_sunday_week_of_year
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func
                "g_date_get_sunday_week_of_year"
                (dynamic-link))
              (list '*))))
    (lambda (date)
      (let ((~date (unwrap-GDate* date)))
        (wrap-guint (~f ~date))))))
(export g_date_get_sunday_week_of_year)

;; extern guint g_date_get_iso8601_week_of_year(const GDate *date);
(define g_date_get_iso8601_week_of_year
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func
                "g_date_get_iso8601_week_of_year"
                (dynamic-link))
              (list '*))))
    (lambda (date)
      (let ((~date (unwrap-GDate* date)))
        (wrap-guint (~f ~date))))))
(export g_date_get_iso8601_week_of_year)

;; extern void g_date_clear(GDate *date, guint n_dates);
(define g_date_clear
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_date_clear" (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (date n_dates)
      (let ((~date (unwrap-GDate* date))
            (~n_dates (unwrap-guint n_dates)))
        (~f ~date ~n_dates)))))
(export g_date_clear)

;; extern void g_date_set_parse(GDate *date, const gchar *str);
(define g_date_set_parse
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_date_set_parse" (dynamic-link))
              (list '* '*))))
    (lambda (date str)
      (let ((~date (unwrap-GDate* date))
            (~str (unwrap-gchar* str)))
        (~f ~date ~str)))))
(export g_date_set_parse)

;; extern void g_date_set_time_t(GDate *date, time_t timet);
(define g_date_set_time_t
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_date_set_time_t" (dynamic-link))
              (list '* ffi:long))))
    (lambda (date timet)
      (let ((~date (unwrap-GDate* date))
            (~timet (unwrap~fixed timet)))
        (~f ~date ~timet)))))
(export g_date_set_time_t)

;; extern void g_date_set_time_val(GDate *date, GTimeVal *timeval);
(define g_date_set_time_val
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_date_set_time_val"
                (dynamic-link))
              (list '* '*))))
    (lambda (date timeval)
      (let ((~date (unwrap-GDate* date))
            (~timeval (unwrap-GTimeVal* timeval)))
        (~f ~date ~timeval)))))
(export g_date_set_time_val)

;; extern void g_date_set_time(GDate *date, GTime time_);
;; ... failed.

;; extern void g_date_set_month(GDate *date, GDateMonth month);
(define g_date_set_month
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_date_set_month" (dynamic-link))
              (list '* ffi:int))))
    (lambda (date month)
      (let ((~date (unwrap-GDate* date))
            (~month (unwrap~fixed month)))
        (~f ~date ~month)))))
(export g_date_set_month)

;; extern void g_date_set_day(GDate *date, GDateDay day);
(define g_date_set_day
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_date_set_day" (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (date day)
      (let ((~date (unwrap-GDate* date))
            (~day (unwrap-GDateDay day)))
        (~f ~date ~day)))))
(export g_date_set_day)

;; extern void g_date_set_year(GDate *date, GDateYear year);
(define g_date_set_year
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_date_set_year" (dynamic-link))
              (list '* ffi:unsigned-short))))
    (lambda (date year)
      (let ((~date (unwrap-GDate* date))
            (~year (unwrap-GDateYear year)))
        (~f ~date ~year)))))
(export g_date_set_year)

;; extern void g_date_set_dmy(GDate *date, GDateDay day, GDateMonth month, 
;;     GDateYear y);
(define g_date_set_dmy
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_date_set_dmy" (dynamic-link))
              (list '*
                    ffi:unsigned-int
                    ffi:int
                    ffi:unsigned-short))))
    (lambda (date day month y)
      (let ((~date (unwrap-GDate* date))
            (~day (unwrap-GDateDay day))
            (~month (unwrap~fixed month))
            (~y (unwrap-GDateYear y)))
        (~f ~date ~day ~month ~y)))))
(export g_date_set_dmy)

;; extern void g_date_set_julian(GDate *date, guint32 julian_date);
(define g_date_set_julian
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_date_set_julian" (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (date julian_date)
      (let ((~date (unwrap-GDate* date))
            (~julian_date (unwrap~fixed julian_date)))
        (~f ~date ~julian_date)))))
(export g_date_set_julian)

;; extern gboolean g_date_is_first_of_month(const GDate *date);
(define g_date_is_first_of_month
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_date_is_first_of_month"
                (dynamic-link))
              (list '*))))
    (lambda (date)
      (let ((~date (unwrap-GDate* date)))
        (wrap-gboolean (~f ~date))))))
(export g_date_is_first_of_month)

;; extern gboolean g_date_is_last_of_month(const GDate *date);
(define g_date_is_last_of_month
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_date_is_last_of_month"
                (dynamic-link))
              (list '*))))
    (lambda (date)
      (let ((~date (unwrap-GDate* date)))
        (wrap-gboolean (~f ~date))))))
(export g_date_is_last_of_month)

;; extern void g_date_add_days(GDate *date, guint n_days);
(define g_date_add_days
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_date_add_days" (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (date n_days)
      (let ((~date (unwrap-GDate* date))
            (~n_days (unwrap-guint n_days)))
        (~f ~date ~n_days)))))
(export g_date_add_days)

;; extern void g_date_subtract_days(GDate *date, guint n_days);
(define g_date_subtract_days
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_date_subtract_days"
                (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (date n_days)
      (let ((~date (unwrap-GDate* date))
            (~n_days (unwrap-guint n_days)))
        (~f ~date ~n_days)))))
(export g_date_subtract_days)

;; extern void g_date_add_months(GDate *date, guint n_months);
(define g_date_add_months
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_date_add_months" (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (date n_months)
      (let ((~date (unwrap-GDate* date))
            (~n_months (unwrap-guint n_months)))
        (~f ~date ~n_months)))))
(export g_date_add_months)

;; extern void g_date_subtract_months(GDate *date, guint n_months);
(define g_date_subtract_months
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_date_subtract_months"
                (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (date n_months)
      (let ((~date (unwrap-GDate* date))
            (~n_months (unwrap-guint n_months)))
        (~f ~date ~n_months)))))
(export g_date_subtract_months)

;; extern void g_date_add_years(GDate *date, guint n_years);
(define g_date_add_years
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_date_add_years" (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (date n_years)
      (let ((~date (unwrap-GDate* date))
            (~n_years (unwrap-guint n_years)))
        (~f ~date ~n_years)))))
(export g_date_add_years)

;; extern void g_date_subtract_years(GDate *date, guint n_years);
(define g_date_subtract_years
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_date_subtract_years"
                (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (date n_years)
      (let ((~date (unwrap-GDate* date))
            (~n_years (unwrap-guint n_years)))
        (~f ~date ~n_years)))))
(export g_date_subtract_years)

;; extern gboolean g_date_is_leap_year(GDateYear year);
(define g_date_is_leap_year
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_date_is_leap_year"
                (dynamic-link))
              (list ffi:unsigned-short))))
    (lambda (year)
      (let ((~year (unwrap-GDateYear year)))
        (wrap-gboolean (~f ~year))))))
(export g_date_is_leap_year)

;; extern guint8 g_date_get_days_in_month(GDateMonth month, GDateYear year);
(define g_date_get_days_in_month
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func
                "g_date_get_days_in_month"
                (dynamic-link))
              (list ffi:int ffi:unsigned-short))))
    (lambda (month year)
      (let ((~month (unwrap~fixed month))
            (~year (unwrap-GDateYear year)))
        (~f ~month ~year)))))
(export g_date_get_days_in_month)

;; extern guint8 g_date_get_monday_weeks_in_year(GDateYear year);
(define g_date_get_monday_weeks_in_year
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func
                "g_date_get_monday_weeks_in_year"
                (dynamic-link))
              (list ffi:unsigned-short))))
    (lambda (year)
      (let ((~year (unwrap-GDateYear year)))
        (~f ~year)))))
(export g_date_get_monday_weeks_in_year)

;; extern guint8 g_date_get_sunday_weeks_in_year(GDateYear year);
(define g_date_get_sunday_weeks_in_year
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func
                "g_date_get_sunday_weeks_in_year"
                (dynamic-link))
              (list ffi:unsigned-short))))
    (lambda (year)
      (let ((~year (unwrap-GDateYear year)))
        (~f ~year)))))
(export g_date_get_sunday_weeks_in_year)

;; extern gint g_date_days_between(const GDate *date1, const GDate *date2);
(define g_date_days_between
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_date_days_between"
                (dynamic-link))
              (list '* '*))))
    (lambda (date1 date2)
      (let ((~date1 (unwrap-GDate* date1))
            (~date2 (unwrap-GDate* date2)))
        (wrap-gint (~f ~date1 ~date2))))))
(export g_date_days_between)

;; extern gint g_date_compare(const GDate *lhs, const GDate *rhs);
(define g_date_compare
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_date_compare" (dynamic-link))
              (list '* '*))))
    (lambda (lhs rhs)
      (let ((~lhs (unwrap-GDate* lhs))
            (~rhs (unwrap-GDate* rhs)))
        (wrap-gint (~f ~lhs ~rhs))))))
(export g_date_compare)

;; extern void g_date_to_struct_tm(const GDate *date, struct tm *tm);
(define g_date_to_struct_tm
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_date_to_struct_tm"
                (dynamic-link))
              (list '* '*))))
    (lambda (date tm)
      (let ((~date (unwrap-GDate* date))
            (~tm (unwrap~pointer tm)))
        (~f ~date ~tm)))))
(export g_date_to_struct_tm)

;; extern void g_date_clamp(GDate *date, const GDate *min_date, const GDate *
;;     max_date);
(define g_date_clamp
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_date_clamp" (dynamic-link))
              (list '* '* '*))))
    (lambda (date min_date max_date)
      (let ((~date (unwrap-GDate* date))
            (~min_date (unwrap-GDate* min_date))
            (~max_date (unwrap-GDate* max_date)))
        (~f ~date ~min_date ~max_date)))))
(export g_date_clamp)

;; extern void g_date_order(GDate *date1, GDate *date2);
(define g_date_order
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_date_order" (dynamic-link))
              (list '* '*))))
    (lambda (date1 date2)
      (let ((~date1 (unwrap-GDate* date1))
            (~date2 (unwrap-GDate* date2)))
        (~f ~date1 ~date2)))))
(export g_date_order)

;; extern gsize g_date_strftime(gchar *s, gsize slen, const gchar *format, 
;;     const GDate *date);
(define g_date_strftime
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-long
              (dynamic-func "g_date_strftime" (dynamic-link))
              (list '* ffi:unsigned-long '* '*))))
    (lambda (s slen format date)
      (let ((~s (unwrap-gchar* s))
            (~slen (unwrap~fixed slen))
            (~format (unwrap-gchar* format))
            (~date (unwrap-GDate* date)))
        (~f ~s ~slen ~format ~date)))))
(export g_date_strftime)

;; typedef struct _GTimeZone GTimeZone;
(define GTimeZone-desc void)
(define GTimeZone*-desc (bs:pointer GTimeZone-desc))
(define-fh-pointer-type GTimeZone* GTimeZone*-desc)

;; typedef enum {
;;   G_TIME_TYPE_STANDARD,
;;   G_TIME_TYPE_DAYLIGHT,
;;   G_TIME_TYPE_UNIVERSAL,
;; } GTimeType;
(define-fh-enum GTimeType
  '((G_TIME_TYPE_STANDARD . 0)
    (G_TIME_TYPE_DAYLIGHT . 1)
    (G_TIME_TYPE_UNIVERSAL . 2))
  )

;; extern GTimeZone *g_time_zone_new(const gchar *identifier);
(define g_time_zone_new
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_time_zone_new" (dynamic-link))
              (list '*))))
    (lambda (identifier)
      (let ((~identifier (unwrap-gchar* identifier)))
        (wrap-GTimeZone* (~f ~identifier))))))
(export g_time_zone_new)

;; extern GTimeZone *g_time_zone_new_utc(void);
(define g_time_zone_new_utc
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_time_zone_new_utc"
                (dynamic-link))
              (list))))
    (lambda () (let () (wrap-GTimeZone* (~f))))))
(export g_time_zone_new_utc)

;; extern GTimeZone *g_time_zone_new_local(void);
(define g_time_zone_new_local
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_time_zone_new_local"
                (dynamic-link))
              (list))))
    (lambda () (let () (wrap-GTimeZone* (~f))))))
(export g_time_zone_new_local)

;; extern GTimeZone *g_time_zone_ref(GTimeZone *tz);
(define g_time_zone_ref
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_time_zone_ref" (dynamic-link))
              (list '*))))
    (lambda (tz)
      (let ((~tz (unwrap-GTimeZone* tz)))
        (wrap-GTimeZone* (~f ~tz))))))
(export g_time_zone_ref)

;; extern void g_time_zone_unref(GTimeZone *tz);
(define g_time_zone_unref
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_time_zone_unref" (dynamic-link))
              (list '*))))
    (lambda (tz)
      (let ((~tz (unwrap-GTimeZone* tz))) (~f ~tz)))))
(export g_time_zone_unref)

;; extern gint g_time_zone_find_interval(GTimeZone *tz, GTimeType type, gint64 
;;     time_);
;; ... failed.

;; extern gint g_time_zone_adjust_time(GTimeZone *tz, GTimeType type, gint64 *
;;     time_);
(define g_time_zone_adjust_time
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_time_zone_adjust_time"
                (dynamic-link))
              (list '* ffi:int '*))))
    (lambda (tz type time_)
      (let ((~tz (unwrap-GTimeZone* tz))
            (~type (unwrap~fixed type))
            (~time_ (unwrap~pointer time_)))
        (wrap-gint (~f ~tz ~type ~time_))))))
(export g_time_zone_adjust_time)

;; extern const gchar *g_time_zone_get_abbreviation(GTimeZone *tz, gint 
;;     interval);
(define g_time_zone_get_abbreviation
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_time_zone_get_abbreviation"
                (dynamic-link))
              (list '* ffi:int))))
    (lambda (tz interval)
      (let ((~tz (unwrap-GTimeZone* tz))
            (~interval (unwrap-gint interval)))
        (wrap-gchar* (~f ~tz ~interval))))))
(export g_time_zone_get_abbreviation)

;; extern gint32 g_time_zone_get_offset(GTimeZone *tz, gint interval);
;; ... failed.

;; extern gboolean g_time_zone_is_dst(GTimeZone *tz, gint interval);
(define g_time_zone_is_dst
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_time_zone_is_dst"
                (dynamic-link))
              (list '* ffi:int))))
    (lambda (tz interval)
      (let ((~tz (unwrap-GTimeZone* tz))
            (~interval (unwrap-gint interval)))
        (wrap-gboolean (~f ~tz ~interval))))))
(export g_time_zone_is_dst)

;; typedef gint64 GTimeSpan;
(define GTimeSpan-desc signed long-desc)
(export GTimeSpan-desc)
(define unwrap-GTimeSpan unwrap~fixed)
(define wrap-GTimeSpan identity)

;; typedef struct _GDateTime GDateTime;
(define GDateTime-desc void)
(define GDateTime*-desc (bs:pointer GDateTime-desc))
(define-fh-pointer-type GDateTime* GDateTime*-desc)

;; extern void g_date_time_unref(GDateTime *datetime);
(define g_date_time_unref
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_date_time_unref" (dynamic-link))
              (list '*))))
    (lambda (datetime)
      (let ((~datetime (unwrap-GDateTime* datetime)))
        (~f ~datetime)))))
(export g_date_time_unref)

;; extern GDateTime *g_date_time_ref(GDateTime *datetime);
(define g_date_time_ref
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_date_time_ref" (dynamic-link))
              (list '*))))
    (lambda (datetime)
      (let ((~datetime (unwrap-GDateTime* datetime)))
        (wrap-GDateTime* (~f ~datetime))))))
(export g_date_time_ref)

;; extern GDateTime *g_date_time_new_now(GTimeZone *tz);
(define g_date_time_new_now
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_date_time_new_now"
                (dynamic-link))
              (list '*))))
    (lambda (tz)
      (let ((~tz (unwrap-GTimeZone* tz)))
        (wrap-GDateTime* (~f ~tz))))))
(export g_date_time_new_now)

;; extern GDateTime *g_date_time_new_now_local(void);
(define g_date_time_new_now_local
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_date_time_new_now_local"
                (dynamic-link))
              (list))))
    (lambda () (let () (wrap-GDateTime* (~f))))))
(export g_date_time_new_now_local)

;; extern GDateTime *g_date_time_new_now_utc(void);
(define g_date_time_new_now_utc
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_date_time_new_now_utc"
                (dynamic-link))
              (list))))
    (lambda () (let () (wrap-GDateTime* (~f))))))
(export g_date_time_new_now_utc)

;; extern GDateTime *g_date_time_new_from_unix_local(gint64 t);
;; ... failed.

;; extern GDateTime *g_date_time_new_from_unix_utc(gint64 t);
;; ... failed.

;; extern GDateTime *g_date_time_new_from_timeval_local(const GTimeVal *tv);
(define g_date_time_new_from_timeval_local
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_date_time_new_from_timeval_local"
                (dynamic-link))
              (list '*))))
    (lambda (tv)
      (let ((~tv (unwrap-GTimeVal* tv)))
        (wrap-GDateTime* (~f ~tv))))))
(export g_date_time_new_from_timeval_local)

;; extern GDateTime *g_date_time_new_from_timeval_utc(const GTimeVal *tv);
(define g_date_time_new_from_timeval_utc
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_date_time_new_from_timeval_utc"
                (dynamic-link))
              (list '*))))
    (lambda (tv)
      (let ((~tv (unwrap-GTimeVal* tv)))
        (wrap-GDateTime* (~f ~tv))))))
(export g_date_time_new_from_timeval_utc)

;; extern GDateTime *g_date_time_new(GTimeZone *tz, gint year, gint month, gint
;;      day, gint hour, gint minute, gdouble seconds);
(define g_date_time_new
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_date_time_new" (dynamic-link))
              (list '*
                    ffi:int
                    ffi:int
                    ffi:int
                    ffi:int
                    ffi:int
                    ffi:double))))
    (lambda (tz year month day hour minute seconds)
      (let ((~tz (unwrap-GTimeZone* tz))
            (~year (unwrap-gint year))
            (~month (unwrap-gint month))
            (~day (unwrap-gint day))
            (~hour (unwrap-gint hour))
            (~minute (unwrap-gint minute))
            (~seconds (unwrap-gdouble seconds)))
        (wrap-GDateTime*
          (~f ~tz ~year ~month ~day ~hour ~minute ~seconds))))))
(export g_date_time_new)

;; extern GDateTime *g_date_time_new_local(gint year, gint month, gint day, 
;;     gint hour, gint minute, gdouble seconds);
(define g_date_time_new_local
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_date_time_new_local"
                (dynamic-link))
              (list ffi:int
                    ffi:int
                    ffi:int
                    ffi:int
                    ffi:int
                    ffi:double))))
    (lambda (year month day hour minute seconds)
      (let ((~year (unwrap-gint year))
            (~month (unwrap-gint month))
            (~day (unwrap-gint day))
            (~hour (unwrap-gint hour))
            (~minute (unwrap-gint minute))
            (~seconds (unwrap-gdouble seconds)))
        (wrap-GDateTime*
          (~f ~year ~month ~day ~hour ~minute ~seconds))))))
(export g_date_time_new_local)

;; extern GDateTime *g_date_time_new_utc(gint year, gint month, gint day, gint 
;;     hour, gint minute, gdouble seconds);
(define g_date_time_new_utc
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_date_time_new_utc"
                (dynamic-link))
              (list ffi:int
                    ffi:int
                    ffi:int
                    ffi:int
                    ffi:int
                    ffi:double))))
    (lambda (year month day hour minute seconds)
      (let ((~year (unwrap-gint year))
            (~month (unwrap-gint month))
            (~day (unwrap-gint day))
            (~hour (unwrap-gint hour))
            (~minute (unwrap-gint minute))
            (~seconds (unwrap-gdouble seconds)))
        (wrap-GDateTime*
          (~f ~year ~month ~day ~hour ~minute ~seconds))))))
(export g_date_time_new_utc)

;; extern GDateTime *g_date_time_add(GDateTime *datetime, GTimeSpan timespan);
;; ... failed.

;; extern GDateTime *g_date_time_add_years(GDateTime *datetime, gint years);
(define g_date_time_add_years
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_date_time_add_years"
                (dynamic-link))
              (list '* ffi:int))))
    (lambda (datetime years)
      (let ((~datetime (unwrap-GDateTime* datetime))
            (~years (unwrap-gint years)))
        (wrap-GDateTime* (~f ~datetime ~years))))))
(export g_date_time_add_years)

;; extern GDateTime *g_date_time_add_months(GDateTime *datetime, gint months);
(define g_date_time_add_months
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_date_time_add_months"
                (dynamic-link))
              (list '* ffi:int))))
    (lambda (datetime months)
      (let ((~datetime (unwrap-GDateTime* datetime))
            (~months (unwrap-gint months)))
        (wrap-GDateTime* (~f ~datetime ~months))))))
(export g_date_time_add_months)

;; extern GDateTime *g_date_time_add_weeks(GDateTime *datetime, gint weeks);
(define g_date_time_add_weeks
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_date_time_add_weeks"
                (dynamic-link))
              (list '* ffi:int))))
    (lambda (datetime weeks)
      (let ((~datetime (unwrap-GDateTime* datetime))
            (~weeks (unwrap-gint weeks)))
        (wrap-GDateTime* (~f ~datetime ~weeks))))))
(export g_date_time_add_weeks)

;; extern GDateTime *g_date_time_add_days(GDateTime *datetime, gint days);
(define g_date_time_add_days
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_date_time_add_days"
                (dynamic-link))
              (list '* ffi:int))))
    (lambda (datetime days)
      (let ((~datetime (unwrap-GDateTime* datetime))
            (~days (unwrap-gint days)))
        (wrap-GDateTime* (~f ~datetime ~days))))))
(export g_date_time_add_days)

;; extern GDateTime *g_date_time_add_hours(GDateTime *datetime, gint hours);
(define g_date_time_add_hours
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_date_time_add_hours"
                (dynamic-link))
              (list '* ffi:int))))
    (lambda (datetime hours)
      (let ((~datetime (unwrap-GDateTime* datetime))
            (~hours (unwrap-gint hours)))
        (wrap-GDateTime* (~f ~datetime ~hours))))))
(export g_date_time_add_hours)

;; extern GDateTime *g_date_time_add_minutes(GDateTime *datetime, gint minutes)
;;     ;
(define g_date_time_add_minutes
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_date_time_add_minutes"
                (dynamic-link))
              (list '* ffi:int))))
    (lambda (datetime minutes)
      (let ((~datetime (unwrap-GDateTime* datetime))
            (~minutes (unwrap-gint minutes)))
        (wrap-GDateTime* (~f ~datetime ~minutes))))))
(export g_date_time_add_minutes)

;; extern GDateTime *g_date_time_add_seconds(GDateTime *datetime, gdouble 
;;     seconds);
(define g_date_time_add_seconds
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_date_time_add_seconds"
                (dynamic-link))
              (list '* ffi:double))))
    (lambda (datetime seconds)
      (let ((~datetime (unwrap-GDateTime* datetime))
            (~seconds (unwrap-gdouble seconds)))
        (wrap-GDateTime* (~f ~datetime ~seconds))))))
(export g_date_time_add_seconds)

;; extern GDateTime *g_date_time_add_full(GDateTime *datetime, gint years, gint
;;      months, gint days, gint hours, gint minutes, gdouble seconds);
(define g_date_time_add_full
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_date_time_add_full"
                (dynamic-link))
              (list '*
                    ffi:int
                    ffi:int
                    ffi:int
                    ffi:int
                    ffi:int
                    ffi:double))))
    (lambda (datetime
             years
             months
             days
             hours
             minutes
             seconds)
      (let ((~datetime (unwrap-GDateTime* datetime))
            (~years (unwrap-gint years))
            (~months (unwrap-gint months))
            (~days (unwrap-gint days))
            (~hours (unwrap-gint hours))
            (~minutes (unwrap-gint minutes))
            (~seconds (unwrap-gdouble seconds)))
        (wrap-GDateTime*
          (~f ~datetime
              ~years
              ~months
              ~days
              ~hours
              ~minutes
              ~seconds))))))
(export g_date_time_add_full)

;; extern gint g_date_time_compare(gconstpointer dt1, gconstpointer dt2);
(define g_date_time_compare
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_date_time_compare"
                (dynamic-link))
              (list '* '*))))
    (lambda (dt1 dt2)
      (let ((~dt1 (unwrap-gconstpointer dt1))
            (~dt2 (unwrap-gconstpointer dt2)))
        (wrap-gint (~f ~dt1 ~dt2))))))
(export g_date_time_compare)

;; extern GTimeSpan g_date_time_difference(GDateTime *end, GDateTime *begin);
;; ... failed.

;; extern guint g_date_time_hash(gconstpointer datetime);
(define g_date_time_hash
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func "g_date_time_hash" (dynamic-link))
              (list '*))))
    (lambda (datetime)
      (let ((~datetime (unwrap-gconstpointer datetime)))
        (wrap-guint (~f ~datetime))))))
(export g_date_time_hash)

;; extern gboolean g_date_time_equal(gconstpointer dt1, gconstpointer dt2);
(define g_date_time_equal
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_date_time_equal" (dynamic-link))
              (list '* '*))))
    (lambda (dt1 dt2)
      (let ((~dt1 (unwrap-gconstpointer dt1))
            (~dt2 (unwrap-gconstpointer dt2)))
        (wrap-gboolean (~f ~dt1 ~dt2))))))
(export g_date_time_equal)

;; extern void g_date_time_get_ymd(GDateTime *datetime, gint *year, gint *month
;;     , gint *day);
(define g_date_time_get_ymd
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_date_time_get_ymd"
                (dynamic-link))
              (list '* '* '* '*))))
    (lambda (datetime year month day)
      (let ((~datetime (unwrap-GDateTime* datetime))
            (~year (unwrap-gint* year))
            (~month (unwrap-gint* month))
            (~day (unwrap-gint* day)))
        (~f ~datetime ~year ~month ~day)))))
(export g_date_time_get_ymd)

;; extern gint g_date_time_get_year(GDateTime *datetime);
(define g_date_time_get_year
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_date_time_get_year"
                (dynamic-link))
              (list '*))))
    (lambda (datetime)
      (let ((~datetime (unwrap-GDateTime* datetime)))
        (wrap-gint (~f ~datetime))))))
(export g_date_time_get_year)

;; extern gint g_date_time_get_month(GDateTime *datetime);
(define g_date_time_get_month
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_date_time_get_month"
                (dynamic-link))
              (list '*))))
    (lambda (datetime)
      (let ((~datetime (unwrap-GDateTime* datetime)))
        (wrap-gint (~f ~datetime))))))
(export g_date_time_get_month)

;; extern gint g_date_time_get_day_of_month(GDateTime *datetime);
(define g_date_time_get_day_of_month
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_date_time_get_day_of_month"
                (dynamic-link))
              (list '*))))
    (lambda (datetime)
      (let ((~datetime (unwrap-GDateTime* datetime)))
        (wrap-gint (~f ~datetime))))))
(export g_date_time_get_day_of_month)

;; extern gint g_date_time_get_week_numbering_year(GDateTime *datetime);
(define g_date_time_get_week_numbering_year
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_date_time_get_week_numbering_year"
                (dynamic-link))
              (list '*))))
    (lambda (datetime)
      (let ((~datetime (unwrap-GDateTime* datetime)))
        (wrap-gint (~f ~datetime))))))
(export g_date_time_get_week_numbering_year)

;; extern gint g_date_time_get_week_of_year(GDateTime *datetime);
(define g_date_time_get_week_of_year
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_date_time_get_week_of_year"
                (dynamic-link))
              (list '*))))
    (lambda (datetime)
      (let ((~datetime (unwrap-GDateTime* datetime)))
        (wrap-gint (~f ~datetime))))))
(export g_date_time_get_week_of_year)

;; extern gint g_date_time_get_day_of_week(GDateTime *datetime);
(define g_date_time_get_day_of_week
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_date_time_get_day_of_week"
                (dynamic-link))
              (list '*))))
    (lambda (datetime)
      (let ((~datetime (unwrap-GDateTime* datetime)))
        (wrap-gint (~f ~datetime))))))
(export g_date_time_get_day_of_week)

;; extern gint g_date_time_get_day_of_year(GDateTime *datetime);
(define g_date_time_get_day_of_year
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_date_time_get_day_of_year"
                (dynamic-link))
              (list '*))))
    (lambda (datetime)
      (let ((~datetime (unwrap-GDateTime* datetime)))
        (wrap-gint (~f ~datetime))))))
(export g_date_time_get_day_of_year)

;; extern gint g_date_time_get_hour(GDateTime *datetime);
(define g_date_time_get_hour
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_date_time_get_hour"
                (dynamic-link))
              (list '*))))
    (lambda (datetime)
      (let ((~datetime (unwrap-GDateTime* datetime)))
        (wrap-gint (~f ~datetime))))))
(export g_date_time_get_hour)

;; extern gint g_date_time_get_minute(GDateTime *datetime);
(define g_date_time_get_minute
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_date_time_get_minute"
                (dynamic-link))
              (list '*))))
    (lambda (datetime)
      (let ((~datetime (unwrap-GDateTime* datetime)))
        (wrap-gint (~f ~datetime))))))
(export g_date_time_get_minute)

;; extern gint g_date_time_get_second(GDateTime *datetime);
(define g_date_time_get_second
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_date_time_get_second"
                (dynamic-link))
              (list '*))))
    (lambda (datetime)
      (let ((~datetime (unwrap-GDateTime* datetime)))
        (wrap-gint (~f ~datetime))))))
(export g_date_time_get_second)

;; extern gint g_date_time_get_microsecond(GDateTime *datetime);
(define g_date_time_get_microsecond
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_date_time_get_microsecond"
                (dynamic-link))
              (list '*))))
    (lambda (datetime)
      (let ((~datetime (unwrap-GDateTime* datetime)))
        (wrap-gint (~f ~datetime))))))
(export g_date_time_get_microsecond)

;; extern gdouble g_date_time_get_seconds(GDateTime *datetime);
(define g_date_time_get_seconds
  (let ((~f (ffi:pointer->procedure
              ffi:double
              (dynamic-func
                "g_date_time_get_seconds"
                (dynamic-link))
              (list '*))))
    (lambda (datetime)
      (let ((~datetime (unwrap-GDateTime* datetime)))
        (wrap-gdouble (~f ~datetime))))))
(export g_date_time_get_seconds)

;; extern gint64 g_date_time_to_unix(GDateTime *datetime);
;; ... failed.

;; extern gboolean g_date_time_to_timeval(GDateTime *datetime, GTimeVal *tv);
(define g_date_time_to_timeval
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_date_time_to_timeval"
                (dynamic-link))
              (list '* '*))))
    (lambda (datetime tv)
      (let ((~datetime (unwrap-GDateTime* datetime))
            (~tv (unwrap-GTimeVal* tv)))
        (wrap-gboolean (~f ~datetime ~tv))))))
(export g_date_time_to_timeval)

;; extern GTimeSpan g_date_time_get_utc_offset(GDateTime *datetime);
;; ... failed.

;; extern const gchar *g_date_time_get_timezone_abbreviation(GDateTime *
;;     datetime);
(define g_date_time_get_timezone_abbreviation
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_date_time_get_timezone_abbreviation"
                (dynamic-link))
              (list '*))))
    (lambda (datetime)
      (let ((~datetime (unwrap-GDateTime* datetime)))
        (wrap-gchar* (~f ~datetime))))))
(export g_date_time_get_timezone_abbreviation)

;; extern gboolean g_date_time_is_daylight_savings(GDateTime *datetime);
(define g_date_time_is_daylight_savings
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_date_time_is_daylight_savings"
                (dynamic-link))
              (list '*))))
    (lambda (datetime)
      (let ((~datetime (unwrap-GDateTime* datetime)))
        (wrap-gboolean (~f ~datetime))))))
(export g_date_time_is_daylight_savings)

;; extern GDateTime *g_date_time_to_timezone(GDateTime *datetime, GTimeZone *tz
;;     );
(define g_date_time_to_timezone
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_date_time_to_timezone"
                (dynamic-link))
              (list '* '*))))
    (lambda (datetime tz)
      (let ((~datetime (unwrap-GDateTime* datetime))
            (~tz (unwrap-GTimeZone* tz)))
        (wrap-GDateTime* (~f ~datetime ~tz))))))
(export g_date_time_to_timezone)

;; extern GDateTime *g_date_time_to_local(GDateTime *datetime);
(define g_date_time_to_local
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_date_time_to_local"
                (dynamic-link))
              (list '*))))
    (lambda (datetime)
      (let ((~datetime (unwrap-GDateTime* datetime)))
        (wrap-GDateTime* (~f ~datetime))))))
(export g_date_time_to_local)

;; extern GDateTime *g_date_time_to_utc(GDateTime *datetime);
(define g_date_time_to_utc
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_date_time_to_utc"
                (dynamic-link))
              (list '*))))
    (lambda (datetime)
      (let ((~datetime (unwrap-GDateTime* datetime)))
        (wrap-GDateTime* (~f ~datetime))))))
(export g_date_time_to_utc)

;; extern gchar *g_date_time_format(GDateTime *datetime, const gchar *format);
(define g_date_time_format
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_date_time_format"
                (dynamic-link))
              (list '* '*))))
    (lambda (datetime format)
      (let ((~datetime (unwrap-GDateTime* datetime))
            (~format (unwrap-gchar* format)))
        (wrap-gchar* (~f ~datetime ~format))))))
(export g_date_time_format)

;; typedef struct _GDir GDir;
(define GDir-desc void)
(define GDir*-desc (bs:pointer GDir-desc))
(define-fh-pointer-type GDir* GDir*-desc)

;; extern GDir *g_dir_open(const gchar *path, guint flags, GError **error);
(define g_dir_open
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_dir_open" (dynamic-link))
              (list '* ffi:unsigned-int '*))))
    (lambda (path flags error)
      (let ((~path (unwrap-gchar* path))
            (~flags (unwrap-guint flags))
            (~error (unwrap~pointer error)))
        (wrap-GDir* (~f ~path ~flags ~error))))))
(export g_dir_open)

;; extern const gchar *g_dir_read_name(GDir *dir);
(define g_dir_read_name
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_dir_read_name" (dynamic-link))
              (list '*))))
    (lambda (dir)
      (let ((~dir (unwrap-GDir* dir)))
        (wrap-gchar* (~f ~dir))))))
(export g_dir_read_name)

;; extern void g_dir_rewind(GDir *dir);
(define g_dir_rewind
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_dir_rewind" (dynamic-link))
              (list '*))))
    (lambda (dir)
      (let ((~dir (unwrap-GDir* dir))) (~f ~dir)))))
(export g_dir_rewind)

;; extern void g_dir_close(GDir *dir);
(define g_dir_close
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_dir_close" (dynamic-link))
              (list '*))))
    (lambda (dir)
      (let ((~dir (unwrap-GDir* dir))) (~f ~dir)))))
(export g_dir_close)

;; extern const gchar *g_getenv(const gchar *variable);
(define g_getenv
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_getenv" (dynamic-link))
              (list '*))))
    (lambda (variable)
      (let ((~variable (unwrap-gchar* variable)))
        (wrap-gchar* (~f ~variable))))))
(export g_getenv)

;; extern gboolean g_setenv(const gchar *variable, const gchar *value, gboolean
;;      overwrite);
(define g_setenv
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_setenv" (dynamic-link))
              (list '* '* ffi:int))))
    (lambda (variable value overwrite)
      (let ((~variable (unwrap-gchar* variable))
            (~value (unwrap-gchar* value))
            (~overwrite (unwrap-gboolean overwrite)))
        (wrap-gboolean (~f ~variable ~value ~overwrite))))))
(export g_setenv)

;; extern void g_unsetenv(const gchar *variable);
(define g_unsetenv
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_unsetenv" (dynamic-link))
              (list '*))))
    (lambda (variable)
      (let ((~variable (unwrap-gchar* variable)))
        (~f ~variable)))))
(export g_unsetenv)

;; extern gchar **g_listenv(void);
;; ... failed.

;; extern gchar **g_get_environ(void);
;; ... failed.

;; extern const gchar *g_environ_getenv(gchar **envp, const gchar *variable);
(define g_environ_getenv
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_environ_getenv" (dynamic-link))
              (list '* '*))))
    (lambda (envp variable)
      (let ((~envp (unwrap~pointer envp))
            (~variable (unwrap-gchar* variable)))
        (wrap-gchar* (~f ~envp ~variable))))))
(export g_environ_getenv)

;; extern gchar **g_environ_setenv(gchar **envp, const gchar *variable, const 
;;     gchar *value, gboolean overwrite);
;; ... failed.

;; extern gchar **g_environ_unsetenv(gchar **envp, const gchar *variable);
;; ... failed.

;; typedef enum {
;;   G_FILE_ERROR_EXIST,
;;   G_FILE_ERROR_ISDIR,
;;   G_FILE_ERROR_ACCES,
;;   G_FILE_ERROR_NAMETOOLONG,
;;   G_FILE_ERROR_NOENT,
;;   G_FILE_ERROR_NOTDIR,
;;   G_FILE_ERROR_NXIO,
;;   G_FILE_ERROR_NODEV,
;;   G_FILE_ERROR_ROFS,
;;   G_FILE_ERROR_TXTBSY,
;;   G_FILE_ERROR_FAULT,
;;   G_FILE_ERROR_LOOP,
;;   G_FILE_ERROR_NOSPC,
;;   G_FILE_ERROR_NOMEM,
;;   G_FILE_ERROR_MFILE,
;;   G_FILE_ERROR_NFILE,
;;   G_FILE_ERROR_BADF,
;;   G_FILE_ERROR_INVAL,
;;   G_FILE_ERROR_PIPE,
;;   G_FILE_ERROR_AGAIN,
;;   G_FILE_ERROR_INTR,
;;   G_FILE_ERROR_IO,
;;   G_FILE_ERROR_PERM,
;;   G_FILE_ERROR_NOSYS,
;;   G_FILE_ERROR_FAILED,
;; } GFileError;
(define-fh-enum GFileError
  '((G_FILE_ERROR_EXIST . 0)
    (G_FILE_ERROR_ISDIR . 1)
    (G_FILE_ERROR_ACCES . 2)
    (G_FILE_ERROR_NAMETOOLONG . 3)
    (G_FILE_ERROR_NOENT . 4)
    (G_FILE_ERROR_NOTDIR . 5)
    (G_FILE_ERROR_NXIO . 6)
    (G_FILE_ERROR_NODEV . 7)
    (G_FILE_ERROR_ROFS . 8)
    (G_FILE_ERROR_TXTBSY . 9)
    (G_FILE_ERROR_FAULT . 10)
    (G_FILE_ERROR_LOOP . 11)
    (G_FILE_ERROR_NOSPC . 12)
    (G_FILE_ERROR_NOMEM . 13)
    (G_FILE_ERROR_MFILE . 14)
    (G_FILE_ERROR_NFILE . 15)
    (G_FILE_ERROR_BADF . 16)
    (G_FILE_ERROR_INVAL . 17)
    (G_FILE_ERROR_PIPE . 18)
    (G_FILE_ERROR_AGAIN . 19)
    (G_FILE_ERROR_INTR . 20)
    (G_FILE_ERROR_IO . 21)
    (G_FILE_ERROR_PERM . 22)
    (G_FILE_ERROR_NOSYS . 23)
    (G_FILE_ERROR_FAILED . 24))
  )

;; typedef enum {
;;   G_FILE_TEST_IS_REGULAR = 1<<0,
;;   G_FILE_TEST_IS_SYMLINK = 1<<1,
;;   G_FILE_TEST_IS_DIR = 1<<2,
;;   G_FILE_TEST_IS_EXECUTABLE = 1<<3,
;;   G_FILE_TEST_EXISTS = 1<<4,
;; } GFileTest;
(define-fh-enum GFileTest
  '((G_FILE_TEST_IS_REGULAR . 1)
    (G_FILE_TEST_IS_SYMLINK . 2)
    (G_FILE_TEST_IS_DIR . 4)
    (G_FILE_TEST_IS_EXECUTABLE . 8)
    (G_FILE_TEST_EXISTS . 16))
  )

;; extern GQuark g_file_error_quark(void);
(define g_file_error_quark
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func
                "g_file_error_quark"
                (dynamic-link))
              (list))))
    (lambda () (let () (wrap-GQuark (~f))))))
(export g_file_error_quark)

;; extern GFileError g_file_error_from_errno(gint err_no);
(define g_file_error_from_errno
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_file_error_from_errno"
                (dynamic-link))
              (list ffi:int))))
    (lambda (err_no)
      (let ((~err_no (unwrap-gint err_no)))
        (~f ~err_no)))))
(export g_file_error_from_errno)

;; extern gboolean g_file_test(const gchar *filename, GFileTest test);
(define g_file_test
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_file_test" (dynamic-link))
              (list '* ffi:int))))
    (lambda (filename test)
      (let ((~filename (unwrap-gchar* filename))
            (~test (unwrap~fixed test)))
        (wrap-gboolean (~f ~filename ~test))))))
(export g_file_test)

;; extern gboolean g_file_get_contents(const gchar *filename, gchar **contents
;;     , gsize *length, GError **error);
(define g_file_get_contents
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_file_get_contents"
                (dynamic-link))
              (list '* '* '* '*))))
    (lambda (filename contents length error)
      (let ((~filename (unwrap-gchar* filename))
            (~contents (unwrap~pointer contents))
            (~length (unwrap~pointer length))
            (~error (unwrap~pointer error)))
        (wrap-gboolean
          (~f ~filename ~contents ~length ~error))))))
(export g_file_get_contents)

;; extern gboolean g_file_set_contents(const gchar *filename, const gchar *
;;     contents, gssize length, GError **error);
;; ... failed.

;; extern gchar *g_file_read_link(const gchar *filename, GError **error);
(define g_file_read_link
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_file_read_link" (dynamic-link))
              (list '* '*))))
    (lambda (filename error)
      (let ((~filename (unwrap-gchar* filename))
            (~error (unwrap~pointer error)))
        (wrap-gchar* (~f ~filename ~error))))))
(export g_file_read_link)

;; extern gchar *g_mkdtemp(gchar *tmpl);
(define g_mkdtemp
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_mkdtemp" (dynamic-link))
              (list '*))))
    (lambda (tmpl)
      (let ((~tmpl (unwrap-gchar* tmpl)))
        (wrap-gchar* (~f ~tmpl))))))
(export g_mkdtemp)

;; extern gchar *g_mkdtemp_full(gchar *tmpl, gint mode);
(define g_mkdtemp_full
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_mkdtemp_full" (dynamic-link))
              (list '* ffi:int))))
    (lambda (tmpl mode)
      (let ((~tmpl (unwrap-gchar* tmpl))
            (~mode (unwrap-gint mode)))
        (wrap-gchar* (~f ~tmpl ~mode))))))
(export g_mkdtemp_full)

;; extern gint g_mkstemp(gchar *tmpl);
(define g_mkstemp
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_mkstemp" (dynamic-link))
              (list '*))))
    (lambda (tmpl)
      (let ((~tmpl (unwrap-gchar* tmpl)))
        (wrap-gint (~f ~tmpl))))))
(export g_mkstemp)

;; extern gint g_mkstemp_full(gchar *tmpl, gint flags, gint mode);
(define g_mkstemp_full
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_mkstemp_full" (dynamic-link))
              (list '* ffi:int ffi:int))))
    (lambda (tmpl flags mode)
      (let ((~tmpl (unwrap-gchar* tmpl))
            (~flags (unwrap-gint flags))
            (~mode (unwrap-gint mode)))
        (wrap-gint (~f ~tmpl ~flags ~mode))))))
(export g_mkstemp_full)

;; extern gint g_file_open_tmp(const gchar *tmpl, gchar **name_used, GError **
;;     error);
(define g_file_open_tmp
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_file_open_tmp" (dynamic-link))
              (list '* '* '*))))
    (lambda (tmpl name_used error)
      (let ((~tmpl (unwrap-gchar* tmpl))
            (~name_used (unwrap~pointer name_used))
            (~error (unwrap~pointer error)))
        (wrap-gint (~f ~tmpl ~name_used ~error))))))
(export g_file_open_tmp)

;; extern gchar *g_dir_make_tmp(const gchar *tmpl, GError **error);
(define g_dir_make_tmp
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_dir_make_tmp" (dynamic-link))
              (list '* '*))))
    (lambda (tmpl error)
      (let ((~tmpl (unwrap-gchar* tmpl))
            (~error (unwrap~pointer error)))
        (wrap-gchar* (~f ~tmpl ~error))))))
(export g_dir_make_tmp)

;; extern gchar *g_build_path(const gchar *separator, const gchar *
;;     first_element, ...);
;; ... failed.

;; extern gchar *g_build_pathv(const gchar *separator, gchar **args);
(define g_build_pathv
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_build_pathv" (dynamic-link))
              (list '* '*))))
    (lambda (separator args)
      (let ((~separator (unwrap-gchar* separator))
            (~args (unwrap~pointer args)))
        (wrap-gchar* (~f ~separator ~args))))))
(export g_build_pathv)

;; extern gchar *g_build_filename(const gchar *first_element, ...);
;; ... failed.

;; extern gchar *g_build_filenamev(gchar **args);
(define g_build_filenamev
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_build_filenamev" (dynamic-link))
              (list '*))))
    (lambda (args)
      (let ((~args (unwrap~pointer args)))
        (wrap-gchar* (~f ~args))))))
(export g_build_filenamev)

;; extern gint g_mkdir_with_parents(const gchar *pathname, gint mode);
(define g_mkdir_with_parents
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_mkdir_with_parents"
                (dynamic-link))
              (list '* ffi:int))))
    (lambda (pathname mode)
      (let ((~pathname (unwrap-gchar* pathname))
            (~mode (unwrap-gint mode)))
        (wrap-gint (~f ~pathname ~mode))))))
(export g_mkdir_with_parents)

;; extern gboolean g_path_is_absolute(const gchar *file_name);
(define g_path_is_absolute
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_path_is_absolute"
                (dynamic-link))
              (list '*))))
    (lambda (file_name)
      (let ((~file_name (unwrap-gchar* file_name)))
        (wrap-gboolean (~f ~file_name))))))
(export g_path_is_absolute)

;; extern const gchar *g_path_skip_root(const gchar *file_name);
(define g_path_skip_root
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_path_skip_root" (dynamic-link))
              (list '*))))
    (lambda (file_name)
      (let ((~file_name (unwrap-gchar* file_name)))
        (wrap-gchar* (~f ~file_name))))))
(export g_path_skip_root)

;; extern const gchar *g_basename(const gchar *file_name);
(define g_basename
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_basename" (dynamic-link))
              (list '*))))
    (lambda (file_name)
      (let ((~file_name (unwrap-gchar* file_name)))
        (wrap-gchar* (~f ~file_name))))))
(export g_basename)

;; extern gchar *g_get_current_dir(void);
(define g_get_current_dir
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_get_current_dir" (dynamic-link))
              (list))))
    (lambda () (let () (wrap-gchar* (~f))))))
(export g_get_current_dir)

;; extern gchar *g_path_get_basename(const gchar *file_name);
(define g_path_get_basename
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_path_get_basename"
                (dynamic-link))
              (list '*))))
    (lambda (file_name)
      (let ((~file_name (unwrap-gchar* file_name)))
        (wrap-gchar* (~f ~file_name))))))
(export g_path_get_basename)

;; extern gchar *g_path_get_dirname(const gchar *file_name);
(define g_path_get_dirname
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_path_get_dirname"
                (dynamic-link))
              (list '*))))
    (lambda (file_name)
      (let ((~file_name (unwrap-gchar* file_name)))
        (wrap-gchar* (~f ~file_name))))))
(export g_path_get_dirname)

;; extern const gchar *g_strip_context(const gchar *msgid, const gchar *msgval)
;;     ;
(define g_strip_context
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_strip_context" (dynamic-link))
              (list '* '*))))
    (lambda (msgid msgval)
      (let ((~msgid (unwrap-gchar* msgid))
            (~msgval (unwrap-gchar* msgval)))
        (wrap-gchar* (~f ~msgid ~msgval))))))
(export g_strip_context)

;; extern const gchar *g_dgettext(const gchar *domain, const gchar *msgid);
(define g_dgettext
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_dgettext" (dynamic-link))
              (list '* '*))))
    (lambda (domain msgid)
      (let ((~domain (unwrap-gchar* domain))
            (~msgid (unwrap-gchar* msgid)))
        (wrap-gchar* (~f ~domain ~msgid))))))
(export g_dgettext)

;; extern const gchar *g_dcgettext(const gchar *domain, const gchar *msgid, 
;;     gint category);
(define g_dcgettext
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_dcgettext" (dynamic-link))
              (list '* '* ffi:int))))
    (lambda (domain msgid category)
      (let ((~domain (unwrap-gchar* domain))
            (~msgid (unwrap-gchar* msgid))
            (~category (unwrap-gint category)))
        (wrap-gchar* (~f ~domain ~msgid ~category))))))
(export g_dcgettext)

;; extern const gchar *g_dngettext(const gchar *domain, const gchar *msgid, 
;;     const gchar *msgid_plural, gulong n);
(define g_dngettext
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_dngettext" (dynamic-link))
              (list '* '* '* ffi:unsigned-long))))
    (lambda (domain msgid msgid_plural n)
      (let ((~domain (unwrap-gchar* domain))
            (~msgid (unwrap-gchar* msgid))
            (~msgid_plural (unwrap-gchar* msgid_plural))
            (~n (unwrap-gulong n)))
        (wrap-gchar*
          (~f ~domain ~msgid ~msgid_plural ~n))))))
(export g_dngettext)

;; extern const gchar *g_dpgettext(const gchar *domain, const gchar *msgctxtid
;;     , gsize msgidoffset);
(define g_dpgettext
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_dpgettext" (dynamic-link))
              (list '* '* ffi:unsigned-long))))
    (lambda (domain msgctxtid msgidoffset)
      (let ((~domain (unwrap-gchar* domain))
            (~msgctxtid (unwrap-gchar* msgctxtid))
            (~msgidoffset (unwrap~fixed msgidoffset)))
        (wrap-gchar*
          (~f ~domain ~msgctxtid ~msgidoffset))))))
(export g_dpgettext)

;; extern const gchar *g_dpgettext2(const gchar *domain, const gchar *context, 
;;     const gchar *msgid);
(define g_dpgettext2
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_dpgettext2" (dynamic-link))
              (list '* '* '*))))
    (lambda (domain context msgid)
      (let ((~domain (unwrap-gchar* domain))
            (~context (unwrap-gchar* context))
            (~msgid (unwrap-gchar* msgid)))
        (wrap-gchar* (~f ~domain ~context ~msgid))))))
(export g_dpgettext2)

;; typedef struct _GMemVTable GMemVTable;
(define GMemVTable-desc void)
(define GMemVTable*-desc (bs:pointer (delay GMemVTable-desc)))
(define-fh-pointer-type GMemVTable* GMemVTable*-desc)

;; extern void g_free(gpointer mem);
(define g_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_free" (dynamic-link))
              (list '*))))
    (lambda (mem)
      (let ((~mem (unwrap-gpointer mem))) (~f ~mem)))))
(export g_free)

;; extern void g_clear_pointer(gpointer *pp, GDestroyNotify destroy);
(define g_clear_pointer
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_clear_pointer" (dynamic-link))
              (list '* '*))))
    (lambda (pp destroy)
      (let ((~pp (unwrap-gpointer* pp))
            (~destroy
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               destroy)))
        (~f ~pp ~destroy)))))
(export g_clear_pointer)

;; extern gpointer g_malloc(gsize n_bytes);
(define g_malloc
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_malloc" (dynamic-link))
              (list ffi:unsigned-long))))
    (lambda (n_bytes)
      (let ((~n_bytes (unwrap~fixed n_bytes)))
        (wrap-gpointer (~f ~n_bytes))))))
(export g_malloc)

;; extern gpointer g_malloc0(gsize n_bytes);
(define g_malloc0
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_malloc0" (dynamic-link))
              (list ffi:unsigned-long))))
    (lambda (n_bytes)
      (let ((~n_bytes (unwrap~fixed n_bytes)))
        (wrap-gpointer (~f ~n_bytes))))))
(export g_malloc0)

;; extern gpointer g_realloc(gpointer mem, gsize n_bytes);
(define g_realloc
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_realloc" (dynamic-link))
              (list '* ffi:unsigned-long))))
    (lambda (mem n_bytes)
      (let ((~mem (unwrap-gpointer mem))
            (~n_bytes (unwrap~fixed n_bytes)))
        (wrap-gpointer (~f ~mem ~n_bytes))))))
(export g_realloc)

;; extern gpointer g_try_malloc(gsize n_bytes);
(define g_try_malloc
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_try_malloc" (dynamic-link))
              (list ffi:unsigned-long))))
    (lambda (n_bytes)
      (let ((~n_bytes (unwrap~fixed n_bytes)))
        (wrap-gpointer (~f ~n_bytes))))))
(export g_try_malloc)

;; extern gpointer g_try_malloc0(gsize n_bytes);
(define g_try_malloc0
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_try_malloc0" (dynamic-link))
              (list ffi:unsigned-long))))
    (lambda (n_bytes)
      (let ((~n_bytes (unwrap~fixed n_bytes)))
        (wrap-gpointer (~f ~n_bytes))))))
(export g_try_malloc0)

;; extern gpointer g_try_realloc(gpointer mem, gsize n_bytes);
(define g_try_realloc
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_try_realloc" (dynamic-link))
              (list '* ffi:unsigned-long))))
    (lambda (mem n_bytes)
      (let ((~mem (unwrap-gpointer mem))
            (~n_bytes (unwrap~fixed n_bytes)))
        (wrap-gpointer (~f ~mem ~n_bytes))))))
(export g_try_realloc)

;; extern gpointer g_malloc_n(gsize n_blocks, gsize n_block_bytes);
(define g_malloc_n
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_malloc_n" (dynamic-link))
              (list ffi:unsigned-long ffi:unsigned-long))))
    (lambda (n_blocks n_block_bytes)
      (let ((~n_blocks (unwrap~fixed n_blocks))
            (~n_block_bytes (unwrap~fixed n_block_bytes)))
        (wrap-gpointer (~f ~n_blocks ~n_block_bytes))))))
(export g_malloc_n)

;; extern gpointer g_malloc0_n(gsize n_blocks, gsize n_block_bytes);
(define g_malloc0_n
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_malloc0_n" (dynamic-link))
              (list ffi:unsigned-long ffi:unsigned-long))))
    (lambda (n_blocks n_block_bytes)
      (let ((~n_blocks (unwrap~fixed n_blocks))
            (~n_block_bytes (unwrap~fixed n_block_bytes)))
        (wrap-gpointer (~f ~n_blocks ~n_block_bytes))))))
(export g_malloc0_n)

;; extern gpointer g_realloc_n(gpointer mem, gsize n_blocks, gsize 
;;     n_block_bytes);
(define g_realloc_n
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_realloc_n" (dynamic-link))
              (list '* ffi:unsigned-long ffi:unsigned-long))))
    (lambda (mem n_blocks n_block_bytes)
      (let ((~mem (unwrap-gpointer mem))
            (~n_blocks (unwrap~fixed n_blocks))
            (~n_block_bytes (unwrap~fixed n_block_bytes)))
        (wrap-gpointer
          (~f ~mem ~n_blocks ~n_block_bytes))))))
(export g_realloc_n)

;; extern gpointer g_try_malloc_n(gsize n_blocks, gsize n_block_bytes);
(define g_try_malloc_n
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_try_malloc_n" (dynamic-link))
              (list ffi:unsigned-long ffi:unsigned-long))))
    (lambda (n_blocks n_block_bytes)
      (let ((~n_blocks (unwrap~fixed n_blocks))
            (~n_block_bytes (unwrap~fixed n_block_bytes)))
        (wrap-gpointer (~f ~n_blocks ~n_block_bytes))))))
(export g_try_malloc_n)

;; extern gpointer g_try_malloc0_n(gsize n_blocks, gsize n_block_bytes);
(define g_try_malloc0_n
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_try_malloc0_n" (dynamic-link))
              (list ffi:unsigned-long ffi:unsigned-long))))
    (lambda (n_blocks n_block_bytes)
      (let ((~n_blocks (unwrap~fixed n_blocks))
            (~n_block_bytes (unwrap~fixed n_block_bytes)))
        (wrap-gpointer (~f ~n_blocks ~n_block_bytes))))))
(export g_try_malloc0_n)

;; extern gpointer g_try_realloc_n(gpointer mem, gsize n_blocks, gsize 
;;     n_block_bytes);
(define g_try_realloc_n
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_try_realloc_n" (dynamic-link))
              (list '* ffi:unsigned-long ffi:unsigned-long))))
    (lambda (mem n_blocks n_block_bytes)
      (let ((~mem (unwrap-gpointer mem))
            (~n_blocks (unwrap~fixed n_blocks))
            (~n_block_bytes (unwrap~fixed n_block_bytes)))
        (wrap-gpointer
          (~f ~mem ~n_blocks ~n_block_bytes))))))
(export g_try_realloc_n)

;; struct _GMemVTable {
;;   gpointer (*malloc)(gsize n_bytes);
;;   gpointer (*realloc)(gpointer mem, gsize n_bytes);
;;   void (*free)(gpointer mem);
;;   /* optional; set to NULL if not used ! */
;;   gpointer (*calloc)(gsize n_blocks, gsize n_block_bytes);
;;   gpointer (*try_malloc)(gsize n_bytes);
;;   gpointer (*try_realloc)(gpointer mem, gsize n_bytes);
;; };
(define struct-_GMemVTable-desc
  (bs:struct
    (list `(malloc ,(bs:pointer void))
          `(realloc ,(bs:pointer void))
          `(free ,(bs:pointer void))
          `(calloc ,(bs:pointer void))
          `(try_malloc ,(bs:pointer void))
          `(try_realloc ,(bs:pointer void)))))
(export struct-_GMemVTable-desc)
(define-fh-compound-type/p struct-_GMemVTable struct-_GMemVTable-desc)
(set! GMemVTable-desc struct-_GMemVTable-desc)
(define-fh-compound-type GMemVTable GMemVTable-desc)

;; extern void g_mem_set_vtable(GMemVTable *vtable);
(define g_mem_set_vtable
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_mem_set_vtable" (dynamic-link))
              (list '*))))
    (lambda (vtable)
      (let ((~vtable (unwrap-GMemVTable* vtable)))
        (~f ~vtable)))))
(export g_mem_set_vtable)

;; extern gboolean g_mem_is_system_malloc(void);
(define g_mem_is_system_malloc
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_mem_is_system_malloc"
                (dynamic-link))
              (list))))
    (lambda () (let () (wrap-gboolean (~f))))))
(export g_mem_is_system_malloc)

;; extern gboolean g_mem_gc_friendly;
(define g_mem_gc_friendly
  (let* ((addr (dynamic-pointer
                 "g_mem_gc_friendly"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (sizeof '*))
                0
                (bs:pointer gboolean-desc))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_mem_gc_friendly)

;; extern GMemVTable *glib_mem_profiler_table;
(define glib_mem_profiler_table (dynamic-pointer "glib_mem_profiler_table" (dynamic-link)))

;; extern void g_mem_profile(void);
(define g_mem_profile
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_mem_profile" (dynamic-link))
              (list))))
    (lambda () (let () (~f)))))
(export g_mem_profile)

;; typedef struct _GNode GNode;
(define GNode-desc void)
(define GNode*-desc (bs:pointer (delay GNode-desc)))
(define-fh-pointer-type GNode* GNode*-desc)

;; typedef enum {
;;   G_TRAVERSE_LEAVES = 1<<0,
;;   G_TRAVERSE_NON_LEAVES = 1<<1,
;;   G_TRAVERSE_ALL = G_TRAVERSE_LEAVES | G_TRAVERSE_NON_LEAVES,
;;   G_TRAVERSE_MASK = 0x03,
;;   G_TRAVERSE_LEAFS = G_TRAVERSE_LEAVES,
;;   G_TRAVERSE_NON_LEAFS = G_TRAVERSE_NON_LEAVES,
;; } GTraverseFlags;
(define-fh-enum GTraverseFlags
  '((G_TRAVERSE_LEAVES . 1)
    (G_TRAVERSE_NON_LEAVES . 2)
    (G_TRAVERSE_ALL . 3)
    (G_TRAVERSE_MASK . 3)
    (G_TRAVERSE_LEAFS . 1)
    (G_TRAVERSE_NON_LEAFS . 2))
  )

;; typedef enum {
;;   G_IN_ORDER,
;;   G_PRE_ORDER,
;;   G_POST_ORDER,
;;   G_LEVEL_ORDER,
;; } GTraverseType;
(define-fh-enum GTraverseType
  '((G_IN_ORDER . 0)
    (G_PRE_ORDER . 1)
    (G_POST_ORDER . 2)
    (G_LEVEL_ORDER . 3))
  )

;; typedef gboolean (*GNodeTraverseFunc)(GNode *node, gpointer data);
(define-fh-function/p GNodeTraverseFunc
  ffi:int (list (quote *) (quote *)))

;; typedef void (*GNodeForeachFunc)(GNode *node, gpointer data);
(define-fh-function/p GNodeForeachFunc
  ffi:void (list (quote *) (quote *)))

;; typedef gpointer (*GCopyFunc)(gconstpointer src, gpointer data);
(define-fh-function/p GCopyFunc
  (quote *) (list (quote *) (quote *)))

;; struct _GNode {
;;   gpointer data;
;;   GNode *next;
;;   GNode *prev;
;;   GNode *parent;
;;   GNode *children;
;; };
(define struct-_GNode-desc
  (bs:struct
    (list `(data ,gpointer-desc)
          `(next ,(bs:pointer GNode*-desc))
          `(prev ,(bs:pointer GNode*-desc))
          `(parent ,(bs:pointer GNode*-desc))
          `(children ,(bs:pointer GNode*-desc)))))
(export struct-_GNode-desc)
(define-fh-compound-type/p struct-_GNode struct-_GNode-desc)
(set! GNode-desc struct-_GNode-desc)
(define-fh-compound-type GNode GNode-desc)

;; extern GNode *g_node_new(gpointer data);
(define g_node_new
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_node_new" (dynamic-link))
              (list '*))))
    (lambda (data)
      (let ((~data (unwrap-gpointer data)))
        (wrap-GNode* (~f ~data))))))
(export g_node_new)

;; extern void g_node_destroy(GNode *root);
(define g_node_destroy
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_node_destroy" (dynamic-link))
              (list '*))))
    (lambda (root)
      (let ((~root (unwrap-GNode* root))) (~f ~root)))))
(export g_node_destroy)

;; extern void g_node_unlink(GNode *node);
(define g_node_unlink
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_node_unlink" (dynamic-link))
              (list '*))))
    (lambda (node)
      (let ((~node (unwrap-GNode* node))) (~f ~node)))))
(export g_node_unlink)

;; extern GNode *g_node_copy_deep(GNode *node, GCopyFunc copy_func, gpointer 
;;     data);
;; ... failed.

;; extern GNode *g_node_copy(GNode *node);
(define g_node_copy
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_node_copy" (dynamic-link))
              (list '*))))
    (lambda (node)
      (let ((~node (unwrap-GNode* node)))
        (wrap-GNode* (~f ~node))))))
(export g_node_copy)

;; extern GNode *g_node_insert(GNode *parent, gint position, GNode *node);
(define g_node_insert
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_node_insert" (dynamic-link))
              (list '* ffi:int '*))))
    (lambda (parent position node)
      (let ((~parent (unwrap-GNode* parent))
            (~position (unwrap-gint position))
            (~node (unwrap-GNode* node)))
        (wrap-GNode* (~f ~parent ~position ~node))))))
(export g_node_insert)

;; extern GNode *g_node_insert_before(GNode *parent, GNode *sibling, GNode *
;;     node);
(define g_node_insert_before
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_node_insert_before"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (parent sibling node)
      (let ((~parent (unwrap-GNode* parent))
            (~sibling (unwrap-GNode* sibling))
            (~node (unwrap-GNode* node)))
        (wrap-GNode* (~f ~parent ~sibling ~node))))))
(export g_node_insert_before)

;; extern GNode *g_node_insert_after(GNode *parent, GNode *sibling, GNode *node
;;     );
(define g_node_insert_after
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_node_insert_after"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (parent sibling node)
      (let ((~parent (unwrap-GNode* parent))
            (~sibling (unwrap-GNode* sibling))
            (~node (unwrap-GNode* node)))
        (wrap-GNode* (~f ~parent ~sibling ~node))))))
(export g_node_insert_after)

;; extern GNode *g_node_prepend(GNode *parent, GNode *node);
(define g_node_prepend
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_node_prepend" (dynamic-link))
              (list '* '*))))
    (lambda (parent node)
      (let ((~parent (unwrap-GNode* parent))
            (~node (unwrap-GNode* node)))
        (wrap-GNode* (~f ~parent ~node))))))
(export g_node_prepend)

;; extern guint g_node_n_nodes(GNode *root, GTraverseFlags flags);
(define g_node_n_nodes
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func "g_node_n_nodes" (dynamic-link))
              (list '* ffi:int))))
    (lambda (root flags)
      (let ((~root (unwrap-GNode* root))
            (~flags (unwrap~fixed flags)))
        (wrap-guint (~f ~root ~flags))))))
(export g_node_n_nodes)

;; extern GNode *g_node_get_root(GNode *node);
(define g_node_get_root
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_node_get_root" (dynamic-link))
              (list '*))))
    (lambda (node)
      (let ((~node (unwrap-GNode* node)))
        (wrap-GNode* (~f ~node))))))
(export g_node_get_root)

;; extern gboolean g_node_is_ancestor(GNode *node, GNode *descendant);
(define g_node_is_ancestor
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_node_is_ancestor"
                (dynamic-link))
              (list '* '*))))
    (lambda (node descendant)
      (let ((~node (unwrap-GNode* node))
            (~descendant (unwrap-GNode* descendant)))
        (wrap-gboolean (~f ~node ~descendant))))))
(export g_node_is_ancestor)

;; extern guint g_node_depth(GNode *node);
(define g_node_depth
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func "g_node_depth" (dynamic-link))
              (list '*))))
    (lambda (node)
      (let ((~node (unwrap-GNode* node)))
        (wrap-guint (~f ~node))))))
(export g_node_depth)

;; extern GNode *g_node_find(GNode *root, GTraverseType order, GTraverseFlags 
;;     flags, gpointer data);
(define g_node_find
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_node_find" (dynamic-link))
              (list '* ffi:int ffi:int '*))))
    (lambda (root order flags data)
      (let ((~root (unwrap-GNode* root))
            (~order (unwrap~fixed order))
            (~flags (unwrap~fixed flags))
            (~data (unwrap-gpointer data)))
        (wrap-GNode* (~f ~root ~order ~flags ~data))))))
(export g_node_find)

;; extern void g_node_traverse(GNode *root, GTraverseType order, GTraverseFlags
;;      flags, gint max_depth, GNodeTraverseFunc func, gpointer data);
;; ... failed.

;; extern guint g_node_max_height(GNode *root);
(define g_node_max_height
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func "g_node_max_height" (dynamic-link))
              (list '*))))
    (lambda (root)
      (let ((~root (unwrap-GNode* root)))
        (wrap-guint (~f ~root))))))
(export g_node_max_height)

;; extern void g_node_children_foreach(GNode *node, GTraverseFlags flags, 
;;     GNodeForeachFunc func, gpointer data);
(define g_node_children_foreach
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_node_children_foreach"
                (dynamic-link))
              (list '* ffi:int '* '*))))
    (lambda (node flags func data)
      (let ((~node (unwrap-GNode* node))
            (~flags (unwrap~fixed flags))
            (~func ((make-ftn-arg-unwrapper ffi:void (list '* '*))
                    func))
            (~data (unwrap-gpointer data)))
        (~f ~node ~flags ~func ~data)))))
(export g_node_children_foreach)

;; extern void g_node_reverse_children(GNode *node);
(define g_node_reverse_children
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_node_reverse_children"
                (dynamic-link))
              (list '*))))
    (lambda (node)
      (let ((~node (unwrap-GNode* node))) (~f ~node)))))
(export g_node_reverse_children)

;; extern guint g_node_n_children(GNode *node);
(define g_node_n_children
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func "g_node_n_children" (dynamic-link))
              (list '*))))
    (lambda (node)
      (let ((~node (unwrap-GNode* node)))
        (wrap-guint (~f ~node))))))
(export g_node_n_children)

;; extern GNode *g_node_nth_child(GNode *node, guint n);
(define g_node_nth_child
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_node_nth_child" (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (node n)
      (let ((~node (unwrap-GNode* node))
            (~n (unwrap-guint n)))
        (wrap-GNode* (~f ~node ~n))))))
(export g_node_nth_child)

;; extern GNode *g_node_last_child(GNode *node);
(define g_node_last_child
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_node_last_child" (dynamic-link))
              (list '*))))
    (lambda (node)
      (let ((~node (unwrap-GNode* node)))
        (wrap-GNode* (~f ~node))))))
(export g_node_last_child)

;; extern GNode *g_node_find_child(GNode *node, GTraverseFlags flags, gpointer 
;;     data);
(define g_node_find_child
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_node_find_child" (dynamic-link))
              (list '* ffi:int '*))))
    (lambda (node flags data)
      (let ((~node (unwrap-GNode* node))
            (~flags (unwrap~fixed flags))
            (~data (unwrap-gpointer data)))
        (wrap-GNode* (~f ~node ~flags ~data))))))
(export g_node_find_child)

;; extern gint g_node_child_position(GNode *node, GNode *child);
(define g_node_child_position
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_node_child_position"
                (dynamic-link))
              (list '* '*))))
    (lambda (node child)
      (let ((~node (unwrap-GNode* node))
            (~child (unwrap-GNode* child)))
        (wrap-gint (~f ~node ~child))))))
(export g_node_child_position)

;; extern gint g_node_child_index(GNode *node, gpointer data);
(define g_node_child_index
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_node_child_index"
                (dynamic-link))
              (list '* '*))))
    (lambda (node data)
      (let ((~node (unwrap-GNode* node))
            (~data (unwrap-gpointer data)))
        (wrap-gint (~f ~node ~data))))))
(export g_node_child_index)

;; extern GNode *g_node_first_sibling(GNode *node);
(define g_node_first_sibling
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_node_first_sibling"
                (dynamic-link))
              (list '*))))
    (lambda (node)
      (let ((~node (unwrap-GNode* node)))
        (wrap-GNode* (~f ~node))))))
(export g_node_first_sibling)

;; extern GNode *g_node_last_sibling(GNode *node);
(define g_node_last_sibling
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_node_last_sibling"
                (dynamic-link))
              (list '*))))
    (lambda (node)
      (let ((~node (unwrap-GNode* node)))
        (wrap-GNode* (~f ~node))))))
(export g_node_last_sibling)

;; typedef struct _GList GList;
(define GList-desc void)
(define GList*-desc (bs:pointer (delay GList-desc)))
(define-fh-pointer-type GList* GList*-desc)

;; struct _GList {
;;   gpointer data;
;;   GList *next;
;;   GList *prev;
;; };
(define struct-_GList-desc
  (bs:struct
    (list `(data ,gpointer-desc)
          `(next ,(bs:pointer GList*-desc))
          `(prev ,(bs:pointer GList*-desc)))))
(export struct-_GList-desc)
(define-fh-compound-type/p struct-_GList struct-_GList-desc)
(set! GList-desc struct-_GList-desc)
(define-fh-compound-type GList GList-desc)

;; extern GList *g_list_alloc(void);
(define g_list_alloc
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_list_alloc" (dynamic-link))
              (list))))
    (lambda () (let () (wrap-GList* (~f))))))
(export g_list_alloc)

;; extern void g_list_free(GList *list);
(define g_list_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_list_free" (dynamic-link))
              (list '*))))
    (lambda (list)
      (let ((~list (unwrap-GList* list))) (~f ~list)))))
(export g_list_free)

;; extern void g_list_free_1(GList *list);
(define g_list_free_1
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_list_free_1" (dynamic-link))
              (list '*))))
    (lambda (list)
      (let ((~list (unwrap-GList* list))) (~f ~list)))))
(export g_list_free_1)

;; extern void g_list_free_full(GList *list, GDestroyNotify free_func);
(define g_list_free_full
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_list_free_full" (dynamic-link))
              (list '* '*))))
    (lambda (list free_func)
      (let ((~list (unwrap-GList* list))
            (~free_func
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               free_func)))
        (~f ~list ~free_func)))))
(export g_list_free_full)

;; extern GList *g_list_append(GList *list, gpointer data);
(define g_list_append
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_list_append" (dynamic-link))
              (list '* '*))))
    (lambda (list data)
      (let ((~list (unwrap-GList* list))
            (~data (unwrap-gpointer data)))
        (wrap-GList* (~f ~list ~data))))))
(export g_list_append)

;; extern GList *g_list_prepend(GList *list, gpointer data);
(define g_list_prepend
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_list_prepend" (dynamic-link))
              (list '* '*))))
    (lambda (list data)
      (let ((~list (unwrap-GList* list))
            (~data (unwrap-gpointer data)))
        (wrap-GList* (~f ~list ~data))))))
(export g_list_prepend)

;; extern GList *g_list_insert(GList *list, gpointer data, gint position);
(define g_list_insert
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_list_insert" (dynamic-link))
              (list '* '* ffi:int))))
    (lambda (list data position)
      (let ((~list (unwrap-GList* list))
            (~data (unwrap-gpointer data))
            (~position (unwrap-gint position)))
        (wrap-GList* (~f ~list ~data ~position))))))
(export g_list_insert)

;; extern GList *g_list_insert_sorted(GList *list, gpointer data, GCompareFunc 
;;     func);
;; ... failed.

;; extern GList *g_list_insert_sorted_with_data(GList *list, gpointer data, 
;;     GCompareDataFunc func, gpointer user_data);
;; ... failed.

;; extern GList *g_list_insert_before(GList *list, GList *sibling, gpointer 
;;     data);
(define g_list_insert_before
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_list_insert_before"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (list sibling data)
      (let ((~list (unwrap-GList* list))
            (~sibling (unwrap-GList* sibling))
            (~data (unwrap-gpointer data)))
        (wrap-GList* (~f ~list ~sibling ~data))))))
(export g_list_insert_before)

;; extern GList *g_list_concat(GList *list1, GList *list2);
(define g_list_concat
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_list_concat" (dynamic-link))
              (list '* '*))))
    (lambda (list1 list2)
      (let ((~list1 (unwrap-GList* list1))
            (~list2 (unwrap-GList* list2)))
        (wrap-GList* (~f ~list1 ~list2))))))
(export g_list_concat)

;; extern GList *g_list_remove(GList *list, gconstpointer data);
(define g_list_remove
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_list_remove" (dynamic-link))
              (list '* '*))))
    (lambda (list data)
      (let ((~list (unwrap-GList* list))
            (~data (unwrap-gconstpointer data)))
        (wrap-GList* (~f ~list ~data))))))
(export g_list_remove)

;; extern GList *g_list_remove_all(GList *list, gconstpointer data);
(define g_list_remove_all
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_list_remove_all" (dynamic-link))
              (list '* '*))))
    (lambda (list data)
      (let ((~list (unwrap-GList* list))
            (~data (unwrap-gconstpointer data)))
        (wrap-GList* (~f ~list ~data))))))
(export g_list_remove_all)

;; extern GList *g_list_remove_link(GList *list, GList *llink);
(define g_list_remove_link
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_list_remove_link"
                (dynamic-link))
              (list '* '*))))
    (lambda (list llink)
      (let ((~list (unwrap-GList* list))
            (~llink (unwrap-GList* llink)))
        (wrap-GList* (~f ~list ~llink))))))
(export g_list_remove_link)

;; extern GList *g_list_delete_link(GList *list, GList *link_);
(define g_list_delete_link
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_list_delete_link"
                (dynamic-link))
              (list '* '*))))
    (lambda (list link_)
      (let ((~list (unwrap-GList* list))
            (~link_ (unwrap-GList* link_)))
        (wrap-GList* (~f ~list ~link_))))))
(export g_list_delete_link)

;; extern GList *g_list_reverse(GList *list);
(define g_list_reverse
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_list_reverse" (dynamic-link))
              (list '*))))
    (lambda (list)
      (let ((~list (unwrap-GList* list)))
        (wrap-GList* (~f ~list))))))
(export g_list_reverse)

;; extern GList *g_list_copy(GList *list);
(define g_list_copy
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_list_copy" (dynamic-link))
              (list '*))))
    (lambda (list)
      (let ((~list (unwrap-GList* list)))
        (wrap-GList* (~f ~list))))))
(export g_list_copy)

;; extern GList *g_list_copy_deep(GList *list, GCopyFunc func, gpointer 
;;     user_data);
;; ... failed.

;; extern GList *g_list_nth(GList *list, guint n);
(define g_list_nth
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_list_nth" (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (list n)
      (let ((~list (unwrap-GList* list))
            (~n (unwrap-guint n)))
        (wrap-GList* (~f ~list ~n))))))
(export g_list_nth)

;; extern GList *g_list_nth_prev(GList *list, guint n);
(define g_list_nth_prev
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_list_nth_prev" (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (list n)
      (let ((~list (unwrap-GList* list))
            (~n (unwrap-guint n)))
        (wrap-GList* (~f ~list ~n))))))
(export g_list_nth_prev)

;; extern GList *g_list_find(GList *list, gconstpointer data);
(define g_list_find
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_list_find" (dynamic-link))
              (list '* '*))))
    (lambda (list data)
      (let ((~list (unwrap-GList* list))
            (~data (unwrap-gconstpointer data)))
        (wrap-GList* (~f ~list ~data))))))
(export g_list_find)

;; extern GList *g_list_find_custom(GList *list, gconstpointer data, 
;;     GCompareFunc func);
;; ... failed.

;; extern gint g_list_position(GList *list, GList *llink);
(define g_list_position
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_list_position" (dynamic-link))
              (list '* '*))))
    (lambda (list llink)
      (let ((~list (unwrap-GList* list))
            (~llink (unwrap-GList* llink)))
        (wrap-gint (~f ~list ~llink))))))
(export g_list_position)

;; extern gint g_list_index(GList *list, gconstpointer data);
(define g_list_index
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_list_index" (dynamic-link))
              (list '* '*))))
    (lambda (list data)
      (let ((~list (unwrap-GList* list))
            (~data (unwrap-gconstpointer data)))
        (wrap-gint (~f ~list ~data))))))
(export g_list_index)

;; extern GList *g_list_last(GList *list);
(define g_list_last
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_list_last" (dynamic-link))
              (list '*))))
    (lambda (list)
      (let ((~list (unwrap-GList* list)))
        (wrap-GList* (~f ~list))))))
(export g_list_last)

;; extern GList *g_list_first(GList *list);
(define g_list_first
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_list_first" (dynamic-link))
              (list '*))))
    (lambda (list)
      (let ((~list (unwrap-GList* list)))
        (wrap-GList* (~f ~list))))))
(export g_list_first)

;; extern guint g_list_length(GList *list);
(define g_list_length
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func "g_list_length" (dynamic-link))
              (list '*))))
    (lambda (list)
      (let ((~list (unwrap-GList* list)))
        (wrap-guint (~f ~list))))))
(export g_list_length)

;; extern void g_list_foreach(GList *list, GFunc func, gpointer user_data);
(define g_list_foreach
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_list_foreach" (dynamic-link))
              (list '* '* '*))))
    (lambda (list func user_data)
      (let ((~list (unwrap-GList* list))
            (~func ((make-ftn-arg-unwrapper ffi:void (list '* '*))
                    func))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~list ~func ~user_data)))))
(export g_list_foreach)

;; extern GList *g_list_sort(GList *list, GCompareFunc compare_func);
;; ... failed.

;; extern GList *g_list_sort_with_data(GList *list, GCompareDataFunc 
;;     compare_func, gpointer user_data);
;; ... failed.

;; extern gpointer g_list_nth_data(GList *list, guint n);
(define g_list_nth_data
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_list_nth_data" (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (list n)
      (let ((~list (unwrap-GList* list))
            (~n (unwrap-guint n)))
        (wrap-gpointer (~f ~list ~n))))))
(export g_list_nth_data)

;; typedef struct _GHashTable GHashTable;
(define GHashTable-desc void)
(define GHashTable*-desc (bs:pointer GHashTable-desc))
(define-fh-pointer-type GHashTable* GHashTable*-desc)

;; typedef gboolean (*GHRFunc)(gpointer key, gpointer value, gpointer user_data
;;     );
(define-fh-function/p GHRFunc
  ffi:int (list (quote *) (quote *) (quote *)))

;; typedef struct _GHashTableIter GHashTableIter;
(define GHashTableIter-desc void)
(define GHashTableIter*-desc (bs:pointer (delay GHashTableIter-desc)))
(define-fh-pointer-type GHashTableIter* GHashTableIter*-desc)

;; struct _GHashTableIter {
;;   /*< private >*/
;;   gpointer dummy1;
;;   gpointer dummy2;
;;   gpointer dummy3;
;;   int dummy4;
;;   gboolean dummy5;
;;   gpointer dummy6;
;; };
(define struct-_GHashTableIter-desc
  (bs:struct
    (list `(dummy1 ,gpointer-desc)
          `(dummy2 ,gpointer-desc)
          `(dummy3 ,gpointer-desc)
          `(dummy4 ,int)
          `(dummy5 ,gboolean-desc)
          `(dummy6 ,gpointer-desc))))
(export struct-_GHashTableIter-desc)
(define-fh-compound-type/p struct-_GHashTableIter struct-_GHashTableIter-desc)
(set! GHashTableIter-desc struct-_GHashTableIter-desc)
(define-fh-compound-type GHashTableIter GHashTableIter-desc)

;; extern GHashTable *g_hash_table_new(GHashFunc hash_func, GEqualFunc 
;;     key_equal_func);
;; ... failed.

;; extern GHashTable *g_hash_table_new_full(GHashFunc hash_func, GEqualFunc 
;;     key_equal_func, GDestroyNotify key_destroy_func, GDestroyNotify 
;;     value_destroy_func);
;; ... failed.

;; extern void g_hash_table_destroy(GHashTable *hash_table);
(define g_hash_table_destroy
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_hash_table_destroy"
                (dynamic-link))
              (list '*))))
    (lambda (hash_table)
      (let ((~hash_table (unwrap-GHashTable* hash_table)))
        (~f ~hash_table)))))
(export g_hash_table_destroy)

;; extern gboolean g_hash_table_insert(GHashTable *hash_table, gpointer key, 
;;     gpointer value);
(define g_hash_table_insert
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_hash_table_insert"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (hash_table key value)
      (let ((~hash_table (unwrap-GHashTable* hash_table))
            (~key (unwrap-gpointer key))
            (~value (unwrap-gpointer value)))
        (wrap-gboolean (~f ~hash_table ~key ~value))))))
(export g_hash_table_insert)

;; extern gboolean g_hash_table_replace(GHashTable *hash_table, gpointer key, 
;;     gpointer value);
(define g_hash_table_replace
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_hash_table_replace"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (hash_table key value)
      (let ((~hash_table (unwrap-GHashTable* hash_table))
            (~key (unwrap-gpointer key))
            (~value (unwrap-gpointer value)))
        (wrap-gboolean (~f ~hash_table ~key ~value))))))
(export g_hash_table_replace)

;; extern gboolean g_hash_table_add(GHashTable *hash_table, gpointer key);
(define g_hash_table_add
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_hash_table_add" (dynamic-link))
              (list '* '*))))
    (lambda (hash_table key)
      (let ((~hash_table (unwrap-GHashTable* hash_table))
            (~key (unwrap-gpointer key)))
        (wrap-gboolean (~f ~hash_table ~key))))))
(export g_hash_table_add)

;; extern gboolean g_hash_table_remove(GHashTable *hash_table, gconstpointer 
;;     key);
(define g_hash_table_remove
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_hash_table_remove"
                (dynamic-link))
              (list '* '*))))
    (lambda (hash_table key)
      (let ((~hash_table (unwrap-GHashTable* hash_table))
            (~key (unwrap-gconstpointer key)))
        (wrap-gboolean (~f ~hash_table ~key))))))
(export g_hash_table_remove)

;; extern void g_hash_table_remove_all(GHashTable *hash_table);
(define g_hash_table_remove_all
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_hash_table_remove_all"
                (dynamic-link))
              (list '*))))
    (lambda (hash_table)
      (let ((~hash_table (unwrap-GHashTable* hash_table)))
        (~f ~hash_table)))))
(export g_hash_table_remove_all)

;; extern gboolean g_hash_table_steal(GHashTable *hash_table, gconstpointer key
;;     );
(define g_hash_table_steal
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_hash_table_steal"
                (dynamic-link))
              (list '* '*))))
    (lambda (hash_table key)
      (let ((~hash_table (unwrap-GHashTable* hash_table))
            (~key (unwrap-gconstpointer key)))
        (wrap-gboolean (~f ~hash_table ~key))))))
(export g_hash_table_steal)

;; extern void g_hash_table_steal_all(GHashTable *hash_table);
(define g_hash_table_steal_all
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_hash_table_steal_all"
                (dynamic-link))
              (list '*))))
    (lambda (hash_table)
      (let ((~hash_table (unwrap-GHashTable* hash_table)))
        (~f ~hash_table)))))
(export g_hash_table_steal_all)

;; extern gpointer g_hash_table_lookup(GHashTable *hash_table, gconstpointer 
;;     key);
(define g_hash_table_lookup
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_hash_table_lookup"
                (dynamic-link))
              (list '* '*))))
    (lambda (hash_table key)
      (let ((~hash_table (unwrap-GHashTable* hash_table))
            (~key (unwrap-gconstpointer key)))
        (wrap-gpointer (~f ~hash_table ~key))))))
(export g_hash_table_lookup)

;; extern gboolean g_hash_table_contains(GHashTable *hash_table, gconstpointer 
;;     key);
(define g_hash_table_contains
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_hash_table_contains"
                (dynamic-link))
              (list '* '*))))
    (lambda (hash_table key)
      (let ((~hash_table (unwrap-GHashTable* hash_table))
            (~key (unwrap-gconstpointer key)))
        (wrap-gboolean (~f ~hash_table ~key))))))
(export g_hash_table_contains)

;; extern gboolean g_hash_table_lookup_extended(GHashTable *hash_table, 
;;     gconstpointer lookup_key, gpointer *orig_key, gpointer *value);
(define g_hash_table_lookup_extended
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_hash_table_lookup_extended"
                (dynamic-link))
              (list '* '* '* '*))))
    (lambda (hash_table lookup_key orig_key value)
      (let ((~hash_table (unwrap-GHashTable* hash_table))
            (~lookup_key (unwrap-gconstpointer lookup_key))
            (~orig_key (unwrap-gpointer* orig_key))
            (~value (unwrap-gpointer* value)))
        (wrap-gboolean
          (~f ~hash_table ~lookup_key ~orig_key ~value))))))
(export g_hash_table_lookup_extended)

;; extern void g_hash_table_foreach(GHashTable *hash_table, GHFunc func, 
;;     gpointer user_data);
(define g_hash_table_foreach
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_hash_table_foreach"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (hash_table func user_data)
      (let ((~hash_table (unwrap-GHashTable* hash_table))
            (~func ((make-ftn-arg-unwrapper ffi:void (list '* '* '*))
                    func))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~hash_table ~func ~user_data)))))
(export g_hash_table_foreach)

;; extern gpointer g_hash_table_find(GHashTable *hash_table, GHRFunc predicate
;;     , gpointer user_data);
;; ... failed.

;; extern guint g_hash_table_foreach_remove(GHashTable *hash_table, GHRFunc 
;;     func, gpointer user_data);
;; ... failed.

;; extern guint g_hash_table_foreach_steal(GHashTable *hash_table, GHRFunc func
;;     , gpointer user_data);
;; ... failed.

;; extern guint g_hash_table_size(GHashTable *hash_table);
(define g_hash_table_size
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func "g_hash_table_size" (dynamic-link))
              (list '*))))
    (lambda (hash_table)
      (let ((~hash_table (unwrap-GHashTable* hash_table)))
        (wrap-guint (~f ~hash_table))))))
(export g_hash_table_size)

;; extern GList *g_hash_table_get_keys(GHashTable *hash_table);
(define g_hash_table_get_keys
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_hash_table_get_keys"
                (dynamic-link))
              (list '*))))
    (lambda (hash_table)
      (let ((~hash_table (unwrap-GHashTable* hash_table)))
        (wrap-GList* (~f ~hash_table))))))
(export g_hash_table_get_keys)

;; extern GList *g_hash_table_get_values(GHashTable *hash_table);
(define g_hash_table_get_values
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_hash_table_get_values"
                (dynamic-link))
              (list '*))))
    (lambda (hash_table)
      (let ((~hash_table (unwrap-GHashTable* hash_table)))
        (wrap-GList* (~f ~hash_table))))))
(export g_hash_table_get_values)

;; extern gpointer *g_hash_table_get_keys_as_array(GHashTable *hash_table, 
;;     guint *length);
(define g_hash_table_get_keys_as_array
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_hash_table_get_keys_as_array"
                (dynamic-link))
              (list '* '*))))
    (lambda (hash_table length)
      (let ((~hash_table (unwrap-GHashTable* hash_table))
            (~length (unwrap-guint* length)))
        (wrap-gpointer* (~f ~hash_table ~length))))))
(export g_hash_table_get_keys_as_array)

;; extern void g_hash_table_iter_init(GHashTableIter *iter, GHashTable *
;;     hash_table);
(define g_hash_table_iter_init
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_hash_table_iter_init"
                (dynamic-link))
              (list '* '*))))
    (lambda (iter hash_table)
      (let ((~iter (unwrap-GHashTableIter* iter))
            (~hash_table (unwrap-GHashTable* hash_table)))
        (~f ~iter ~hash_table)))))
(export g_hash_table_iter_init)

;; extern gboolean g_hash_table_iter_next(GHashTableIter *iter, gpointer *key, 
;;     gpointer *value);
(define g_hash_table_iter_next
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_hash_table_iter_next"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (iter key value)
      (let ((~iter (unwrap-GHashTableIter* iter))
            (~key (unwrap-gpointer* key))
            (~value (unwrap-gpointer* value)))
        (wrap-gboolean (~f ~iter ~key ~value))))))
(export g_hash_table_iter_next)

;; extern GHashTable *g_hash_table_iter_get_hash_table(GHashTableIter *iter);
(define g_hash_table_iter_get_hash_table
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_hash_table_iter_get_hash_table"
                (dynamic-link))
              (list '*))))
    (lambda (iter)
      (let ((~iter (unwrap-GHashTableIter* iter)))
        (wrap-GHashTable* (~f ~iter))))))
(export g_hash_table_iter_get_hash_table)

;; extern void g_hash_table_iter_remove(GHashTableIter *iter);
(define g_hash_table_iter_remove
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_hash_table_iter_remove"
                (dynamic-link))
              (list '*))))
    (lambda (iter)
      (let ((~iter (unwrap-GHashTableIter* iter)))
        (~f ~iter)))))
(export g_hash_table_iter_remove)

;; extern void g_hash_table_iter_replace(GHashTableIter *iter, gpointer value)
;;     ;
(define g_hash_table_iter_replace
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_hash_table_iter_replace"
                (dynamic-link))
              (list '* '*))))
    (lambda (iter value)
      (let ((~iter (unwrap-GHashTableIter* iter))
            (~value (unwrap-gpointer value)))
        (~f ~iter ~value)))))
(export g_hash_table_iter_replace)

;; extern void g_hash_table_iter_steal(GHashTableIter *iter);
(define g_hash_table_iter_steal
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_hash_table_iter_steal"
                (dynamic-link))
              (list '*))))
    (lambda (iter)
      (let ((~iter (unwrap-GHashTableIter* iter)))
        (~f ~iter)))))
(export g_hash_table_iter_steal)

;; extern GHashTable *g_hash_table_ref(GHashTable *hash_table);
(define g_hash_table_ref
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_hash_table_ref" (dynamic-link))
              (list '*))))
    (lambda (hash_table)
      (let ((~hash_table (unwrap-GHashTable* hash_table)))
        (wrap-GHashTable* (~f ~hash_table))))))
(export g_hash_table_ref)

;; extern void g_hash_table_unref(GHashTable *hash_table);
(define g_hash_table_unref
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_hash_table_unref"
                (dynamic-link))
              (list '*))))
    (lambda (hash_table)
      (let ((~hash_table (unwrap-GHashTable* hash_table)))
        (~f ~hash_table)))))
(export g_hash_table_unref)

;; extern gboolean g_str_equal(gconstpointer v1, gconstpointer v2);
(define g_str_equal
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_str_equal" (dynamic-link))
              (list '* '*))))
    (lambda (v1 v2)
      (let ((~v1 (unwrap-gconstpointer v1))
            (~v2 (unwrap-gconstpointer v2)))
        (wrap-gboolean (~f ~v1 ~v2))))))
(export g_str_equal)

;; extern guint g_str_hash(gconstpointer v);
(define g_str_hash
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func "g_str_hash" (dynamic-link))
              (list '*))))
    (lambda (v)
      (let ((~v (unwrap-gconstpointer v)))
        (wrap-guint (~f ~v))))))
(export g_str_hash)

;; extern gboolean g_int_equal(gconstpointer v1, gconstpointer v2);
(define g_int_equal
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_int_equal" (dynamic-link))
              (list '* '*))))
    (lambda (v1 v2)
      (let ((~v1 (unwrap-gconstpointer v1))
            (~v2 (unwrap-gconstpointer v2)))
        (wrap-gboolean (~f ~v1 ~v2))))))
(export g_int_equal)

;; extern guint g_int_hash(gconstpointer v);
(define g_int_hash
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func "g_int_hash" (dynamic-link))
              (list '*))))
    (lambda (v)
      (let ((~v (unwrap-gconstpointer v)))
        (wrap-guint (~f ~v))))))
(export g_int_hash)

;; extern gboolean g_int64_equal(gconstpointer v1, gconstpointer v2);
(define g_int64_equal
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_int64_equal" (dynamic-link))
              (list '* '*))))
    (lambda (v1 v2)
      (let ((~v1 (unwrap-gconstpointer v1))
            (~v2 (unwrap-gconstpointer v2)))
        (wrap-gboolean (~f ~v1 ~v2))))))
(export g_int64_equal)

;; extern guint g_int64_hash(gconstpointer v);
(define g_int64_hash
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func "g_int64_hash" (dynamic-link))
              (list '*))))
    (lambda (v)
      (let ((~v (unwrap-gconstpointer v)))
        (wrap-guint (~f ~v))))))
(export g_int64_hash)

;; extern gboolean g_double_equal(gconstpointer v1, gconstpointer v2);
(define g_double_equal
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_double_equal" (dynamic-link))
              (list '* '*))))
    (lambda (v1 v2)
      (let ((~v1 (unwrap-gconstpointer v1))
            (~v2 (unwrap-gconstpointer v2)))
        (wrap-gboolean (~f ~v1 ~v2))))))
(export g_double_equal)

;; extern guint g_double_hash(gconstpointer v);
(define g_double_hash
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func "g_double_hash" (dynamic-link))
              (list '*))))
    (lambda (v)
      (let ((~v (unwrap-gconstpointer v)))
        (wrap-guint (~f ~v))))))
(export g_double_hash)

;; extern guint g_direct_hash(gconstpointer v);
(define g_direct_hash
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func "g_direct_hash" (dynamic-link))
              (list '*))))
    (lambda (v)
      (let ((~v (unwrap-gconstpointer v)))
        (wrap-guint (~f ~v))))))
(export g_direct_hash)

;; extern gboolean g_direct_equal(gconstpointer v1, gconstpointer v2);
(define g_direct_equal
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_direct_equal" (dynamic-link))
              (list '* '*))))
    (lambda (v1 v2)
      (let ((~v1 (unwrap-gconstpointer v1))
            (~v2 (unwrap-gconstpointer v2)))
        (wrap-gboolean (~f ~v1 ~v2))))))
(export g_direct_equal)

;; typedef struct _GHmac GHmac;
(define GHmac-desc void)
(define GHmac*-desc (bs:pointer GHmac-desc))
(define-fh-pointer-type GHmac* GHmac*-desc)

;; extern GHmac *g_hmac_new(GChecksumType digest_type, const guchar *key, gsize
;;      key_len);
(define g_hmac_new
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_hmac_new" (dynamic-link))
              (list ffi:int '* ffi:unsigned-long))))
    (lambda (digest_type key key_len)
      (let ((~digest_type (unwrap~fixed digest_type))
            (~key (unwrap-guchar* key))
            (~key_len (unwrap~fixed key_len)))
        (wrap-GHmac* (~f ~digest_type ~key ~key_len))))))
(export g_hmac_new)

;; extern GHmac *g_hmac_copy(const GHmac *hmac);
(define g_hmac_copy
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_hmac_copy" (dynamic-link))
              (list '*))))
    (lambda (hmac)
      (let ((~hmac (unwrap-GHmac* hmac)))
        (wrap-GHmac* (~f ~hmac))))))
(export g_hmac_copy)

;; extern GHmac *g_hmac_ref(GHmac *hmac);
(define g_hmac_ref
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_hmac_ref" (dynamic-link))
              (list '*))))
    (lambda (hmac)
      (let ((~hmac (unwrap-GHmac* hmac)))
        (wrap-GHmac* (~f ~hmac))))))
(export g_hmac_ref)

;; extern void g_hmac_unref(GHmac *hmac);
(define g_hmac_unref
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_hmac_unref" (dynamic-link))
              (list '*))))
    (lambda (hmac)
      (let ((~hmac (unwrap-GHmac* hmac))) (~f ~hmac)))))
(export g_hmac_unref)

;; extern void g_hmac_update(GHmac *hmac, const guchar *data, gssize length);
;; ... failed.

;; extern const gchar *g_hmac_get_string(GHmac *hmac);
(define g_hmac_get_string
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_hmac_get_string" (dynamic-link))
              (list '*))))
    (lambda (hmac)
      (let ((~hmac (unwrap-GHmac* hmac)))
        (wrap-gchar* (~f ~hmac))))))
(export g_hmac_get_string)

;; extern void g_hmac_get_digest(GHmac *hmac, guint8 *buffer, gsize *digest_len
;;     );
(define g_hmac_get_digest
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_hmac_get_digest" (dynamic-link))
              (list '* '* '*))))
    (lambda (hmac buffer digest_len)
      (let ((~hmac (unwrap-GHmac* hmac))
            (~buffer (unwrap~pointer buffer))
            (~digest_len (unwrap~pointer digest_len)))
        (~f ~hmac ~buffer ~digest_len)))))
(export g_hmac_get_digest)

;; extern gchar *g_compute_hmac_for_data(GChecksumType digest_type, const 
;;     guchar *key, gsize key_len, const guchar *data, gsize length);
(define g_compute_hmac_for_data
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_compute_hmac_for_data"
                (dynamic-link))
              (list ffi:int
                    '*
                    ffi:unsigned-long
                    '*
                    ffi:unsigned-long))))
    (lambda (digest_type key key_len data length)
      (let ((~digest_type (unwrap~fixed digest_type))
            (~key (unwrap-guchar* key))
            (~key_len (unwrap~fixed key_len))
            (~data (unwrap-guchar* data))
            (~length (unwrap~fixed length)))
        (wrap-gchar*
          (~f ~digest_type ~key ~key_len ~data ~length))))))
(export g_compute_hmac_for_data)

;; extern gchar *g_compute_hmac_for_string(GChecksumType digest_type, const 
;;     guchar *key, gsize key_len, const gchar *str, gssize length);
;; ... failed.

;; extern gchar *g_compute_hmac_for_bytes(GChecksumType digest_type, GBytes *
;;     key, GBytes *data);
(define g_compute_hmac_for_bytes
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_compute_hmac_for_bytes"
                (dynamic-link))
              (list ffi:int '* '*))))
    (lambda (digest_type key data)
      (let ((~digest_type (unwrap~fixed digest_type))
            (~key (unwrap-GBytes* key))
            (~data (unwrap-GBytes* data)))
        (wrap-gchar* (~f ~digest_type ~key ~data))))))
(export g_compute_hmac_for_bytes)

;; typedef struct _GHook GHook;
(define GHook-desc void)
(define GHook*-desc (bs:pointer (delay GHook-desc)))
(define-fh-pointer-type GHook* GHook*-desc)

;; typedef struct _GHookList GHookList;
(define GHookList-desc void)
(define GHookList*-desc (bs:pointer (delay GHookList-desc)))
(define-fh-pointer-type GHookList* GHookList*-desc)

;; typedef gint (*GHookCompareFunc)(GHook *new_hook, GHook *sibling);
(define-fh-function/p GHookCompareFunc
  ffi:int (list (quote *) (quote *)))

;; typedef gboolean (*GHookFindFunc)(GHook *hook, gpointer data);
(define-fh-function/p GHookFindFunc
  ffi:int (list (quote *) (quote *)))

;; typedef void (*GHookMarshaller)(GHook *hook, gpointer marshal_data);
(define-fh-function/p GHookMarshaller
  ffi:void (list (quote *) (quote *)))

;; typedef gboolean (*GHookCheckMarshaller)(GHook *hook, gpointer marshal_data)
;;     ;
(define-fh-function/p GHookCheckMarshaller
  ffi:int (list (quote *) (quote *)))

;; typedef void (*GHookFunc)(gpointer data);
(define-fh-function/p GHookFunc
  ffi:void (list (quote *)))

;; typedef gboolean (*GHookCheckFunc)(gpointer data);
(define-fh-function/p GHookCheckFunc
  ffi:int (list (quote *)))

;; typedef void (*GHookFinalizeFunc)(GHookList *hook_list, GHook *hook);
(define-fh-function/p GHookFinalizeFunc
  ffi:void (list (quote *) (quote *)))

;; typedef enum {
;;   G_HOOK_FLAG_ACTIVE = 1<<0,
;;   G_HOOK_FLAG_IN_CALL = 1<<1,
;;   G_HOOK_FLAG_MASK = 0x0f,
;; } GHookFlagMask;
(define-fh-enum GHookFlagMask
  '((G_HOOK_FLAG_ACTIVE . 1)
    (G_HOOK_FLAG_IN_CALL . 2)
    (G_HOOK_FLAG_MASK . 15))
  )

;; struct _GHookList {
;;   gulong seq_id;
;;   guint hook_size : 16;
;;   guint is_setup : 1;
;;   GHook *hooks;
;;   gpointer dummy3;
;;   GHookFinalizeFunc finalize_hook;
;;   gpointer dummy[2];
;; };
(define struct-_GHookList-desc
  (bs:struct
    (list `(seq_id ,gulong-desc)
          `(hook_size ,guint-desc)
          `(is_setup ,guint-desc)
          `(hooks ,(bs:pointer GHook*-desc))
          `(dummy3 ,gpointer-desc)
          `(finalize_hook ,(bs:pointer void))
          `(dummy ,(bs:vector 2 gpointer-desc)))))
(export struct-_GHookList-desc)
(define-fh-compound-type/p struct-_GHookList struct-_GHookList-desc)
(set! GHookList-desc struct-_GHookList-desc)
(define-fh-compound-type GHookList GHookList-desc)

;; struct _GHook {
;;   gpointer data;
;;   GHook *next;
;;   GHook *prev;
;;   guint ref_count;
;;   gulong hook_id;
;;   guint flags;
;;   gpointer func;
;;   GDestroyNotify destroy;
;; };
(define struct-_GHook-desc
  (bs:struct
    (list `(data ,gpointer-desc)
          `(next ,(bs:pointer GHook*-desc))
          `(prev ,(bs:pointer GHook*-desc))
          `(ref_count ,guint-desc)
          `(hook_id ,gulong-desc)
          `(flags ,guint-desc)
          `(func ,gpointer-desc)
          `(destroy ,(bs:pointer void)))))
(export struct-_GHook-desc)
(define-fh-compound-type/p struct-_GHook struct-_GHook-desc)
(set! GHook-desc struct-_GHook-desc)
(define-fh-compound-type GHook GHook-desc)

;; extern void g_hook_list_init(GHookList *hook_list, guint hook_size);
(define g_hook_list_init
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_hook_list_init" (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (hook_list hook_size)
      (let ((~hook_list (unwrap-GHookList* hook_list))
            (~hook_size (unwrap-guint hook_size)))
        (~f ~hook_list ~hook_size)))))
(export g_hook_list_init)

;; extern void g_hook_list_clear(GHookList *hook_list);
(define g_hook_list_clear
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_hook_list_clear" (dynamic-link))
              (list '*))))
    (lambda (hook_list)
      (let ((~hook_list (unwrap-GHookList* hook_list)))
        (~f ~hook_list)))))
(export g_hook_list_clear)

;; extern GHook *g_hook_alloc(GHookList *hook_list);
(define g_hook_alloc
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_hook_alloc" (dynamic-link))
              (list '*))))
    (lambda (hook_list)
      (let ((~hook_list (unwrap-GHookList* hook_list)))
        (wrap-GHook* (~f ~hook_list))))))
(export g_hook_alloc)

;; extern void g_hook_free(GHookList *hook_list, GHook *hook);
(define g_hook_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_hook_free" (dynamic-link))
              (list '* '*))))
    (lambda (hook_list hook)
      (let ((~hook_list (unwrap-GHookList* hook_list))
            (~hook (unwrap-GHook* hook)))
        (~f ~hook_list ~hook)))))
(export g_hook_free)

;; extern GHook *g_hook_ref(GHookList *hook_list, GHook *hook);
(define g_hook_ref
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_hook_ref" (dynamic-link))
              (list '* '*))))
    (lambda (hook_list hook)
      (let ((~hook_list (unwrap-GHookList* hook_list))
            (~hook (unwrap-GHook* hook)))
        (wrap-GHook* (~f ~hook_list ~hook))))))
(export g_hook_ref)

;; extern void g_hook_unref(GHookList *hook_list, GHook *hook);
(define g_hook_unref
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_hook_unref" (dynamic-link))
              (list '* '*))))
    (lambda (hook_list hook)
      (let ((~hook_list (unwrap-GHookList* hook_list))
            (~hook (unwrap-GHook* hook)))
        (~f ~hook_list ~hook)))))
(export g_hook_unref)

;; extern gboolean g_hook_destroy(GHookList *hook_list, gulong hook_id);
(define g_hook_destroy
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_hook_destroy" (dynamic-link))
              (list '* ffi:unsigned-long))))
    (lambda (hook_list hook_id)
      (let ((~hook_list (unwrap-GHookList* hook_list))
            (~hook_id (unwrap-gulong hook_id)))
        (wrap-gboolean (~f ~hook_list ~hook_id))))))
(export g_hook_destroy)

;; extern void g_hook_destroy_link(GHookList *hook_list, GHook *hook);
(define g_hook_destroy_link
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_hook_destroy_link"
                (dynamic-link))
              (list '* '*))))
    (lambda (hook_list hook)
      (let ((~hook_list (unwrap-GHookList* hook_list))
            (~hook (unwrap-GHook* hook)))
        (~f ~hook_list ~hook)))))
(export g_hook_destroy_link)

;; extern void g_hook_prepend(GHookList *hook_list, GHook *hook);
(define g_hook_prepend
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_hook_prepend" (dynamic-link))
              (list '* '*))))
    (lambda (hook_list hook)
      (let ((~hook_list (unwrap-GHookList* hook_list))
            (~hook (unwrap-GHook* hook)))
        (~f ~hook_list ~hook)))))
(export g_hook_prepend)

;; extern void g_hook_insert_before(GHookList *hook_list, GHook *sibling, GHook
;;      *hook);
(define g_hook_insert_before
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_hook_insert_before"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (hook_list sibling hook)
      (let ((~hook_list (unwrap-GHookList* hook_list))
            (~sibling (unwrap-GHook* sibling))
            (~hook (unwrap-GHook* hook)))
        (~f ~hook_list ~sibling ~hook)))))
(export g_hook_insert_before)

;; extern void g_hook_insert_sorted(GHookList *hook_list, GHook *hook, 
;;     GHookCompareFunc func);
;; ... failed.

;; extern GHook *g_hook_get(GHookList *hook_list, gulong hook_id);
(define g_hook_get
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_hook_get" (dynamic-link))
              (list '* ffi:unsigned-long))))
    (lambda (hook_list hook_id)
      (let ((~hook_list (unwrap-GHookList* hook_list))
            (~hook_id (unwrap-gulong hook_id)))
        (wrap-GHook* (~f ~hook_list ~hook_id))))))
(export g_hook_get)

;; extern GHook *g_hook_find(GHookList *hook_list, gboolean need_valids, 
;;     GHookFindFunc func, gpointer data);
;; ... failed.

;; extern GHook *g_hook_find_data(GHookList *hook_list, gboolean need_valids, 
;;     gpointer data);
(define g_hook_find_data
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_hook_find_data" (dynamic-link))
              (list '* ffi:int '*))))
    (lambda (hook_list need_valids data)
      (let ((~hook_list (unwrap-GHookList* hook_list))
            (~need_valids (unwrap-gboolean need_valids))
            (~data (unwrap-gpointer data)))
        (wrap-GHook* (~f ~hook_list ~need_valids ~data))))))
(export g_hook_find_data)

;; extern GHook *g_hook_find_func(GHookList *hook_list, gboolean need_valids, 
;;     gpointer func);
(define g_hook_find_func
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_hook_find_func" (dynamic-link))
              (list '* ffi:int '*))))
    (lambda (hook_list need_valids func)
      (let ((~hook_list (unwrap-GHookList* hook_list))
            (~need_valids (unwrap-gboolean need_valids))
            (~func (unwrap-gpointer func)))
        (wrap-GHook* (~f ~hook_list ~need_valids ~func))))))
(export g_hook_find_func)

;; extern GHook *g_hook_find_func_data(GHookList *hook_list, gboolean 
;;     need_valids, gpointer func, gpointer data);
(define g_hook_find_func_data
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_hook_find_func_data"
                (dynamic-link))
              (list '* ffi:int '* '*))))
    (lambda (hook_list need_valids func data)
      (let ((~hook_list (unwrap-GHookList* hook_list))
            (~need_valids (unwrap-gboolean need_valids))
            (~func (unwrap-gpointer func))
            (~data (unwrap-gpointer data)))
        (wrap-GHook*
          (~f ~hook_list ~need_valids ~func ~data))))))
(export g_hook_find_func_data)

;; extern GHook *g_hook_first_valid(GHookList *hook_list, gboolean 
;;     may_be_in_call);
(define g_hook_first_valid
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_hook_first_valid"
                (dynamic-link))
              (list '* ffi:int))))
    (lambda (hook_list may_be_in_call)
      (let ((~hook_list (unwrap-GHookList* hook_list))
            (~may_be_in_call
              (unwrap-gboolean may_be_in_call)))
        (wrap-GHook* (~f ~hook_list ~may_be_in_call))))))
(export g_hook_first_valid)

;; extern GHook *g_hook_next_valid(GHookList *hook_list, GHook *hook, gboolean 
;;     may_be_in_call);
(define g_hook_next_valid
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_hook_next_valid" (dynamic-link))
              (list '* '* ffi:int))))
    (lambda (hook_list hook may_be_in_call)
      (let ((~hook_list (unwrap-GHookList* hook_list))
            (~hook (unwrap-GHook* hook))
            (~may_be_in_call
              (unwrap-gboolean may_be_in_call)))
        (wrap-GHook*
          (~f ~hook_list ~hook ~may_be_in_call))))))
(export g_hook_next_valid)

;; extern gint g_hook_compare_ids(GHook *new_hook, GHook *sibling);
(define g_hook_compare_ids
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_hook_compare_ids"
                (dynamic-link))
              (list '* '*))))
    (lambda (new_hook sibling)
      (let ((~new_hook (unwrap-GHook* new_hook))
            (~sibling (unwrap-GHook* sibling)))
        (wrap-gint (~f ~new_hook ~sibling))))))
(export g_hook_compare_ids)

;; extern void g_hook_list_invoke(GHookList *hook_list, gboolean may_recurse);
(define g_hook_list_invoke
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_hook_list_invoke"
                (dynamic-link))
              (list '* ffi:int))))
    (lambda (hook_list may_recurse)
      (let ((~hook_list (unwrap-GHookList* hook_list))
            (~may_recurse (unwrap-gboolean may_recurse)))
        (~f ~hook_list ~may_recurse)))))
(export g_hook_list_invoke)

;; extern void g_hook_list_invoke_check(GHookList *hook_list, gboolean 
;;     may_recurse);
(define g_hook_list_invoke_check
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_hook_list_invoke_check"
                (dynamic-link))
              (list '* ffi:int))))
    (lambda (hook_list may_recurse)
      (let ((~hook_list (unwrap-GHookList* hook_list))
            (~may_recurse (unwrap-gboolean may_recurse)))
        (~f ~hook_list ~may_recurse)))))
(export g_hook_list_invoke_check)

;; extern void g_hook_list_marshal(GHookList *hook_list, gboolean may_recurse, 
;;     GHookMarshaller marshaller, gpointer marshal_data);
(define g_hook_list_marshal
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_hook_list_marshal"
                (dynamic-link))
              (list '* ffi:int '* '*))))
    (lambda (hook_list may_recurse marshaller marshal_data)
      (let ((~hook_list (unwrap-GHookList* hook_list))
            (~may_recurse (unwrap-gboolean may_recurse))
            (~marshaller
              ((make-ftn-arg-unwrapper ffi:void (list '* '*))
               marshaller))
            (~marshal_data (unwrap-gpointer marshal_data)))
        (~f ~hook_list
            ~may_recurse
            ~marshaller
            ~marshal_data)))))
(export g_hook_list_marshal)

;; extern void g_hook_list_marshal_check(GHookList *hook_list, gboolean 
;;     may_recurse, GHookCheckMarshaller marshaller, gpointer marshal_data);
;; ... failed.

;; extern gboolean g_hostname_is_non_ascii(const gchar *hostname);
(define g_hostname_is_non_ascii
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_hostname_is_non_ascii"
                (dynamic-link))
              (list '*))))
    (lambda (hostname)
      (let ((~hostname (unwrap-gchar* hostname)))
        (wrap-gboolean (~f ~hostname))))))
(export g_hostname_is_non_ascii)

;; extern gboolean g_hostname_is_ascii_encoded(const gchar *hostname);
(define g_hostname_is_ascii_encoded
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_hostname_is_ascii_encoded"
                (dynamic-link))
              (list '*))))
    (lambda (hostname)
      (let ((~hostname (unwrap-gchar* hostname)))
        (wrap-gboolean (~f ~hostname))))))
(export g_hostname_is_ascii_encoded)

;; extern gboolean g_hostname_is_ip_address(const gchar *hostname);
(define g_hostname_is_ip_address
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_hostname_is_ip_address"
                (dynamic-link))
              (list '*))))
    (lambda (hostname)
      (let ((~hostname (unwrap-gchar* hostname)))
        (wrap-gboolean (~f ~hostname))))))
(export g_hostname_is_ip_address)

;; extern gchar *g_hostname_to_ascii(const gchar *hostname);
(define g_hostname_to_ascii
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_hostname_to_ascii"
                (dynamic-link))
              (list '*))))
    (lambda (hostname)
      (let ((~hostname (unwrap-gchar* hostname)))
        (wrap-gchar* (~f ~hostname))))))
(export g_hostname_to_ascii)

;; extern gchar *g_hostname_to_unicode(const gchar *hostname);
(define g_hostname_to_unicode
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_hostname_to_unicode"
                (dynamic-link))
              (list '*))))
    (lambda (hostname)
      (let ((~hostname (unwrap-gchar* hostname)))
        (wrap-gchar* (~f ~hostname))))))
(export g_hostname_to_unicode)

;; typedef struct _GPollFD GPollFD;
(define GPollFD-desc void)
(define GPollFD*-desc (bs:pointer (delay GPollFD-desc)))
(define-fh-pointer-type GPollFD* GPollFD*-desc)

;; typedef gint (*GPollFunc)(GPollFD *ufds, guint nfsd, gint timeout_);
(define-fh-function/p GPollFunc
  ffi:int (list (quote *) ffi:unsigned-int ffi:int))

;; struct _GPollFD {
;;   gint fd;
;;   gushort events;
;;   gushort revents;
;; };
(define struct-_GPollFD-desc
  (bs:struct
    (list `(fd ,gint-desc)
          `(events ,gushort-desc)
          `(revents ,gushort-desc))))
(export struct-_GPollFD-desc)
(define-fh-compound-type/p struct-_GPollFD struct-_GPollFD-desc)
(set! GPollFD-desc struct-_GPollFD-desc)
(define-fh-compound-type GPollFD GPollFD-desc)

;; extern gint g_poll(GPollFD *fds, guint nfds, gint timeout);
(define g_poll
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_poll" (dynamic-link))
              (list '* ffi:unsigned-int ffi:int))))
    (lambda (fds nfds timeout)
      (let ((~fds (unwrap-GPollFD* fds))
            (~nfds (unwrap-guint nfds))
            (~timeout (unwrap-gint timeout)))
        (wrap-gint (~f ~fds ~nfds ~timeout))))))
(export g_poll)

;; typedef struct _GSList GSList;
(define GSList-desc void)
(define GSList*-desc (bs:pointer (delay GSList-desc)))
(define-fh-pointer-type GSList* GSList*-desc)

;; struct _GSList {
;;   gpointer data;
;;   GSList *next;
;; };
(define struct-_GSList-desc
  (bs:struct
    (list `(data ,gpointer-desc)
          `(next ,(bs:pointer GSList*-desc)))))
(export struct-_GSList-desc)
(define-fh-compound-type/p struct-_GSList struct-_GSList-desc)
(set! GSList-desc struct-_GSList-desc)
(define-fh-compound-type GSList GSList-desc)

;; extern GSList *g_slist_alloc(void);
(define g_slist_alloc
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_slist_alloc" (dynamic-link))
              (list))))
    (lambda () (let () (wrap-GSList* (~f))))))
(export g_slist_alloc)

;; extern void g_slist_free(GSList *list);
(define g_slist_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_slist_free" (dynamic-link))
              (list '*))))
    (lambda (list)
      (let ((~list (unwrap-GSList* list))) (~f ~list)))))
(export g_slist_free)

;; extern void g_slist_free_1(GSList *list);
(define g_slist_free_1
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_slist_free_1" (dynamic-link))
              (list '*))))
    (lambda (list)
      (let ((~list (unwrap-GSList* list))) (~f ~list)))))
(export g_slist_free_1)

;; extern void g_slist_free_full(GSList *list, GDestroyNotify free_func);
(define g_slist_free_full
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_slist_free_full" (dynamic-link))
              (list '* '*))))
    (lambda (list free_func)
      (let ((~list (unwrap-GSList* list))
            (~free_func
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               free_func)))
        (~f ~list ~free_func)))))
(export g_slist_free_full)

;; extern GSList *g_slist_append(GSList *list, gpointer data);
(define g_slist_append
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_slist_append" (dynamic-link))
              (list '* '*))))
    (lambda (list data)
      (let ((~list (unwrap-GSList* list))
            (~data (unwrap-gpointer data)))
        (wrap-GSList* (~f ~list ~data))))))
(export g_slist_append)

;; extern GSList *g_slist_prepend(GSList *list, gpointer data);
(define g_slist_prepend
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_slist_prepend" (dynamic-link))
              (list '* '*))))
    (lambda (list data)
      (let ((~list (unwrap-GSList* list))
            (~data (unwrap-gpointer data)))
        (wrap-GSList* (~f ~list ~data))))))
(export g_slist_prepend)

;; extern GSList *g_slist_insert(GSList *list, gpointer data, gint position);
(define g_slist_insert
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_slist_insert" (dynamic-link))
              (list '* '* ffi:int))))
    (lambda (list data position)
      (let ((~list (unwrap-GSList* list))
            (~data (unwrap-gpointer data))
            (~position (unwrap-gint position)))
        (wrap-GSList* (~f ~list ~data ~position))))))
(export g_slist_insert)

;; extern GSList *g_slist_insert_sorted(GSList *list, gpointer data, 
;;     GCompareFunc func);
;; ... failed.

;; extern GSList *g_slist_insert_sorted_with_data(GSList *list, gpointer data, 
;;     GCompareDataFunc func, gpointer user_data);
;; ... failed.

;; extern GSList *g_slist_insert_before(GSList *slist, GSList *sibling, 
;;     gpointer data);
(define g_slist_insert_before
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_slist_insert_before"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (slist sibling data)
      (let ((~slist (unwrap-GSList* slist))
            (~sibling (unwrap-GSList* sibling))
            (~data (unwrap-gpointer data)))
        (wrap-GSList* (~f ~slist ~sibling ~data))))))
(export g_slist_insert_before)

;; extern GSList *g_slist_concat(GSList *list1, GSList *list2);
(define g_slist_concat
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_slist_concat" (dynamic-link))
              (list '* '*))))
    (lambda (list1 list2)
      (let ((~list1 (unwrap-GSList* list1))
            (~list2 (unwrap-GSList* list2)))
        (wrap-GSList* (~f ~list1 ~list2))))))
(export g_slist_concat)

;; extern GSList *g_slist_remove(GSList *list, gconstpointer data);
(define g_slist_remove
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_slist_remove" (dynamic-link))
              (list '* '*))))
    (lambda (list data)
      (let ((~list (unwrap-GSList* list))
            (~data (unwrap-gconstpointer data)))
        (wrap-GSList* (~f ~list ~data))))))
(export g_slist_remove)

;; extern GSList *g_slist_remove_all(GSList *list, gconstpointer data);
(define g_slist_remove_all
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_slist_remove_all"
                (dynamic-link))
              (list '* '*))))
    (lambda (list data)
      (let ((~list (unwrap-GSList* list))
            (~data (unwrap-gconstpointer data)))
        (wrap-GSList* (~f ~list ~data))))))
(export g_slist_remove_all)

;; extern GSList *g_slist_remove_link(GSList *list, GSList *link_);
(define g_slist_remove_link
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_slist_remove_link"
                (dynamic-link))
              (list '* '*))))
    (lambda (list link_)
      (let ((~list (unwrap-GSList* list))
            (~link_ (unwrap-GSList* link_)))
        (wrap-GSList* (~f ~list ~link_))))))
(export g_slist_remove_link)

;; extern GSList *g_slist_delete_link(GSList *list, GSList *link_);
(define g_slist_delete_link
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_slist_delete_link"
                (dynamic-link))
              (list '* '*))))
    (lambda (list link_)
      (let ((~list (unwrap-GSList* list))
            (~link_ (unwrap-GSList* link_)))
        (wrap-GSList* (~f ~list ~link_))))))
(export g_slist_delete_link)

;; extern GSList *g_slist_reverse(GSList *list);
(define g_slist_reverse
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_slist_reverse" (dynamic-link))
              (list '*))))
    (lambda (list)
      (let ((~list (unwrap-GSList* list)))
        (wrap-GSList* (~f ~list))))))
(export g_slist_reverse)

;; extern GSList *g_slist_copy(GSList *list);
(define g_slist_copy
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_slist_copy" (dynamic-link))
              (list '*))))
    (lambda (list)
      (let ((~list (unwrap-GSList* list)))
        (wrap-GSList* (~f ~list))))))
(export g_slist_copy)

;; extern GSList *g_slist_copy_deep(GSList *list, GCopyFunc func, gpointer 
;;     user_data);
;; ... failed.

;; extern GSList *g_slist_nth(GSList *list, guint n);
(define g_slist_nth
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_slist_nth" (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (list n)
      (let ((~list (unwrap-GSList* list))
            (~n (unwrap-guint n)))
        (wrap-GSList* (~f ~list ~n))))))
(export g_slist_nth)

;; extern GSList *g_slist_find(GSList *list, gconstpointer data);
(define g_slist_find
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_slist_find" (dynamic-link))
              (list '* '*))))
    (lambda (list data)
      (let ((~list (unwrap-GSList* list))
            (~data (unwrap-gconstpointer data)))
        (wrap-GSList* (~f ~list ~data))))))
(export g_slist_find)

;; extern GSList *g_slist_find_custom(GSList *list, gconstpointer data, 
;;     GCompareFunc func);
;; ... failed.

;; extern gint g_slist_position(GSList *list, GSList *llink);
(define g_slist_position
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_slist_position" (dynamic-link))
              (list '* '*))))
    (lambda (list llink)
      (let ((~list (unwrap-GSList* list))
            (~llink (unwrap-GSList* llink)))
        (wrap-gint (~f ~list ~llink))))))
(export g_slist_position)

;; extern gint g_slist_index(GSList *list, gconstpointer data);
(define g_slist_index
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_slist_index" (dynamic-link))
              (list '* '*))))
    (lambda (list data)
      (let ((~list (unwrap-GSList* list))
            (~data (unwrap-gconstpointer data)))
        (wrap-gint (~f ~list ~data))))))
(export g_slist_index)

;; extern GSList *g_slist_last(GSList *list);
(define g_slist_last
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_slist_last" (dynamic-link))
              (list '*))))
    (lambda (list)
      (let ((~list (unwrap-GSList* list)))
        (wrap-GSList* (~f ~list))))))
(export g_slist_last)

;; extern guint g_slist_length(GSList *list);
(define g_slist_length
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func "g_slist_length" (dynamic-link))
              (list '*))))
    (lambda (list)
      (let ((~list (unwrap-GSList* list)))
        (wrap-guint (~f ~list))))))
(export g_slist_length)

;; extern void g_slist_foreach(GSList *list, GFunc func, gpointer user_data);
(define g_slist_foreach
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_slist_foreach" (dynamic-link))
              (list '* '* '*))))
    (lambda (list func user_data)
      (let ((~list (unwrap-GSList* list))
            (~func ((make-ftn-arg-unwrapper ffi:void (list '* '*))
                    func))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~list ~func ~user_data)))))
(export g_slist_foreach)

;; extern GSList *g_slist_sort(GSList *list, GCompareFunc compare_func);
;; ... failed.

;; extern GSList *g_slist_sort_with_data(GSList *list, GCompareDataFunc 
;;     compare_func, gpointer user_data);
;; ... failed.

;; extern gpointer g_slist_nth_data(GSList *list, guint n);
(define g_slist_nth_data
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_slist_nth_data" (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (list n)
      (let ((~list (unwrap-GSList* list))
            (~n (unwrap-guint n)))
        (wrap-gpointer (~f ~list ~n))))))
(export g_slist_nth_data)

;; typedef enum {
;;   G_IO_IN = 1,
;;   G_IO_OUT = 4,
;;   G_IO_PRI = 2,
;;   G_IO_ERR = 8,
;;   G_IO_HUP = 16,
;;   G_IO_NVAL = 32,
;; } GIOCondition;
(define-fh-enum GIOCondition
  '((G_IO_IN . 1)
    (G_IO_OUT . 4)
    (G_IO_PRI . 2)
    (G_IO_ERR . 8)
    (G_IO_HUP . 16)
    (G_IO_NVAL . 32))
  )

;; typedef struct _GMainContext GMainContext;
(define GMainContext-desc void)
(define GMainContext*-desc (bs:pointer GMainContext-desc))
(define-fh-pointer-type GMainContext* GMainContext*-desc)

;; typedef struct _GMainLoop GMainLoop;
(define GMainLoop-desc void)
(define GMainLoop*-desc (bs:pointer GMainLoop-desc))
(define-fh-pointer-type GMainLoop* GMainLoop*-desc)

;; typedef struct _GSource GSource;
(define GSource-desc void)
(define GSource*-desc (bs:pointer (delay GSource-desc)))
(define-fh-pointer-type GSource* GSource*-desc)

;; typedef struct _GSourcePrivate GSourcePrivate;
(define GSourcePrivate-desc void)
(define GSourcePrivate*-desc (bs:pointer GSourcePrivate-desc))
(define-fh-pointer-type GSourcePrivate* GSourcePrivate*-desc)

;; typedef struct _GSourceCallbackFuncs GSourceCallbackFuncs;
(define GSourceCallbackFuncs-desc void)
(define GSourceCallbackFuncs*-desc (bs:pointer (delay GSourceCallbackFuncs-desc)))
(define-fh-pointer-type GSourceCallbackFuncs* GSourceCallbackFuncs*-desc)

;; typedef struct _GSourceFuncs GSourceFuncs;
(define GSourceFuncs-desc void)
(define GSourceFuncs*-desc (bs:pointer (delay GSourceFuncs-desc)))
(define-fh-pointer-type GSourceFuncs* GSourceFuncs*-desc)

;; typedef gboolean (*GSourceFunc)(gpointer user_data);
(define-fh-function/p GSourceFunc
  ffi:int (list (quote *)))

;; typedef void (*GChildWatchFunc)(GPid pid, gint status, gpointer user_data);
(define-fh-function/p GChildWatchFunc
  ffi:void (list ffi:int ffi:int (quote *)))

;; struct _GSource {
;;   /*< private >*/
;;   gpointer callback_data;
;;   GSourceCallbackFuncs *callback_funcs;
;;   const GSourceFuncs *source_funcs;
;;   guint ref_count;
;;   GMainContext *context;
;;   gint priority;
;;   guint flags;
;;   guint source_id;
;;   GSList *poll_fds;
;;   GSource *prev;
;;   GSource *next;
;;   char *name;
;;   GSourcePrivate *priv;
;; };
(define struct-_GSource-desc
  (bs:struct
    (list `(callback_data ,gpointer-desc)
          `(callback_funcs
             ,(bs:pointer GSourceCallbackFuncs*-desc))
          `(source_funcs ,(bs:pointer GSourceFuncs*-desc))
          `(ref_count ,guint-desc)
          `(context ,(bs:pointer GMainContext*-desc))
          `(priority ,gint-desc)
          `(flags ,guint-desc)
          `(source_id ,guint-desc)
          `(poll_fds ,(bs:pointer GSList*-desc))
          `(prev ,(bs:pointer GSource*-desc))
          `(next ,(bs:pointer GSource*-desc))
          `(name ,(bs:pointer int))
          `(priv ,(bs:pointer GSourcePrivate*-desc)))))
(export struct-_GSource-desc)
(define-fh-compound-type/p struct-_GSource struct-_GSource-desc)
(set! GSource-desc struct-_GSource-desc)
(define-fh-compound-type GSource GSource-desc)

;; struct _GSourceCallbackFuncs {
;;   void (*ref)(gpointer cb_data);
;;   void (*unref)(gpointer cb_data);
;;   void (*get)(gpointer cb_data, GSource *source, GSourceFunc *func, gpointer
;;        *data);
;; };
(define struct-_GSourceCallbackFuncs-desc
  (bs:struct
    (list `(ref ,(bs:pointer void))
          `(unref ,(bs:pointer void))
          `(get ,(bs:pointer void)))))
(export struct-_GSourceCallbackFuncs-desc)
(define-fh-compound-type/p struct-_GSourceCallbackFuncs struct-_GSourceCallbackFuncs-desc)
(set! GSourceCallbackFuncs-desc struct-_GSourceCallbackFuncs-desc)
(define-fh-compound-type GSourceCallbackFuncs GSourceCallbackFuncs-desc)

;; typedef void (*GSourceDummyMarshal)(void);
(define-fh-function/p GSourceDummyMarshal
  ffi:void (list ffi:void))

;; struct _GSourceFuncs {
;;   gboolean (*prepare)(GSource *source, gint *timeout_);
;;   gboolean (*check)(GSource *source);
;;   gboolean (*dispatch)(GSource *source, GSourceFunc callback, gpointer 
;;       user_data);
;;   void (*finalize)(GSource *source); /* Can be NULL */
;;   /*< private >*/
;;   /* For use by g_source_set_closure */
;;   GSourceFunc closure_callback;
;;   GSourceDummyMarshal closure_marshal; 
;;       /* Really is of type GClosureMarshal */
;; };
(define struct-_GSourceFuncs-desc
  (bs:struct
    (list `(prepare ,(bs:pointer void))
          `(check ,(bs:pointer void))
          `(dispatch ,(bs:pointer void))
          `(finalize ,(bs:pointer void))
          `(closure_callback ,(bs:pointer void))
          `(closure_marshal ,(bs:pointer void)))))
(export struct-_GSourceFuncs-desc)
(define-fh-compound-type/p struct-_GSourceFuncs struct-_GSourceFuncs-desc)
(set! GSourceFuncs-desc struct-_GSourceFuncs-desc)
(define-fh-compound-type GSourceFuncs GSourceFuncs-desc)

;; extern GMainContext *g_main_context_new(void);
(define g_main_context_new
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_main_context_new"
                (dynamic-link))
              (list))))
    (lambda () (let () (wrap-GMainContext* (~f))))))
(export g_main_context_new)

;; extern GMainContext *g_main_context_ref(GMainContext *context);
(define g_main_context_ref
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_main_context_ref"
                (dynamic-link))
              (list '*))))
    (lambda (context)
      (let ((~context (unwrap-GMainContext* context)))
        (wrap-GMainContext* (~f ~context))))))
(export g_main_context_ref)

;; extern void g_main_context_unref(GMainContext *context);
(define g_main_context_unref
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_main_context_unref"
                (dynamic-link))
              (list '*))))
    (lambda (context)
      (let ((~context (unwrap-GMainContext* context)))
        (~f ~context)))))
(export g_main_context_unref)

;; extern GMainContext *g_main_context_default(void);
(define g_main_context_default
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_main_context_default"
                (dynamic-link))
              (list))))
    (lambda () (let () (wrap-GMainContext* (~f))))))
(export g_main_context_default)

;; extern gboolean g_main_context_iteration(GMainContext *context, gboolean 
;;     may_block);
(define g_main_context_iteration
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_main_context_iteration"
                (dynamic-link))
              (list '* ffi:int))))
    (lambda (context may_block)
      (let ((~context (unwrap-GMainContext* context))
            (~may_block (unwrap-gboolean may_block)))
        (wrap-gboolean (~f ~context ~may_block))))))
(export g_main_context_iteration)

;; extern gboolean g_main_context_pending(GMainContext *context);
(define g_main_context_pending
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_main_context_pending"
                (dynamic-link))
              (list '*))))
    (lambda (context)
      (let ((~context (unwrap-GMainContext* context)))
        (wrap-gboolean (~f ~context))))))
(export g_main_context_pending)

;; extern GSource *g_main_context_find_source_by_id(GMainContext *context, 
;;     guint source_id);
(define g_main_context_find_source_by_id
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_main_context_find_source_by_id"
                (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (context source_id)
      (let ((~context (unwrap-GMainContext* context))
            (~source_id (unwrap-guint source_id)))
        (wrap-GSource* (~f ~context ~source_id))))))
(export g_main_context_find_source_by_id)

;; extern GSource *g_main_context_find_source_by_user_data(GMainContext *
;;     context, gpointer user_data);
(define g_main_context_find_source_by_user_data
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_main_context_find_source_by_user_data"
                (dynamic-link))
              (list '* '*))))
    (lambda (context user_data)
      (let ((~context (unwrap-GMainContext* context))
            (~user_data (unwrap-gpointer user_data)))
        (wrap-GSource* (~f ~context ~user_data))))))
(export g_main_context_find_source_by_user_data)

;; extern GSource *g_main_context_find_source_by_funcs_user_data(GMainContext *
;;     context, GSourceFuncs *funcs, gpointer user_data);
(define g_main_context_find_source_by_funcs_user_data
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_main_context_find_source_by_funcs_user_data"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (context funcs user_data)
      (let ((~context (unwrap-GMainContext* context))
            (~funcs (unwrap-GSourceFuncs* funcs))
            (~user_data (unwrap-gpointer user_data)))
        (wrap-GSource* (~f ~context ~funcs ~user_data))))))
(export g_main_context_find_source_by_funcs_user_data)

;; extern void g_main_context_wakeup(GMainContext *context);
(define g_main_context_wakeup
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_main_context_wakeup"
                (dynamic-link))
              (list '*))))
    (lambda (context)
      (let ((~context (unwrap-GMainContext* context)))
        (~f ~context)))))
(export g_main_context_wakeup)

;; extern gboolean g_main_context_acquire(GMainContext *context);
(define g_main_context_acquire
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_main_context_acquire"
                (dynamic-link))
              (list '*))))
    (lambda (context)
      (let ((~context (unwrap-GMainContext* context)))
        (wrap-gboolean (~f ~context))))))
(export g_main_context_acquire)

;; extern void g_main_context_release(GMainContext *context);
(define g_main_context_release
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_main_context_release"
                (dynamic-link))
              (list '*))))
    (lambda (context)
      (let ((~context (unwrap-GMainContext* context)))
        (~f ~context)))))
(export g_main_context_release)

;; extern gboolean g_main_context_is_owner(GMainContext *context);
(define g_main_context_is_owner
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_main_context_is_owner"
                (dynamic-link))
              (list '*))))
    (lambda (context)
      (let ((~context (unwrap-GMainContext* context)))
        (wrap-gboolean (~f ~context))))))
(export g_main_context_is_owner)

;; extern gboolean g_main_context_wait(GMainContext *context, GCond *cond, 
;;     GMutex *mutex);
(define g_main_context_wait
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_main_context_wait"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (context cond mutex)
      (let ((~context (unwrap-GMainContext* context))
            (~cond (unwrap-GCond* cond))
            (~mutex (unwrap-GMutex* mutex)))
        (wrap-gboolean (~f ~context ~cond ~mutex))))))
(export g_main_context_wait)

;; extern gboolean g_main_context_prepare(GMainContext *context, gint *priority
;;     );
(define g_main_context_prepare
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_main_context_prepare"
                (dynamic-link))
              (list '* '*))))
    (lambda (context priority)
      (let ((~context (unwrap-GMainContext* context))
            (~priority (unwrap-gint* priority)))
        (wrap-gboolean (~f ~context ~priority))))))
(export g_main_context_prepare)

;; extern gint g_main_context_query(GMainContext *context, gint max_priority, 
;;     gint *timeout_, GPollFD *fds, gint n_fds);
(define g_main_context_query
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_main_context_query"
                (dynamic-link))
              (list '* ffi:int '* '* ffi:int))))
    (lambda (context max_priority timeout_ fds n_fds)
      (let ((~context (unwrap-GMainContext* context))
            (~max_priority (unwrap-gint max_priority))
            (~timeout_ (unwrap-gint* timeout_))
            (~fds (unwrap-GPollFD* fds))
            (~n_fds (unwrap-gint n_fds)))
        (wrap-gint
          (~f ~context ~max_priority ~timeout_ ~fds ~n_fds))))))
(export g_main_context_query)

;; extern gboolean g_main_context_check(GMainContext *context, gint 
;;     max_priority, GPollFD *fds, gint n_fds);
(define g_main_context_check
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_main_context_check"
                (dynamic-link))
              (list '* ffi:int '* ffi:int))))
    (lambda (context max_priority fds n_fds)
      (let ((~context (unwrap-GMainContext* context))
            (~max_priority (unwrap-gint max_priority))
            (~fds (unwrap-GPollFD* fds))
            (~n_fds (unwrap-gint n_fds)))
        (wrap-gboolean
          (~f ~context ~max_priority ~fds ~n_fds))))))
(export g_main_context_check)

;; extern void g_main_context_dispatch(GMainContext *context);
(define g_main_context_dispatch
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_main_context_dispatch"
                (dynamic-link))
              (list '*))))
    (lambda (context)
      (let ((~context (unwrap-GMainContext* context)))
        (~f ~context)))))
(export g_main_context_dispatch)

;; extern void g_main_context_set_poll_func(GMainContext *context, GPollFunc 
;;     func);
;; ... failed.

;; extern GPollFunc g_main_context_get_poll_func(GMainContext *context);
(define g_main_context_get_poll_func
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_main_context_get_poll_func"
                (dynamic-link))
              (list '*))))
    (lambda (context)
      (let ((~context (unwrap-GMainContext* context)))
        (~f ~context)))))
(export g_main_context_get_poll_func)

;; extern void g_main_context_add_poll(GMainContext *context, GPollFD *fd, gint
;;      priority);
(define g_main_context_add_poll
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_main_context_add_poll"
                (dynamic-link))
              (list '* '* ffi:int))))
    (lambda (context fd priority)
      (let ((~context (unwrap-GMainContext* context))
            (~fd (unwrap-GPollFD* fd))
            (~priority (unwrap-gint priority)))
        (~f ~context ~fd ~priority)))))
(export g_main_context_add_poll)

;; extern void g_main_context_remove_poll(GMainContext *context, GPollFD *fd);
(define g_main_context_remove_poll
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_main_context_remove_poll"
                (dynamic-link))
              (list '* '*))))
    (lambda (context fd)
      (let ((~context (unwrap-GMainContext* context))
            (~fd (unwrap-GPollFD* fd)))
        (~f ~context ~fd)))))
(export g_main_context_remove_poll)

;; extern gint g_main_depth(void);
(define g_main_depth
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_main_depth" (dynamic-link))
              (list))))
    (lambda () (let () (wrap-gint (~f))))))
(export g_main_depth)

;; extern GSource *g_main_current_source(void);
(define g_main_current_source
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_main_current_source"
                (dynamic-link))
              (list))))
    (lambda () (let () (wrap-GSource* (~f))))))
(export g_main_current_source)

;; extern void g_main_context_push_thread_default(GMainContext *context);
(define g_main_context_push_thread_default
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_main_context_push_thread_default"
                (dynamic-link))
              (list '*))))
    (lambda (context)
      (let ((~context (unwrap-GMainContext* context)))
        (~f ~context)))))
(export g_main_context_push_thread_default)

;; extern void g_main_context_pop_thread_default(GMainContext *context);
(define g_main_context_pop_thread_default
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_main_context_pop_thread_default"
                (dynamic-link))
              (list '*))))
    (lambda (context)
      (let ((~context (unwrap-GMainContext* context)))
        (~f ~context)))))
(export g_main_context_pop_thread_default)

;; extern GMainContext *g_main_context_get_thread_default(void);
(define g_main_context_get_thread_default
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_main_context_get_thread_default"
                (dynamic-link))
              (list))))
    (lambda () (let () (wrap-GMainContext* (~f))))))
(export g_main_context_get_thread_default)

;; extern GMainContext *g_main_context_ref_thread_default(void);
(define g_main_context_ref_thread_default
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_main_context_ref_thread_default"
                (dynamic-link))
              (list))))
    (lambda () (let () (wrap-GMainContext* (~f))))))
(export g_main_context_ref_thread_default)

;; extern GMainLoop *g_main_loop_new(GMainContext *context, gboolean is_running
;;     );
(define g_main_loop_new
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_main_loop_new" (dynamic-link))
              (list '* ffi:int))))
    (lambda (context is_running)
      (let ((~context (unwrap-GMainContext* context))
            (~is_running (unwrap-gboolean is_running)))
        (wrap-GMainLoop* (~f ~context ~is_running))))))
(export g_main_loop_new)

;; extern void g_main_loop_run(GMainLoop *loop);
(define g_main_loop_run
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_main_loop_run" (dynamic-link))
              (list '*))))
    (lambda (loop)
      (let ((~loop (unwrap-GMainLoop* loop)))
        (~f ~loop)))))
(export g_main_loop_run)

;; extern void g_main_loop_quit(GMainLoop *loop);
(define g_main_loop_quit
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_main_loop_quit" (dynamic-link))
              (list '*))))
    (lambda (loop)
      (let ((~loop (unwrap-GMainLoop* loop)))
        (~f ~loop)))))
(export g_main_loop_quit)

;; extern GMainLoop *g_main_loop_ref(GMainLoop *loop);
(define g_main_loop_ref
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_main_loop_ref" (dynamic-link))
              (list '*))))
    (lambda (loop)
      (let ((~loop (unwrap-GMainLoop* loop)))
        (wrap-GMainLoop* (~f ~loop))))))
(export g_main_loop_ref)

;; extern void g_main_loop_unref(GMainLoop *loop);
(define g_main_loop_unref
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_main_loop_unref" (dynamic-link))
              (list '*))))
    (lambda (loop)
      (let ((~loop (unwrap-GMainLoop* loop)))
        (~f ~loop)))))
(export g_main_loop_unref)

;; extern gboolean g_main_loop_is_running(GMainLoop *loop);
(define g_main_loop_is_running
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_main_loop_is_running"
                (dynamic-link))
              (list '*))))
    (lambda (loop)
      (let ((~loop (unwrap-GMainLoop* loop)))
        (wrap-gboolean (~f ~loop))))))
(export g_main_loop_is_running)

;; extern GMainContext *g_main_loop_get_context(GMainLoop *loop);
(define g_main_loop_get_context
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_main_loop_get_context"
                (dynamic-link))
              (list '*))))
    (lambda (loop)
      (let ((~loop (unwrap-GMainLoop* loop)))
        (wrap-GMainContext* (~f ~loop))))))
(export g_main_loop_get_context)

;; extern GSource *g_source_new(GSourceFuncs *source_funcs, guint struct_size)
;;     ;
(define g_source_new
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_source_new" (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (source_funcs struct_size)
      (let ((~source_funcs
              (unwrap-GSourceFuncs* source_funcs))
            (~struct_size (unwrap-guint struct_size)))
        (wrap-GSource* (~f ~source_funcs ~struct_size))))))
(export g_source_new)

;; extern GSource *g_source_ref(GSource *source);
(define g_source_ref
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_source_ref" (dynamic-link))
              (list '*))))
    (lambda (source)
      (let ((~source (unwrap-GSource* source)))
        (wrap-GSource* (~f ~source))))))
(export g_source_ref)

;; extern void g_source_unref(GSource *source);
(define g_source_unref
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_source_unref" (dynamic-link))
              (list '*))))
    (lambda (source)
      (let ((~source (unwrap-GSource* source)))
        (~f ~source)))))
(export g_source_unref)

;; extern guint g_source_attach(GSource *source, GMainContext *context);
(define g_source_attach
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func "g_source_attach" (dynamic-link))
              (list '* '*))))
    (lambda (source context)
      (let ((~source (unwrap-GSource* source))
            (~context (unwrap-GMainContext* context)))
        (wrap-guint (~f ~source ~context))))))
(export g_source_attach)

;; extern void g_source_destroy(GSource *source);
(define g_source_destroy
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_source_destroy" (dynamic-link))
              (list '*))))
    (lambda (source)
      (let ((~source (unwrap-GSource* source)))
        (~f ~source)))))
(export g_source_destroy)

;; extern void g_source_set_priority(GSource *source, gint priority);
(define g_source_set_priority
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_source_set_priority"
                (dynamic-link))
              (list '* ffi:int))))
    (lambda (source priority)
      (let ((~source (unwrap-GSource* source))
            (~priority (unwrap-gint priority)))
        (~f ~source ~priority)))))
(export g_source_set_priority)

;; extern gint g_source_get_priority(GSource *source);
(define g_source_get_priority
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_source_get_priority"
                (dynamic-link))
              (list '*))))
    (lambda (source)
      (let ((~source (unwrap-GSource* source)))
        (wrap-gint (~f ~source))))))
(export g_source_get_priority)

;; extern void g_source_set_can_recurse(GSource *source, gboolean can_recurse)
;;     ;
(define g_source_set_can_recurse
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_source_set_can_recurse"
                (dynamic-link))
              (list '* ffi:int))))
    (lambda (source can_recurse)
      (let ((~source (unwrap-GSource* source))
            (~can_recurse (unwrap-gboolean can_recurse)))
        (~f ~source ~can_recurse)))))
(export g_source_set_can_recurse)

;; extern gboolean g_source_get_can_recurse(GSource *source);
(define g_source_get_can_recurse
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_source_get_can_recurse"
                (dynamic-link))
              (list '*))))
    (lambda (source)
      (let ((~source (unwrap-GSource* source)))
        (wrap-gboolean (~f ~source))))))
(export g_source_get_can_recurse)

;; extern guint g_source_get_id(GSource *source);
(define g_source_get_id
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func "g_source_get_id" (dynamic-link))
              (list '*))))
    (lambda (source)
      (let ((~source (unwrap-GSource* source)))
        (wrap-guint (~f ~source))))))
(export g_source_get_id)

;; extern GMainContext *g_source_get_context(GSource *source);
(define g_source_get_context
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_source_get_context"
                (dynamic-link))
              (list '*))))
    (lambda (source)
      (let ((~source (unwrap-GSource* source)))
        (wrap-GMainContext* (~f ~source))))))
(export g_source_get_context)

;; extern void g_source_set_callback(GSource *source, GSourceFunc func, 
;;     gpointer data, GDestroyNotify notify);
;; ... failed.

;; extern void g_source_set_funcs(GSource *source, GSourceFuncs *funcs);
(define g_source_set_funcs
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_source_set_funcs"
                (dynamic-link))
              (list '* '*))))
    (lambda (source funcs)
      (let ((~source (unwrap-GSource* source))
            (~funcs (unwrap-GSourceFuncs* funcs)))
        (~f ~source ~funcs)))))
(export g_source_set_funcs)

;; extern gboolean g_source_is_destroyed(GSource *source);
(define g_source_is_destroyed
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_source_is_destroyed"
                (dynamic-link))
              (list '*))))
    (lambda (source)
      (let ((~source (unwrap-GSource* source)))
        (wrap-gboolean (~f ~source))))))
(export g_source_is_destroyed)

;; extern void g_source_set_name(GSource *source, const char *name);
(define g_source_set_name
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_source_set_name" (dynamic-link))
              (list '* '*))))
    (lambda (source name)
      (let ((~source (unwrap-GSource* source))
            (~name (unwrap~pointer name)))
        (~f ~source ~name)))))
(export g_source_set_name)

;; extern const char *g_source_get_name(GSource *source);
(define g_source_get_name
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_source_get_name" (dynamic-link))
              (list '*))))
    (lambda (source)
      (let ((~source (unwrap-GSource* source)))
        (~f ~source)))))
(export g_source_get_name)

;; extern void g_source_set_name_by_id(guint tag, const char *name);
(define g_source_set_name_by_id
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_source_set_name_by_id"
                (dynamic-link))
              (list ffi:unsigned-int '*))))
    (lambda (tag name)
      (let ((~tag (unwrap-guint tag))
            (~name (unwrap~pointer name)))
        (~f ~tag ~name)))))
(export g_source_set_name_by_id)

;; extern void g_source_set_ready_time(GSource *source, gint64 ready_time);
;; ... failed.

;; extern gint64 g_source_get_ready_time(GSource *source);
;; ... failed.

;; extern gpointer g_source_add_unix_fd(GSource *source, gint fd, GIOCondition 
;;     events);
(define g_source_add_unix_fd
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_source_add_unix_fd"
                (dynamic-link))
              (list '* ffi:int ffi:int))))
    (lambda (source fd events)
      (let ((~source (unwrap-GSource* source))
            (~fd (unwrap-gint fd))
            (~events (unwrap~fixed events)))
        (wrap-gpointer (~f ~source ~fd ~events))))))
(export g_source_add_unix_fd)

;; extern void g_source_modify_unix_fd(GSource *source, gpointer tag, 
;;     GIOCondition new_events);
(define g_source_modify_unix_fd
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_source_modify_unix_fd"
                (dynamic-link))
              (list '* '* ffi:int))))
    (lambda (source tag new_events)
      (let ((~source (unwrap-GSource* source))
            (~tag (unwrap-gpointer tag))
            (~new_events (unwrap~fixed new_events)))
        (~f ~source ~tag ~new_events)))))
(export g_source_modify_unix_fd)

;; extern void g_source_remove_unix_fd(GSource *source, gpointer tag);
(define g_source_remove_unix_fd
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_source_remove_unix_fd"
                (dynamic-link))
              (list '* '*))))
    (lambda (source tag)
      (let ((~source (unwrap-GSource* source))
            (~tag (unwrap-gpointer tag)))
        (~f ~source ~tag)))))
(export g_source_remove_unix_fd)

;; extern GIOCondition g_source_query_unix_fd(GSource *source, gpointer tag);
(define g_source_query_unix_fd
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_source_query_unix_fd"
                (dynamic-link))
              (list '* '*))))
    (lambda (source tag)
      (let ((~source (unwrap-GSource* source))
            (~tag (unwrap-gpointer tag)))
        (~f ~source ~tag)))))
(export g_source_query_unix_fd)

;; extern void g_source_set_callback_indirect(GSource *source, gpointer 
;;     callback_data, GSourceCallbackFuncs *callback_funcs);
(define g_source_set_callback_indirect
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_source_set_callback_indirect"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (source callback_data callback_funcs)
      (let ((~source (unwrap-GSource* source))
            (~callback_data (unwrap-gpointer callback_data))
            (~callback_funcs
              (unwrap-GSourceCallbackFuncs* callback_funcs)))
        (~f ~source ~callback_data ~callback_funcs)))))
(export g_source_set_callback_indirect)

;; extern void g_source_add_poll(GSource *source, GPollFD *fd);
(define g_source_add_poll
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_source_add_poll" (dynamic-link))
              (list '* '*))))
    (lambda (source fd)
      (let ((~source (unwrap-GSource* source))
            (~fd (unwrap-GPollFD* fd)))
        (~f ~source ~fd)))))
(export g_source_add_poll)

;; extern void g_source_remove_poll(GSource *source, GPollFD *fd);
(define g_source_remove_poll
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_source_remove_poll"
                (dynamic-link))
              (list '* '*))))
    (lambda (source fd)
      (let ((~source (unwrap-GSource* source))
            (~fd (unwrap-GPollFD* fd)))
        (~f ~source ~fd)))))
(export g_source_remove_poll)

;; extern void g_source_add_child_source(GSource *source, GSource *child_source
;;     );
(define g_source_add_child_source
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_source_add_child_source"
                (dynamic-link))
              (list '* '*))))
    (lambda (source child_source)
      (let ((~source (unwrap-GSource* source))
            (~child_source (unwrap-GSource* child_source)))
        (~f ~source ~child_source)))))
(export g_source_add_child_source)

;; extern void g_source_remove_child_source(GSource *source, GSource *
;;     child_source);
(define g_source_remove_child_source
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_source_remove_child_source"
                (dynamic-link))
              (list '* '*))))
    (lambda (source child_source)
      (let ((~source (unwrap-GSource* source))
            (~child_source (unwrap-GSource* child_source)))
        (~f ~source ~child_source)))))
(export g_source_remove_child_source)

;; extern void g_source_get_current_time(GSource *source, GTimeVal *timeval);
(define g_source_get_current_time
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_source_get_current_time"
                (dynamic-link))
              (list '* '*))))
    (lambda (source timeval)
      (let ((~source (unwrap-GSource* source))
            (~timeval (unwrap-GTimeVal* timeval)))
        (~f ~source ~timeval)))))
(export g_source_get_current_time)

;; extern gint64 g_source_get_time(GSource *source);
;; ... failed.

;; extern GSource *g_idle_source_new(void);
(define g_idle_source_new
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_idle_source_new" (dynamic-link))
              (list))))
    (lambda () (let () (wrap-GSource* (~f))))))
(export g_idle_source_new)

;; extern GSource *g_child_watch_source_new(GPid pid);
(define g_child_watch_source_new
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_child_watch_source_new"
                (dynamic-link))
              (list ffi:int))))
    (lambda (pid)
      (let ((~pid (unwrap~fixed pid)))
        (wrap-GSource* (~f ~pid))))))
(export g_child_watch_source_new)

;; extern GSource *g_timeout_source_new(guint interval);
(define g_timeout_source_new
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_timeout_source_new"
                (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (interval)
      (let ((~interval (unwrap-guint interval)))
        (wrap-GSource* (~f ~interval))))))
(export g_timeout_source_new)

;; extern GSource *g_timeout_source_new_seconds(guint interval);
(define g_timeout_source_new_seconds
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_timeout_source_new_seconds"
                (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (interval)
      (let ((~interval (unwrap-guint interval)))
        (wrap-GSource* (~f ~interval))))))
(export g_timeout_source_new_seconds)

;; extern void g_get_current_time(GTimeVal *result);
(define g_get_current_time
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_get_current_time"
                (dynamic-link))
              (list '*))))
    (lambda (result)
      (let ((~result (unwrap-GTimeVal* result)))
        (~f ~result)))))
(export g_get_current_time)

;; extern gint64 g_get_monotonic_time(void);
;; ... failed.

;; extern gint64 g_get_real_time(void);
;; ... failed.

;; extern gboolean g_source_remove(guint tag);
(define g_source_remove
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_source_remove" (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (tag)
      (let ((~tag (unwrap-guint tag)))
        (wrap-gboolean (~f ~tag))))))
(export g_source_remove)

;; extern gboolean g_source_remove_by_user_data(gpointer user_data);
(define g_source_remove_by_user_data
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_source_remove_by_user_data"
                (dynamic-link))
              (list '*))))
    (lambda (user_data)
      (let ((~user_data (unwrap-gpointer user_data)))
        (wrap-gboolean (~f ~user_data))))))
(export g_source_remove_by_user_data)

;; extern gboolean g_source_remove_by_funcs_user_data(GSourceFuncs *funcs, 
;;     gpointer user_data);
(define g_source_remove_by_funcs_user_data
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_source_remove_by_funcs_user_data"
                (dynamic-link))
              (list '* '*))))
    (lambda (funcs user_data)
      (let ((~funcs (unwrap-GSourceFuncs* funcs))
            (~user_data (unwrap-gpointer user_data)))
        (wrap-gboolean (~f ~funcs ~user_data))))))
(export g_source_remove_by_funcs_user_data)

;; extern guint g_timeout_add_full(gint priority, guint interval, GSourceFunc 
;;     function, gpointer data, GDestroyNotify notify);
;; ... failed.

;; extern guint g_timeout_add(guint interval, GSourceFunc function, gpointer 
;;     data);
;; ... failed.

;; extern guint g_timeout_add_seconds_full(gint priority, guint interval, 
;;     GSourceFunc function, gpointer data, GDestroyNotify notify);
;; ... failed.

;; extern guint g_timeout_add_seconds(guint interval, GSourceFunc function, 
;;     gpointer data);
;; ... failed.

;; extern guint g_child_watch_add_full(gint priority, GPid pid, GChildWatchFunc
;;      function, gpointer data, GDestroyNotify notify);
(define g_child_watch_add_full
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func
                "g_child_watch_add_full"
                (dynamic-link))
              (list ffi:int ffi:int '* '* '*))))
    (lambda (priority pid function data notify)
      (let ((~priority (unwrap-gint priority))
            (~pid (unwrap~fixed pid))
            (~function
              ((make-ftn-arg-unwrapper
                 ffi:void
                 (list ffi:int ffi:int '*))
               function))
            (~data (unwrap-gpointer data))
            (~notify
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               notify)))
        (wrap-guint
          (~f ~priority ~pid ~function ~data ~notify))))))
(export g_child_watch_add_full)

;; extern guint g_child_watch_add(GPid pid, GChildWatchFunc function, gpointer 
;;     data);
(define g_child_watch_add
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func "g_child_watch_add" (dynamic-link))
              (list ffi:int '* '*))))
    (lambda (pid function data)
      (let ((~pid (unwrap~fixed pid))
            (~function
              ((make-ftn-arg-unwrapper
                 ffi:void
                 (list ffi:int ffi:int '*))
               function))
            (~data (unwrap-gpointer data)))
        (wrap-guint (~f ~pid ~function ~data))))))
(export g_child_watch_add)

;; extern guint g_idle_add(GSourceFunc function, gpointer data);
;; ... failed.

;; extern guint g_idle_add_full(gint priority, GSourceFunc function, gpointer 
;;     data, GDestroyNotify notify);
;; ... failed.

;; extern gboolean g_idle_remove_by_data(gpointer data);
(define g_idle_remove_by_data
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_idle_remove_by_data"
                (dynamic-link))
              (list '*))))
    (lambda (data)
      (let ((~data (unwrap-gpointer data)))
        (wrap-gboolean (~f ~data))))))
(export g_idle_remove_by_data)

;; extern void g_main_context_invoke_full(GMainContext *context, gint priority
;;     , GSourceFunc function, gpointer data, GDestroyNotify notify);
;; ... failed.

;; extern void g_main_context_invoke(GMainContext *context, GSourceFunc 
;;     function, gpointer data);
;; ... failed.

;; extern GSourceFuncs g_timeout_funcs;
(define g_timeout_funcs
  (let* ((addr (dynamic-pointer
                 "g_timeout_funcs"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (sizeof '*))
                0
                (bs:pointer GSourceFuncs-desc))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_timeout_funcs)

;; extern GSourceFuncs g_child_watch_funcs;
(define g_child_watch_funcs
  (let* ((addr (dynamic-pointer
                 "g_child_watch_funcs"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (sizeof '*))
                0
                (bs:pointer GSourceFuncs-desc))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_child_watch_funcs)

;; extern GSourceFuncs g_idle_funcs;
(define g_idle_funcs
  (let* ((addr (dynamic-pointer "g_idle_funcs" (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (sizeof '*))
                0
                (bs:pointer GSourceFuncs-desc))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_idle_funcs)

;; extern GSourceFuncs g_unix_signal_funcs;
(define g_unix_signal_funcs
  (let* ((addr (dynamic-pointer
                 "g_unix_signal_funcs"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (sizeof '*))
                0
                (bs:pointer GSourceFuncs-desc))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_unix_signal_funcs)

;; extern GSourceFuncs g_unix_fd_source_funcs;
(define g_unix_fd_source_funcs
  (let* ((addr (dynamic-pointer
                 "g_unix_fd_source_funcs"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (sizeof '*))
                0
                (bs:pointer GSourceFuncs-desc))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_unix_fd_source_funcs)

;; typedef guint32 gunichar;
(define gunichar-desc unsigned-int)
(export gunichar-desc)
(define unwrap-gunichar unwrap~fixed)
(define wrap-gunichar identity)

;; typedef guint16 gunichar2;
(define gunichar2-desc unsigned-short)
(export gunichar2-desc)
(define unwrap-gunichar2 unwrap~fixed)
(define wrap-gunichar2 identity)

;; typedef enum {
;;   G_UNICODE_CONTROL,
;;   G_UNICODE_FORMAT,
;;   G_UNICODE_UNASSIGNED,
;;   G_UNICODE_PRIVATE_USE,
;;   G_UNICODE_SURROGATE,
;;   G_UNICODE_LOWERCASE_LETTER,
;;   G_UNICODE_MODIFIER_LETTER,
;;   G_UNICODE_OTHER_LETTER,
;;   G_UNICODE_TITLECASE_LETTER,
;;   G_UNICODE_UPPERCASE_LETTER,
;;   G_UNICODE_SPACING_MARK,
;;   G_UNICODE_ENCLOSING_MARK,
;;   G_UNICODE_NON_SPACING_MARK,
;;   G_UNICODE_DECIMAL_NUMBER,
;;   G_UNICODE_LETTER_NUMBER,
;;   G_UNICODE_OTHER_NUMBER,
;;   G_UNICODE_CONNECT_PUNCTUATION,
;;   G_UNICODE_DASH_PUNCTUATION,
;;   G_UNICODE_CLOSE_PUNCTUATION,
;;   G_UNICODE_FINAL_PUNCTUATION,
;;   G_UNICODE_INITIAL_PUNCTUATION,
;;   G_UNICODE_OTHER_PUNCTUATION,
;;   G_UNICODE_OPEN_PUNCTUATION,
;;   G_UNICODE_CURRENCY_SYMBOL,
;;   G_UNICODE_MODIFIER_SYMBOL,
;;   G_UNICODE_MATH_SYMBOL,
;;   G_UNICODE_OTHER_SYMBOL,
;;   G_UNICODE_LINE_SEPARATOR,
;;   G_UNICODE_PARAGRAPH_SEPARATOR,
;;   G_UNICODE_SPACE_SEPARATOR,
;; } GUnicodeType;
(define-fh-enum GUnicodeType
  '((G_UNICODE_CONTROL . 0)
    (G_UNICODE_FORMAT . 1)
    (G_UNICODE_UNASSIGNED . 2)
    (G_UNICODE_PRIVATE_USE . 3)
    (G_UNICODE_SURROGATE . 4)
    (G_UNICODE_LOWERCASE_LETTER . 5)
    (G_UNICODE_MODIFIER_LETTER . 6)
    (G_UNICODE_OTHER_LETTER . 7)
    (G_UNICODE_TITLECASE_LETTER . 8)
    (G_UNICODE_UPPERCASE_LETTER . 9)
    (G_UNICODE_SPACING_MARK . 10)
    (G_UNICODE_ENCLOSING_MARK . 11)
    (G_UNICODE_NON_SPACING_MARK . 12)
    (G_UNICODE_DECIMAL_NUMBER . 13)
    (G_UNICODE_LETTER_NUMBER . 14)
    (G_UNICODE_OTHER_NUMBER . 15)
    (G_UNICODE_CONNECT_PUNCTUATION . 16)
    (G_UNICODE_DASH_PUNCTUATION . 17)
    (G_UNICODE_CLOSE_PUNCTUATION . 18)
    (G_UNICODE_FINAL_PUNCTUATION . 19)
    (G_UNICODE_INITIAL_PUNCTUATION . 20)
    (G_UNICODE_OTHER_PUNCTUATION . 21)
    (G_UNICODE_OPEN_PUNCTUATION . 22)
    (G_UNICODE_CURRENCY_SYMBOL . 23)
    (G_UNICODE_MODIFIER_SYMBOL . 24)
    (G_UNICODE_MATH_SYMBOL . 25)
    (G_UNICODE_OTHER_SYMBOL . 26)
    (G_UNICODE_LINE_SEPARATOR . 27)
    (G_UNICODE_PARAGRAPH_SEPARATOR . 28)
    (G_UNICODE_SPACE_SEPARATOR . 29))
  )

;; typedef enum {
;;   G_UNICODE_BREAK_MANDATORY,
;;   G_UNICODE_BREAK_CARRIAGE_RETURN,
;;   G_UNICODE_BREAK_LINE_FEED,
;;   G_UNICODE_BREAK_COMBINING_MARK,
;;   G_UNICODE_BREAK_SURROGATE,
;;   G_UNICODE_BREAK_ZERO_WIDTH_SPACE,
;;   G_UNICODE_BREAK_INSEPARABLE,
;;   G_UNICODE_BREAK_NON_BREAKING_GLUE,
;;   G_UNICODE_BREAK_CONTINGENT,
;;   G_UNICODE_BREAK_SPACE,
;;   G_UNICODE_BREAK_AFTER,
;;   G_UNICODE_BREAK_BEFORE,
;;   G_UNICODE_BREAK_BEFORE_AND_AFTER,
;;   G_UNICODE_BREAK_HYPHEN,
;;   G_UNICODE_BREAK_NON_STARTER,
;;   G_UNICODE_BREAK_OPEN_PUNCTUATION,
;;   G_UNICODE_BREAK_CLOSE_PUNCTUATION,
;;   G_UNICODE_BREAK_QUOTATION,
;;   G_UNICODE_BREAK_EXCLAMATION,
;;   G_UNICODE_BREAK_IDEOGRAPHIC,
;;   G_UNICODE_BREAK_NUMERIC,
;;   G_UNICODE_BREAK_INFIX_SEPARATOR,
;;   G_UNICODE_BREAK_SYMBOL,
;;   G_UNICODE_BREAK_ALPHABETIC,
;;   G_UNICODE_BREAK_PREFIX,
;;   G_UNICODE_BREAK_POSTFIX,
;;   G_UNICODE_BREAK_COMPLEX_CONTEXT,
;;   G_UNICODE_BREAK_AMBIGUOUS,
;;   G_UNICODE_BREAK_UNKNOWN,
;;   G_UNICODE_BREAK_NEXT_LINE,
;;   G_UNICODE_BREAK_WORD_JOINER,
;;   G_UNICODE_BREAK_HANGUL_L_JAMO,
;;   G_UNICODE_BREAK_HANGUL_V_JAMO,
;;   G_UNICODE_BREAK_HANGUL_T_JAMO,
;;   G_UNICODE_BREAK_HANGUL_LV_SYLLABLE,
;;   G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,
;;   G_UNICODE_BREAK_CLOSE_PARANTHESIS,
;;   G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER,
;;   G_UNICODE_BREAK_HEBREW_LETTER,
;;   G_UNICODE_BREAK_REGIONAL_INDICATOR,
;;   G_UNICODE_BREAK_EMOJI_BASE,
;;   G_UNICODE_BREAK_EMOJI_MODIFIER,
;;   G_UNICODE_BREAK_ZERO_WIDTH_JOINER,
;; } GUnicodeBreakType;
(define-fh-enum GUnicodeBreakType
  '((G_UNICODE_BREAK_MANDATORY . 0)
    (G_UNICODE_BREAK_CARRIAGE_RETURN . 1)
    (G_UNICODE_BREAK_LINE_FEED . 2)
    (G_UNICODE_BREAK_COMBINING_MARK . 3)
    (G_UNICODE_BREAK_SURROGATE . 4)
    (G_UNICODE_BREAK_ZERO_WIDTH_SPACE . 5)
    (G_UNICODE_BREAK_INSEPARABLE . 6)
    (G_UNICODE_BREAK_NON_BREAKING_GLUE . 7)
    (G_UNICODE_BREAK_CONTINGENT . 8)
    (G_UNICODE_BREAK_SPACE . 9)
    (G_UNICODE_BREAK_AFTER . 10)
    (G_UNICODE_BREAK_BEFORE . 11)
    (G_UNICODE_BREAK_BEFORE_AND_AFTER . 12)
    (G_UNICODE_BREAK_HYPHEN . 13)
    (G_UNICODE_BREAK_NON_STARTER . 14)
    (G_UNICODE_BREAK_OPEN_PUNCTUATION . 15)
    (G_UNICODE_BREAK_CLOSE_PUNCTUATION . 16)
    (G_UNICODE_BREAK_QUOTATION . 17)
    (G_UNICODE_BREAK_EXCLAMATION . 18)
    (G_UNICODE_BREAK_IDEOGRAPHIC . 19)
    (G_UNICODE_BREAK_NUMERIC . 20)
    (G_UNICODE_BREAK_INFIX_SEPARATOR . 21)
    (G_UNICODE_BREAK_SYMBOL . 22)
    (G_UNICODE_BREAK_ALPHABETIC . 23)
    (G_UNICODE_BREAK_PREFIX . 24)
    (G_UNICODE_BREAK_POSTFIX . 25)
    (G_UNICODE_BREAK_COMPLEX_CONTEXT . 26)
    (G_UNICODE_BREAK_AMBIGUOUS . 27)
    (G_UNICODE_BREAK_UNKNOWN . 28)
    (G_UNICODE_BREAK_NEXT_LINE . 29)
    (G_UNICODE_BREAK_WORD_JOINER . 30)
    (G_UNICODE_BREAK_HANGUL_L_JAMO . 31)
    (G_UNICODE_BREAK_HANGUL_V_JAMO . 32)
    (G_UNICODE_BREAK_HANGUL_T_JAMO . 33)
    (G_UNICODE_BREAK_HANGUL_LV_SYLLABLE . 34)
    (G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE . 35)
    (G_UNICODE_BREAK_CLOSE_PARANTHESIS . 36)
    (G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER
      .
      37)
    (G_UNICODE_BREAK_HEBREW_LETTER . 38)
    (G_UNICODE_BREAK_REGIONAL_INDICATOR . 39)
    (G_UNICODE_BREAK_EMOJI_BASE . 40)
    (G_UNICODE_BREAK_EMOJI_MODIFIER . 41)
    (G_UNICODE_BREAK_ZERO_WIDTH_JOINER . 42))
  )

;; typedef enum {
;;   G_UNICODE_SCRIPT_INVALID_CODE = -1,
;;   G_UNICODE_SCRIPT_COMMON = 0,
;;   G_UNICODE_SCRIPT_INHERITED,
;;   G_UNICODE_SCRIPT_ARABIC,
;;   G_UNICODE_SCRIPT_ARMENIAN,
;;   G_UNICODE_SCRIPT_BENGALI,
;;   G_UNICODE_SCRIPT_BOPOMOFO,
;;   G_UNICODE_SCRIPT_CHEROKEE,
;;   G_UNICODE_SCRIPT_COPTIC,
;;   G_UNICODE_SCRIPT_CYRILLIC,
;;   G_UNICODE_SCRIPT_DESERET,
;;   G_UNICODE_SCRIPT_DEVANAGARI,
;;   G_UNICODE_SCRIPT_ETHIOPIC,
;;   G_UNICODE_SCRIPT_GEORGIAN,
;;   G_UNICODE_SCRIPT_GOTHIC,
;;   G_UNICODE_SCRIPT_GREEK,
;;   G_UNICODE_SCRIPT_GUJARATI,
;;   G_UNICODE_SCRIPT_GURMUKHI,
;;   G_UNICODE_SCRIPT_HAN,
;;   G_UNICODE_SCRIPT_HANGUL,
;;   G_UNICODE_SCRIPT_HEBREW,
;;   G_UNICODE_SCRIPT_HIRAGANA,
;;   G_UNICODE_SCRIPT_KANNADA,
;;   G_UNICODE_SCRIPT_KATAKANA,
;;   G_UNICODE_SCRIPT_KHMER,
;;   G_UNICODE_SCRIPT_LAO,
;;   G_UNICODE_SCRIPT_LATIN,
;;   G_UNICODE_SCRIPT_MALAYALAM,
;;   G_UNICODE_SCRIPT_MONGOLIAN,
;;   G_UNICODE_SCRIPT_MYANMAR,
;;   G_UNICODE_SCRIPT_OGHAM,
;;   G_UNICODE_SCRIPT_OLD_ITALIC,
;;   G_UNICODE_SCRIPT_ORIYA,
;;   G_UNICODE_SCRIPT_RUNIC,
;;   G_UNICODE_SCRIPT_SINHALA,
;;   G_UNICODE_SCRIPT_SYRIAC,
;;   G_UNICODE_SCRIPT_TAMIL,
;;   G_UNICODE_SCRIPT_TELUGU,
;;   G_UNICODE_SCRIPT_THAANA,
;;   G_UNICODE_SCRIPT_THAI,
;;   G_UNICODE_SCRIPT_TIBETAN,
;;   G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL,
;;   G_UNICODE_SCRIPT_YI,
;;   G_UNICODE_SCRIPT_TAGALOG,
;;   G_UNICODE_SCRIPT_HANUNOO,
;;   G_UNICODE_SCRIPT_BUHID,
;;   G_UNICODE_SCRIPT_TAGBANWA,
;;   G_UNICODE_SCRIPT_BRAILLE,
;;   G_UNICODE_SCRIPT_CYPRIOT,
;;   G_UNICODE_SCRIPT_LIMBU,
;;   G_UNICODE_SCRIPT_OSMANYA,
;;   G_UNICODE_SCRIPT_SHAVIAN,
;;   G_UNICODE_SCRIPT_LINEAR_B,
;;   G_UNICODE_SCRIPT_TAI_LE,
;;   G_UNICODE_SCRIPT_UGARITIC,
;;   G_UNICODE_SCRIPT_NEW_TAI_LUE,
;;   G_UNICODE_SCRIPT_BUGINESE,
;;   G_UNICODE_SCRIPT_GLAGOLITIC,
;;   G_UNICODE_SCRIPT_TIFINAGH,
;;   G_UNICODE_SCRIPT_SYLOTI_NAGRI,
;;   G_UNICODE_SCRIPT_OLD_PERSIAN,
;;   G_UNICODE_SCRIPT_KHAROSHTHI,
;;   G_UNICODE_SCRIPT_UNKNOWN,
;;   G_UNICODE_SCRIPT_BALINESE,
;;   G_UNICODE_SCRIPT_CUNEIFORM,
;;   G_UNICODE_SCRIPT_PHOENICIAN,
;;   G_UNICODE_SCRIPT_PHAGS_PA,
;;   G_UNICODE_SCRIPT_NKO,
;;   G_UNICODE_SCRIPT_KAYAH_LI,
;;   G_UNICODE_SCRIPT_LEPCHA,
;;   G_UNICODE_SCRIPT_REJANG,
;;   G_UNICODE_SCRIPT_SUNDANESE,
;;   G_UNICODE_SCRIPT_SAURASHTRA,
;;   G_UNICODE_SCRIPT_CHAM,
;;   G_UNICODE_SCRIPT_OL_CHIKI,
;;   G_UNICODE_SCRIPT_VAI,
;;   G_UNICODE_SCRIPT_CARIAN,
;;   G_UNICODE_SCRIPT_LYCIAN,
;;   G_UNICODE_SCRIPT_LYDIAN,
;;   G_UNICODE_SCRIPT_AVESTAN,
;;   G_UNICODE_SCRIPT_BAMUM,
;;   G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS,
;;   G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC,
;;   G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI,
;;   G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN,
;;   G_UNICODE_SCRIPT_JAVANESE,
;;   G_UNICODE_SCRIPT_KAITHI,
;;   G_UNICODE_SCRIPT_LISU,
;;   G_UNICODE_SCRIPT_MEETEI_MAYEK,
;;   G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN,
;;   G_UNICODE_SCRIPT_OLD_TURKIC,
;;   G_UNICODE_SCRIPT_SAMARITAN,
;;   G_UNICODE_SCRIPT_TAI_THAM,
;;   G_UNICODE_SCRIPT_TAI_VIET,
;;   G_UNICODE_SCRIPT_BATAK,
;;   G_UNICODE_SCRIPT_BRAHMI,
;;   G_UNICODE_SCRIPT_MANDAIC,
;;   G_UNICODE_SCRIPT_CHAKMA,
;;   G_UNICODE_SCRIPT_MEROITIC_CURSIVE,
;;   G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS,
;;   G_UNICODE_SCRIPT_MIAO,
;;   G_UNICODE_SCRIPT_SHARADA,
;;   G_UNICODE_SCRIPT_SORA_SOMPENG,
;;   G_UNICODE_SCRIPT_TAKRI,
;;   G_UNICODE_SCRIPT_BASSA_VAH,
;;   G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN,
;;   G_UNICODE_SCRIPT_DUPLOYAN,
;;   G_UNICODE_SCRIPT_ELBASAN,
;;   G_UNICODE_SCRIPT_GRANTHA,
;;   G_UNICODE_SCRIPT_KHOJKI,
;;   G_UNICODE_SCRIPT_KHUDAWADI,
;;   G_UNICODE_SCRIPT_LINEAR_A,
;;   G_UNICODE_SCRIPT_MAHAJANI,
;;   G_UNICODE_SCRIPT_MANICHAEAN,
;;   G_UNICODE_SCRIPT_MENDE_KIKAKUI,
;;   G_UNICODE_SCRIPT_MODI,
;;   G_UNICODE_SCRIPT_MRO,
;;   G_UNICODE_SCRIPT_NABATAEAN,
;;   G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN,
;;   G_UNICODE_SCRIPT_OLD_PERMIC,
;;   G_UNICODE_SCRIPT_PAHAWH_HMONG,
;;   G_UNICODE_SCRIPT_PALMYRENE,
;;   G_UNICODE_SCRIPT_PAU_CIN_HAU,
;;   G_UNICODE_SCRIPT_PSALTER_PAHLAVI,
;;   G_UNICODE_SCRIPT_SIDDHAM,
;;   G_UNICODE_SCRIPT_TIRHUTA,
;;   G_UNICODE_SCRIPT_WARANG_CITI,
;;   G_UNICODE_SCRIPT_AHOM,
;;   G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS,
;;   G_UNICODE_SCRIPT_HATRAN,
;;   G_UNICODE_SCRIPT_MULTANI,
;;   G_UNICODE_SCRIPT_OLD_HUNGARIAN,
;;   G_UNICODE_SCRIPT_SIGNWRITING,
;;   G_UNICODE_SCRIPT_ADLAM,
;;   G_UNICODE_SCRIPT_BHAIKSUKI,
;;   G_UNICODE_SCRIPT_MARCHEN,
;;   G_UNICODE_SCRIPT_NEWA,
;;   G_UNICODE_SCRIPT_OSAGE,
;;   G_UNICODE_SCRIPT_TANGUT,
;; } GUnicodeScript;
(define-fh-enum GUnicodeScript
  '((G_UNICODE_SCRIPT_INVALID_CODE . -1)
    (G_UNICODE_SCRIPT_COMMON . 0)
    (G_UNICODE_SCRIPT_INHERITED . 1)
    (G_UNICODE_SCRIPT_ARABIC . 2)
    (G_UNICODE_SCRIPT_ARMENIAN . 3)
    (G_UNICODE_SCRIPT_BENGALI . 4)
    (G_UNICODE_SCRIPT_BOPOMOFO . 5)
    (G_UNICODE_SCRIPT_CHEROKEE . 6)
    (G_UNICODE_SCRIPT_COPTIC . 7)
    (G_UNICODE_SCRIPT_CYRILLIC . 8)
    (G_UNICODE_SCRIPT_DESERET . 9)
    (G_UNICODE_SCRIPT_DEVANAGARI . 10)
    (G_UNICODE_SCRIPT_ETHIOPIC . 11)
    (G_UNICODE_SCRIPT_GEORGIAN . 12)
    (G_UNICODE_SCRIPT_GOTHIC . 13)
    (G_UNICODE_SCRIPT_GREEK . 14)
    (G_UNICODE_SCRIPT_GUJARATI . 15)
    (G_UNICODE_SCRIPT_GURMUKHI . 16)
    (G_UNICODE_SCRIPT_HAN . 17)
    (G_UNICODE_SCRIPT_HANGUL . 18)
    (G_UNICODE_SCRIPT_HEBREW . 19)
    (G_UNICODE_SCRIPT_HIRAGANA . 20)
    (G_UNICODE_SCRIPT_KANNADA . 21)
    (G_UNICODE_SCRIPT_KATAKANA . 22)
    (G_UNICODE_SCRIPT_KHMER . 23)
    (G_UNICODE_SCRIPT_LAO . 24)
    (G_UNICODE_SCRIPT_LATIN . 25)
    (G_UNICODE_SCRIPT_MALAYALAM . 26)
    (G_UNICODE_SCRIPT_MONGOLIAN . 27)
    (G_UNICODE_SCRIPT_MYANMAR . 28)
    (G_UNICODE_SCRIPT_OGHAM . 29)
    (G_UNICODE_SCRIPT_OLD_ITALIC . 30)
    (G_UNICODE_SCRIPT_ORIYA . 31)
    (G_UNICODE_SCRIPT_RUNIC . 32)
    (G_UNICODE_SCRIPT_SINHALA . 33)
    (G_UNICODE_SCRIPT_SYRIAC . 34)
    (G_UNICODE_SCRIPT_TAMIL . 35)
    (G_UNICODE_SCRIPT_TELUGU . 36)
    (G_UNICODE_SCRIPT_THAANA . 37)
    (G_UNICODE_SCRIPT_THAI . 38)
    (G_UNICODE_SCRIPT_TIBETAN . 39)
    (G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL . 40)
    (G_UNICODE_SCRIPT_YI . 41)
    (G_UNICODE_SCRIPT_TAGALOG . 42)
    (G_UNICODE_SCRIPT_HANUNOO . 43)
    (G_UNICODE_SCRIPT_BUHID . 44)
    (G_UNICODE_SCRIPT_TAGBANWA . 45)
    (G_UNICODE_SCRIPT_BRAILLE . 46)
    (G_UNICODE_SCRIPT_CYPRIOT . 47)
    (G_UNICODE_SCRIPT_LIMBU . 48)
    (G_UNICODE_SCRIPT_OSMANYA . 49)
    (G_UNICODE_SCRIPT_SHAVIAN . 50)
    (G_UNICODE_SCRIPT_LINEAR_B . 51)
    (G_UNICODE_SCRIPT_TAI_LE . 52)
    (G_UNICODE_SCRIPT_UGARITIC . 53)
    (G_UNICODE_SCRIPT_NEW_TAI_LUE . 54)
    (G_UNICODE_SCRIPT_BUGINESE . 55)
    (G_UNICODE_SCRIPT_GLAGOLITIC . 56)
    (G_UNICODE_SCRIPT_TIFINAGH . 57)
    (G_UNICODE_SCRIPT_SYLOTI_NAGRI . 58)
    (G_UNICODE_SCRIPT_OLD_PERSIAN . 59)
    (G_UNICODE_SCRIPT_KHAROSHTHI . 60)
    (G_UNICODE_SCRIPT_UNKNOWN . 61)
    (G_UNICODE_SCRIPT_BALINESE . 62)
    (G_UNICODE_SCRIPT_CUNEIFORM . 63)
    (G_UNICODE_SCRIPT_PHOENICIAN . 64)
    (G_UNICODE_SCRIPT_PHAGS_PA . 65)
    (G_UNICODE_SCRIPT_NKO . 66)
    (G_UNICODE_SCRIPT_KAYAH_LI . 67)
    (G_UNICODE_SCRIPT_LEPCHA . 68)
    (G_UNICODE_SCRIPT_REJANG . 69)
    (G_UNICODE_SCRIPT_SUNDANESE . 70)
    (G_UNICODE_SCRIPT_SAURASHTRA . 71)
    (G_UNICODE_SCRIPT_CHAM . 72)
    (G_UNICODE_SCRIPT_OL_CHIKI . 73)
    (G_UNICODE_SCRIPT_VAI . 74)
    (G_UNICODE_SCRIPT_CARIAN . 75)
    (G_UNICODE_SCRIPT_LYCIAN . 76)
    (G_UNICODE_SCRIPT_LYDIAN . 77)
    (G_UNICODE_SCRIPT_AVESTAN . 78)
    (G_UNICODE_SCRIPT_BAMUM . 79)
    (G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS . 80)
    (G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC . 81)
    (G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI . 82)
    (G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN . 83)
    (G_UNICODE_SCRIPT_JAVANESE . 84)
    (G_UNICODE_SCRIPT_KAITHI . 85)
    (G_UNICODE_SCRIPT_LISU . 86)
    (G_UNICODE_SCRIPT_MEETEI_MAYEK . 87)
    (G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN . 88)
    (G_UNICODE_SCRIPT_OLD_TURKIC . 89)
    (G_UNICODE_SCRIPT_SAMARITAN . 90)
    (G_UNICODE_SCRIPT_TAI_THAM . 91)
    (G_UNICODE_SCRIPT_TAI_VIET . 92)
    (G_UNICODE_SCRIPT_BATAK . 93)
    (G_UNICODE_SCRIPT_BRAHMI . 94)
    (G_UNICODE_SCRIPT_MANDAIC . 95)
    (G_UNICODE_SCRIPT_CHAKMA . 96)
    (G_UNICODE_SCRIPT_MEROITIC_CURSIVE . 97)
    (G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS . 98)
    (G_UNICODE_SCRIPT_MIAO . 99)
    (G_UNICODE_SCRIPT_SHARADA . 100)
    (G_UNICODE_SCRIPT_SORA_SOMPENG . 101)
    (G_UNICODE_SCRIPT_TAKRI . 102)
    (G_UNICODE_SCRIPT_BASSA_VAH . 103)
    (G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN . 104)
    (G_UNICODE_SCRIPT_DUPLOYAN . 105)
    (G_UNICODE_SCRIPT_ELBASAN . 106)
    (G_UNICODE_SCRIPT_GRANTHA . 107)
    (G_UNICODE_SCRIPT_KHOJKI . 108)
    (G_UNICODE_SCRIPT_KHUDAWADI . 109)
    (G_UNICODE_SCRIPT_LINEAR_A . 110)
    (G_UNICODE_SCRIPT_MAHAJANI . 111)
    (G_UNICODE_SCRIPT_MANICHAEAN . 112)
    (G_UNICODE_SCRIPT_MENDE_KIKAKUI . 113)
    (G_UNICODE_SCRIPT_MODI . 114)
    (G_UNICODE_SCRIPT_MRO . 115)
    (G_UNICODE_SCRIPT_NABATAEAN . 116)
    (G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN . 117)
    (G_UNICODE_SCRIPT_OLD_PERMIC . 118)
    (G_UNICODE_SCRIPT_PAHAWH_HMONG . 119)
    (G_UNICODE_SCRIPT_PALMYRENE . 120)
    (G_UNICODE_SCRIPT_PAU_CIN_HAU . 121)
    (G_UNICODE_SCRIPT_PSALTER_PAHLAVI . 122)
    (G_UNICODE_SCRIPT_SIDDHAM . 123)
    (G_UNICODE_SCRIPT_TIRHUTA . 124)
    (G_UNICODE_SCRIPT_WARANG_CITI . 125)
    (G_UNICODE_SCRIPT_AHOM . 126)
    (G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS . 127)
    (G_UNICODE_SCRIPT_HATRAN . 128)
    (G_UNICODE_SCRIPT_MULTANI . 129)
    (G_UNICODE_SCRIPT_OLD_HUNGARIAN . 130)
    (G_UNICODE_SCRIPT_SIGNWRITING . 131)
    (G_UNICODE_SCRIPT_ADLAM . 132)
    (G_UNICODE_SCRIPT_BHAIKSUKI . 133)
    (G_UNICODE_SCRIPT_MARCHEN . 134)
    (G_UNICODE_SCRIPT_NEWA . 135)
    (G_UNICODE_SCRIPT_OSAGE . 136)
    (G_UNICODE_SCRIPT_TANGUT . 137))
  )

;; extern guint32 g_unicode_script_to_iso15924(GUnicodeScript script);
(define g_unicode_script_to_iso15924
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func
                "g_unicode_script_to_iso15924"
                (dynamic-link))
              (list ffi:int))))
    (lambda (script)
      (let ((~script (unwrap~fixed script)))
        (~f ~script)))))
(export g_unicode_script_to_iso15924)

;; extern GUnicodeScript g_unicode_script_from_iso15924(guint32 iso15924);
(define g_unicode_script_from_iso15924
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_unicode_script_from_iso15924"
                (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (iso15924)
      (let ((~iso15924 (unwrap~fixed iso15924)))
        (~f ~iso15924)))))
(export g_unicode_script_from_iso15924)

;; extern gboolean g_unichar_isalnum(gunichar c);
(define g_unichar_isalnum
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_unichar_isalnum" (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (c)
      (let ((~c (unwrap-gunichar c)))
        (wrap-gboolean (~f ~c))))))
(export g_unichar_isalnum)

;; extern gboolean g_unichar_isalpha(gunichar c);
(define g_unichar_isalpha
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_unichar_isalpha" (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (c)
      (let ((~c (unwrap-gunichar c)))
        (wrap-gboolean (~f ~c))))))
(export g_unichar_isalpha)

;; extern gboolean g_unichar_iscntrl(gunichar c);
(define g_unichar_iscntrl
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_unichar_iscntrl" (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (c)
      (let ((~c (unwrap-gunichar c)))
        (wrap-gboolean (~f ~c))))))
(export g_unichar_iscntrl)

;; extern gboolean g_unichar_isdigit(gunichar c);
(define g_unichar_isdigit
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_unichar_isdigit" (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (c)
      (let ((~c (unwrap-gunichar c)))
        (wrap-gboolean (~f ~c))))))
(export g_unichar_isdigit)

;; extern gboolean g_unichar_isgraph(gunichar c);
(define g_unichar_isgraph
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_unichar_isgraph" (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (c)
      (let ((~c (unwrap-gunichar c)))
        (wrap-gboolean (~f ~c))))))
(export g_unichar_isgraph)

;; extern gboolean g_unichar_islower(gunichar c);
(define g_unichar_islower
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_unichar_islower" (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (c)
      (let ((~c (unwrap-gunichar c)))
        (wrap-gboolean (~f ~c))))))
(export g_unichar_islower)

;; extern gboolean g_unichar_isprint(gunichar c);
(define g_unichar_isprint
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_unichar_isprint" (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (c)
      (let ((~c (unwrap-gunichar c)))
        (wrap-gboolean (~f ~c))))))
(export g_unichar_isprint)

;; extern gboolean g_unichar_ispunct(gunichar c);
(define g_unichar_ispunct
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_unichar_ispunct" (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (c)
      (let ((~c (unwrap-gunichar c)))
        (wrap-gboolean (~f ~c))))))
(export g_unichar_ispunct)

;; extern gboolean g_unichar_isspace(gunichar c);
(define g_unichar_isspace
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_unichar_isspace" (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (c)
      (let ((~c (unwrap-gunichar c)))
        (wrap-gboolean (~f ~c))))))
(export g_unichar_isspace)

;; extern gboolean g_unichar_isupper(gunichar c);
(define g_unichar_isupper
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_unichar_isupper" (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (c)
      (let ((~c (unwrap-gunichar c)))
        (wrap-gboolean (~f ~c))))))
(export g_unichar_isupper)

;; extern gboolean g_unichar_isxdigit(gunichar c);
(define g_unichar_isxdigit
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_unichar_isxdigit"
                (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (c)
      (let ((~c (unwrap-gunichar c)))
        (wrap-gboolean (~f ~c))))))
(export g_unichar_isxdigit)

;; extern gboolean g_unichar_istitle(gunichar c);
(define g_unichar_istitle
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_unichar_istitle" (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (c)
      (let ((~c (unwrap-gunichar c)))
        (wrap-gboolean (~f ~c))))))
(export g_unichar_istitle)

;; extern gboolean g_unichar_isdefined(gunichar c);
(define g_unichar_isdefined
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_unichar_isdefined"
                (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (c)
      (let ((~c (unwrap-gunichar c)))
        (wrap-gboolean (~f ~c))))))
(export g_unichar_isdefined)

;; extern gboolean g_unichar_iswide(gunichar c);
(define g_unichar_iswide
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_unichar_iswide" (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (c)
      (let ((~c (unwrap-gunichar c)))
        (wrap-gboolean (~f ~c))))))
(export g_unichar_iswide)

;; extern gboolean g_unichar_iswide_cjk(gunichar c);
(define g_unichar_iswide_cjk
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_unichar_iswide_cjk"
                (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (c)
      (let ((~c (unwrap-gunichar c)))
        (wrap-gboolean (~f ~c))))))
(export g_unichar_iswide_cjk)

;; extern gboolean g_unichar_iszerowidth(gunichar c);
(define g_unichar_iszerowidth
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_unichar_iszerowidth"
                (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (c)
      (let ((~c (unwrap-gunichar c)))
        (wrap-gboolean (~f ~c))))))
(export g_unichar_iszerowidth)

;; extern gboolean g_unichar_ismark(gunichar c);
(define g_unichar_ismark
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_unichar_ismark" (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (c)
      (let ((~c (unwrap-gunichar c)))
        (wrap-gboolean (~f ~c))))))
(export g_unichar_ismark)

;; extern gunichar g_unichar_toupper(gunichar c);
(define g_unichar_toupper
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func "g_unichar_toupper" (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (c)
      (let ((~c (unwrap-gunichar c)))
        (wrap-gunichar (~f ~c))))))
(export g_unichar_toupper)

;; extern gunichar g_unichar_tolower(gunichar c);
(define g_unichar_tolower
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func "g_unichar_tolower" (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (c)
      (let ((~c (unwrap-gunichar c)))
        (wrap-gunichar (~f ~c))))))
(export g_unichar_tolower)

;; extern gunichar g_unichar_totitle(gunichar c);
(define g_unichar_totitle
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func "g_unichar_totitle" (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (c)
      (let ((~c (unwrap-gunichar c)))
        (wrap-gunichar (~f ~c))))))
(export g_unichar_totitle)

;; extern gint g_unichar_digit_value(gunichar c);
(define g_unichar_digit_value
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_unichar_digit_value"
                (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (c)
      (let ((~c (unwrap-gunichar c)))
        (wrap-gint (~f ~c))))))
(export g_unichar_digit_value)

;; extern gint g_unichar_xdigit_value(gunichar c);
(define g_unichar_xdigit_value
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_unichar_xdigit_value"
                (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (c)
      (let ((~c (unwrap-gunichar c)))
        (wrap-gint (~f ~c))))))
(export g_unichar_xdigit_value)

;; extern GUnicodeType g_unichar_type(gunichar c);
(define g_unichar_type
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_unichar_type" (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (c)
      (let ((~c (unwrap-gunichar c))) (~f ~c)))))
(export g_unichar_type)

;; extern GUnicodeBreakType g_unichar_break_type(gunichar c);
(define g_unichar_break_type
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_unichar_break_type"
                (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (c)
      (let ((~c (unwrap-gunichar c))) (~f ~c)))))
(export g_unichar_break_type)

;; extern gint g_unichar_combining_class(gunichar uc);
(define g_unichar_combining_class
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_unichar_combining_class"
                (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (uc)
      (let ((~uc (unwrap-gunichar uc)))
        (wrap-gint (~f ~uc))))))
(export g_unichar_combining_class)

;; extern gboolean g_unichar_get_mirror_char(gunichar ch, gunichar *mirrored_ch
;;     );
(define g_unichar_get_mirror_char
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_unichar_get_mirror_char"
                (dynamic-link))
              (list ffi:unsigned-int '*))))
    (lambda (ch mirrored_ch)
      (let ((~ch (unwrap-gunichar ch))
            (~mirrored_ch (unwrap-gunichar* mirrored_ch)))
        (wrap-gboolean (~f ~ch ~mirrored_ch))))))
(export g_unichar_get_mirror_char)

;; extern GUnicodeScript g_unichar_get_script(gunichar ch);
(define g_unichar_get_script
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_unichar_get_script"
                (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (ch)
      (let ((~ch (unwrap-gunichar ch))) (~f ~ch)))))
(export g_unichar_get_script)

;; extern gboolean g_unichar_validate(gunichar ch);
(define g_unichar_validate
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_unichar_validate"
                (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (ch)
      (let ((~ch (unwrap-gunichar ch)))
        (wrap-gboolean (~f ~ch))))))
(export g_unichar_validate)

;; extern gboolean g_unichar_compose(gunichar a, gunichar b, gunichar *ch);
(define g_unichar_compose
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_unichar_compose" (dynamic-link))
              (list ffi:unsigned-int ffi:unsigned-int '*))))
    (lambda (a b ch)
      (let ((~a (unwrap-gunichar a))
            (~b (unwrap-gunichar b))
            (~ch (unwrap-gunichar* ch)))
        (wrap-gboolean (~f ~a ~b ~ch))))))
(export g_unichar_compose)

;; extern gboolean g_unichar_decompose(gunichar ch, gunichar *a, gunichar *b);
(define g_unichar_decompose
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_unichar_decompose"
                (dynamic-link))
              (list ffi:unsigned-int '* '*))))
    (lambda (ch a b)
      (let ((~ch (unwrap-gunichar ch))
            (~a (unwrap-gunichar* a))
            (~b (unwrap-gunichar* b)))
        (wrap-gboolean (~f ~ch ~a ~b))))))
(export g_unichar_decompose)

;; extern gsize g_unichar_fully_decompose(gunichar ch, gboolean compat, 
;;     gunichar *result, gsize result_len);
(define g_unichar_fully_decompose
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-long
              (dynamic-func
                "g_unichar_fully_decompose"
                (dynamic-link))
              (list ffi:unsigned-int
                    ffi:int
                    '*
                    ffi:unsigned-long))))
    (lambda (ch compat result result_len)
      (let ((~ch (unwrap-gunichar ch))
            (~compat (unwrap-gboolean compat))
            (~result (unwrap-gunichar* result))
            (~result_len (unwrap~fixed result_len)))
        (~f ~ch ~compat ~result ~result_len)))))
(export g_unichar_fully_decompose)

;; extern void g_unicode_canonical_ordering(gunichar *string, gsize len);
(define g_unicode_canonical_ordering
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_unicode_canonical_ordering"
                (dynamic-link))
              (list '* ffi:unsigned-long))))
    (lambda (string len)
      (let ((~string (unwrap-gunichar* string))
            (~len (unwrap~fixed len)))
        (~f ~string ~len)))))
(export g_unicode_canonical_ordering)

;; extern gunichar *g_unicode_canonical_decomposition(gunichar ch, gsize *
;;     result_len);
(define g_unicode_canonical_decomposition
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_unicode_canonical_decomposition"
                (dynamic-link))
              (list ffi:unsigned-int '*))))
    (lambda (ch result_len)
      (let ((~ch (unwrap-gunichar ch))
            (~result_len (unwrap~pointer result_len)))
        (wrap-gunichar* (~f ~ch ~result_len))))))
(export g_unicode_canonical_decomposition)

;; extern const gchar *constg_utf8_skip;
(define g_utf8_skip
  (let* ((addr (dynamic-pointer "g_utf8_skip" (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (sizeof '*))
                0
                (bs:pointer (bs:pointer gchar*-desc)))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_utf8_skip)

;; extern gunichar g_utf8_get_char(const gchar *p);
(define g_utf8_get_char
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func "g_utf8_get_char" (dynamic-link))
              (list '*))))
    (lambda (p)
      (let ((~p (unwrap-gchar* p)))
        (wrap-gunichar (~f ~p))))))
(export g_utf8_get_char)

;; extern gunichar g_utf8_get_char_validated(const gchar *p, gssize max_len);
;; ... failed.

;; extern gchar *g_utf8_offset_to_pointer(const gchar *str, glong offset);
(define g_utf8_offset_to_pointer
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_utf8_offset_to_pointer"
                (dynamic-link))
              (list '* ffi:long))))
    (lambda (str offset)
      (let ((~str (unwrap-gchar* str))
            (~offset (unwrap-glong offset)))
        (wrap-gchar* (~f ~str ~offset))))))
(export g_utf8_offset_to_pointer)

;; extern glong g_utf8_pointer_to_offset(const gchar *str, const gchar *pos);
(define g_utf8_pointer_to_offset
  (let ((~f (ffi:pointer->procedure
              ffi:long
              (dynamic-func
                "g_utf8_pointer_to_offset"
                (dynamic-link))
              (list '* '*))))
    (lambda (str pos)
      (let ((~str (unwrap-gchar* str))
            (~pos (unwrap-gchar* pos)))
        (wrap-glong (~f ~str ~pos))))))
(export g_utf8_pointer_to_offset)

;; extern gchar *g_utf8_prev_char(const gchar *p);
(define g_utf8_prev_char
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_utf8_prev_char" (dynamic-link))
              (list '*))))
    (lambda (p)
      (let ((~p (unwrap-gchar* p)))
        (wrap-gchar* (~f ~p))))))
(export g_utf8_prev_char)

;; extern gchar *g_utf8_find_next_char(const gchar *p, const gchar *end);
(define g_utf8_find_next_char
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_utf8_find_next_char"
                (dynamic-link))
              (list '* '*))))
    (lambda (p end)
      (let ((~p (unwrap-gchar* p))
            (~end (unwrap-gchar* end)))
        (wrap-gchar* (~f ~p ~end))))))
(export g_utf8_find_next_char)

;; extern gchar *g_utf8_find_prev_char(const gchar *str, const gchar *p);
(define g_utf8_find_prev_char
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_utf8_find_prev_char"
                (dynamic-link))
              (list '* '*))))
    (lambda (str p)
      (let ((~str (unwrap-gchar* str))
            (~p (unwrap-gchar* p)))
        (wrap-gchar* (~f ~str ~p))))))
(export g_utf8_find_prev_char)

;; extern glong g_utf8_strlen(const gchar *p, gssize max);
;; ... failed.

;; extern gchar *g_utf8_substring(const gchar *str, glong start_pos, glong 
;;     end_pos);
(define g_utf8_substring
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_utf8_substring" (dynamic-link))
              (list '* ffi:long ffi:long))))
    (lambda (str start_pos end_pos)
      (let ((~str (unwrap-gchar* str))
            (~start_pos (unwrap-glong start_pos))
            (~end_pos (unwrap-glong end_pos)))
        (wrap-gchar* (~f ~str ~start_pos ~end_pos))))))
(export g_utf8_substring)

;; extern gchar *g_utf8_strncpy(gchar *dest, const gchar *src, gsize n);
(define g_utf8_strncpy
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_utf8_strncpy" (dynamic-link))
              (list '* '* ffi:unsigned-long))))
    (lambda (dest src n)
      (let ((~dest (unwrap-gchar* dest))
            (~src (unwrap-gchar* src))
            (~n (unwrap~fixed n)))
        (wrap-gchar* (~f ~dest ~src ~n))))))
(export g_utf8_strncpy)

;; extern gchar *g_utf8_strchr(const gchar *p, gssize len, gunichar c);
;; ... failed.

;; extern gchar *g_utf8_strrchr(const gchar *p, gssize len, gunichar c);
;; ... failed.

;; extern gchar *g_utf8_strreverse(const gchar *str, gssize len);
;; ... failed.

;; extern gunichar2 *g_utf8_to_utf16(const gchar *str, glong len, glong *
;;     items_read, glong *items_written, GError **error);
(define g_utf8_to_utf16
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_utf8_to_utf16" (dynamic-link))
              (list '* ffi:long '* '* '*))))
    (lambda (str len items_read items_written error)
      (let ((~str (unwrap-gchar* str))
            (~len (unwrap-glong len))
            (~items_read (unwrap-glong* items_read))
            (~items_written (unwrap-glong* items_written))
            (~error (unwrap~pointer error)))
        (wrap-gunichar2*
          (~f ~str ~len ~items_read ~items_written ~error))))))
(export g_utf8_to_utf16)

;; extern gunichar *g_utf8_to_ucs4(const gchar *str, glong len, glong *
;;     items_read, glong *items_written, GError **error);
(define g_utf8_to_ucs4
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_utf8_to_ucs4" (dynamic-link))
              (list '* ffi:long '* '* '*))))
    (lambda (str len items_read items_written error)
      (let ((~str (unwrap-gchar* str))
            (~len (unwrap-glong len))
            (~items_read (unwrap-glong* items_read))
            (~items_written (unwrap-glong* items_written))
            (~error (unwrap~pointer error)))
        (wrap-gunichar*
          (~f ~str ~len ~items_read ~items_written ~error))))))
(export g_utf8_to_ucs4)

;; extern gunichar *g_utf8_to_ucs4_fast(const gchar *str, glong len, glong *
;;     items_written);
(define g_utf8_to_ucs4_fast
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_utf8_to_ucs4_fast"
                (dynamic-link))
              (list '* ffi:long '*))))
    (lambda (str len items_written)
      (let ((~str (unwrap-gchar* str))
            (~len (unwrap-glong len))
            (~items_written (unwrap-glong* items_written)))
        (wrap-gunichar* (~f ~str ~len ~items_written))))))
(export g_utf8_to_ucs4_fast)

;; extern gunichar *g_utf16_to_ucs4(const gunichar2 *str, glong len, glong *
;;     items_read, glong *items_written, GError **error);
(define g_utf16_to_ucs4
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_utf16_to_ucs4" (dynamic-link))
              (list '* ffi:long '* '* '*))))
    (lambda (str len items_read items_written error)
      (let ((~str (unwrap-gunichar2* str))
            (~len (unwrap-glong len))
            (~items_read (unwrap-glong* items_read))
            (~items_written (unwrap-glong* items_written))
            (~error (unwrap~pointer error)))
        (wrap-gunichar*
          (~f ~str ~len ~items_read ~items_written ~error))))))
(export g_utf16_to_ucs4)

;; extern gchar *g_utf16_to_utf8(const gunichar2 *str, glong len, glong *
;;     items_read, glong *items_written, GError **error);
(define g_utf16_to_utf8
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_utf16_to_utf8" (dynamic-link))
              (list '* ffi:long '* '* '*))))
    (lambda (str len items_read items_written error)
      (let ((~str (unwrap-gunichar2* str))
            (~len (unwrap-glong len))
            (~items_read (unwrap-glong* items_read))
            (~items_written (unwrap-glong* items_written))
            (~error (unwrap~pointer error)))
        (wrap-gchar*
          (~f ~str ~len ~items_read ~items_written ~error))))))
(export g_utf16_to_utf8)

;; extern gunichar2 *g_ucs4_to_utf16(const gunichar *str, glong len, glong *
;;     items_read, glong *items_written, GError **error);
(define g_ucs4_to_utf16
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_ucs4_to_utf16" (dynamic-link))
              (list '* ffi:long '* '* '*))))
    (lambda (str len items_read items_written error)
      (let ((~str (unwrap-gunichar* str))
            (~len (unwrap-glong len))
            (~items_read (unwrap-glong* items_read))
            (~items_written (unwrap-glong* items_written))
            (~error (unwrap~pointer error)))
        (wrap-gunichar2*
          (~f ~str ~len ~items_read ~items_written ~error))))))
(export g_ucs4_to_utf16)

;; extern gchar *g_ucs4_to_utf8(const gunichar *str, glong len, glong *
;;     items_read, glong *items_written, GError **error);
(define g_ucs4_to_utf8
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_ucs4_to_utf8" (dynamic-link))
              (list '* ffi:long '* '* '*))))
    (lambda (str len items_read items_written error)
      (let ((~str (unwrap-gunichar* str))
            (~len (unwrap-glong len))
            (~items_read (unwrap-glong* items_read))
            (~items_written (unwrap-glong* items_written))
            (~error (unwrap~pointer error)))
        (wrap-gchar*
          (~f ~str ~len ~items_read ~items_written ~error))))))
(export g_ucs4_to_utf8)

;; extern gint g_unichar_to_utf8(gunichar c, gchar *outbuf);
(define g_unichar_to_utf8
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_unichar_to_utf8" (dynamic-link))
              (list ffi:unsigned-int '*))))
    (lambda (c outbuf)
      (let ((~c (unwrap-gunichar c))
            (~outbuf (unwrap-gchar* outbuf)))
        (wrap-gint (~f ~c ~outbuf))))))
(export g_unichar_to_utf8)

;; extern gboolean g_utf8_validate(const gchar *str, gssize max_len, const 
;;     gchar **end);
;; ... failed.

;; extern gchar *g_utf8_strup(const gchar *str, gssize len);
;; ... failed.

;; extern gchar *g_utf8_strdown(const gchar *str, gssize len);
;; ... failed.

;; extern gchar *g_utf8_casefold(const gchar *str, gssize len);
;; ... failed.

;; typedef enum {
;;   G_NORMALIZE_DEFAULT,
;;   G_NORMALIZE_NFD = G_NORMALIZE_DEFAULT,
;;   G_NORMALIZE_DEFAULT_COMPOSE,
;;   G_NORMALIZE_NFC = G_NORMALIZE_DEFAULT_COMPOSE,
;;   G_NORMALIZE_ALL,
;;   G_NORMALIZE_NFKD = G_NORMALIZE_ALL,
;;   G_NORMALIZE_ALL_COMPOSE,
;;   G_NORMALIZE_NFKC = G_NORMALIZE_ALL_COMPOSE,
;; } GNormalizeMode;
(define-fh-enum GNormalizeMode
  '((G_NORMALIZE_DEFAULT . 0)
    (G_NORMALIZE_NFD . 0)
    (G_NORMALIZE_DEFAULT_COMPOSE . 1)
    (G_NORMALIZE_NFC . 1)
    (G_NORMALIZE_ALL . 2)
    (G_NORMALIZE_NFKD . 2)
    (G_NORMALIZE_ALL_COMPOSE . 3)
    (G_NORMALIZE_NFKC . 3))
  )

;; extern gchar *g_utf8_normalize(const gchar *str, gssize len, GNormalizeMode 
;;     mode);
;; ... failed.

;; extern gint g_utf8_collate(const gchar *str1, const gchar *str2);
(define g_utf8_collate
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_utf8_collate" (dynamic-link))
              (list '* '*))))
    (lambda (str1 str2)
      (let ((~str1 (unwrap-gchar* str1))
            (~str2 (unwrap-gchar* str2)))
        (wrap-gint (~f ~str1 ~str2))))))
(export g_utf8_collate)

;; extern gchar *g_utf8_collate_key(const gchar *str, gssize len);
;; ... failed.

;; extern gchar *g_utf8_collate_key_for_filename(const gchar *str, gssize len)
;;     ;
;; ... failed.

;; extern gchar *g_utf8_make_valid(const gchar *str, gssize len);
;; ... failed.

;; typedef struct _GString GString;
(define GString-desc void)
(define GString*-desc (bs:pointer (delay GString-desc)))
(define-fh-pointer-type GString* GString*-desc)

;; struct _GString {
;;   gchar *str;
;;   gsize len;
;;   gsize allocated_len;
;; };
(define struct-_GString-desc
  (bs:struct
    (list `(str ,(bs:pointer gchar*-desc))
          `(len ,unsigned-long)
          `(allocated_len ,unsigned-long))))
(export struct-_GString-desc)
(define-fh-compound-type/p struct-_GString struct-_GString-desc)
(set! GString-desc struct-_GString-desc)
(define-fh-compound-type GString GString-desc)

;; extern GString *g_string_new(const gchar *init);
(define g_string_new
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_string_new" (dynamic-link))
              (list '*))))
    (lambda (init)
      (let ((~init (unwrap-gchar* init)))
        (wrap-GString* (~f ~init))))))
(export g_string_new)

;; extern GString *g_string_new_len(const gchar *init, gssize len);
;; ... failed.

;; extern GString *g_string_sized_new(gsize dfl_size);
(define g_string_sized_new
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_string_sized_new"
                (dynamic-link))
              (list ffi:unsigned-long))))
    (lambda (dfl_size)
      (let ((~dfl_size (unwrap~fixed dfl_size)))
        (wrap-GString* (~f ~dfl_size))))))
(export g_string_sized_new)

;; extern gchar *g_string_free(GString *string, gboolean free_segment);
(define g_string_free
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_string_free" (dynamic-link))
              (list '* ffi:int))))
    (lambda (string free_segment)
      (let ((~string (unwrap-GString* string))
            (~free_segment (unwrap-gboolean free_segment)))
        (wrap-gchar* (~f ~string ~free_segment))))))
(export g_string_free)

;; extern GBytes *g_string_free_to_bytes(GString *string);
(define g_string_free_to_bytes
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_string_free_to_bytes"
                (dynamic-link))
              (list '*))))
    (lambda (string)
      (let ((~string (unwrap-GString* string)))
        (wrap-GBytes* (~f ~string))))))
(export g_string_free_to_bytes)

;; extern gboolean g_string_equal(const GString *v, const GString *v2);
(define g_string_equal
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_string_equal" (dynamic-link))
              (list '* '*))))
    (lambda (v v2)
      (let ((~v (unwrap-GString* v))
            (~v2 (unwrap-GString* v2)))
        (wrap-gboolean (~f ~v ~v2))))))
(export g_string_equal)

;; extern guint g_string_hash(const GString *str);
(define g_string_hash
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func "g_string_hash" (dynamic-link))
              (list '*))))
    (lambda (str)
      (let ((~str (unwrap-GString* str)))
        (wrap-guint (~f ~str))))))
(export g_string_hash)

;; extern GString *g_string_assign(GString *string, const gchar *rval);
(define g_string_assign
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_string_assign" (dynamic-link))
              (list '* '*))))
    (lambda (string rval)
      (let ((~string (unwrap-GString* string))
            (~rval (unwrap-gchar* rval)))
        (wrap-GString* (~f ~string ~rval))))))
(export g_string_assign)

;; extern GString *g_string_truncate(GString *string, gsize len);
(define g_string_truncate
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_string_truncate" (dynamic-link))
              (list '* ffi:unsigned-long))))
    (lambda (string len)
      (let ((~string (unwrap-GString* string))
            (~len (unwrap~fixed len)))
        (wrap-GString* (~f ~string ~len))))))
(export g_string_truncate)

;; extern GString *g_string_set_size(GString *string, gsize len);
(define g_string_set_size
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_string_set_size" (dynamic-link))
              (list '* ffi:unsigned-long))))
    (lambda (string len)
      (let ((~string (unwrap-GString* string))
            (~len (unwrap~fixed len)))
        (wrap-GString* (~f ~string ~len))))))
(export g_string_set_size)

;; extern GString *g_string_insert_len(GString *string, gssize pos, const gchar
;;      *val, gssize len);
;; ... failed.

;; extern GString *g_string_append(GString *string, const gchar *val);
(define g_string_append
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_string_append" (dynamic-link))
              (list '* '*))))
    (lambda (string val)
      (let ((~string (unwrap-GString* string))
            (~val (unwrap-gchar* val)))
        (wrap-GString* (~f ~string ~val))))))
(export g_string_append)

;; extern GString *g_string_append_len(GString *string, const gchar *val, 
;;     gssize len);
;; ... failed.

;; extern GString *g_string_append_c(GString *string, gchar c);
(define g_string_append_c
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_string_append_c" (dynamic-link))
              (list '* ffi:int))))
    (lambda (string c)
      (let ((~string (unwrap-GString* string))
            (~c (unwrap-gchar c)))
        (wrap-GString* (~f ~string ~c))))))
(export g_string_append_c)

;; extern GString *g_string_append_unichar(GString *string, gunichar wc);
(define g_string_append_unichar
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_string_append_unichar"
                (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (string wc)
      (let ((~string (unwrap-GString* string))
            (~wc (unwrap-gunichar wc)))
        (wrap-GString* (~f ~string ~wc))))))
(export g_string_append_unichar)

;; extern GString *g_string_prepend(GString *string, const gchar *val);
(define g_string_prepend
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_string_prepend" (dynamic-link))
              (list '* '*))))
    (lambda (string val)
      (let ((~string (unwrap-GString* string))
            (~val (unwrap-gchar* val)))
        (wrap-GString* (~f ~string ~val))))))
(export g_string_prepend)

;; extern GString *g_string_prepend_c(GString *string, gchar c);
(define g_string_prepend_c
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_string_prepend_c"
                (dynamic-link))
              (list '* ffi:int))))
    (lambda (string c)
      (let ((~string (unwrap-GString* string))
            (~c (unwrap-gchar c)))
        (wrap-GString* (~f ~string ~c))))))
(export g_string_prepend_c)

;; extern GString *g_string_prepend_unichar(GString *string, gunichar wc);
(define g_string_prepend_unichar
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_string_prepend_unichar"
                (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (string wc)
      (let ((~string (unwrap-GString* string))
            (~wc (unwrap-gunichar wc)))
        (wrap-GString* (~f ~string ~wc))))))
(export g_string_prepend_unichar)

;; extern GString *g_string_prepend_len(GString *string, const gchar *val, 
;;     gssize len);
;; ... failed.

;; extern GString *g_string_insert(GString *string, gssize pos, const gchar *
;;     val);
;; ... failed.

;; extern GString *g_string_insert_c(GString *string, gssize pos, gchar c);
;; ... failed.

;; extern GString *g_string_insert_unichar(GString *string, gssize pos, 
;;     gunichar wc);
;; ... failed.

;; extern GString *g_string_overwrite(GString *string, gsize pos, const gchar *
;;     val);
(define g_string_overwrite
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_string_overwrite"
                (dynamic-link))
              (list '* ffi:unsigned-long '*))))
    (lambda (string pos val)
      (let ((~string (unwrap-GString* string))
            (~pos (unwrap~fixed pos))
            (~val (unwrap-gchar* val)))
        (wrap-GString* (~f ~string ~pos ~val))))))
(export g_string_overwrite)

;; extern GString *g_string_overwrite_len(GString *string, gsize pos, const 
;;     gchar *val, gssize len);
;; ... failed.

;; extern GString *g_string_erase(GString *string, gssize pos, gssize len);
;; ... failed.

;; extern GString *g_string_ascii_down(GString *string);
(define g_string_ascii_down
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_string_ascii_down"
                (dynamic-link))
              (list '*))))
    (lambda (string)
      (let ((~string (unwrap-GString* string)))
        (wrap-GString* (~f ~string))))))
(export g_string_ascii_down)

;; extern GString *g_string_ascii_up(GString *string);
(define g_string_ascii_up
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_string_ascii_up" (dynamic-link))
              (list '*))))
    (lambda (string)
      (let ((~string (unwrap-GString* string)))
        (wrap-GString* (~f ~string))))))
(export g_string_ascii_up)

;; extern void g_string_vprintf(GString *string, const gchar *format, va_list 
;;     args);
(define g_string_vprintf
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_string_vprintf" (dynamic-link))
              (list '* '* '*))))
    (lambda (string format args)
      (let ((~string (unwrap-GString* string))
            (~format (unwrap-gchar* format))
            (~args (unwrap~pointer args)))
        (~f ~string ~format ~args)))))
(export g_string_vprintf)

;; extern void g_string_printf(GString *string, const gchar *format, ...);
;; ... failed.

;; extern void g_string_append_vprintf(GString *string, const gchar *format, 
;;     va_list args);
(define g_string_append_vprintf
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_string_append_vprintf"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (string format args)
      (let ((~string (unwrap-GString* string))
            (~format (unwrap-gchar* format))
            (~args (unwrap~pointer args)))
        (~f ~string ~format ~args)))))
(export g_string_append_vprintf)

;; extern void g_string_append_printf(GString *string, const gchar *format, ...
;;     );
;; ... failed.

;; extern GString *g_string_append_uri_escaped(GString *string, const gchar *
;;     unescaped, const gchar *reserved_chars_allowed, gboolean allow_utf8);
(define g_string_append_uri_escaped
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_string_append_uri_escaped"
                (dynamic-link))
              (list '* '* '* ffi:int))))
    (lambda (string
             unescaped
             reserved_chars_allowed
             allow_utf8)
      (let ((~string (unwrap-GString* string))
            (~unescaped (unwrap-gchar* unescaped))
            (~reserved_chars_allowed
              (unwrap-gchar* reserved_chars_allowed))
            (~allow_utf8 (unwrap-gboolean allow_utf8)))
        (wrap-GString*
          (~f ~string
              ~unescaped
              ~reserved_chars_allowed
              ~allow_utf8))))))
(export g_string_append_uri_escaped)

;; extern GString *g_string_down(GString *string);
(define g_string_down
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_string_down" (dynamic-link))
              (list '*))))
    (lambda (string)
      (let ((~string (unwrap-GString* string)))
        (wrap-GString* (~f ~string))))))
(export g_string_down)

;; extern GString *g_string_up(GString *string);
(define g_string_up
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_string_up" (dynamic-link))
              (list '*))))
    (lambda (string)
      (let ((~string (unwrap-GString* string)))
        (wrap-GString* (~f ~string))))))
(export g_string_up)

;; typedef struct _GIOChannel GIOChannel;
(define GIOChannel-desc void)
(define GIOChannel*-desc (bs:pointer (delay GIOChannel-desc)))
(define-fh-pointer-type GIOChannel* GIOChannel*-desc)

;; typedef struct _GIOFuncs GIOFuncs;
(define GIOFuncs-desc void)
(define GIOFuncs*-desc (bs:pointer (delay GIOFuncs-desc)))
(define-fh-pointer-type GIOFuncs* GIOFuncs*-desc)

;; typedef enum {
;;   G_IO_ERROR_NONE,
;;   G_IO_ERROR_AGAIN,
;;   G_IO_ERROR_INVAL,
;;   G_IO_ERROR_UNKNOWN,
;; } GIOError;
(define-fh-enum GIOError
  '((G_IO_ERROR_NONE . 0)
    (G_IO_ERROR_AGAIN . 1)
    (G_IO_ERROR_INVAL . 2)
    (G_IO_ERROR_UNKNOWN . 3))
  )

;; typedef enum {
;;   G_IO_CHANNEL_ERROR_FBIG,
;;   G_IO_CHANNEL_ERROR_INVAL,
;;   G_IO_CHANNEL_ERROR_IO,
;;   G_IO_CHANNEL_ERROR_ISDIR,
;;   G_IO_CHANNEL_ERROR_NOSPC,
;;   G_IO_CHANNEL_ERROR_NXIO,
;;   G_IO_CHANNEL_ERROR_OVERFLOW,
;;   G_IO_CHANNEL_ERROR_PIPE,
;;   G_IO_CHANNEL_ERROR_FAILED,
;; } GIOChannelError;
(define-fh-enum GIOChannelError
  '((G_IO_CHANNEL_ERROR_FBIG . 0)
    (G_IO_CHANNEL_ERROR_INVAL . 1)
    (G_IO_CHANNEL_ERROR_IO . 2)
    (G_IO_CHANNEL_ERROR_ISDIR . 3)
    (G_IO_CHANNEL_ERROR_NOSPC . 4)
    (G_IO_CHANNEL_ERROR_NXIO . 5)
    (G_IO_CHANNEL_ERROR_OVERFLOW . 6)
    (G_IO_CHANNEL_ERROR_PIPE . 7)
    (G_IO_CHANNEL_ERROR_FAILED . 8))
  )

;; typedef enum {
;;   G_IO_STATUS_ERROR,
;;   G_IO_STATUS_NORMAL,
;;   G_IO_STATUS_EOF,
;;   G_IO_STATUS_AGAIN,
;; } GIOStatus;
(define-fh-enum GIOStatus
  '((G_IO_STATUS_ERROR . 0)
    (G_IO_STATUS_NORMAL . 1)
    (G_IO_STATUS_EOF . 2)
    (G_IO_STATUS_AGAIN . 3))
  )

;; typedef enum {
;;   G_SEEK_CUR,
;;   G_SEEK_SET,
;;   G_SEEK_END,
;; } GSeekType;
(define-fh-enum GSeekType
  '((G_SEEK_CUR . 0)
    (G_SEEK_SET . 1)
    (G_SEEK_END . 2))
  )

;; typedef enum {
;;   G_IO_FLAG_APPEND = 1<<0,
;;   G_IO_FLAG_NONBLOCK = 1<<1,
;;   G_IO_FLAG_IS_READABLE = 1<<2,
;;   G_IO_FLAG_IS_WRITABLE = 1<<3,
;;   G_IO_FLAG_IS_WRITEABLE = 1<<3,
;;   G_IO_FLAG_IS_SEEKABLE = 1<<4,
;;   G_IO_FLAG_MASK = (1<<5) - 1,
;;   G_IO_FLAG_GET_MASK = G_IO_FLAG_MASK,
;;   G_IO_FLAG_SET_MASK = G_IO_FLAG_APPEND | G_IO_FLAG_NONBLOCK,
;; } GIOFlags;
(define-fh-enum GIOFlags
  '((G_IO_FLAG_APPEND . 1)
    (G_IO_FLAG_NONBLOCK . 2)
    (G_IO_FLAG_IS_READABLE . 4)
    (G_IO_FLAG_IS_WRITABLE . 8)
    (G_IO_FLAG_IS_WRITEABLE . 8)
    (G_IO_FLAG_IS_SEEKABLE . 16)
    (G_IO_FLAG_MASK . 31)
    (G_IO_FLAG_GET_MASK . 31)
    (G_IO_FLAG_SET_MASK . 3))
  )

;; struct _GIOChannel {
;;   /*< private >*/
;;   gint ref_count;
;;   GIOFuncs *funcs;
;;   gchar *encoding;
;;   GIConv read_cd;
;;   GIConv write_cd;
;;   gchar *line_term; /* String which indicates the end of a line of text */
;;   guint line_term_len; /* So we can have null in the line term */
;;   gsize buf_size;
;;   GString *read_buf; /* Raw data from the channel */
;;   GString *encoded_read_buf; /* Channel data converted to UTF-8 */
;;   GString *write_buf; /* Data ready to be written to the file */
;;   gchar partial_write_buf[6]; 
;;       /* UTF-8 partial characters, null terminated */
;;   /* Group the flags together, immediately after partial_write_buf, to save memory */
;;       
;;   guint use_buffer : 1; /* The encoding uses the buffers */
;;   guint do_encode : 1; /* The encoding uses the GIConv coverters */
;;   guint close_on_unref : 1; /* Close the channel on final unref */
;;   guint is_readable : 1; /* Cached GIOFlag */
;;   guint is_writeable : 1; /* ditto */
;;   guint is_seekable : 1; /* ditto */
;;   gpointer reserved1;
;;   gpointer reserved2;
;; };
(define struct-_GIOChannel-desc
  (bs:struct
    (list `(ref_count ,gint-desc)
          `(funcs ,(bs:pointer GIOFuncs*-desc))
          `(encoding ,(bs:pointer gchar*-desc))
          `(read_cd ,(bs:pointer void))
          `(write_cd ,(bs:pointer void))
          `(line_term ,(bs:pointer gchar*-desc))
          `(line_term_len ,guint-desc)
          `(buf_size ,unsigned-long)
          `(read_buf ,(bs:pointer GString*-desc))
          `(encoded_read_buf ,(bs:pointer GString*-desc))
          `(write_buf ,(bs:pointer GString*-desc))
          `(partial_write_buf ,(bs:vector 6 gchar-desc))
          `(use_buffer ,guint-desc)
          `(do_encode ,guint-desc)
          `(close_on_unref ,guint-desc)
          `(is_readable ,guint-desc)
          `(is_writeable ,guint-desc)
          `(is_seekable ,guint-desc)
          `(reserved1 ,gpointer-desc)
          `(reserved2 ,gpointer-desc))))
(export struct-_GIOChannel-desc)
(define-fh-compound-type/p struct-_GIOChannel struct-_GIOChannel-desc)
(set! GIOChannel-desc struct-_GIOChannel-desc)
(define-fh-compound-type GIOChannel GIOChannel-desc)

;; typedef gboolean (*GIOFunc)(GIOChannel *source, GIOCondition condition, 
;;     gpointer data);
(define-fh-function/p GIOFunc
  ffi:int (list (quote *) ffi:int (quote *)))

;; struct _GIOFuncs {
;;   GIOStatus (*io_read)(GIOChannel *channel, gchar *buf, gsize count, gsize *
;;       bytes_read, GError **err);
;;   GIOStatus (*io_write)(GIOChannel *channel, const gchar *buf, gsize count, 
;;       gsize *bytes_written, GError **err);
;;   GIOStatus (*io_seek)(GIOChannel *channel, gint64 offset, GSeekType type, 
;;       GError **err);
;;   GIOStatus (*io_close)(GIOChannel *channel, GError **err);
;;   GSource *(*io_create_watch)(GIOChannel *channel, GIOCondition condition);
;;   void (*io_free)(GIOChannel *channel);
;;   GIOStatus (*io_set_flags)(GIOChannel *channel, GIOFlags flags, GError **
;;       err);
;;   GIOFlags (*io_get_flags)(GIOChannel *channel);
;; };
(define struct-_GIOFuncs-desc
  (bs:struct
    (list `(io_read ,(bs:pointer void))
          `(io_write ,(bs:pointer void))
          `(io_seek ,(bs:pointer void))
          `(io_close ,(bs:pointer void))
          `(io_create_watch ,(bs:pointer void))
          `(io_free ,(bs:pointer void))
          `(io_set_flags ,(bs:pointer void))
          `(io_get_flags ,(bs:pointer void)))))
(export struct-_GIOFuncs-desc)
(define-fh-compound-type/p struct-_GIOFuncs struct-_GIOFuncs-desc)
(set! GIOFuncs-desc struct-_GIOFuncs-desc)
(define-fh-compound-type GIOFuncs GIOFuncs-desc)

;; extern void g_io_channel_init(GIOChannel *channel);
(define g_io_channel_init
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_io_channel_init" (dynamic-link))
              (list '*))))
    (lambda (channel)
      (let ((~channel (unwrap-GIOChannel* channel)))
        (~f ~channel)))))
(export g_io_channel_init)

;; extern GIOChannel *g_io_channel_ref(GIOChannel *channel);
(define g_io_channel_ref
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_io_channel_ref" (dynamic-link))
              (list '*))))
    (lambda (channel)
      (let ((~channel (unwrap-GIOChannel* channel)))
        (wrap-GIOChannel* (~f ~channel))))))
(export g_io_channel_ref)

;; extern void g_io_channel_unref(GIOChannel *channel);
(define g_io_channel_unref
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_io_channel_unref"
                (dynamic-link))
              (list '*))))
    (lambda (channel)
      (let ((~channel (unwrap-GIOChannel* channel)))
        (~f ~channel)))))
(export g_io_channel_unref)

;; extern GIOError g_io_channel_read(GIOChannel *channel, gchar *buf, gsize 
;;     count, gsize *bytes_read);
(define g_io_channel_read
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_io_channel_read" (dynamic-link))
              (list '* '* ffi:unsigned-long '*))))
    (lambda (channel buf count bytes_read)
      (let ((~channel (unwrap-GIOChannel* channel))
            (~buf (unwrap-gchar* buf))
            (~count (unwrap~fixed count))
            (~bytes_read (unwrap~pointer bytes_read)))
        (~f ~channel ~buf ~count ~bytes_read)))))
(export g_io_channel_read)

;; extern GIOError g_io_channel_write(GIOChannel *channel, const gchar *buf, 
;;     gsize count, gsize *bytes_written);
(define g_io_channel_write
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_io_channel_write"
                (dynamic-link))
              (list '* '* ffi:unsigned-long '*))))
    (lambda (channel buf count bytes_written)
      (let ((~channel (unwrap-GIOChannel* channel))
            (~buf (unwrap-gchar* buf))
            (~count (unwrap~fixed count))
            (~bytes_written (unwrap~pointer bytes_written)))
        (~f ~channel ~buf ~count ~bytes_written)))))
(export g_io_channel_write)

;; extern GIOError g_io_channel_seek(GIOChannel *channel, gint64 offset, 
;;     GSeekType type);
;; ... failed.

;; extern void g_io_channel_close(GIOChannel *channel);
(define g_io_channel_close
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_io_channel_close"
                (dynamic-link))
              (list '*))))
    (lambda (channel)
      (let ((~channel (unwrap-GIOChannel* channel)))
        (~f ~channel)))))
(export g_io_channel_close)

;; extern GIOStatus g_io_channel_shutdown(GIOChannel *channel, gboolean flush, 
;;     GError **err);
(define g_io_channel_shutdown
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_io_channel_shutdown"
                (dynamic-link))
              (list '* ffi:int '*))))
    (lambda (channel flush err)
      (let ((~channel (unwrap-GIOChannel* channel))
            (~flush (unwrap-gboolean flush))
            (~err (unwrap~pointer err)))
        (~f ~channel ~flush ~err)))))
(export g_io_channel_shutdown)

;; extern guint g_io_add_watch_full(GIOChannel *channel, gint priority, 
;;     GIOCondition condition, GIOFunc func, gpointer user_data, GDestroyNotify
;;      notify);
;; ... failed.

;; extern GSource *g_io_create_watch(GIOChannel *channel, GIOCondition 
;;     condition);
(define g_io_create_watch
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_io_create_watch" (dynamic-link))
              (list '* ffi:int))))
    (lambda (channel condition)
      (let ((~channel (unwrap-GIOChannel* channel))
            (~condition (unwrap~fixed condition)))
        (wrap-GSource* (~f ~channel ~condition))))))
(export g_io_create_watch)

;; extern guint g_io_add_watch(GIOChannel *channel, GIOCondition condition, 
;;     GIOFunc func, gpointer user_data);
;; ... failed.

;; extern void g_io_channel_set_buffer_size(GIOChannel *channel, gsize size);
(define g_io_channel_set_buffer_size
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_io_channel_set_buffer_size"
                (dynamic-link))
              (list '* ffi:unsigned-long))))
    (lambda (channel size)
      (let ((~channel (unwrap-GIOChannel* channel))
            (~size (unwrap~fixed size)))
        (~f ~channel ~size)))))
(export g_io_channel_set_buffer_size)

;; extern gsize g_io_channel_get_buffer_size(GIOChannel *channel);
(define g_io_channel_get_buffer_size
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-long
              (dynamic-func
                "g_io_channel_get_buffer_size"
                (dynamic-link))
              (list '*))))
    (lambda (channel)
      (let ((~channel (unwrap-GIOChannel* channel)))
        (~f ~channel)))))
(export g_io_channel_get_buffer_size)

;; extern GIOCondition g_io_channel_get_buffer_condition(GIOChannel *channel);
(define g_io_channel_get_buffer_condition
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_io_channel_get_buffer_condition"
                (dynamic-link))
              (list '*))))
    (lambda (channel)
      (let ((~channel (unwrap-GIOChannel* channel)))
        (~f ~channel)))))
(export g_io_channel_get_buffer_condition)

;; extern GIOStatus g_io_channel_set_flags(GIOChannel *channel, GIOFlags flags
;;     , GError **error);
(define g_io_channel_set_flags
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_io_channel_set_flags"
                (dynamic-link))
              (list '* ffi:int '*))))
    (lambda (channel flags error)
      (let ((~channel (unwrap-GIOChannel* channel))
            (~flags (unwrap~fixed flags))
            (~error (unwrap~pointer error)))
        (~f ~channel ~flags ~error)))))
(export g_io_channel_set_flags)

;; extern GIOFlags g_io_channel_get_flags(GIOChannel *channel);
(define g_io_channel_get_flags
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_io_channel_get_flags"
                (dynamic-link))
              (list '*))))
    (lambda (channel)
      (let ((~channel (unwrap-GIOChannel* channel)))
        (~f ~channel)))))
(export g_io_channel_get_flags)

;; extern void g_io_channel_set_line_term(GIOChannel *channel, const gchar *
;;     line_term, gint length);
(define g_io_channel_set_line_term
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_io_channel_set_line_term"
                (dynamic-link))
              (list '* '* ffi:int))))
    (lambda (channel line_term length)
      (let ((~channel (unwrap-GIOChannel* channel))
            (~line_term (unwrap-gchar* line_term))
            (~length (unwrap-gint length)))
        (~f ~channel ~line_term ~length)))))
(export g_io_channel_set_line_term)

;; extern const gchar *g_io_channel_get_line_term(GIOChannel *channel, gint *
;;     length);
(define g_io_channel_get_line_term
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_io_channel_get_line_term"
                (dynamic-link))
              (list '* '*))))
    (lambda (channel length)
      (let ((~channel (unwrap-GIOChannel* channel))
            (~length (unwrap-gint* length)))
        (wrap-gchar* (~f ~channel ~length))))))
(export g_io_channel_get_line_term)

;; extern void g_io_channel_set_buffered(GIOChannel *channel, gboolean buffered
;;     );
(define g_io_channel_set_buffered
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_io_channel_set_buffered"
                (dynamic-link))
              (list '* ffi:int))))
    (lambda (channel buffered)
      (let ((~channel (unwrap-GIOChannel* channel))
            (~buffered (unwrap-gboolean buffered)))
        (~f ~channel ~buffered)))))
(export g_io_channel_set_buffered)

;; extern gboolean g_io_channel_get_buffered(GIOChannel *channel);
(define g_io_channel_get_buffered
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_io_channel_get_buffered"
                (dynamic-link))
              (list '*))))
    (lambda (channel)
      (let ((~channel (unwrap-GIOChannel* channel)))
        (wrap-gboolean (~f ~channel))))))
(export g_io_channel_get_buffered)

;; extern GIOStatus g_io_channel_set_encoding(GIOChannel *channel, const gchar 
;;     *encoding, GError **error);
(define g_io_channel_set_encoding
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_io_channel_set_encoding"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (channel encoding error)
      (let ((~channel (unwrap-GIOChannel* channel))
            (~encoding (unwrap-gchar* encoding))
            (~error (unwrap~pointer error)))
        (~f ~channel ~encoding ~error)))))
(export g_io_channel_set_encoding)

;; extern const gchar *g_io_channel_get_encoding(GIOChannel *channel);
(define g_io_channel_get_encoding
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_io_channel_get_encoding"
                (dynamic-link))
              (list '*))))
    (lambda (channel)
      (let ((~channel (unwrap-GIOChannel* channel)))
        (wrap-gchar* (~f ~channel))))))
(export g_io_channel_get_encoding)

;; extern void g_io_channel_set_close_on_unref(GIOChannel *channel, gboolean 
;;     do_close);
(define g_io_channel_set_close_on_unref
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_io_channel_set_close_on_unref"
                (dynamic-link))
              (list '* ffi:int))))
    (lambda (channel do_close)
      (let ((~channel (unwrap-GIOChannel* channel))
            (~do_close (unwrap-gboolean do_close)))
        (~f ~channel ~do_close)))))
(export g_io_channel_set_close_on_unref)

;; extern gboolean g_io_channel_get_close_on_unref(GIOChannel *channel);
(define g_io_channel_get_close_on_unref
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_io_channel_get_close_on_unref"
                (dynamic-link))
              (list '*))))
    (lambda (channel)
      (let ((~channel (unwrap-GIOChannel* channel)))
        (wrap-gboolean (~f ~channel))))))
(export g_io_channel_get_close_on_unref)

;; extern GIOStatus g_io_channel_flush(GIOChannel *channel, GError **error);
(define g_io_channel_flush
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_io_channel_flush"
                (dynamic-link))
              (list '* '*))))
    (lambda (channel error)
      (let ((~channel (unwrap-GIOChannel* channel))
            (~error (unwrap~pointer error)))
        (~f ~channel ~error)))))
(export g_io_channel_flush)

;; extern GIOStatus g_io_channel_read_line(GIOChannel *channel, gchar **
;;     str_return, gsize *length, gsize *terminator_pos, GError **error);
(define g_io_channel_read_line
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_io_channel_read_line"
                (dynamic-link))
              (list '* '* '* '* '*))))
    (lambda (channel str_return length terminator_pos error)
      (let ((~channel (unwrap-GIOChannel* channel))
            (~str_return (unwrap~pointer str_return))
            (~length (unwrap~pointer length))
            (~terminator_pos (unwrap~pointer terminator_pos))
            (~error (unwrap~pointer error)))
        (~f ~channel
            ~str_return
            ~length
            ~terminator_pos
            ~error)))))
(export g_io_channel_read_line)

;; extern GIOStatus g_io_channel_read_line_string(GIOChannel *channel, GString 
;;     *buffer, gsize *terminator_pos, GError **error);
(define g_io_channel_read_line_string
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_io_channel_read_line_string"
                (dynamic-link))
              (list '* '* '* '*))))
    (lambda (channel buffer terminator_pos error)
      (let ((~channel (unwrap-GIOChannel* channel))
            (~buffer (unwrap-GString* buffer))
            (~terminator_pos (unwrap~pointer terminator_pos))
            (~error (unwrap~pointer error)))
        (~f ~channel ~buffer ~terminator_pos ~error)))))
(export g_io_channel_read_line_string)

;; extern GIOStatus g_io_channel_read_to_end(GIOChannel *channel, gchar **
;;     str_return, gsize *length, GError **error);
(define g_io_channel_read_to_end
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_io_channel_read_to_end"
                (dynamic-link))
              (list '* '* '* '*))))
    (lambda (channel str_return length error)
      (let ((~channel (unwrap-GIOChannel* channel))
            (~str_return (unwrap~pointer str_return))
            (~length (unwrap~pointer length))
            (~error (unwrap~pointer error)))
        (~f ~channel ~str_return ~length ~error)))))
(export g_io_channel_read_to_end)

;; extern GIOStatus g_io_channel_read_chars(GIOChannel *channel, gchar *buf, 
;;     gsize count, gsize *bytes_read, GError **error);
(define g_io_channel_read_chars
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_io_channel_read_chars"
                (dynamic-link))
              (list '* '* ffi:unsigned-long '* '*))))
    (lambda (channel buf count bytes_read error)
      (let ((~channel (unwrap-GIOChannel* channel))
            (~buf (unwrap-gchar* buf))
            (~count (unwrap~fixed count))
            (~bytes_read (unwrap~pointer bytes_read))
            (~error (unwrap~pointer error)))
        (~f ~channel ~buf ~count ~bytes_read ~error)))))
(export g_io_channel_read_chars)

;; extern GIOStatus g_io_channel_read_unichar(GIOChannel *channel, gunichar *
;;     thechar, GError **error);
(define g_io_channel_read_unichar
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_io_channel_read_unichar"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (channel thechar error)
      (let ((~channel (unwrap-GIOChannel* channel))
            (~thechar (unwrap-gunichar* thechar))
            (~error (unwrap~pointer error)))
        (~f ~channel ~thechar ~error)))))
(export g_io_channel_read_unichar)

;; extern GIOStatus g_io_channel_write_chars(GIOChannel *channel, const gchar *
;;     buf, gssize count, gsize *bytes_written, GError **error);
;; ... failed.

;; extern GIOStatus g_io_channel_write_unichar(GIOChannel *channel, gunichar 
;;     thechar, GError **error);
(define g_io_channel_write_unichar
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_io_channel_write_unichar"
                (dynamic-link))
              (list '* ffi:unsigned-int '*))))
    (lambda (channel thechar error)
      (let ((~channel (unwrap-GIOChannel* channel))
            (~thechar (unwrap-gunichar thechar))
            (~error (unwrap~pointer error)))
        (~f ~channel ~thechar ~error)))))
(export g_io_channel_write_unichar)

;; extern GIOStatus g_io_channel_seek_position(GIOChannel *channel, gint64 
;;     offset, GSeekType type, GError **error);
;; ... failed.

;; extern GIOChannel *g_io_channel_new_file(const gchar *filename, const gchar 
;;     *mode, GError **error);
(define g_io_channel_new_file
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_io_channel_new_file"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (filename mode error)
      (let ((~filename (unwrap-gchar* filename))
            (~mode (unwrap-gchar* mode))
            (~error (unwrap~pointer error)))
        (wrap-GIOChannel* (~f ~filename ~mode ~error))))))
(export g_io_channel_new_file)

;; extern GQuark g_io_channel_error_quark(void);
(define g_io_channel_error_quark
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func
                "g_io_channel_error_quark"
                (dynamic-link))
              (list))))
    (lambda () (let () (wrap-GQuark (~f))))))
(export g_io_channel_error_quark)

;; extern GIOChannelError g_io_channel_error_from_errno(gint en);
(define g_io_channel_error_from_errno
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_io_channel_error_from_errno"
                (dynamic-link))
              (list ffi:int))))
    (lambda (en)
      (let ((~en (unwrap-gint en))) (~f ~en)))))
(export g_io_channel_error_from_errno)

;; extern GIOChannel *g_io_channel_unix_new(int fd);
(define g_io_channel_unix_new
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_io_channel_unix_new"
                (dynamic-link))
              (list ffi:int))))
    (lambda (fd)
      (let ((~fd (unwrap~fixed fd)))
        (wrap-GIOChannel* (~f ~fd))))))
(export g_io_channel_unix_new)

;; extern gint g_io_channel_unix_get_fd(GIOChannel *channel);
(define g_io_channel_unix_get_fd
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_io_channel_unix_get_fd"
                (dynamic-link))
              (list '*))))
    (lambda (channel)
      (let ((~channel (unwrap-GIOChannel* channel)))
        (wrap-gint (~f ~channel))))))
(export g_io_channel_unix_get_fd)

;; extern GSourceFuncs g_io_watch_funcs;
(define g_io_watch_funcs
  (let* ((addr (dynamic-pointer
                 "g_io_watch_funcs"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (sizeof '*))
                0
                (bs:pointer GSourceFuncs-desc))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_io_watch_funcs)

;; typedef enum {
;;   G_KEY_FILE_ERROR_UNKNOWN_ENCODING,
;;   G_KEY_FILE_ERROR_PARSE,
;;   G_KEY_FILE_ERROR_NOT_FOUND,
;;   G_KEY_FILE_ERROR_KEY_NOT_FOUND,
;;   G_KEY_FILE_ERROR_GROUP_NOT_FOUND,
;;   G_KEY_FILE_ERROR_INVALID_VALUE,
;; } GKeyFileError;
(define-fh-enum GKeyFileError
  '((G_KEY_FILE_ERROR_UNKNOWN_ENCODING . 0)
    (G_KEY_FILE_ERROR_PARSE . 1)
    (G_KEY_FILE_ERROR_NOT_FOUND . 2)
    (G_KEY_FILE_ERROR_KEY_NOT_FOUND . 3)
    (G_KEY_FILE_ERROR_GROUP_NOT_FOUND . 4)
    (G_KEY_FILE_ERROR_INVALID_VALUE . 5))
  )

;; extern GQuark g_key_file_error_quark(void);
(define g_key_file_error_quark
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func
                "g_key_file_error_quark"
                (dynamic-link))
              (list))))
    (lambda () (let () (wrap-GQuark (~f))))))
(export g_key_file_error_quark)

;; typedef struct _GKeyFile GKeyFile;
(define GKeyFile-desc void)
(define GKeyFile*-desc (bs:pointer GKeyFile-desc))
(define-fh-pointer-type GKeyFile* GKeyFile*-desc)

;; typedef enum {
;;   G_KEY_FILE_NONE = 0,
;;   G_KEY_FILE_KEEP_COMMENTS = 1<<0,
;;   G_KEY_FILE_KEEP_TRANSLATIONS = 1<<1,
;; } GKeyFileFlags;
(define-fh-enum GKeyFileFlags
  '((G_KEY_FILE_NONE . 0)
    (G_KEY_FILE_KEEP_COMMENTS . 1)
    (G_KEY_FILE_KEEP_TRANSLATIONS . 2))
  )

;; extern GKeyFile *g_key_file_new(void);
(define g_key_file_new
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_key_file_new" (dynamic-link))
              (list))))
    (lambda () (let () (wrap-GKeyFile* (~f))))))
(export g_key_file_new)

;; extern GKeyFile *g_key_file_ref(GKeyFile *key_file);
(define g_key_file_ref
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_key_file_ref" (dynamic-link))
              (list '*))))
    (lambda (key_file)
      (let ((~key_file (unwrap-GKeyFile* key_file)))
        (wrap-GKeyFile* (~f ~key_file))))))
(export g_key_file_ref)

;; extern void g_key_file_unref(GKeyFile *key_file);
(define g_key_file_unref
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_key_file_unref" (dynamic-link))
              (list '*))))
    (lambda (key_file)
      (let ((~key_file (unwrap-GKeyFile* key_file)))
        (~f ~key_file)))))
(export g_key_file_unref)

;; extern void g_key_file_free(GKeyFile *key_file);
(define g_key_file_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_key_file_free" (dynamic-link))
              (list '*))))
    (lambda (key_file)
      (let ((~key_file (unwrap-GKeyFile* key_file)))
        (~f ~key_file)))))
(export g_key_file_free)

;; extern void g_key_file_set_list_separator(GKeyFile *key_file, gchar 
;;     separator);
(define g_key_file_set_list_separator
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_key_file_set_list_separator"
                (dynamic-link))
              (list '* ffi:int))))
    (lambda (key_file separator)
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~separator (unwrap-gchar separator)))
        (~f ~key_file ~separator)))))
(export g_key_file_set_list_separator)

;; extern gboolean g_key_file_load_from_file(GKeyFile *key_file, const gchar *
;;     file, GKeyFileFlags flags, GError **error);
(define g_key_file_load_from_file
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_key_file_load_from_file"
                (dynamic-link))
              (list '* '* ffi:int '*))))
    (lambda (key_file file flags error)
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~file (unwrap-gchar* file))
            (~flags (unwrap~fixed flags))
            (~error (unwrap~pointer error)))
        (wrap-gboolean
          (~f ~key_file ~file ~flags ~error))))))
(export g_key_file_load_from_file)

;; extern gboolean g_key_file_load_from_data(GKeyFile *key_file, const gchar *
;;     data, gsize length, GKeyFileFlags flags, GError **error);
(define g_key_file_load_from_data
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_key_file_load_from_data"
                (dynamic-link))
              (list '* '* ffi:unsigned-long ffi:int '*))))
    (lambda (key_file data length flags error)
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~data (unwrap-gchar* data))
            (~length (unwrap~fixed length))
            (~flags (unwrap~fixed flags))
            (~error (unwrap~pointer error)))
        (wrap-gboolean
          (~f ~key_file ~data ~length ~flags ~error))))))
(export g_key_file_load_from_data)

;; extern gboolean g_key_file_load_from_bytes(GKeyFile *key_file, GBytes *bytes
;;     , GKeyFileFlags flags, GError **error);
(define g_key_file_load_from_bytes
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_key_file_load_from_bytes"
                (dynamic-link))
              (list '* '* ffi:int '*))))
    (lambda (key_file bytes flags error)
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~bytes (unwrap-GBytes* bytes))
            (~flags (unwrap~fixed flags))
            (~error (unwrap~pointer error)))
        (wrap-gboolean
          (~f ~key_file ~bytes ~flags ~error))))))
(export g_key_file_load_from_bytes)

;; extern gboolean g_key_file_load_from_dirs(GKeyFile *key_file, const gchar *
;;     file, const gchar **search_dirs, gchar **full_path, GKeyFileFlags flags
;;     , GError **error);
(define g_key_file_load_from_dirs
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_key_file_load_from_dirs"
                (dynamic-link))
              (list '* '* '* '* ffi:int '*))))
    (lambda (key_file file search_dirs full_path flags error)
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~file (unwrap-gchar* file))
            (~search_dirs (unwrap~pointer search_dirs))
            (~full_path (unwrap~pointer full_path))
            (~flags (unwrap~fixed flags))
            (~error (unwrap~pointer error)))
        (wrap-gboolean
          (~f ~key_file
              ~file
              ~search_dirs
              ~full_path
              ~flags
              ~error))))))
(export g_key_file_load_from_dirs)

;; extern gboolean g_key_file_load_from_data_dirs(GKeyFile *key_file, const 
;;     gchar *file, gchar **full_path, GKeyFileFlags flags, GError **error);
(define g_key_file_load_from_data_dirs
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_key_file_load_from_data_dirs"
                (dynamic-link))
              (list '* '* '* ffi:int '*))))
    (lambda (key_file file full_path flags error)
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~file (unwrap-gchar* file))
            (~full_path (unwrap~pointer full_path))
            (~flags (unwrap~fixed flags))
            (~error (unwrap~pointer error)))
        (wrap-gboolean
          (~f ~key_file ~file ~full_path ~flags ~error))))))
(export g_key_file_load_from_data_dirs)

;; extern gchar *g_key_file_to_data(GKeyFile *key_file, gsize *length, GError *
;;     *error);
(define g_key_file_to_data
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_key_file_to_data"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (key_file length error)
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~length (unwrap~pointer length))
            (~error (unwrap~pointer error)))
        (wrap-gchar* (~f ~key_file ~length ~error))))))
(export g_key_file_to_data)

;; extern gboolean g_key_file_save_to_file(GKeyFile *key_file, const gchar *
;;     filename, GError **error);
(define g_key_file_save_to_file
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_key_file_save_to_file"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (key_file filename error)
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~filename (unwrap-gchar* filename))
            (~error (unwrap~pointer error)))
        (wrap-gboolean (~f ~key_file ~filename ~error))))))
(export g_key_file_save_to_file)

;; extern gchar *g_key_file_get_start_group(GKeyFile *key_file);
(define g_key_file_get_start_group
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_key_file_get_start_group"
                (dynamic-link))
              (list '*))))
    (lambda (key_file)
      (let ((~key_file (unwrap-GKeyFile* key_file)))
        (wrap-gchar* (~f ~key_file))))))
(export g_key_file_get_start_group)

;; extern gchar **g_key_file_get_groups(GKeyFile *key_file, gsize *length);
;; ... failed.

;; extern gchar **g_key_file_get_keys(GKeyFile *key_file, const gchar *
;;     group_name, gsize *length, GError **error);
;; ... failed.

;; extern gboolean g_key_file_has_group(GKeyFile *key_file, const gchar *
;;     group_name);
(define g_key_file_has_group
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_key_file_has_group"
                (dynamic-link))
              (list '* '*))))
    (lambda (key_file group_name)
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap-gchar* group_name)))
        (wrap-gboolean (~f ~key_file ~group_name))))))
(export g_key_file_has_group)

;; extern gboolean g_key_file_has_key(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, GError **error);
(define g_key_file_has_key
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_key_file_has_key"
                (dynamic-link))
              (list '* '* '* '*))))
    (lambda (key_file group_name key error)
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap-gchar* group_name))
            (~key (unwrap-gchar* key))
            (~error (unwrap~pointer error)))
        (wrap-gboolean
          (~f ~key_file ~group_name ~key ~error))))))
(export g_key_file_has_key)

;; extern gchar *g_key_file_get_value(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, GError **error);
(define g_key_file_get_value
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_key_file_get_value"
                (dynamic-link))
              (list '* '* '* '*))))
    (lambda (key_file group_name key error)
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap-gchar* group_name))
            (~key (unwrap-gchar* key))
            (~error (unwrap~pointer error)))
        (wrap-gchar*
          (~f ~key_file ~group_name ~key ~error))))))
(export g_key_file_get_value)

;; extern void g_key_file_set_value(GKeyFile *key_file, const gchar *group_name
;;     , const gchar *key, const gchar *value);
(define g_key_file_set_value
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_key_file_set_value"
                (dynamic-link))
              (list '* '* '* '*))))
    (lambda (key_file group_name key value)
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap-gchar* group_name))
            (~key (unwrap-gchar* key))
            (~value (unwrap-gchar* value)))
        (~f ~key_file ~group_name ~key ~value)))))
(export g_key_file_set_value)

;; extern gchar *g_key_file_get_string(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, GError **error);
(define g_key_file_get_string
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_key_file_get_string"
                (dynamic-link))
              (list '* '* '* '*))))
    (lambda (key_file group_name key error)
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap-gchar* group_name))
            (~key (unwrap-gchar* key))
            (~error (unwrap~pointer error)))
        (wrap-gchar*
          (~f ~key_file ~group_name ~key ~error))))))
(export g_key_file_get_string)

;; extern void g_key_file_set_string(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, const gchar *string);
(define g_key_file_set_string
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_key_file_set_string"
                (dynamic-link))
              (list '* '* '* '*))))
    (lambda (key_file group_name key string)
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap-gchar* group_name))
            (~key (unwrap-gchar* key))
            (~string (unwrap-gchar* string)))
        (~f ~key_file ~group_name ~key ~string)))))
(export g_key_file_set_string)

;; extern gchar *g_key_file_get_locale_string(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, const gchar *locale, GError **error);
(define g_key_file_get_locale_string
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_key_file_get_locale_string"
                (dynamic-link))
              (list '* '* '* '* '*))))
    (lambda (key_file group_name key locale error)
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap-gchar* group_name))
            (~key (unwrap-gchar* key))
            (~locale (unwrap-gchar* locale))
            (~error (unwrap~pointer error)))
        (wrap-gchar*
          (~f ~key_file ~group_name ~key ~locale ~error))))))
(export g_key_file_get_locale_string)

;; extern void g_key_file_set_locale_string(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, const gchar *locale, const gchar *string)
;;     ;
(define g_key_file_set_locale_string
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_key_file_set_locale_string"
                (dynamic-link))
              (list '* '* '* '* '*))))
    (lambda (key_file group_name key locale string)
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap-gchar* group_name))
            (~key (unwrap-gchar* key))
            (~locale (unwrap-gchar* locale))
            (~string (unwrap-gchar* string)))
        (~f ~key_file ~group_name ~key ~locale ~string)))))
(export g_key_file_set_locale_string)

;; extern gboolean g_key_file_get_boolean(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, GError **error);
(define g_key_file_get_boolean
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_key_file_get_boolean"
                (dynamic-link))
              (list '* '* '* '*))))
    (lambda (key_file group_name key error)
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap-gchar* group_name))
            (~key (unwrap-gchar* key))
            (~error (unwrap~pointer error)))
        (wrap-gboolean
          (~f ~key_file ~group_name ~key ~error))))))
(export g_key_file_get_boolean)

;; extern void g_key_file_set_boolean(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, gboolean value);
(define g_key_file_set_boolean
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_key_file_set_boolean"
                (dynamic-link))
              (list '* '* '* ffi:int))))
    (lambda (key_file group_name key value)
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap-gchar* group_name))
            (~key (unwrap-gchar* key))
            (~value (unwrap-gboolean value)))
        (~f ~key_file ~group_name ~key ~value)))))
(export g_key_file_set_boolean)

;; extern gint g_key_file_get_integer(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, GError **error);
(define g_key_file_get_integer
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_key_file_get_integer"
                (dynamic-link))
              (list '* '* '* '*))))
    (lambda (key_file group_name key error)
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap-gchar* group_name))
            (~key (unwrap-gchar* key))
            (~error (unwrap~pointer error)))
        (wrap-gint
          (~f ~key_file ~group_name ~key ~error))))))
(export g_key_file_get_integer)

;; extern void g_key_file_set_integer(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, gint value);
(define g_key_file_set_integer
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_key_file_set_integer"
                (dynamic-link))
              (list '* '* '* ffi:int))))
    (lambda (key_file group_name key value)
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap-gchar* group_name))
            (~key (unwrap-gchar* key))
            (~value (unwrap-gint value)))
        (~f ~key_file ~group_name ~key ~value)))))
(export g_key_file_set_integer)

;; extern gint64 g_key_file_get_int64(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, GError **error);
;; ... failed.

;; extern void g_key_file_set_int64(GKeyFile *key_file, const gchar *group_name
;;     , const gchar *key, gint64 value);
;; ... failed.

;; extern guint64 g_key_file_get_uint64(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, GError **error);
(define g_key_file_get_uint64
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-long
              (dynamic-func
                "g_key_file_get_uint64"
                (dynamic-link))
              (list '* '* '* '*))))
    (lambda (key_file group_name key error)
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap-gchar* group_name))
            (~key (unwrap-gchar* key))
            (~error (unwrap~pointer error)))
        (~f ~key_file ~group_name ~key ~error)))))
(export g_key_file_get_uint64)

;; extern void g_key_file_set_uint64(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, guint64 value);
(define g_key_file_set_uint64
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_key_file_set_uint64"
                (dynamic-link))
              (list '* '* '* ffi:unsigned-long))))
    (lambda (key_file group_name key value)
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap-gchar* group_name))
            (~key (unwrap-gchar* key))
            (~value (unwrap~fixed value)))
        (~f ~key_file ~group_name ~key ~value)))))
(export g_key_file_set_uint64)

;; extern gdouble g_key_file_get_double(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, GError **error);
(define g_key_file_get_double
  (let ((~f (ffi:pointer->procedure
              ffi:double
              (dynamic-func
                "g_key_file_get_double"
                (dynamic-link))
              (list '* '* '* '*))))
    (lambda (key_file group_name key error)
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap-gchar* group_name))
            (~key (unwrap-gchar* key))
            (~error (unwrap~pointer error)))
        (wrap-gdouble
          (~f ~key_file ~group_name ~key ~error))))))
(export g_key_file_get_double)

;; extern void g_key_file_set_double(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, gdouble value);
(define g_key_file_set_double
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_key_file_set_double"
                (dynamic-link))
              (list '* '* '* ffi:double))))
    (lambda (key_file group_name key value)
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap-gchar* group_name))
            (~key (unwrap-gchar* key))
            (~value (unwrap-gdouble value)))
        (~f ~key_file ~group_name ~key ~value)))))
(export g_key_file_set_double)

;; extern gchar **g_key_file_get_string_list(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, gsize *length, GError **error);
;; ... failed.

;; extern void g_key_file_set_string_list(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, const gchar *constlist[], gsize length);
(define g_key_file_set_string_list
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_key_file_set_string_list"
                (dynamic-link))
              (list '* '* '* '* ffi:unsigned-long))))
    (lambda (key_file group_name key list length)
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap-gchar* group_name))
            (~key (unwrap-gchar* key))
            (~list (unwrap~array list))
            (~length (unwrap~fixed length)))
        (~f ~key_file ~group_name ~key ~list ~length)))))
(export g_key_file_set_string_list)

;; extern gchar **g_key_file_get_locale_string_list(GKeyFile *key_file, const 
;;     gchar *group_name, const gchar *key, const gchar *locale, gsize *length
;;     , GError **error);
;; ... failed.

;; extern void g_key_file_set_locale_string_list(GKeyFile *key_file, const 
;;     gchar *group_name, const gchar *key, const gchar *locale, const gchar *
;;     constlist[], gsize length);
(define g_key_file_set_locale_string_list
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_key_file_set_locale_string_list"
                (dynamic-link))
              (list '* '* '* '* '* ffi:unsigned-long))))
    (lambda (key_file group_name key locale list length)
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap-gchar* group_name))
            (~key (unwrap-gchar* key))
            (~locale (unwrap-gchar* locale))
            (~list (unwrap~array list))
            (~length (unwrap~fixed length)))
        (~f ~key_file
            ~group_name
            ~key
            ~locale
            ~list
            ~length)))))
(export g_key_file_set_locale_string_list)

;; extern gboolean *g_key_file_get_boolean_list(GKeyFile *key_file, const gchar
;;      *group_name, const gchar *key, gsize *length, GError **error);
(define g_key_file_get_boolean_list
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_key_file_get_boolean_list"
                (dynamic-link))
              (list '* '* '* '* '*))))
    (lambda (key_file group_name key length error)
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap-gchar* group_name))
            (~key (unwrap-gchar* key))
            (~length (unwrap~pointer length))
            (~error (unwrap~pointer error)))
        (wrap-gboolean*
          (~f ~key_file ~group_name ~key ~length ~error))))))
(export g_key_file_get_boolean_list)

;; extern void g_key_file_set_boolean_list(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, gboolean list[], gsize length);
(define g_key_file_set_boolean_list
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_key_file_set_boolean_list"
                (dynamic-link))
              (list '* '* '* '* ffi:unsigned-long))))
    (lambda (key_file group_name key list length)
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap-gchar* group_name))
            (~key (unwrap-gchar* key))
            (~list (unwrap~array list))
            (~length (unwrap~fixed length)))
        (~f ~key_file ~group_name ~key ~list ~length)))))
(export g_key_file_set_boolean_list)

;; extern gint *g_key_file_get_integer_list(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, gsize *length, GError **error);
(define g_key_file_get_integer_list
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_key_file_get_integer_list"
                (dynamic-link))
              (list '* '* '* '* '*))))
    (lambda (key_file group_name key length error)
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap-gchar* group_name))
            (~key (unwrap-gchar* key))
            (~length (unwrap~pointer length))
            (~error (unwrap~pointer error)))
        (wrap-gint*
          (~f ~key_file ~group_name ~key ~length ~error))))))
(export g_key_file_get_integer_list)

;; extern void g_key_file_set_double_list(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, gdouble list[], gsize length);
(define g_key_file_set_double_list
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_key_file_set_double_list"
                (dynamic-link))
              (list '* '* '* '* ffi:unsigned-long))))
    (lambda (key_file group_name key list length)
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap-gchar* group_name))
            (~key (unwrap-gchar* key))
            (~list (unwrap~array list))
            (~length (unwrap~fixed length)))
        (~f ~key_file ~group_name ~key ~list ~length)))))
(export g_key_file_set_double_list)

;; extern gdouble *g_key_file_get_double_list(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, gsize *length, GError **error);
(define g_key_file_get_double_list
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_key_file_get_double_list"
                (dynamic-link))
              (list '* '* '* '* '*))))
    (lambda (key_file group_name key length error)
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap-gchar* group_name))
            (~key (unwrap-gchar* key))
            (~length (unwrap~pointer length))
            (~error (unwrap~pointer error)))
        (wrap-gdouble*
          (~f ~key_file ~group_name ~key ~length ~error))))))
(export g_key_file_get_double_list)

;; extern void g_key_file_set_integer_list(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, gint list[], gsize length);
(define g_key_file_set_integer_list
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_key_file_set_integer_list"
                (dynamic-link))
              (list '* '* '* '* ffi:unsigned-long))))
    (lambda (key_file group_name key list length)
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap-gchar* group_name))
            (~key (unwrap-gchar* key))
            (~list (unwrap~array list))
            (~length (unwrap~fixed length)))
        (~f ~key_file ~group_name ~key ~list ~length)))))
(export g_key_file_set_integer_list)

;; extern gboolean g_key_file_set_comment(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, const gchar *comment, GError **error);
(define g_key_file_set_comment
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_key_file_set_comment"
                (dynamic-link))
              (list '* '* '* '* '*))))
    (lambda (key_file group_name key comment error)
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap-gchar* group_name))
            (~key (unwrap-gchar* key))
            (~comment (unwrap-gchar* comment))
            (~error (unwrap~pointer error)))
        (wrap-gboolean
          (~f ~key_file ~group_name ~key ~comment ~error))))))
(export g_key_file_set_comment)

;; extern gchar *g_key_file_get_comment(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, GError **error);
(define g_key_file_get_comment
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_key_file_get_comment"
                (dynamic-link))
              (list '* '* '* '*))))
    (lambda (key_file group_name key error)
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap-gchar* group_name))
            (~key (unwrap-gchar* key))
            (~error (unwrap~pointer error)))
        (wrap-gchar*
          (~f ~key_file ~group_name ~key ~error))))))
(export g_key_file_get_comment)

;; extern gboolean g_key_file_remove_comment(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, GError **error);
(define g_key_file_remove_comment
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_key_file_remove_comment"
                (dynamic-link))
              (list '* '* '* '*))))
    (lambda (key_file group_name key error)
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap-gchar* group_name))
            (~key (unwrap-gchar* key))
            (~error (unwrap~pointer error)))
        (wrap-gboolean
          (~f ~key_file ~group_name ~key ~error))))))
(export g_key_file_remove_comment)

;; extern gboolean g_key_file_remove_key(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, GError **error);
(define g_key_file_remove_key
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_key_file_remove_key"
                (dynamic-link))
              (list '* '* '* '*))))
    (lambda (key_file group_name key error)
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap-gchar* group_name))
            (~key (unwrap-gchar* key))
            (~error (unwrap~pointer error)))
        (wrap-gboolean
          (~f ~key_file ~group_name ~key ~error))))))
(export g_key_file_remove_key)

;; extern gboolean g_key_file_remove_group(GKeyFile *key_file, const gchar *
;;     group_name, GError **error);
(define g_key_file_remove_group
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_key_file_remove_group"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (key_file group_name error)
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap-gchar* group_name))
            (~error (unwrap~pointer error)))
        (wrap-gboolean (~f ~key_file ~group_name ~error))))))
(export g_key_file_remove_group)

;; typedef struct _GMappedFile GMappedFile;
(define GMappedFile-desc void)
(define GMappedFile*-desc (bs:pointer GMappedFile-desc))
(define-fh-pointer-type GMappedFile* GMappedFile*-desc)

;; extern GMappedFile *g_mapped_file_new(const gchar *filename, gboolean 
;;     writable, GError **error);
(define g_mapped_file_new
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_mapped_file_new" (dynamic-link))
              (list '* ffi:int '*))))
    (lambda (filename writable error)
      (let ((~filename (unwrap-gchar* filename))
            (~writable (unwrap-gboolean writable))
            (~error (unwrap~pointer error)))
        (wrap-GMappedFile*
          (~f ~filename ~writable ~error))))))
(export g_mapped_file_new)

;; extern GMappedFile *g_mapped_file_new_from_fd(gint fd, gboolean writable, 
;;     GError **error);
(define g_mapped_file_new_from_fd
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_mapped_file_new_from_fd"
                (dynamic-link))
              (list ffi:int ffi:int '*))))
    (lambda (fd writable error)
      (let ((~fd (unwrap-gint fd))
            (~writable (unwrap-gboolean writable))
            (~error (unwrap~pointer error)))
        (wrap-GMappedFile* (~f ~fd ~writable ~error))))))
(export g_mapped_file_new_from_fd)

;; extern gsize g_mapped_file_get_length(GMappedFile *file);
(define g_mapped_file_get_length
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-long
              (dynamic-func
                "g_mapped_file_get_length"
                (dynamic-link))
              (list '*))))
    (lambda (file)
      (let ((~file (unwrap-GMappedFile* file)))
        (~f ~file)))))
(export g_mapped_file_get_length)

;; extern gchar *g_mapped_file_get_contents(GMappedFile *file);
(define g_mapped_file_get_contents
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_mapped_file_get_contents"
                (dynamic-link))
              (list '*))))
    (lambda (file)
      (let ((~file (unwrap-GMappedFile* file)))
        (wrap-gchar* (~f ~file))))))
(export g_mapped_file_get_contents)

;; extern GBytes *g_mapped_file_get_bytes(GMappedFile *file);
(define g_mapped_file_get_bytes
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_mapped_file_get_bytes"
                (dynamic-link))
              (list '*))))
    (lambda (file)
      (let ((~file (unwrap-GMappedFile* file)))
        (wrap-GBytes* (~f ~file))))))
(export g_mapped_file_get_bytes)

;; extern GMappedFile *g_mapped_file_ref(GMappedFile *file);
(define g_mapped_file_ref
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_mapped_file_ref" (dynamic-link))
              (list '*))))
    (lambda (file)
      (let ((~file (unwrap-GMappedFile* file)))
        (wrap-GMappedFile* (~f ~file))))))
(export g_mapped_file_ref)

;; extern void g_mapped_file_unref(GMappedFile *file);
(define g_mapped_file_unref
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_mapped_file_unref"
                (dynamic-link))
              (list '*))))
    (lambda (file)
      (let ((~file (unwrap-GMappedFile* file)))
        (~f ~file)))))
(export g_mapped_file_unref)

;; extern void g_mapped_file_free(GMappedFile *file);
(define g_mapped_file_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_mapped_file_free"
                (dynamic-link))
              (list '*))))
    (lambda (file)
      (let ((~file (unwrap-GMappedFile* file)))
        (~f ~file)))))
(export g_mapped_file_free)

;; typedef enum {
;;   G_MARKUP_ERROR_BAD_UTF8,
;;   G_MARKUP_ERROR_EMPTY,
;;   G_MARKUP_ERROR_PARSE,
;;   G_MARKUP_ERROR_UNKNOWN_ELEMENT,
;;   G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE,
;;   G_MARKUP_ERROR_INVALID_CONTENT,
;;   G_MARKUP_ERROR_MISSING_ATTRIBUTE,
;; } GMarkupError;
(define-fh-enum GMarkupError
  '((G_MARKUP_ERROR_BAD_UTF8 . 0)
    (G_MARKUP_ERROR_EMPTY . 1)
    (G_MARKUP_ERROR_PARSE . 2)
    (G_MARKUP_ERROR_UNKNOWN_ELEMENT . 3)
    (G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE . 4)
    (G_MARKUP_ERROR_INVALID_CONTENT . 5)
    (G_MARKUP_ERROR_MISSING_ATTRIBUTE . 6))
  )

;; extern GQuark g_markup_error_quark(void);
(define g_markup_error_quark
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func
                "g_markup_error_quark"
                (dynamic-link))
              (list))))
    (lambda () (let () (wrap-GQuark (~f))))))
(export g_markup_error_quark)

;; typedef enum {
;;   G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG = 1<<0,
;;   G_MARKUP_TREAT_CDATA_AS_TEXT = 1<<1,
;;   G_MARKUP_PREFIX_ERROR_POSITION = 1<<2,
;;   G_MARKUP_IGNORE_QUALIFIED = 1<<3,
;; } GMarkupParseFlags;
(define-fh-enum GMarkupParseFlags
  '((G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG . 1)
    (G_MARKUP_TREAT_CDATA_AS_TEXT . 2)
    (G_MARKUP_PREFIX_ERROR_POSITION . 4)
    (G_MARKUP_IGNORE_QUALIFIED . 8))
  )

;; typedef struct _GMarkupParseContext GMarkupParseContext;
(define GMarkupParseContext-desc void)
(define GMarkupParseContext*-desc (bs:pointer GMarkupParseContext-desc))
(define-fh-pointer-type GMarkupParseContext* GMarkupParseContext*-desc)

;; typedef struct _GMarkupParser GMarkupParser;
(define GMarkupParser-desc void)
(define GMarkupParser*-desc (bs:pointer (delay GMarkupParser-desc)))
(define-fh-pointer-type GMarkupParser* GMarkupParser*-desc)

;; struct _GMarkupParser {
;;   /* Called for open tags <foo bar="baz"> */
;;   void (*start_element)(GMarkupParseContext *context, const gchar *
;;       element_name, const gchar **attribute_names, const gchar **
;;       attribute_values, gpointer user_data, GError **error);
;;   /* Called for close tags </foo> */
;;   void (*end_element)(GMarkupParseContext *context, const gchar *
;;       element_name, gpointer user_data, GError **error);
;;   /* Called for character data */
;;   /* text is not nul-terminated */
;;   void (*text)(GMarkupParseContext *context, const gchar *text, gsize 
;;       text_len, gpointer user_data, GError **error);
;;   /* Called for strings that should be re-saved verbatim in this same
;;    * position, but are not otherwise interpretable.  At the moment
;;    * this includes comments and processing instructions.
;;    */
;;   /* text is not nul-terminated. */
;;   void (*passthrough)(GMarkupParseContext *context, const gchar *
;;       passthrough_text, gsize text_len, gpointer user_data, GError **error)
;;       ;
;;   /* Called on error, including one set by other
;;    * methods in the vtable. The GError should not be freed.
;;    */
;;   void (*error)(GMarkupParseContext *context, GError *error, gpointer 
;;       user_data);
;; };
(define struct-_GMarkupParser-desc
  (bs:struct
    (list `(start_element ,(bs:pointer void))
          `(end_element ,(bs:pointer void))
          `(text ,(bs:pointer void))
          `(passthrough ,(bs:pointer void))
          `(error ,(bs:pointer void)))))
(export struct-_GMarkupParser-desc)
(define-fh-compound-type/p struct-_GMarkupParser struct-_GMarkupParser-desc)
(set! GMarkupParser-desc struct-_GMarkupParser-desc)
(define-fh-compound-type GMarkupParser GMarkupParser-desc)

;; extern GMarkupParseContext *g_markup_parse_context_new(const GMarkupParser *
;;     parser, GMarkupParseFlags flags, gpointer user_data, GDestroyNotify 
;;     user_data_dnotify);
(define g_markup_parse_context_new
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_markup_parse_context_new"
                (dynamic-link))
              (list '* ffi:int '* '*))))
    (lambda (parser flags user_data user_data_dnotify)
      (let ((~parser (unwrap-GMarkupParser* parser))
            (~flags (unwrap~fixed flags))
            (~user_data (unwrap-gpointer user_data))
            (~user_data_dnotify
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               user_data_dnotify)))
        (wrap-GMarkupParseContext*
          (~f ~parser ~flags ~user_data ~user_data_dnotify))))))
(export g_markup_parse_context_new)

;; extern GMarkupParseContext *g_markup_parse_context_ref(GMarkupParseContext *
;;     context);
(define g_markup_parse_context_ref
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_markup_parse_context_ref"
                (dynamic-link))
              (list '*))))
    (lambda (context)
      (let ((~context (unwrap-GMarkupParseContext* context)))
        (wrap-GMarkupParseContext* (~f ~context))))))
(export g_markup_parse_context_ref)

;; extern void g_markup_parse_context_unref(GMarkupParseContext *context);
(define g_markup_parse_context_unref
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_markup_parse_context_unref"
                (dynamic-link))
              (list '*))))
    (lambda (context)
      (let ((~context (unwrap-GMarkupParseContext* context)))
        (~f ~context)))))
(export g_markup_parse_context_unref)

;; extern void g_markup_parse_context_free(GMarkupParseContext *context);
(define g_markup_parse_context_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_markup_parse_context_free"
                (dynamic-link))
              (list '*))))
    (lambda (context)
      (let ((~context (unwrap-GMarkupParseContext* context)))
        (~f ~context)))))
(export g_markup_parse_context_free)

;; extern gboolean g_markup_parse_context_parse(GMarkupParseContext *context, 
;;     const gchar *text, gssize text_len, GError **error);
;; ... failed.

;; extern void g_markup_parse_context_push(GMarkupParseContext *context, const 
;;     GMarkupParser *parser, gpointer user_data);
(define g_markup_parse_context_push
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_markup_parse_context_push"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (context parser user_data)
      (let ((~context (unwrap-GMarkupParseContext* context))
            (~parser (unwrap-GMarkupParser* parser))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~context ~parser ~user_data)))))
(export g_markup_parse_context_push)

;; extern gpointer g_markup_parse_context_pop(GMarkupParseContext *context);
(define g_markup_parse_context_pop
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_markup_parse_context_pop"
                (dynamic-link))
              (list '*))))
    (lambda (context)
      (let ((~context (unwrap-GMarkupParseContext* context)))
        (wrap-gpointer (~f ~context))))))
(export g_markup_parse_context_pop)

;; extern gboolean g_markup_parse_context_end_parse(GMarkupParseContext *
;;     context, GError **error);
(define g_markup_parse_context_end_parse
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_markup_parse_context_end_parse"
                (dynamic-link))
              (list '* '*))))
    (lambda (context error)
      (let ((~context (unwrap-GMarkupParseContext* context))
            (~error (unwrap~pointer error)))
        (wrap-gboolean (~f ~context ~error))))))
(export g_markup_parse_context_end_parse)

;; extern const gchar *g_markup_parse_context_get_element(GMarkupParseContext *
;;     context);
(define g_markup_parse_context_get_element
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_markup_parse_context_get_element"
                (dynamic-link))
              (list '*))))
    (lambda (context)
      (let ((~context (unwrap-GMarkupParseContext* context)))
        (wrap-gchar* (~f ~context))))))
(export g_markup_parse_context_get_element)

;; extern const GSList *g_markup_parse_context_get_element_stack(
;;     GMarkupParseContext *context);
(define g_markup_parse_context_get_element_stack
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_markup_parse_context_get_element_stack"
                (dynamic-link))
              (list '*))))
    (lambda (context)
      (let ((~context (unwrap-GMarkupParseContext* context)))
        (wrap-GSList* (~f ~context))))))
(export g_markup_parse_context_get_element_stack)

;; extern void g_markup_parse_context_get_position(GMarkupParseContext *context
;;     , gint *line_number, gint *char_number);
(define g_markup_parse_context_get_position
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_markup_parse_context_get_position"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (context line_number char_number)
      (let ((~context (unwrap-GMarkupParseContext* context))
            (~line_number (unwrap-gint* line_number))
            (~char_number (unwrap-gint* char_number)))
        (~f ~context ~line_number ~char_number)))))
(export g_markup_parse_context_get_position)

;; extern gpointer g_markup_parse_context_get_user_data(GMarkupParseContext *
;;     context);
(define g_markup_parse_context_get_user_data
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_markup_parse_context_get_user_data"
                (dynamic-link))
              (list '*))))
    (lambda (context)
      (let ((~context (unwrap-GMarkupParseContext* context)))
        (wrap-gpointer (~f ~context))))))
(export g_markup_parse_context_get_user_data)

;; extern gchar *g_markup_escape_text(const gchar *text, gssize length);
;; ... failed.

;; extern gchar *g_markup_printf_escaped(const char *format, ...);
;; ... failed.

;; extern gchar *g_markup_vprintf_escaped(const char *format, va_list args);
(define g_markup_vprintf_escaped
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_markup_vprintf_escaped"
                (dynamic-link))
              (list '* '*))))
    (lambda (format args)
      (let ((~format (unwrap~pointer format))
            (~args (unwrap~pointer args)))
        (wrap-gchar* (~f ~format ~args))))))
(export g_markup_vprintf_escaped)

;; typedef enum {
;;   G_MARKUP_COLLECT_INVALID,
;;   G_MARKUP_COLLECT_STRING,
;;   G_MARKUP_COLLECT_STRDUP,
;;   G_MARKUP_COLLECT_BOOLEAN,
;;   G_MARKUP_COLLECT_TRISTATE,
;;   G_MARKUP_COLLECT_OPTIONAL = 1<<16,
;; } GMarkupCollectType;
(define-fh-enum GMarkupCollectType
  '((G_MARKUP_COLLECT_INVALID . 0)
    (G_MARKUP_COLLECT_STRING . 1)
    (G_MARKUP_COLLECT_STRDUP . 2)
    (G_MARKUP_COLLECT_BOOLEAN . 3)
    (G_MARKUP_COLLECT_TRISTATE . 4)
    (G_MARKUP_COLLECT_OPTIONAL . 65536))
  )

;; extern gboolean g_markup_collect_attributes(const gchar *element_name, const
;;      gchar **attribute_names, const gchar **attribute_values, GError **error
;;     , GMarkupCollectType first_type, const gchar *first_attr, ...);
;; ... failed.

;; typedef struct _GVariantType GVariantType;
(define GVariantType-desc void)
(define GVariantType*-desc (bs:pointer GVariantType-desc))
(define-fh-pointer-type GVariantType* GVariantType*-desc)

;; extern gboolean g_variant_type_string_is_valid(const gchar *type_string);
(define g_variant_type_string_is_valid
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_variant_type_string_is_valid"
                (dynamic-link))
              (list '*))))
    (lambda (type_string)
      (let ((~type_string (unwrap-gchar* type_string)))
        (wrap-gboolean (~f ~type_string))))))
(export g_variant_type_string_is_valid)

;; extern gboolean g_variant_type_string_scan(const gchar *string, const gchar 
;;     *limit, const gchar **endptr);
(define g_variant_type_string_scan
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_variant_type_string_scan"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (string limit endptr)
      (let ((~string (unwrap-gchar* string))
            (~limit (unwrap-gchar* limit))
            (~endptr (unwrap~pointer endptr)))
        (wrap-gboolean (~f ~string ~limit ~endptr))))))
(export g_variant_type_string_scan)

;; extern void g_variant_type_free(GVariantType *type);
(define g_variant_type_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_variant_type_free"
                (dynamic-link))
              (list '*))))
    (lambda (type)
      (let ((~type (unwrap-GVariantType* type)))
        (~f ~type)))))
(export g_variant_type_free)

;; extern GVariantType *g_variant_type_copy(const GVariantType *type);
(define g_variant_type_copy
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_type_copy"
                (dynamic-link))
              (list '*))))
    (lambda (type)
      (let ((~type (unwrap-GVariantType* type)))
        (wrap-GVariantType* (~f ~type))))))
(export g_variant_type_copy)

;; extern GVariantType *g_variant_type_new(const gchar *type_string);
(define g_variant_type_new
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_type_new"
                (dynamic-link))
              (list '*))))
    (lambda (type_string)
      (let ((~type_string (unwrap-gchar* type_string)))
        (wrap-GVariantType* (~f ~type_string))))))
(export g_variant_type_new)

;; extern gsize g_variant_type_get_string_length(const GVariantType *type);
(define g_variant_type_get_string_length
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-long
              (dynamic-func
                "g_variant_type_get_string_length"
                (dynamic-link))
              (list '*))))
    (lambda (type)
      (let ((~type (unwrap-GVariantType* type)))
        (~f ~type)))))
(export g_variant_type_get_string_length)

;; extern const gchar *g_variant_type_peek_string(const GVariantType *type);
(define g_variant_type_peek_string
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_type_peek_string"
                (dynamic-link))
              (list '*))))
    (lambda (type)
      (let ((~type (unwrap-GVariantType* type)))
        (wrap-gchar* (~f ~type))))))
(export g_variant_type_peek_string)

;; extern gchar *g_variant_type_dup_string(const GVariantType *type);
(define g_variant_type_dup_string
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_type_dup_string"
                (dynamic-link))
              (list '*))))
    (lambda (type)
      (let ((~type (unwrap-GVariantType* type)))
        (wrap-gchar* (~f ~type))))))
(export g_variant_type_dup_string)

;; extern gboolean g_variant_type_is_definite(const GVariantType *type);
(define g_variant_type_is_definite
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_variant_type_is_definite"
                (dynamic-link))
              (list '*))))
    (lambda (type)
      (let ((~type (unwrap-GVariantType* type)))
        (wrap-gboolean (~f ~type))))))
(export g_variant_type_is_definite)

;; extern gboolean g_variant_type_is_container(const GVariantType *type);
(define g_variant_type_is_container
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_variant_type_is_container"
                (dynamic-link))
              (list '*))))
    (lambda (type)
      (let ((~type (unwrap-GVariantType* type)))
        (wrap-gboolean (~f ~type))))))
(export g_variant_type_is_container)

;; extern gboolean g_variant_type_is_basic(const GVariantType *type);
(define g_variant_type_is_basic
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_variant_type_is_basic"
                (dynamic-link))
              (list '*))))
    (lambda (type)
      (let ((~type (unwrap-GVariantType* type)))
        (wrap-gboolean (~f ~type))))))
(export g_variant_type_is_basic)

;; extern gboolean g_variant_type_is_maybe(const GVariantType *type);
(define g_variant_type_is_maybe
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_variant_type_is_maybe"
                (dynamic-link))
              (list '*))))
    (lambda (type)
      (let ((~type (unwrap-GVariantType* type)))
        (wrap-gboolean (~f ~type))))))
(export g_variant_type_is_maybe)

;; extern gboolean g_variant_type_is_array(const GVariantType *type);
(define g_variant_type_is_array
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_variant_type_is_array"
                (dynamic-link))
              (list '*))))
    (lambda (type)
      (let ((~type (unwrap-GVariantType* type)))
        (wrap-gboolean (~f ~type))))))
(export g_variant_type_is_array)

;; extern gboolean g_variant_type_is_tuple(const GVariantType *type);
(define g_variant_type_is_tuple
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_variant_type_is_tuple"
                (dynamic-link))
              (list '*))))
    (lambda (type)
      (let ((~type (unwrap-GVariantType* type)))
        (wrap-gboolean (~f ~type))))))
(export g_variant_type_is_tuple)

;; extern gboolean g_variant_type_is_dict_entry(const GVariantType *type);
(define g_variant_type_is_dict_entry
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_variant_type_is_dict_entry"
                (dynamic-link))
              (list '*))))
    (lambda (type)
      (let ((~type (unwrap-GVariantType* type)))
        (wrap-gboolean (~f ~type))))))
(export g_variant_type_is_dict_entry)

;; extern gboolean g_variant_type_is_variant(const GVariantType *type);
(define g_variant_type_is_variant
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_variant_type_is_variant"
                (dynamic-link))
              (list '*))))
    (lambda (type)
      (let ((~type (unwrap-GVariantType* type)))
        (wrap-gboolean (~f ~type))))))
(export g_variant_type_is_variant)

;; extern guint g_variant_type_hash(gconstpointer type);
(define g_variant_type_hash
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func
                "g_variant_type_hash"
                (dynamic-link))
              (list '*))))
    (lambda (type)
      (let ((~type (unwrap-gconstpointer type)))
        (wrap-guint (~f ~type))))))
(export g_variant_type_hash)

;; extern gboolean g_variant_type_equal(gconstpointer type1, gconstpointer 
;;     type2);
(define g_variant_type_equal
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_variant_type_equal"
                (dynamic-link))
              (list '* '*))))
    (lambda (type1 type2)
      (let ((~type1 (unwrap-gconstpointer type1))
            (~type2 (unwrap-gconstpointer type2)))
        (wrap-gboolean (~f ~type1 ~type2))))))
(export g_variant_type_equal)

;; extern gboolean g_variant_type_is_subtype_of(const GVariantType *type, const
;;      GVariantType *supertype);
(define g_variant_type_is_subtype_of
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_variant_type_is_subtype_of"
                (dynamic-link))
              (list '* '*))))
    (lambda (type supertype)
      (let ((~type (unwrap-GVariantType* type))
            (~supertype (unwrap-GVariantType* supertype)))
        (wrap-gboolean (~f ~type ~supertype))))))
(export g_variant_type_is_subtype_of)

;; extern const GVariantType *g_variant_type_element(const GVariantType *type)
;;     ;
(define g_variant_type_element
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_type_element"
                (dynamic-link))
              (list '*))))
    (lambda (type)
      (let ((~type (unwrap-GVariantType* type)))
        (wrap-GVariantType* (~f ~type))))))
(export g_variant_type_element)

;; extern const GVariantType *g_variant_type_first(const GVariantType *type);
(define g_variant_type_first
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_type_first"
                (dynamic-link))
              (list '*))))
    (lambda (type)
      (let ((~type (unwrap-GVariantType* type)))
        (wrap-GVariantType* (~f ~type))))))
(export g_variant_type_first)

;; extern const GVariantType *g_variant_type_next(const GVariantType *type);
(define g_variant_type_next
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_type_next"
                (dynamic-link))
              (list '*))))
    (lambda (type)
      (let ((~type (unwrap-GVariantType* type)))
        (wrap-GVariantType* (~f ~type))))))
(export g_variant_type_next)

;; extern gsize g_variant_type_n_items(const GVariantType *type);
(define g_variant_type_n_items
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-long
              (dynamic-func
                "g_variant_type_n_items"
                (dynamic-link))
              (list '*))))
    (lambda (type)
      (let ((~type (unwrap-GVariantType* type)))
        (~f ~type)))))
(export g_variant_type_n_items)

;; extern const GVariantType *g_variant_type_key(const GVariantType *type);
(define g_variant_type_key
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_type_key"
                (dynamic-link))
              (list '*))))
    (lambda (type)
      (let ((~type (unwrap-GVariantType* type)))
        (wrap-GVariantType* (~f ~type))))))
(export g_variant_type_key)

;; extern const GVariantType *g_variant_type_value(const GVariantType *type);
(define g_variant_type_value
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_type_value"
                (dynamic-link))
              (list '*))))
    (lambda (type)
      (let ((~type (unwrap-GVariantType* type)))
        (wrap-GVariantType* (~f ~type))))))
(export g_variant_type_value)

;; extern GVariantType *g_variant_type_new_array(const GVariantType *element);
(define g_variant_type_new_array
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_type_new_array"
                (dynamic-link))
              (list '*))))
    (lambda (element)
      (let ((~element (unwrap-GVariantType* element)))
        (wrap-GVariantType* (~f ~element))))))
(export g_variant_type_new_array)

;; extern GVariantType *g_variant_type_new_maybe(const GVariantType *element);
(define g_variant_type_new_maybe
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_type_new_maybe"
                (dynamic-link))
              (list '*))))
    (lambda (element)
      (let ((~element (unwrap-GVariantType* element)))
        (wrap-GVariantType* (~f ~element))))))
(export g_variant_type_new_maybe)

;; extern GVariantType *g_variant_type_new_tuple(const GVariantType *const*
;;     items, gint length);
(define g_variant_type_new_tuple
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_type_new_tuple"
                (dynamic-link))
              (list '* ffi:int))))
    (lambda (items length)
      (let ((~items (unwrap~pointer items))
            (~length (unwrap-gint length)))
        (wrap-GVariantType* (~f ~items ~length))))))
(export g_variant_type_new_tuple)

;; extern GVariantType *g_variant_type_new_dict_entry(const GVariantType *key, 
;;     const GVariantType *value);
(define g_variant_type_new_dict_entry
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_type_new_dict_entry"
                (dynamic-link))
              (list '* '*))))
    (lambda (key value)
      (let ((~key (unwrap-GVariantType* key))
            (~value (unwrap-GVariantType* value)))
        (wrap-GVariantType* (~f ~key ~value))))))
(export g_variant_type_new_dict_entry)

;; extern const GVariantType *g_variant_type_checked_(const gchar *);
(define g_variant_type_checked_
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_type_checked_"
                (dynamic-link))
              (list '*))))
    (lambda (@76)
      (let ((~@76 (unwrap-gchar* @76)))
        (wrap-GVariantType* (~f ~@76))))))
(export g_variant_type_checked_)

;; typedef struct _GVariant GVariant;
(define GVariant-desc void)
(define GVariant*-desc (bs:pointer GVariant-desc))
(define-fh-pointer-type GVariant* GVariant*-desc)

;; typedef enum {
;;   G_VARIANT_CLASS_BOOLEAN = 'b',
;;   G_VARIANT_CLASS_BYTE = 'y',
;;   G_VARIANT_CLASS_INT16 = 'n',
;;   G_VARIANT_CLASS_UINT16 = 'q',
;;   G_VARIANT_CLASS_INT32 = 'i',
;;   G_VARIANT_CLASS_UINT32 = 'u',
;;   G_VARIANT_CLASS_INT64 = 'x',
;;   G_VARIANT_CLASS_UINT64 = 't',
;;   G_VARIANT_CLASS_HANDLE = 'h',
;;   G_VARIANT_CLASS_DOUBLE = 'd',
;;   G_VARIANT_CLASS_STRING = 's',
;;   G_VARIANT_CLASS_OBJECT_PATH = 'o',
;;   G_VARIANT_CLASS_SIGNATURE = 'g',
;;   G_VARIANT_CLASS_VARIANT = 'v',
;;   G_VARIANT_CLASS_MAYBE = 'm',
;;   G_VARIANT_CLASS_ARRAY = 'a',
;;   G_VARIANT_CLASS_TUPLE = '(',
;;   G_VARIANT_CLASS_DICT_ENTRY = '{',
;; } GVariantClass;
(define-fh-enum GVariantClass
  '((G_VARIANT_CLASS_BOOLEAN . 98)
    (G_VARIANT_CLASS_BYTE . 121)
    (G_VARIANT_CLASS_INT16 . 110)
    (G_VARIANT_CLASS_UINT16 . 113)
    (G_VARIANT_CLASS_INT32 . 105)
    (G_VARIANT_CLASS_UINT32 . 117)
    (G_VARIANT_CLASS_INT64 . 120)
    (G_VARIANT_CLASS_UINT64 . 116)
    (G_VARIANT_CLASS_HANDLE . 104)
    (G_VARIANT_CLASS_DOUBLE . 100)
    (G_VARIANT_CLASS_STRING . 115)
    (G_VARIANT_CLASS_OBJECT_PATH . 111)
    (G_VARIANT_CLASS_SIGNATURE . 103)
    (G_VARIANT_CLASS_VARIANT . 118)
    (G_VARIANT_CLASS_MAYBE . 109)
    (G_VARIANT_CLASS_ARRAY . 97)
    (G_VARIANT_CLASS_TUPLE . 40)
    (G_VARIANT_CLASS_DICT_ENTRY . 123))
  )

;; extern void g_variant_unref(GVariant *value);
(define g_variant_unref
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_variant_unref" (dynamic-link))
              (list '*))))
    (lambda (value)
      (let ((~value (unwrap-GVariant* value)))
        (~f ~value)))))
(export g_variant_unref)

;; extern GVariant *g_variant_ref(GVariant *value);
(define g_variant_ref
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_variant_ref" (dynamic-link))
              (list '*))))
    (lambda (value)
      (let ((~value (unwrap-GVariant* value)))
        (wrap-GVariant* (~f ~value))))))
(export g_variant_ref)

;; extern GVariant *g_variant_ref_sink(GVariant *value);
(define g_variant_ref_sink
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_ref_sink"
                (dynamic-link))
              (list '*))))
    (lambda (value)
      (let ((~value (unwrap-GVariant* value)))
        (wrap-GVariant* (~f ~value))))))
(export g_variant_ref_sink)

;; extern gboolean g_variant_is_floating(GVariant *value);
(define g_variant_is_floating
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_variant_is_floating"
                (dynamic-link))
              (list '*))))
    (lambda (value)
      (let ((~value (unwrap-GVariant* value)))
        (wrap-gboolean (~f ~value))))))
(export g_variant_is_floating)

;; extern GVariant *g_variant_take_ref(GVariant *value);
(define g_variant_take_ref
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_take_ref"
                (dynamic-link))
              (list '*))))
    (lambda (value)
      (let ((~value (unwrap-GVariant* value)))
        (wrap-GVariant* (~f ~value))))))
(export g_variant_take_ref)

;; extern const GVariantType *g_variant_get_type(GVariant *value);
(define g_variant_get_type
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_get_type"
                (dynamic-link))
              (list '*))))
    (lambda (value)
      (let ((~value (unwrap-GVariant* value)))
        (wrap-GVariantType* (~f ~value))))))
(export g_variant_get_type)

;; extern const gchar *g_variant_get_type_string(GVariant *value);
(define g_variant_get_type_string
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_get_type_string"
                (dynamic-link))
              (list '*))))
    (lambda (value)
      (let ((~value (unwrap-GVariant* value)))
        (wrap-gchar* (~f ~value))))))
(export g_variant_get_type_string)

;; extern gboolean g_variant_is_of_type(GVariant *value, const GVariantType *
;;     type);
(define g_variant_is_of_type
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_variant_is_of_type"
                (dynamic-link))
              (list '* '*))))
    (lambda (value type)
      (let ((~value (unwrap-GVariant* value))
            (~type (unwrap-GVariantType* type)))
        (wrap-gboolean (~f ~value ~type))))))
(export g_variant_is_of_type)

;; extern gboolean g_variant_is_container(GVariant *value);
(define g_variant_is_container
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_variant_is_container"
                (dynamic-link))
              (list '*))))
    (lambda (value)
      (let ((~value (unwrap-GVariant* value)))
        (wrap-gboolean (~f ~value))))))
(export g_variant_is_container)

;; extern GVariantClass g_variant_classify(GVariant *value);
(define g_variant_classify
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_variant_classify"
                (dynamic-link))
              (list '*))))
    (lambda (value)
      (let ((~value (unwrap-GVariant* value)))
        (~f ~value)))))
(export g_variant_classify)

;; extern GVariant *g_variant_new_boolean(gboolean value);
(define g_variant_new_boolean
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_new_boolean"
                (dynamic-link))
              (list ffi:int))))
    (lambda (value)
      (let ((~value (unwrap-gboolean value)))
        (wrap-GVariant* (~f ~value))))))
(export g_variant_new_boolean)

;; extern GVariant *g_variant_new_byte(guchar value);
(define g_variant_new_byte
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_new_byte"
                (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (value)
      (let ((~value (unwrap-guchar value)))
        (wrap-GVariant* (~f ~value))))))
(export g_variant_new_byte)

;; extern GVariant *g_variant_new_int16(gint16 value);
;; ... failed.

;; extern GVariant *g_variant_new_uint16(guint16 value);
(define g_variant_new_uint16
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_new_uint16"
                (dynamic-link))
              (list ffi:unsigned-short))))
    (lambda (value)
      (let ((~value (unwrap~fixed value)))
        (wrap-GVariant* (~f ~value))))))
(export g_variant_new_uint16)

;; extern GVariant *g_variant_new_int32(gint32 value);
;; ... failed.

;; extern GVariant *g_variant_new_uint32(guint32 value);
(define g_variant_new_uint32
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_new_uint32"
                (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (value)
      (let ((~value (unwrap~fixed value)))
        (wrap-GVariant* (~f ~value))))))
(export g_variant_new_uint32)

;; extern GVariant *g_variant_new_int64(gint64 value);
;; ... failed.

;; extern GVariant *g_variant_new_uint64(guint64 value);
(define g_variant_new_uint64
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_new_uint64"
                (dynamic-link))
              (list ffi:unsigned-long))))
    (lambda (value)
      (let ((~value (unwrap~fixed value)))
        (wrap-GVariant* (~f ~value))))))
(export g_variant_new_uint64)

;; extern GVariant *g_variant_new_handle(gint32 value);
;; ... failed.

;; extern GVariant *g_variant_new_double(gdouble value);
(define g_variant_new_double
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_new_double"
                (dynamic-link))
              (list ffi:double))))
    (lambda (value)
      (let ((~value (unwrap-gdouble value)))
        (wrap-GVariant* (~f ~value))))))
(export g_variant_new_double)

;; extern GVariant *g_variant_new_string(const gchar *string);
(define g_variant_new_string
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_new_string"
                (dynamic-link))
              (list '*))))
    (lambda (string)
      (let ((~string (unwrap-gchar* string)))
        (wrap-GVariant* (~f ~string))))))
(export g_variant_new_string)

;; extern GVariant *g_variant_new_take_string(gchar *string);
(define g_variant_new_take_string
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_new_take_string"
                (dynamic-link))
              (list '*))))
    (lambda (string)
      (let ((~string (unwrap-gchar* string)))
        (wrap-GVariant* (~f ~string))))))
(export g_variant_new_take_string)

;; extern GVariant *g_variant_new_printf(const gchar *format_string, ...);
;; ... failed.

;; extern GVariant *g_variant_new_object_path(const gchar *object_path);
(define g_variant_new_object_path
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_new_object_path"
                (dynamic-link))
              (list '*))))
    (lambda (object_path)
      (let ((~object_path (unwrap-gchar* object_path)))
        (wrap-GVariant* (~f ~object_path))))))
(export g_variant_new_object_path)

;; extern gboolean g_variant_is_object_path(const gchar *string);
(define g_variant_is_object_path
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_variant_is_object_path"
                (dynamic-link))
              (list '*))))
    (lambda (string)
      (let ((~string (unwrap-gchar* string)))
        (wrap-gboolean (~f ~string))))))
(export g_variant_is_object_path)

;; extern GVariant *g_variant_new_signature(const gchar *signature);
(define g_variant_new_signature
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_new_signature"
                (dynamic-link))
              (list '*))))
    (lambda (signature)
      (let ((~signature (unwrap-gchar* signature)))
        (wrap-GVariant* (~f ~signature))))))
(export g_variant_new_signature)

;; extern gboolean g_variant_is_signature(const gchar *string);
(define g_variant_is_signature
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_variant_is_signature"
                (dynamic-link))
              (list '*))))
    (lambda (string)
      (let ((~string (unwrap-gchar* string)))
        (wrap-gboolean (~f ~string))))))
(export g_variant_is_signature)

;; extern GVariant *g_variant_new_variant(GVariant *value);
(define g_variant_new_variant
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_new_variant"
                (dynamic-link))
              (list '*))))
    (lambda (value)
      (let ((~value (unwrap-GVariant* value)))
        (wrap-GVariant* (~f ~value))))))
(export g_variant_new_variant)

;; extern GVariant *g_variant_new_strv(const gchar *const*strv, gssize length)
;;     ;
;; ... failed.

;; extern GVariant *g_variant_new_objv(const gchar *const*strv, gssize length)
;;     ;
;; ... failed.

;; extern GVariant *g_variant_new_bytestring(const gchar *string);
(define g_variant_new_bytestring
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_new_bytestring"
                (dynamic-link))
              (list '*))))
    (lambda (string)
      (let ((~string (unwrap-gchar* string)))
        (wrap-GVariant* (~f ~string))))))
(export g_variant_new_bytestring)

;; extern GVariant *g_variant_new_bytestring_array(const gchar *const*strv, 
;;     gssize length);
;; ... failed.

;; extern GVariant *g_variant_new_fixed_array(const GVariantType *element_type
;;     , gconstpointer elements, gsize n_elements, gsize element_size);
(define g_variant_new_fixed_array
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_new_fixed_array"
                (dynamic-link))
              (list '* '* ffi:unsigned-long ffi:unsigned-long))))
    (lambda (element_type elements n_elements element_size)
      (let ((~element_type
              (unwrap-GVariantType* element_type))
            (~elements (unwrap-gconstpointer elements))
            (~n_elements (unwrap~fixed n_elements))
            (~element_size (unwrap~fixed element_size)))
        (wrap-GVariant*
          (~f ~element_type
              ~elements
              ~n_elements
              ~element_size))))))
(export g_variant_new_fixed_array)

;; extern gboolean g_variant_get_boolean(GVariant *value);
(define g_variant_get_boolean
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_variant_get_boolean"
                (dynamic-link))
              (list '*))))
    (lambda (value)
      (let ((~value (unwrap-GVariant* value)))
        (wrap-gboolean (~f ~value))))))
(export g_variant_get_boolean)

;; extern guchar g_variant_get_byte(GVariant *value);
(define g_variant_get_byte
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func
                "g_variant_get_byte"
                (dynamic-link))
              (list '*))))
    (lambda (value)
      (let ((~value (unwrap-GVariant* value)))
        (wrap-guchar (~f ~value))))))
(export g_variant_get_byte)

;; extern gint16 g_variant_get_int16(GVariant *value);
;; ... failed.

;; extern guint16 g_variant_get_uint16(GVariant *value);
(define g_variant_get_uint16
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-short
              (dynamic-func
                "g_variant_get_uint16"
                (dynamic-link))
              (list '*))))
    (lambda (value)
      (let ((~value (unwrap-GVariant* value)))
        (~f ~value)))))
(export g_variant_get_uint16)

;; extern gint32 g_variant_get_int32(GVariant *value);
;; ... failed.

;; extern guint32 g_variant_get_uint32(GVariant *value);
(define g_variant_get_uint32
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func
                "g_variant_get_uint32"
                (dynamic-link))
              (list '*))))
    (lambda (value)
      (let ((~value (unwrap-GVariant* value)))
        (~f ~value)))))
(export g_variant_get_uint32)

;; extern gint64 g_variant_get_int64(GVariant *value);
;; ... failed.

;; extern guint64 g_variant_get_uint64(GVariant *value);
(define g_variant_get_uint64
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-long
              (dynamic-func
                "g_variant_get_uint64"
                (dynamic-link))
              (list '*))))
    (lambda (value)
      (let ((~value (unwrap-GVariant* value)))
        (~f ~value)))))
(export g_variant_get_uint64)

;; extern gint32 g_variant_get_handle(GVariant *value);
;; ... failed.

;; extern gdouble g_variant_get_double(GVariant *value);
(define g_variant_get_double
  (let ((~f (ffi:pointer->procedure
              ffi:double
              (dynamic-func
                "g_variant_get_double"
                (dynamic-link))
              (list '*))))
    (lambda (value)
      (let ((~value (unwrap-GVariant* value)))
        (wrap-gdouble (~f ~value))))))
(export g_variant_get_double)

;; extern GVariant *g_variant_get_variant(GVariant *value);
(define g_variant_get_variant
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_get_variant"
                (dynamic-link))
              (list '*))))
    (lambda (value)
      (let ((~value (unwrap-GVariant* value)))
        (wrap-GVariant* (~f ~value))))))
(export g_variant_get_variant)

;; extern const gchar *g_variant_get_string(GVariant *value, gsize *length);
(define g_variant_get_string
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_get_string"
                (dynamic-link))
              (list '* '*))))
    (lambda (value length)
      (let ((~value (unwrap-GVariant* value))
            (~length (unwrap~pointer length)))
        (wrap-gchar* (~f ~value ~length))))))
(export g_variant_get_string)

;; extern gchar *g_variant_dup_string(GVariant *value, gsize *length);
(define g_variant_dup_string
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_dup_string"
                (dynamic-link))
              (list '* '*))))
    (lambda (value length)
      (let ((~value (unwrap-GVariant* value))
            (~length (unwrap~pointer length)))
        (wrap-gchar* (~f ~value ~length))))))
(export g_variant_dup_string)

;; extern const gchar **g_variant_get_strv(GVariant *value, gsize *length);
;; ... failed.

;; extern gchar **g_variant_dup_strv(GVariant *value, gsize *length);
;; ... failed.

;; extern const gchar **g_variant_get_objv(GVariant *value, gsize *length);
;; ... failed.

;; extern gchar **g_variant_dup_objv(GVariant *value, gsize *length);
;; ... failed.

;; extern const gchar *g_variant_get_bytestring(GVariant *value);
(define g_variant_get_bytestring
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_get_bytestring"
                (dynamic-link))
              (list '*))))
    (lambda (value)
      (let ((~value (unwrap-GVariant* value)))
        (wrap-gchar* (~f ~value))))))
(export g_variant_get_bytestring)

;; extern gchar *g_variant_dup_bytestring(GVariant *value, gsize *length);
(define g_variant_dup_bytestring
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_dup_bytestring"
                (dynamic-link))
              (list '* '*))))
    (lambda (value length)
      (let ((~value (unwrap-GVariant* value))
            (~length (unwrap~pointer length)))
        (wrap-gchar* (~f ~value ~length))))))
(export g_variant_dup_bytestring)

;; extern const gchar **g_variant_get_bytestring_array(GVariant *value, gsize *
;;     length);
;; ... failed.

;; extern gchar **g_variant_dup_bytestring_array(GVariant *value, gsize *length
;;     );
;; ... failed.

;; extern GVariant *g_variant_new_maybe(const GVariantType *child_type, 
;;     GVariant *child);
(define g_variant_new_maybe
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_new_maybe"
                (dynamic-link))
              (list '* '*))))
    (lambda (child_type child)
      (let ((~child_type (unwrap-GVariantType* child_type))
            (~child (unwrap-GVariant* child)))
        (wrap-GVariant* (~f ~child_type ~child))))))
(export g_variant_new_maybe)

;; extern GVariant *g_variant_new_array(const GVariantType *child_type, 
;;     GVariant *const*children, gsize n_children);
(define g_variant_new_array
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_new_array"
                (dynamic-link))
              (list '* '* ffi:unsigned-long))))
    (lambda (child_type children n_children)
      (let ((~child_type (unwrap-GVariantType* child_type))
            (~children (unwrap~pointer children))
            (~n_children (unwrap~fixed n_children)))
        (wrap-GVariant*
          (~f ~child_type ~children ~n_children))))))
(export g_variant_new_array)

;; extern GVariant *g_variant_new_tuple(GVariant *const*children, gsize 
;;     n_children);
(define g_variant_new_tuple
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_new_tuple"
                (dynamic-link))
              (list '* ffi:unsigned-long))))
    (lambda (children n_children)
      (let ((~children (unwrap~pointer children))
            (~n_children (unwrap~fixed n_children)))
        (wrap-GVariant* (~f ~children ~n_children))))))
(export g_variant_new_tuple)

;; extern GVariant *g_variant_new_dict_entry(GVariant *key, GVariant *value);
(define g_variant_new_dict_entry
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_new_dict_entry"
                (dynamic-link))
              (list '* '*))))
    (lambda (key value)
      (let ((~key (unwrap-GVariant* key))
            (~value (unwrap-GVariant* value)))
        (wrap-GVariant* (~f ~key ~value))))))
(export g_variant_new_dict_entry)

;; extern GVariant *g_variant_get_maybe(GVariant *value);
(define g_variant_get_maybe
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_get_maybe"
                (dynamic-link))
              (list '*))))
    (lambda (value)
      (let ((~value (unwrap-GVariant* value)))
        (wrap-GVariant* (~f ~value))))))
(export g_variant_get_maybe)

;; extern gsize g_variant_n_children(GVariant *value);
(define g_variant_n_children
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-long
              (dynamic-func
                "g_variant_n_children"
                (dynamic-link))
              (list '*))))
    (lambda (value)
      (let ((~value (unwrap-GVariant* value)))
        (~f ~value)))))
(export g_variant_n_children)

;; extern void g_variant_get_child(GVariant *value, gsize index_, const gchar *
;;     format_string, ...);
;; ... failed.

;; extern GVariant *g_variant_get_child_value(GVariant *value, gsize index_);
(define g_variant_get_child_value
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_get_child_value"
                (dynamic-link))
              (list '* ffi:unsigned-long))))
    (lambda (value index_)
      (let ((~value (unwrap-GVariant* value))
            (~index_ (unwrap~fixed index_)))
        (wrap-GVariant* (~f ~value ~index_))))))
(export g_variant_get_child_value)

;; extern gboolean g_variant_lookup(GVariant *dictionary, const gchar *key, 
;;     const gchar *format_string, ...);
;; ... failed.

;; extern GVariant *g_variant_lookup_value(GVariant *dictionary, const gchar *
;;     key, const GVariantType *expected_type);
(define g_variant_lookup_value
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_lookup_value"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (dictionary key expected_type)
      (let ((~dictionary (unwrap-GVariant* dictionary))
            (~key (unwrap-gchar* key))
            (~expected_type
              (unwrap-GVariantType* expected_type)))
        (wrap-GVariant*
          (~f ~dictionary ~key ~expected_type))))))
(export g_variant_lookup_value)

;; extern gconstpointer g_variant_get_fixed_array(GVariant *value, gsize *
;;     n_elements, gsize element_size);
(define g_variant_get_fixed_array
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_get_fixed_array"
                (dynamic-link))
              (list '* '* ffi:unsigned-long))))
    (lambda (value n_elements element_size)
      (let ((~value (unwrap-GVariant* value))
            (~n_elements (unwrap~pointer n_elements))
            (~element_size (unwrap~fixed element_size)))
        (wrap-gconstpointer
          (~f ~value ~n_elements ~element_size))))))
(export g_variant_get_fixed_array)

;; extern gsize g_variant_get_size(GVariant *value);
(define g_variant_get_size
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-long
              (dynamic-func
                "g_variant_get_size"
                (dynamic-link))
              (list '*))))
    (lambda (value)
      (let ((~value (unwrap-GVariant* value)))
        (~f ~value)))))
(export g_variant_get_size)

;; extern gconstpointer g_variant_get_data(GVariant *value);
(define g_variant_get_data
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_get_data"
                (dynamic-link))
              (list '*))))
    (lambda (value)
      (let ((~value (unwrap-GVariant* value)))
        (wrap-gconstpointer (~f ~value))))))
(export g_variant_get_data)

;; extern GBytes *g_variant_get_data_as_bytes(GVariant *value);
(define g_variant_get_data_as_bytes
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_get_data_as_bytes"
                (dynamic-link))
              (list '*))))
    (lambda (value)
      (let ((~value (unwrap-GVariant* value)))
        (wrap-GBytes* (~f ~value))))))
(export g_variant_get_data_as_bytes)

;; extern void g_variant_store(GVariant *value, gpointer data);
(define g_variant_store
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_variant_store" (dynamic-link))
              (list '* '*))))
    (lambda (value data)
      (let ((~value (unwrap-GVariant* value))
            (~data (unwrap-gpointer data)))
        (~f ~value ~data)))))
(export g_variant_store)

;; extern gchar *g_variant_print(GVariant *value, gboolean type_annotate);
(define g_variant_print
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_variant_print" (dynamic-link))
              (list '* ffi:int))))
    (lambda (value type_annotate)
      (let ((~value (unwrap-GVariant* value))
            (~type_annotate (unwrap-gboolean type_annotate)))
        (wrap-gchar* (~f ~value ~type_annotate))))))
(export g_variant_print)

;; extern GString *g_variant_print_string(GVariant *value, GString *string, 
;;     gboolean type_annotate);
(define g_variant_print_string
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_print_string"
                (dynamic-link))
              (list '* '* ffi:int))))
    (lambda (value string type_annotate)
      (let ((~value (unwrap-GVariant* value))
            (~string (unwrap-GString* string))
            (~type_annotate (unwrap-gboolean type_annotate)))
        (wrap-GString*
          (~f ~value ~string ~type_annotate))))))
(export g_variant_print_string)

;; extern guint g_variant_hash(gconstpointer value);
(define g_variant_hash
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func "g_variant_hash" (dynamic-link))
              (list '*))))
    (lambda (value)
      (let ((~value (unwrap-gconstpointer value)))
        (wrap-guint (~f ~value))))))
(export g_variant_hash)

;; extern gboolean g_variant_equal(gconstpointer one, gconstpointer two);
(define g_variant_equal
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_variant_equal" (dynamic-link))
              (list '* '*))))
    (lambda (one two)
      (let ((~one (unwrap-gconstpointer one))
            (~two (unwrap-gconstpointer two)))
        (wrap-gboolean (~f ~one ~two))))))
(export g_variant_equal)

;; extern GVariant *g_variant_get_normal_form(GVariant *value);
(define g_variant_get_normal_form
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_get_normal_form"
                (dynamic-link))
              (list '*))))
    (lambda (value)
      (let ((~value (unwrap-GVariant* value)))
        (wrap-GVariant* (~f ~value))))))
(export g_variant_get_normal_form)

;; extern gboolean g_variant_is_normal_form(GVariant *value);
(define g_variant_is_normal_form
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_variant_is_normal_form"
                (dynamic-link))
              (list '*))))
    (lambda (value)
      (let ((~value (unwrap-GVariant* value)))
        (wrap-gboolean (~f ~value))))))
(export g_variant_is_normal_form)

;; extern GVariant *g_variant_byteswap(GVariant *value);
(define g_variant_byteswap
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_byteswap"
                (dynamic-link))
              (list '*))))
    (lambda (value)
      (let ((~value (unwrap-GVariant* value)))
        (wrap-GVariant* (~f ~value))))))
(export g_variant_byteswap)

;; extern GVariant *g_variant_new_from_bytes(const GVariantType *type, GBytes *
;;     bytes, gboolean trusted);
(define g_variant_new_from_bytes
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_new_from_bytes"
                (dynamic-link))
              (list '* '* ffi:int))))
    (lambda (type bytes trusted)
      (let ((~type (unwrap-GVariantType* type))
            (~bytes (unwrap-GBytes* bytes))
            (~trusted (unwrap-gboolean trusted)))
        (wrap-GVariant* (~f ~type ~bytes ~trusted))))))
(export g_variant_new_from_bytes)

;; extern GVariant *g_variant_new_from_data(const GVariantType *type, 
;;     gconstpointer data, gsize size, gboolean trusted, GDestroyNotify notify
;;     , gpointer user_data);
(define g_variant_new_from_data
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_new_from_data"
                (dynamic-link))
              (list '* '* ffi:unsigned-long ffi:int '* '*))))
    (lambda (type data size trusted notify user_data)
      (let ((~type (unwrap-GVariantType* type))
            (~data (unwrap-gconstpointer data))
            (~size (unwrap~fixed size))
            (~trusted (unwrap-gboolean trusted))
            (~notify
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               notify))
            (~user_data (unwrap-gpointer user_data)))
        (wrap-GVariant*
          (~f ~type
              ~data
              ~size
              ~trusted
              ~notify
              ~user_data))))))
(export g_variant_new_from_data)

;; typedef struct _GVariantIter GVariantIter;
(define GVariantIter-desc void)
(define GVariantIter*-desc (bs:pointer (delay GVariantIter-desc)))
(define-fh-pointer-type GVariantIter* GVariantIter*-desc)

;; struct _GVariantIter {
;;   /*< private >*/
;;   gsize x[16];
;; };
(define struct-_GVariantIter-desc
  (bs:struct (list `(x ,(bs:vector 16 void)))))
(export struct-_GVariantIter-desc)
(define-fh-compound-type/p struct-_GVariantIter struct-_GVariantIter-desc)
(set! GVariantIter-desc struct-_GVariantIter-desc)
(define-fh-compound-type GVariantIter GVariantIter-desc)

;; extern GVariantIter *g_variant_iter_new(GVariant *value);
(define g_variant_iter_new
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_iter_new"
                (dynamic-link))
              (list '*))))
    (lambda (value)
      (let ((~value (unwrap-GVariant* value)))
        (wrap-GVariantIter* (~f ~value))))))
(export g_variant_iter_new)

;; extern gsize g_variant_iter_init(GVariantIter *iter, GVariant *value);
(define g_variant_iter_init
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-long
              (dynamic-func
                "g_variant_iter_init"
                (dynamic-link))
              (list '* '*))))
    (lambda (iter value)
      (let ((~iter (unwrap-GVariantIter* iter))
            (~value (unwrap-GVariant* value)))
        (~f ~iter ~value)))))
(export g_variant_iter_init)

;; extern GVariantIter *g_variant_iter_copy(GVariantIter *iter);
(define g_variant_iter_copy
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_iter_copy"
                (dynamic-link))
              (list '*))))
    (lambda (iter)
      (let ((~iter (unwrap-GVariantIter* iter)))
        (wrap-GVariantIter* (~f ~iter))))))
(export g_variant_iter_copy)

;; extern gsize g_variant_iter_n_children(GVariantIter *iter);
(define g_variant_iter_n_children
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-long
              (dynamic-func
                "g_variant_iter_n_children"
                (dynamic-link))
              (list '*))))
    (lambda (iter)
      (let ((~iter (unwrap-GVariantIter* iter)))
        (~f ~iter)))))
(export g_variant_iter_n_children)

;; extern void g_variant_iter_free(GVariantIter *iter);
(define g_variant_iter_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_variant_iter_free"
                (dynamic-link))
              (list '*))))
    (lambda (iter)
      (let ((~iter (unwrap-GVariantIter* iter)))
        (~f ~iter)))))
(export g_variant_iter_free)

;; extern GVariant *g_variant_iter_next_value(GVariantIter *iter);
(define g_variant_iter_next_value
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_iter_next_value"
                (dynamic-link))
              (list '*))))
    (lambda (iter)
      (let ((~iter (unwrap-GVariantIter* iter)))
        (wrap-GVariant* (~f ~iter))))))
(export g_variant_iter_next_value)

;; extern gboolean g_variant_iter_next(GVariantIter *iter, const gchar *
;;     format_string, ...);
;; ... failed.

;; extern gboolean g_variant_iter_loop(GVariantIter *iter, const gchar *
;;     format_string, ...);
;; ... failed.

;; typedef struct _GVariantBuilder GVariantBuilder;
(define GVariantBuilder-desc void)
(define GVariantBuilder*-desc (bs:pointer (delay GVariantBuilder-desc)))
(define-fh-pointer-type GVariantBuilder* GVariantBuilder*-desc)

;; struct _GVariantBuilder {
;;   /*< private >*/
;;   union {
;;     struct {
;;       gsize partial_magic;
;;       const GVariantType *type;
;;       gsize y[14];
;;     } s;
;;     gsize x[16];
;;   } u;
;; };
(define struct-_GVariantBuilder-desc
  (bs:struct
    (list `(u ,(bs:union
                 (list `(s ,(bs:struct
                              (list `(partial_magic ,unsigned-long)
                                    `(type ,(bs:pointer GVariantType*-desc))
                                    `(y ,(bs:vector 14 void)))))
                       `(x ,(bs:vector 16 void))))))))
(export struct-_GVariantBuilder-desc)
(define-fh-compound-type/p struct-_GVariantBuilder struct-_GVariantBuilder-desc)
(set! GVariantBuilder-desc struct-_GVariantBuilder-desc)
(define-fh-compound-type GVariantBuilder GVariantBuilder-desc)

;; typedef enum {
;;   G_VARIANT_PARSE_ERROR_FAILED,
;;   G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED,
;;   G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE,
;;   G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED,
;;   G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END,
;;   G_VARIANT_PARSE_ERROR_INVALID_CHARACTER,
;;   G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING,
;;   G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH,
;;   G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE,
;;   G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING,
;;   G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE,
;;   G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE,
;;   G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG,
;;   G_VARIANT_PARSE_ERROR_TYPE_ERROR,
;;   G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN,
;;   G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD,
;;   G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT,
;;   G_VARIANT_PARSE_ERROR_VALUE_EXPECTED,
;; } GVariantParseError;
(define-fh-enum GVariantParseError
  '((G_VARIANT_PARSE_ERROR_FAILED . 0)
    (G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED . 1)
    (G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE . 2)
    (G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED
      .
      3)
    (G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END . 4)
    (G_VARIANT_PARSE_ERROR_INVALID_CHARACTER . 5)
    (G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING . 6)
    (G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH . 7)
    (G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE . 8)
    (G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING . 9)
    (G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE . 10)
    (G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE . 11)
    (G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG . 12)
    (G_VARIANT_PARSE_ERROR_TYPE_ERROR . 13)
    (G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN . 14)
    (G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD . 15)
    (G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT
      .
      16)
    (G_VARIANT_PARSE_ERROR_VALUE_EXPECTED . 17))
  )

;; extern GQuark g_variant_parser_get_error_quark(void);
(define g_variant_parser_get_error_quark
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func
                "g_variant_parser_get_error_quark"
                (dynamic-link))
              (list))))
    (lambda () (let () (wrap-GQuark (~f))))))
(export g_variant_parser_get_error_quark)

;; extern GQuark g_variant_parse_error_quark(void);
(define g_variant_parse_error_quark
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func
                "g_variant_parse_error_quark"
                (dynamic-link))
              (list))))
    (lambda () (let () (wrap-GQuark (~f))))))
(export g_variant_parse_error_quark)

;; extern GVariantBuilder *g_variant_builder_new(const GVariantType *type);
(define g_variant_builder_new
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_builder_new"
                (dynamic-link))
              (list '*))))
    (lambda (type)
      (let ((~type (unwrap-GVariantType* type)))
        (wrap-GVariantBuilder* (~f ~type))))))
(export g_variant_builder_new)

;; extern void g_variant_builder_unref(GVariantBuilder *builder);
(define g_variant_builder_unref
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_variant_builder_unref"
                (dynamic-link))
              (list '*))))
    (lambda (builder)
      (let ((~builder (unwrap-GVariantBuilder* builder)))
        (~f ~builder)))))
(export g_variant_builder_unref)

;; extern GVariantBuilder *g_variant_builder_ref(GVariantBuilder *builder);
(define g_variant_builder_ref
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_builder_ref"
                (dynamic-link))
              (list '*))))
    (lambda (builder)
      (let ((~builder (unwrap-GVariantBuilder* builder)))
        (wrap-GVariantBuilder* (~f ~builder))))))
(export g_variant_builder_ref)

;; extern void g_variant_builder_init(GVariantBuilder *builder, const 
;;     GVariantType *type);
(define g_variant_builder_init
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_variant_builder_init"
                (dynamic-link))
              (list '* '*))))
    (lambda (builder type)
      (let ((~builder (unwrap-GVariantBuilder* builder))
            (~type (unwrap-GVariantType* type)))
        (~f ~builder ~type)))))
(export g_variant_builder_init)

;; extern GVariant *g_variant_builder_end(GVariantBuilder *builder);
(define g_variant_builder_end
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_builder_end"
                (dynamic-link))
              (list '*))))
    (lambda (builder)
      (let ((~builder (unwrap-GVariantBuilder* builder)))
        (wrap-GVariant* (~f ~builder))))))
(export g_variant_builder_end)

;; extern void g_variant_builder_clear(GVariantBuilder *builder);
(define g_variant_builder_clear
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_variant_builder_clear"
                (dynamic-link))
              (list '*))))
    (lambda (builder)
      (let ((~builder (unwrap-GVariantBuilder* builder)))
        (~f ~builder)))))
(export g_variant_builder_clear)

;; extern void g_variant_builder_open(GVariantBuilder *builder, const 
;;     GVariantType *type);
(define g_variant_builder_open
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_variant_builder_open"
                (dynamic-link))
              (list '* '*))))
    (lambda (builder type)
      (let ((~builder (unwrap-GVariantBuilder* builder))
            (~type (unwrap-GVariantType* type)))
        (~f ~builder ~type)))))
(export g_variant_builder_open)

;; extern void g_variant_builder_close(GVariantBuilder *builder);
(define g_variant_builder_close
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_variant_builder_close"
                (dynamic-link))
              (list '*))))
    (lambda (builder)
      (let ((~builder (unwrap-GVariantBuilder* builder)))
        (~f ~builder)))))
(export g_variant_builder_close)

;; extern void g_variant_builder_add_value(GVariantBuilder *builder, GVariant *
;;     value);
(define g_variant_builder_add_value
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_variant_builder_add_value"
                (dynamic-link))
              (list '* '*))))
    (lambda (builder value)
      (let ((~builder (unwrap-GVariantBuilder* builder))
            (~value (unwrap-GVariant* value)))
        (~f ~builder ~value)))))
(export g_variant_builder_add_value)

;; extern void g_variant_builder_add(GVariantBuilder *builder, const gchar *
;;     format_string, ...);
;; ... failed.

;; extern void g_variant_builder_add_parsed(GVariantBuilder *builder, const 
;;     gchar *format, ...);
;; ... failed.

;; extern GVariant *g_variant_new(const gchar *format_string, ...);
;; ... failed.

;; extern void g_variant_get(GVariant *value, const gchar *format_string, ...)
;;     ;
;; ... failed.

;; extern GVariant *g_variant_new_va(const gchar *format_string, const gchar **
;;     endptr, va_list *app);
(define g_variant_new_va
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_variant_new_va" (dynamic-link))
              (list '* '* '*))))
    (lambda (format_string endptr app)
      (let ((~format_string (unwrap-gchar* format_string))
            (~endptr (unwrap~pointer endptr))
            (~app (unwrap~pointer app)))
        (wrap-GVariant* (~f ~format_string ~endptr ~app))))))
(export g_variant_new_va)

;; extern void g_variant_get_va(GVariant *value, const gchar *format_string, 
;;     const gchar **endptr, va_list *app);
(define g_variant_get_va
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_variant_get_va" (dynamic-link))
              (list '* '* '* '*))))
    (lambda (value format_string endptr app)
      (let ((~value (unwrap-GVariant* value))
            (~format_string (unwrap-gchar* format_string))
            (~endptr (unwrap~pointer endptr))
            (~app (unwrap~pointer app)))
        (~f ~value ~format_string ~endptr ~app)))))
(export g_variant_get_va)

;; extern gboolean g_variant_check_format_string(GVariant *value, const gchar *
;;     format_string, gboolean copy_only);
(define g_variant_check_format_string
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_variant_check_format_string"
                (dynamic-link))
              (list '* '* ffi:int))))
    (lambda (value format_string copy_only)
      (let ((~value (unwrap-GVariant* value))
            (~format_string (unwrap-gchar* format_string))
            (~copy_only (unwrap-gboolean copy_only)))
        (wrap-gboolean
          (~f ~value ~format_string ~copy_only))))))
(export g_variant_check_format_string)

;; extern GVariant *g_variant_parse(const GVariantType *type, const gchar *text
;;     , const gchar *limit, const gchar **endptr, GError **error);
(define g_variant_parse
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_variant_parse" (dynamic-link))
              (list '* '* '* '* '*))))
    (lambda (type text limit endptr error)
      (let ((~type (unwrap-GVariantType* type))
            (~text (unwrap-gchar* text))
            (~limit (unwrap-gchar* limit))
            (~endptr (unwrap~pointer endptr))
            (~error (unwrap~pointer error)))
        (wrap-GVariant*
          (~f ~type ~text ~limit ~endptr ~error))))))
(export g_variant_parse)

;; extern GVariant *g_variant_new_parsed(const gchar *format, ...);
;; ... failed.

;; extern GVariant *g_variant_new_parsed_va(const gchar *format, va_list *app)
;;     ;
(define g_variant_new_parsed_va
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_new_parsed_va"
                (dynamic-link))
              (list '* '*))))
    (lambda (format app)
      (let ((~format (unwrap-gchar* format))
            (~app (unwrap~pointer app)))
        (wrap-GVariant* (~f ~format ~app))))))
(export g_variant_new_parsed_va)

;; extern gchar *g_variant_parse_error_print_context(GError *error, const gchar
;;      *source_str);
(define g_variant_parse_error_print_context
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_parse_error_print_context"
                (dynamic-link))
              (list '* '*))))
    (lambda (error source_str)
      (let ((~error (unwrap-GError* error))
            (~source_str (unwrap-gchar* source_str)))
        (wrap-gchar* (~f ~error ~source_str))))))
(export g_variant_parse_error_print_context)

;; extern gint g_variant_compare(gconstpointer one, gconstpointer two);
(define g_variant_compare
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_variant_compare" (dynamic-link))
              (list '* '*))))
    (lambda (one two)
      (let ((~one (unwrap-gconstpointer one))
            (~two (unwrap-gconstpointer two)))
        (wrap-gint (~f ~one ~two))))))
(export g_variant_compare)

;; typedef struct _GVariantDict GVariantDict;
(define GVariantDict-desc void)
(define GVariantDict*-desc (bs:pointer (delay GVariantDict-desc)))
(define-fh-pointer-type GVariantDict* GVariantDict*-desc)

;; struct _GVariantDict {
;;   /*< private >*/
;;   union {
;;     struct {
;;       GVariant *asv;
;;       gsize partial_magic;
;;       gsize y[14];
;;     } s;
;;     gsize x[16];
;;   } u;
;; };
(define struct-_GVariantDict-desc
  (bs:struct
    (list `(u ,(bs:union
                 (list `(s ,(bs:struct
                              (list `(asv ,(bs:pointer GVariant*-desc))
                                    `(partial_magic ,unsigned-long)
                                    `(y ,(bs:vector 14 void)))))
                       `(x ,(bs:vector 16 void))))))))
(export struct-_GVariantDict-desc)
(define-fh-compound-type/p struct-_GVariantDict struct-_GVariantDict-desc)
(set! GVariantDict-desc struct-_GVariantDict-desc)
(define-fh-compound-type GVariantDict GVariantDict-desc)

;; extern GVariantDict *g_variant_dict_new(GVariant *from_asv);
(define g_variant_dict_new
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_dict_new"
                (dynamic-link))
              (list '*))))
    (lambda (from_asv)
      (let ((~from_asv (unwrap-GVariant* from_asv)))
        (wrap-GVariantDict* (~f ~from_asv))))))
(export g_variant_dict_new)

;; extern void g_variant_dict_init(GVariantDict *dict, GVariant *from_asv);
(define g_variant_dict_init
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_variant_dict_init"
                (dynamic-link))
              (list '* '*))))
    (lambda (dict from_asv)
      (let ((~dict (unwrap-GVariantDict* dict))
            (~from_asv (unwrap-GVariant* from_asv)))
        (~f ~dict ~from_asv)))))
(export g_variant_dict_init)

;; extern gboolean g_variant_dict_lookup(GVariantDict *dict, const gchar *key, 
;;     const gchar *format_string, ...);
;; ... failed.

;; extern GVariant *g_variant_dict_lookup_value(GVariantDict *dict, const gchar
;;      *key, const GVariantType *expected_type);
(define g_variant_dict_lookup_value
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_dict_lookup_value"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (dict key expected_type)
      (let ((~dict (unwrap-GVariantDict* dict))
            (~key (unwrap-gchar* key))
            (~expected_type
              (unwrap-GVariantType* expected_type)))
        (wrap-GVariant* (~f ~dict ~key ~expected_type))))))
(export g_variant_dict_lookup_value)

;; extern gboolean g_variant_dict_contains(GVariantDict *dict, const gchar *key
;;     );
(define g_variant_dict_contains
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_variant_dict_contains"
                (dynamic-link))
              (list '* '*))))
    (lambda (dict key)
      (let ((~dict (unwrap-GVariantDict* dict))
            (~key (unwrap-gchar* key)))
        (wrap-gboolean (~f ~dict ~key))))))
(export g_variant_dict_contains)

;; extern void g_variant_dict_insert(GVariantDict *dict, const gchar *key, 
;;     const gchar *format_string, ...);
;; ... failed.

;; extern void g_variant_dict_insert_value(GVariantDict *dict, const gchar *key
;;     , GVariant *value);
(define g_variant_dict_insert_value
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_variant_dict_insert_value"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (dict key value)
      (let ((~dict (unwrap-GVariantDict* dict))
            (~key (unwrap-gchar* key))
            (~value (unwrap-GVariant* value)))
        (~f ~dict ~key ~value)))))
(export g_variant_dict_insert_value)

;; extern gboolean g_variant_dict_remove(GVariantDict *dict, const gchar *key)
;;     ;
(define g_variant_dict_remove
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_variant_dict_remove"
                (dynamic-link))
              (list '* '*))))
    (lambda (dict key)
      (let ((~dict (unwrap-GVariantDict* dict))
            (~key (unwrap-gchar* key)))
        (wrap-gboolean (~f ~dict ~key))))))
(export g_variant_dict_remove)

;; extern void g_variant_dict_clear(GVariantDict *dict);
(define g_variant_dict_clear
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_variant_dict_clear"
                (dynamic-link))
              (list '*))))
    (lambda (dict)
      (let ((~dict (unwrap-GVariantDict* dict)))
        (~f ~dict)))))
(export g_variant_dict_clear)

;; extern GVariant *g_variant_dict_end(GVariantDict *dict);
(define g_variant_dict_end
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_dict_end"
                (dynamic-link))
              (list '*))))
    (lambda (dict)
      (let ((~dict (unwrap-GVariantDict* dict)))
        (wrap-GVariant* (~f ~dict))))))
(export g_variant_dict_end)

;; extern GVariantDict *g_variant_dict_ref(GVariantDict *dict);
(define g_variant_dict_ref
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_variant_dict_ref"
                (dynamic-link))
              (list '*))))
    (lambda (dict)
      (let ((~dict (unwrap-GVariantDict* dict)))
        (wrap-GVariantDict* (~f ~dict))))))
(export g_variant_dict_ref)

;; extern void g_variant_dict_unref(GVariantDict *dict);
(define g_variant_dict_unref
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_variant_dict_unref"
                (dynamic-link))
              (list '*))))
    (lambda (dict)
      (let ((~dict (unwrap-GVariantDict* dict)))
        (~f ~dict)))))
(export g_variant_dict_unref)

;; extern gsize g_printf_string_upper_bound(const gchar *format, va_list args)
;;     ;
(define g_printf_string_upper_bound
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-long
              (dynamic-func
                "g_printf_string_upper_bound"
                (dynamic-link))
              (list '* '*))))
    (lambda (format args)
      (let ((~format (unwrap-gchar* format))
            (~args (unwrap~pointer args)))
        (~f ~format ~args)))))
(export g_printf_string_upper_bound)

;; typedef enum {
;;   G_LOG_FLAG_RECURSION = 1<<0,
;;   G_LOG_FLAG_FATAL = 1<<1,
;;   G_LOG_LEVEL_ERROR = 1<<2,
;;   G_LOG_LEVEL_CRITICAL = 1<<3,
;;   G_LOG_LEVEL_WARNING = 1<<4,
;;   G_LOG_LEVEL_MESSAGE = 1<<5,
;;   G_LOG_LEVEL_INFO = 1<<6,
;;   G_LOG_LEVEL_DEBUG = 1<<7,
;;   G_LOG_LEVEL_MASK = ~(G_LOG_FLAG_RECURSION | G_LOG_FLAG_FATAL),
;; } GLogLevelFlags;
(define-fh-enum GLogLevelFlags
  '((G_LOG_FLAG_RECURSION . 1)
    (G_LOG_FLAG_FATAL . 2)
    (G_LOG_LEVEL_ERROR . 4)
    (G_LOG_LEVEL_CRITICAL . 8)
    (G_LOG_LEVEL_WARNING . 16)
    (G_LOG_LEVEL_MESSAGE . 32)
    (G_LOG_LEVEL_INFO . 64)
    (G_LOG_LEVEL_DEBUG . 128)
    (G_LOG_LEVEL_MASK . -4))
  )

;; typedef void (*GLogFunc)(const gchar *log_domain, GLogLevelFlags log_level, 
;;     const gchar *message, gpointer user_data);
(define-fh-function/p GLogFunc
  ffi:void (list (quote *) ffi:int (quote *) (quote *)))

;; extern guint g_log_set_handler(const gchar *log_domain, GLogLevelFlags 
;;     log_levels, GLogFunc log_func, gpointer user_data);
(define g_log_set_handler
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func "g_log_set_handler" (dynamic-link))
              (list '* ffi:int '* '*))))
    (lambda (log_domain log_levels log_func user_data)
      (let ((~log_domain (unwrap-gchar* log_domain))
            (~log_levels (unwrap~fixed log_levels))
            (~log_func
              ((make-ftn-arg-unwrapper
                 ffi:void
                 (list '* ffi:int '* '*))
               log_func))
            (~user_data (unwrap-gpointer user_data)))
        (wrap-guint
          (~f ~log_domain ~log_levels ~log_func ~user_data))))))
(export g_log_set_handler)

;; extern guint g_log_set_handler_full(const gchar *log_domain, GLogLevelFlags 
;;     log_levels, GLogFunc log_func, gpointer user_data, GDestroyNotify 
;;     destroy);
(define g_log_set_handler_full
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func
                "g_log_set_handler_full"
                (dynamic-link))
              (list '* ffi:int '* '* '*))))
    (lambda (log_domain
             log_levels
             log_func
             user_data
             destroy)
      (let ((~log_domain (unwrap-gchar* log_domain))
            (~log_levels (unwrap~fixed log_levels))
            (~log_func
              ((make-ftn-arg-unwrapper
                 ffi:void
                 (list '* ffi:int '* '*))
               log_func))
            (~user_data (unwrap-gpointer user_data))
            (~destroy
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               destroy)))
        (wrap-guint
          (~f ~log_domain
              ~log_levels
              ~log_func
              ~user_data
              ~destroy))))))
(export g_log_set_handler_full)

;; extern void g_log_remove_handler(const gchar *log_domain, guint handler_id)
;;     ;
(define g_log_remove_handler
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_log_remove_handler"
                (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (log_domain handler_id)
      (let ((~log_domain (unwrap-gchar* log_domain))
            (~handler_id (unwrap-guint handler_id)))
        (~f ~log_domain ~handler_id)))))
(export g_log_remove_handler)

;; extern void g_log_default_handler(const gchar *log_domain, GLogLevelFlags 
;;     log_level, const gchar *message, gpointer unused_data);
(define g_log_default_handler
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_log_default_handler"
                (dynamic-link))
              (list '* ffi:int '* '*))))
    (lambda (log_domain log_level message unused_data)
      (let ((~log_domain (unwrap-gchar* log_domain))
            (~log_level (unwrap~fixed log_level))
            (~message (unwrap-gchar* message))
            (~unused_data (unwrap-gpointer unused_data)))
        (~f ~log_domain ~log_level ~message ~unused_data)))))
(export g_log_default_handler)

;; extern GLogFunc g_log_set_default_handler(GLogFunc log_func, gpointer 
;;     user_data);
(define g_log_set_default_handler
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_log_set_default_handler"
                (dynamic-link))
              (list '* '*))))
    (lambda (log_func user_data)
      (let ((~log_func
              ((make-ftn-arg-unwrapper
                 ffi:void
                 (list '* ffi:int '* '*))
               log_func))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~log_func ~user_data)))))
(export g_log_set_default_handler)

;; extern void g_log(const gchar *log_domain, GLogLevelFlags log_level, const 
;;     gchar *format, ...);
;; ... failed.

;; extern void g_logv(const gchar *log_domain, GLogLevelFlags log_level, const 
;;     gchar *format, va_list args);
(define g_logv
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_logv" (dynamic-link))
              (list '* ffi:int '* '*))))
    (lambda (log_domain log_level format args)
      (let ((~log_domain (unwrap-gchar* log_domain))
            (~log_level (unwrap~fixed log_level))
            (~format (unwrap-gchar* format))
            (~args (unwrap~pointer args)))
        (~f ~log_domain ~log_level ~format ~args)))))
(export g_logv)

;; extern GLogLevelFlags g_log_set_fatal_mask(const gchar *log_domain, 
;;     GLogLevelFlags fatal_mask);
(define g_log_set_fatal_mask
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_log_set_fatal_mask"
                (dynamic-link))
              (list '* ffi:int))))
    (lambda (log_domain fatal_mask)
      (let ((~log_domain (unwrap-gchar* log_domain))
            (~fatal_mask (unwrap~fixed fatal_mask)))
        (~f ~log_domain ~fatal_mask)))))
(export g_log_set_fatal_mask)

;; extern GLogLevelFlags g_log_set_always_fatal(GLogLevelFlags fatal_mask);
(define g_log_set_always_fatal
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_log_set_always_fatal"
                (dynamic-link))
              (list ffi:int))))
    (lambda (fatal_mask)
      (let ((~fatal_mask (unwrap~fixed fatal_mask)))
        (~f ~fatal_mask)))))
(export g_log_set_always_fatal)

;; typedef enum {
;;   G_LOG_WRITER_HANDLED = 1,
;;   G_LOG_WRITER_UNHANDLED = 0,
;; } GLogWriterOutput;
(define-fh-enum GLogWriterOutput
  '((G_LOG_WRITER_HANDLED . 1)
    (G_LOG_WRITER_UNHANDLED . 0))
  )

;; typedef struct _GLogField GLogField;
(define GLogField-desc void)
(define GLogField*-desc (bs:pointer (delay GLogField-desc)))
(define-fh-pointer-type GLogField* GLogField*-desc)

;; struct _GLogField {
;;   const gchar *key;
;;   gconstpointer value;
;;   gssize length;
;; };
(define struct-_GLogField-desc
  (bs:struct
    (list `(key ,(bs:pointer gchar*-desc))
          `(value ,gconstpointer-desc)
          `(length ,#f))))
(export struct-_GLogField-desc)
(define-fh-compound-type/p struct-_GLogField struct-_GLogField-desc)
(set! GLogField-desc struct-_GLogField-desc)
(define-fh-compound-type GLogField GLogField-desc)

;; typedef GLogWriterOutput (*GLogWriterFunc)(GLogLevelFlags log_level, const 
;;     GLogField *fields, gsize n_fields, gpointer user_data);
(define-fh-function/p GLogWriterFunc
  ffi:int (list ffi:int (quote *) ffi:unsigned-long (quote *)))

;; extern void g_log_structured(const gchar *log_domain, GLogLevelFlags 
;;     log_level, ...);
;; ... failed.

;; extern void g_log_structured_array(GLogLevelFlags log_level, const GLogField
;;      *fields, gsize n_fields);
(define g_log_structured_array
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_log_structured_array"
                (dynamic-link))
              (list ffi:int '* ffi:unsigned-long))))
    (lambda (log_level fields n_fields)
      (let ((~log_level (unwrap~fixed log_level))
            (~fields (unwrap-GLogField* fields))
            (~n_fields (unwrap~fixed n_fields)))
        (~f ~log_level ~fields ~n_fields)))))
(export g_log_structured_array)

;; extern void g_log_variant(const gchar *log_domain, GLogLevelFlags log_level
;;     , GVariant *fields);
(define g_log_variant
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_log_variant" (dynamic-link))
              (list '* ffi:int '*))))
    (lambda (log_domain log_level fields)
      (let ((~log_domain (unwrap-gchar* log_domain))
            (~log_level (unwrap~fixed log_level))
            (~fields (unwrap-GVariant* fields)))
        (~f ~log_domain ~log_level ~fields)))))
(export g_log_variant)

;; extern void g_log_set_writer_func(GLogWriterFunc func, gpointer user_data, 
;;     GDestroyNotify user_data_free);
(define g_log_set_writer_func
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_log_set_writer_func"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (func user_data user_data_free)
      (let ((~func ((make-ftn-arg-unwrapper
                      ffi:void
                      (list ffi:int '* ffi:unsigned-long '*))
                    func))
            (~user_data (unwrap-gpointer user_data))
            (~user_data_free
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               user_data_free)))
        (~f ~func ~user_data ~user_data_free)))))
(export g_log_set_writer_func)

;; extern gboolean g_log_writer_supports_color(gint output_fd);
(define g_log_writer_supports_color
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_log_writer_supports_color"
                (dynamic-link))
              (list ffi:int))))
    (lambda (output_fd)
      (let ((~output_fd (unwrap-gint output_fd)))
        (wrap-gboolean (~f ~output_fd))))))
(export g_log_writer_supports_color)

;; extern gboolean g_log_writer_is_journald(gint output_fd);
(define g_log_writer_is_journald
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_log_writer_is_journald"
                (dynamic-link))
              (list ffi:int))))
    (lambda (output_fd)
      (let ((~output_fd (unwrap-gint output_fd)))
        (wrap-gboolean (~f ~output_fd))))))
(export g_log_writer_is_journald)

;; extern gchar *g_log_writer_format_fields(GLogLevelFlags log_level, const 
;;     GLogField *fields, gsize n_fields, gboolean use_color);
(define g_log_writer_format_fields
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_log_writer_format_fields"
                (dynamic-link))
              (list ffi:int '* ffi:unsigned-long ffi:int))))
    (lambda (log_level fields n_fields use_color)
      (let ((~log_level (unwrap~fixed log_level))
            (~fields (unwrap-GLogField* fields))
            (~n_fields (unwrap~fixed n_fields))
            (~use_color (unwrap-gboolean use_color)))
        (wrap-gchar*
          (~f ~log_level ~fields ~n_fields ~use_color))))))
(export g_log_writer_format_fields)

;; extern GLogWriterOutput g_log_writer_journald(GLogLevelFlags log_level, 
;;     const GLogField *fields, gsize n_fields, gpointer user_data);
(define g_log_writer_journald
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_log_writer_journald"
                (dynamic-link))
              (list ffi:int '* ffi:unsigned-long '*))))
    (lambda (log_level fields n_fields user_data)
      (let ((~log_level (unwrap~fixed log_level))
            (~fields (unwrap-GLogField* fields))
            (~n_fields (unwrap~fixed n_fields))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~log_level ~fields ~n_fields ~user_data)))))
(export g_log_writer_journald)

;; extern GLogWriterOutput g_log_writer_standard_streams(GLogLevelFlags 
;;     log_level, const GLogField *fields, gsize n_fields, gpointer user_data)
;;     ;
(define g_log_writer_standard_streams
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_log_writer_standard_streams"
                (dynamic-link))
              (list ffi:int '* ffi:unsigned-long '*))))
    (lambda (log_level fields n_fields user_data)
      (let ((~log_level (unwrap~fixed log_level))
            (~fields (unwrap-GLogField* fields))
            (~n_fields (unwrap~fixed n_fields))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~log_level ~fields ~n_fields ~user_data)))))
(export g_log_writer_standard_streams)

;; extern GLogWriterOutput g_log_writer_default(GLogLevelFlags log_level, const
;;      GLogField *fields, gsize n_fields, gpointer user_data);
(define g_log_writer_default
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_log_writer_default"
                (dynamic-link))
              (list ffi:int '* ffi:unsigned-long '*))))
    (lambda (log_level fields n_fields user_data)
      (let ((~log_level (unwrap~fixed log_level))
            (~fields (unwrap-GLogField* fields))
            (~n_fields (unwrap~fixed n_fields))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~log_level ~fields ~n_fields ~user_data)))))
(export g_log_writer_default)

;; void _g_log_fallback_handler(const gchar *log_domain, GLogLevelFlags 
;;     log_level, const gchar *message, gpointer unused_data);
(define _g_log_fallback_handler
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "_g_log_fallback_handler"
                (dynamic-link))
              (list '* ffi:int '* '*))))
    (lambda (log_domain log_level message unused_data)
      (let ((~log_domain (unwrap-gchar* log_domain))
            (~log_level (unwrap~fixed log_level))
            (~message (unwrap-gchar* message))
            (~unused_data (unwrap-gpointer unused_data)))
        (~f ~log_domain ~log_level ~message ~unused_data)))))
(export _g_log_fallback_handler)

;; extern void g_return_if_fail_warning(const char *log_domain, const char *
;;     pretty_function, const char *expression);
(define g_return_if_fail_warning
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_return_if_fail_warning"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (log_domain pretty_function expression)
      (let ((~log_domain (unwrap~pointer log_domain))
            (~pretty_function
              (unwrap~pointer pretty_function))
            (~expression (unwrap~pointer expression)))
        (~f ~log_domain ~pretty_function ~expression)))))
(export g_return_if_fail_warning)

;; extern void g_warn_message(const char *domain, const char *file, int line, 
;;     const char *func, const char *warnexpr);
(define g_warn_message
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_warn_message" (dynamic-link))
              (list '* '* ffi:int '* '*))))
    (lambda (domain file line func warnexpr)
      (let ((~domain (unwrap~pointer domain))
            (~file (unwrap~pointer file))
            (~line (unwrap~fixed line))
            (~func (unwrap~pointer func))
            (~warnexpr (unwrap~pointer warnexpr)))
        (~f ~domain ~file ~line ~func ~warnexpr)))))
(export g_warn_message)

;; extern void g_assert_warning(const char *log_domain, const char *file, const
;;      int line, const char *pretty_function, const char *expression);
(define g_assert_warning
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_assert_warning" (dynamic-link))
              (list '* '* ffi:int '* '*))))
    (lambda (log_domain file line pretty_function expression)
      (let ((~log_domain (unwrap~pointer log_domain))
            (~file (unwrap~pointer file))
            (~line (unwrap~fixed line))
            (~pretty_function
              (unwrap~pointer pretty_function))
            (~expression (unwrap~pointer expression)))
        (~f ~log_domain
            ~file
            ~line
            ~pretty_function
            ~expression)))))
(export g_assert_warning)

;; typedef void (*GPrintFunc)(const gchar *string);
(define-fh-function/p GPrintFunc
  ffi:void (list (quote *)))

;; extern void g_print(const gchar *format, ...);
;; ... failed.

;; extern GPrintFunc g_set_print_handler(GPrintFunc func);
(define g_set_print_handler
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_set_print_handler"
                (dynamic-link))
              (list '*))))
    (lambda (func)
      (let ((~func ((make-ftn-arg-unwrapper ffi:void (list '*))
                    func)))
        (~f ~func)))))
(export g_set_print_handler)

;; extern void g_printerr(const gchar *format, ...);
;; ... failed.

;; extern GPrintFunc g_set_printerr_handler(GPrintFunc func);
(define g_set_printerr_handler
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_set_printerr_handler"
                (dynamic-link))
              (list '*))))
    (lambda (func)
      (let ((~func ((make-ftn-arg-unwrapper ffi:void (list '*))
                    func)))
        (~f ~func)))))
(export g_set_printerr_handler)

;; typedef struct _GOptionContext GOptionContext;
(define GOptionContext-desc void)
(define GOptionContext*-desc (bs:pointer GOptionContext-desc))
(define-fh-pointer-type GOptionContext* GOptionContext*-desc)

;; typedef struct _GOptionGroup GOptionGroup;
(define GOptionGroup-desc void)
(define GOptionGroup*-desc (bs:pointer GOptionGroup-desc))
(define-fh-pointer-type GOptionGroup* GOptionGroup*-desc)

;; typedef struct _GOptionEntry GOptionEntry;
(define GOptionEntry-desc void)
(define GOptionEntry*-desc (bs:pointer (delay GOptionEntry-desc)))
(define-fh-pointer-type GOptionEntry* GOptionEntry*-desc)

;; typedef enum {
;;   G_OPTION_FLAG_NONE = 0,
;;   G_OPTION_FLAG_HIDDEN = 1<<0,
;;   G_OPTION_FLAG_IN_MAIN = 1<<1,
;;   G_OPTION_FLAG_REVERSE = 1<<2,
;;   G_OPTION_FLAG_NO_ARG = 1<<3,
;;   G_OPTION_FLAG_FILENAME = 1<<4,
;;   G_OPTION_FLAG_OPTIONAL_ARG = 1<<5,
;;   G_OPTION_FLAG_NOALIAS = 1<<6,
;; } GOptionFlags;
(define-fh-enum GOptionFlags
  '((G_OPTION_FLAG_NONE . 0)
    (G_OPTION_FLAG_HIDDEN . 1)
    (G_OPTION_FLAG_IN_MAIN . 2)
    (G_OPTION_FLAG_REVERSE . 4)
    (G_OPTION_FLAG_NO_ARG . 8)
    (G_OPTION_FLAG_FILENAME . 16)
    (G_OPTION_FLAG_OPTIONAL_ARG . 32)
    (G_OPTION_FLAG_NOALIAS . 64))
  )

;; typedef enum {
;;   G_OPTION_ARG_NONE,
;;   G_OPTION_ARG_STRING,
;;   G_OPTION_ARG_INT,
;;   G_OPTION_ARG_CALLBACK,
;;   G_OPTION_ARG_FILENAME,
;;   G_OPTION_ARG_STRING_ARRAY,
;;   G_OPTION_ARG_FILENAME_ARRAY,
;;   G_OPTION_ARG_DOUBLE,
;;   G_OPTION_ARG_INT64,
;; } GOptionArg;
(define-fh-enum GOptionArg
  '((G_OPTION_ARG_NONE . 0)
    (G_OPTION_ARG_STRING . 1)
    (G_OPTION_ARG_INT . 2)
    (G_OPTION_ARG_CALLBACK . 3)
    (G_OPTION_ARG_FILENAME . 4)
    (G_OPTION_ARG_STRING_ARRAY . 5)
    (G_OPTION_ARG_FILENAME_ARRAY . 6)
    (G_OPTION_ARG_DOUBLE . 7)
    (G_OPTION_ARG_INT64 . 8))
  )

;; typedef gboolean (*GOptionArgFunc)(const gchar *option_name, const gchar *
;;     value, gpointer data, GError **error);
(define-fh-function/p GOptionArgFunc
  ffi:int (list (quote *) (quote *) (quote *) (quote *)))

;; typedef gboolean (*GOptionParseFunc)(GOptionContext *context, GOptionGroup *
;;     group, gpointer data, GError **error);
(define-fh-function/p GOptionParseFunc
  ffi:int (list (quote *) (quote *) (quote *) (quote *)))

;; typedef void (*GOptionErrorFunc)(GOptionContext *context, GOptionGroup *
;;     group, gpointer data, GError **error);
(define-fh-function/p GOptionErrorFunc
  ffi:void (list (quote *) (quote *) (quote *) (quote *)))

;; typedef enum {
;;   G_OPTION_ERROR_UNKNOWN_OPTION,
;;   G_OPTION_ERROR_BAD_VALUE,
;;   G_OPTION_ERROR_FAILED,
;; } GOptionError;
(define-fh-enum GOptionError
  '((G_OPTION_ERROR_UNKNOWN_OPTION . 0)
    (G_OPTION_ERROR_BAD_VALUE . 1)
    (G_OPTION_ERROR_FAILED . 2))
  )

;; extern GQuark g_option_error_quark(void);
(define g_option_error_quark
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func
                "g_option_error_quark"
                (dynamic-link))
              (list))))
    (lambda () (let () (wrap-GQuark (~f))))))
(export g_option_error_quark)

;; struct _GOptionEntry {
;;   const gchar *long_name;
;;   gchar short_name;
;;   gint flags;
;;   GOptionArg arg;
;;   gpointer arg_data;
;;   const gchar *description;
;;   const gchar *arg_description;
;; };
(define struct-_GOptionEntry-desc
  (bs:struct
    (list `(long_name ,(bs:pointer gchar*-desc))
          `(short_name ,gchar-desc)
          `(flags ,gint-desc)
          `(arg ,int)
          `(arg_data ,gpointer-desc)
          `(description ,(bs:pointer gchar*-desc))
          `(arg_description ,(bs:pointer gchar*-desc)))))
(export struct-_GOptionEntry-desc)
(define-fh-compound-type/p struct-_GOptionEntry struct-_GOptionEntry-desc)
(set! GOptionEntry-desc struct-_GOptionEntry-desc)
(define-fh-compound-type GOptionEntry GOptionEntry-desc)

;; extern GOptionContext *g_option_context_new(const gchar *parameter_string);
(define g_option_context_new
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_option_context_new"
                (dynamic-link))
              (list '*))))
    (lambda (parameter_string)
      (let ((~parameter_string
              (unwrap-gchar* parameter_string)))
        (wrap-GOptionContext* (~f ~parameter_string))))))
(export g_option_context_new)

;; extern void g_option_context_set_summary(GOptionContext *context, const 
;;     gchar *summary);
(define g_option_context_set_summary
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_option_context_set_summary"
                (dynamic-link))
              (list '* '*))))
    (lambda (context summary)
      (let ((~context (unwrap-GOptionContext* context))
            (~summary (unwrap-gchar* summary)))
        (~f ~context ~summary)))))
(export g_option_context_set_summary)

;; extern const gchar *g_option_context_get_summary(GOptionContext *context);
(define g_option_context_get_summary
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_option_context_get_summary"
                (dynamic-link))
              (list '*))))
    (lambda (context)
      (let ((~context (unwrap-GOptionContext* context)))
        (wrap-gchar* (~f ~context))))))
(export g_option_context_get_summary)

;; extern void g_option_context_set_description(GOptionContext *context, const 
;;     gchar *description);
(define g_option_context_set_description
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_option_context_set_description"
                (dynamic-link))
              (list '* '*))))
    (lambda (context description)
      (let ((~context (unwrap-GOptionContext* context))
            (~description (unwrap-gchar* description)))
        (~f ~context ~description)))))
(export g_option_context_set_description)

;; extern const gchar *g_option_context_get_description(GOptionContext *context
;;     );
(define g_option_context_get_description
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_option_context_get_description"
                (dynamic-link))
              (list '*))))
    (lambda (context)
      (let ((~context (unwrap-GOptionContext* context)))
        (wrap-gchar* (~f ~context))))))
(export g_option_context_get_description)

;; extern void g_option_context_free(GOptionContext *context);
(define g_option_context_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_option_context_free"
                (dynamic-link))
              (list '*))))
    (lambda (context)
      (let ((~context (unwrap-GOptionContext* context)))
        (~f ~context)))))
(export g_option_context_free)

;; extern void g_option_context_set_help_enabled(GOptionContext *context, 
;;     gboolean help_enabled);
(define g_option_context_set_help_enabled
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_option_context_set_help_enabled"
                (dynamic-link))
              (list '* ffi:int))))
    (lambda (context help_enabled)
      (let ((~context (unwrap-GOptionContext* context))
            (~help_enabled (unwrap-gboolean help_enabled)))
        (~f ~context ~help_enabled)))))
(export g_option_context_set_help_enabled)

;; extern gboolean g_option_context_get_help_enabled(GOptionContext *context);
(define g_option_context_get_help_enabled
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_option_context_get_help_enabled"
                (dynamic-link))
              (list '*))))
    (lambda (context)
      (let ((~context (unwrap-GOptionContext* context)))
        (wrap-gboolean (~f ~context))))))
(export g_option_context_get_help_enabled)

;; extern void g_option_context_set_ignore_unknown_options(GOptionContext *
;;     context, gboolean ignore_unknown);
(define g_option_context_set_ignore_unknown_options
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_option_context_set_ignore_unknown_options"
                (dynamic-link))
              (list '* ffi:int))))
    (lambda (context ignore_unknown)
      (let ((~context (unwrap-GOptionContext* context))
            (~ignore_unknown
              (unwrap-gboolean ignore_unknown)))
        (~f ~context ~ignore_unknown)))))
(export g_option_context_set_ignore_unknown_options)

;; extern gboolean g_option_context_get_ignore_unknown_options(GOptionContext *
;;     context);
(define g_option_context_get_ignore_unknown_options
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_option_context_get_ignore_unknown_options"
                (dynamic-link))
              (list '*))))
    (lambda (context)
      (let ((~context (unwrap-GOptionContext* context)))
        (wrap-gboolean (~f ~context))))))
(export g_option_context_get_ignore_unknown_options)

;; extern void g_option_context_set_strict_posix(GOptionContext *context, 
;;     gboolean strict_posix);
(define g_option_context_set_strict_posix
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_option_context_set_strict_posix"
                (dynamic-link))
              (list '* ffi:int))))
    (lambda (context strict_posix)
      (let ((~context (unwrap-GOptionContext* context))
            (~strict_posix (unwrap-gboolean strict_posix)))
        (~f ~context ~strict_posix)))))
(export g_option_context_set_strict_posix)

;; extern gboolean g_option_context_get_strict_posix(GOptionContext *context);
(define g_option_context_get_strict_posix
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_option_context_get_strict_posix"
                (dynamic-link))
              (list '*))))
    (lambda (context)
      (let ((~context (unwrap-GOptionContext* context)))
        (wrap-gboolean (~f ~context))))))
(export g_option_context_get_strict_posix)

;; extern void g_option_context_add_main_entries(GOptionContext *context, const
;;      GOptionEntry *entries, const gchar *translation_domain);
(define g_option_context_add_main_entries
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_option_context_add_main_entries"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (context entries translation_domain)
      (let ((~context (unwrap-GOptionContext* context))
            (~entries (unwrap-GOptionEntry* entries))
            (~translation_domain
              (unwrap-gchar* translation_domain)))
        (~f ~context ~entries ~translation_domain)))))
(export g_option_context_add_main_entries)

;; extern gboolean g_option_context_parse(GOptionContext *context, gint *argc, 
;;     gchar ***argv, GError **error);
(define g_option_context_parse
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_option_context_parse"
                (dynamic-link))
              (list '* '* '* '*))))
    (lambda (context argc argv error)
      (let ((~context (unwrap-GOptionContext* context))
            (~argc (unwrap-gint* argc))
            (~argv (unwrap~pointer argv))
            (~error (unwrap~pointer error)))
        (wrap-gboolean (~f ~context ~argc ~argv ~error))))))
(export g_option_context_parse)

;; extern gboolean g_option_context_parse_strv(GOptionContext *context, gchar *
;;     **arguments, GError **error);
(define g_option_context_parse_strv
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_option_context_parse_strv"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (context arguments error)
      (let ((~context (unwrap-GOptionContext* context))
            (~arguments (unwrap~pointer arguments))
            (~error (unwrap~pointer error)))
        (wrap-gboolean (~f ~context ~arguments ~error))))))
(export g_option_context_parse_strv)

;; extern void g_option_context_set_translate_func(GOptionContext *context, 
;;     GTranslateFunc func, gpointer data, GDestroyNotify destroy_notify);
(define g_option_context_set_translate_func
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_option_context_set_translate_func"
                (dynamic-link))
              (list '* '* '* '*))))
    (lambda (context func data destroy_notify)
      (let ((~context (unwrap-GOptionContext* context))
            (~func ((make-ftn-arg-unwrapper '* (list '* '*)) func))
            (~data (unwrap-gpointer data))
            (~destroy_notify
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               destroy_notify)))
        (~f ~context ~func ~data ~destroy_notify)))))
(export g_option_context_set_translate_func)

;; extern void g_option_context_set_translation_domain(GOptionContext *context
;;     , const gchar *domain);
(define g_option_context_set_translation_domain
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_option_context_set_translation_domain"
                (dynamic-link))
              (list '* '*))))
    (lambda (context domain)
      (let ((~context (unwrap-GOptionContext* context))
            (~domain (unwrap-gchar* domain)))
        (~f ~context ~domain)))))
(export g_option_context_set_translation_domain)

;; extern void g_option_context_add_group(GOptionContext *context, GOptionGroup
;;      *group);
(define g_option_context_add_group
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_option_context_add_group"
                (dynamic-link))
              (list '* '*))))
    (lambda (context group)
      (let ((~context (unwrap-GOptionContext* context))
            (~group (unwrap-GOptionGroup* group)))
        (~f ~context ~group)))))
(export g_option_context_add_group)

;; extern void g_option_context_set_main_group(GOptionContext *context, 
;;     GOptionGroup *group);
(define g_option_context_set_main_group
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_option_context_set_main_group"
                (dynamic-link))
              (list '* '*))))
    (lambda (context group)
      (let ((~context (unwrap-GOptionContext* context))
            (~group (unwrap-GOptionGroup* group)))
        (~f ~context ~group)))))
(export g_option_context_set_main_group)

;; extern GOptionGroup *g_option_context_get_main_group(GOptionContext *context
;;     );
(define g_option_context_get_main_group
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_option_context_get_main_group"
                (dynamic-link))
              (list '*))))
    (lambda (context)
      (let ((~context (unwrap-GOptionContext* context)))
        (wrap-GOptionGroup* (~f ~context))))))
(export g_option_context_get_main_group)

;; extern gchar *g_option_context_get_help(GOptionContext *context, gboolean 
;;     main_help, GOptionGroup *group);
(define g_option_context_get_help
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_option_context_get_help"
                (dynamic-link))
              (list '* ffi:int '*))))
    (lambda (context main_help group)
      (let ((~context (unwrap-GOptionContext* context))
            (~main_help (unwrap-gboolean main_help))
            (~group (unwrap-GOptionGroup* group)))
        (wrap-gchar* (~f ~context ~main_help ~group))))))
(export g_option_context_get_help)

;; extern GOptionGroup *g_option_group_new(const gchar *name, const gchar *
;;     description, const gchar *help_description, gpointer user_data, 
;;     GDestroyNotify destroy);
(define g_option_group_new
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_option_group_new"
                (dynamic-link))
              (list '* '* '* '* '*))))
    (lambda (name
             description
             help_description
             user_data
             destroy)
      (let ((~name (unwrap-gchar* name))
            (~description (unwrap-gchar* description))
            (~help_description
              (unwrap-gchar* help_description))
            (~user_data (unwrap-gpointer user_data))
            (~destroy
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               destroy)))
        (wrap-GOptionGroup*
          (~f ~name
              ~description
              ~help_description
              ~user_data
              ~destroy))))))
(export g_option_group_new)

;; extern void g_option_group_set_parse_hooks(GOptionGroup *group, 
;;     GOptionParseFunc pre_parse_func, GOptionParseFunc post_parse_func);
;; ... failed.

;; extern void g_option_group_set_error_hook(GOptionGroup *group, 
;;     GOptionErrorFunc error_func);
(define g_option_group_set_error_hook
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_option_group_set_error_hook"
                (dynamic-link))
              (list '* '*))))
    (lambda (group error_func)
      (let ((~group (unwrap-GOptionGroup* group))
            (~error_func
              ((make-ftn-arg-unwrapper
                 ffi:void
                 (list '* '* '* '*))
               error_func)))
        (~f ~group ~error_func)))))
(export g_option_group_set_error_hook)

;; extern void g_option_group_free(GOptionGroup *group);
(define g_option_group_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_option_group_free"
                (dynamic-link))
              (list '*))))
    (lambda (group)
      (let ((~group (unwrap-GOptionGroup* group)))
        (~f ~group)))))
(export g_option_group_free)

;; extern GOptionGroup *g_option_group_ref(GOptionGroup *group);
(define g_option_group_ref
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_option_group_ref"
                (dynamic-link))
              (list '*))))
    (lambda (group)
      (let ((~group (unwrap-GOptionGroup* group)))
        (wrap-GOptionGroup* (~f ~group))))))
(export g_option_group_ref)

;; extern void g_option_group_unref(GOptionGroup *group);
(define g_option_group_unref
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_option_group_unref"
                (dynamic-link))
              (list '*))))
    (lambda (group)
      (let ((~group (unwrap-GOptionGroup* group)))
        (~f ~group)))))
(export g_option_group_unref)

;; extern void g_option_group_add_entries(GOptionGroup *group, const 
;;     GOptionEntry *entries);
(define g_option_group_add_entries
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_option_group_add_entries"
                (dynamic-link))
              (list '* '*))))
    (lambda (group entries)
      (let ((~group (unwrap-GOptionGroup* group))
            (~entries (unwrap-GOptionEntry* entries)))
        (~f ~group ~entries)))))
(export g_option_group_add_entries)

;; extern void g_option_group_set_translate_func(GOptionGroup *group, 
;;     GTranslateFunc func, gpointer data, GDestroyNotify destroy_notify);
(define g_option_group_set_translate_func
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_option_group_set_translate_func"
                (dynamic-link))
              (list '* '* '* '*))))
    (lambda (group func data destroy_notify)
      (let ((~group (unwrap-GOptionGroup* group))
            (~func ((make-ftn-arg-unwrapper '* (list '* '*)) func))
            (~data (unwrap-gpointer data))
            (~destroy_notify
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               destroy_notify)))
        (~f ~group ~func ~data ~destroy_notify)))))
(export g_option_group_set_translate_func)

;; extern void g_option_group_set_translation_domain(GOptionGroup *group, const
;;      gchar *domain);
(define g_option_group_set_translation_domain
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_option_group_set_translation_domain"
                (dynamic-link))
              (list '* '*))))
    (lambda (group domain)
      (let ((~group (unwrap-GOptionGroup* group))
            (~domain (unwrap-gchar* domain)))
        (~f ~group ~domain)))))
(export g_option_group_set_translation_domain)

;; typedef struct _GPatternSpec GPatternSpec;
(define GPatternSpec-desc void)
(define GPatternSpec*-desc (bs:pointer GPatternSpec-desc))
(define-fh-pointer-type GPatternSpec* GPatternSpec*-desc)

;; extern GPatternSpec *g_pattern_spec_new(const gchar *pattern);
(define g_pattern_spec_new
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_pattern_spec_new"
                (dynamic-link))
              (list '*))))
    (lambda (pattern)
      (let ((~pattern (unwrap-gchar* pattern)))
        (wrap-GPatternSpec* (~f ~pattern))))))
(export g_pattern_spec_new)

;; extern void g_pattern_spec_free(GPatternSpec *pspec);
(define g_pattern_spec_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_pattern_spec_free"
                (dynamic-link))
              (list '*))))
    (lambda (pspec)
      (let ((~pspec (unwrap-GPatternSpec* pspec)))
        (~f ~pspec)))))
(export g_pattern_spec_free)

;; extern gboolean g_pattern_spec_equal(GPatternSpec *pspec1, GPatternSpec *
;;     pspec2);
(define g_pattern_spec_equal
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_pattern_spec_equal"
                (dynamic-link))
              (list '* '*))))
    (lambda (pspec1 pspec2)
      (let ((~pspec1 (unwrap-GPatternSpec* pspec1))
            (~pspec2 (unwrap-GPatternSpec* pspec2)))
        (wrap-gboolean (~f ~pspec1 ~pspec2))))))
(export g_pattern_spec_equal)

;; extern gboolean g_pattern_match(GPatternSpec *pspec, guint string_length, 
;;     const gchar *string, const gchar *string_reversed);
(define g_pattern_match
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_pattern_match" (dynamic-link))
              (list '* ffi:unsigned-int '* '*))))
    (lambda (pspec string_length string string_reversed)
      (let ((~pspec (unwrap-GPatternSpec* pspec))
            (~string_length (unwrap-guint string_length))
            (~string (unwrap-gchar* string))
            (~string_reversed
              (unwrap-gchar* string_reversed)))
        (wrap-gboolean
          (~f ~pspec
              ~string_length
              ~string
              ~string_reversed))))))
(export g_pattern_match)

;; extern gboolean g_pattern_match_string(GPatternSpec *pspec, const gchar *
;;     string);
(define g_pattern_match_string
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_pattern_match_string"
                (dynamic-link))
              (list '* '*))))
    (lambda (pspec string)
      (let ((~pspec (unwrap-GPatternSpec* pspec))
            (~string (unwrap-gchar* string)))
        (wrap-gboolean (~f ~pspec ~string))))))
(export g_pattern_match_string)

;; extern gboolean g_pattern_match_simple(const gchar *pattern, const gchar *
;;     string);
(define g_pattern_match_simple
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_pattern_match_simple"
                (dynamic-link))
              (list '* '*))))
    (lambda (pattern string)
      (let ((~pattern (unwrap-gchar* pattern))
            (~string (unwrap-gchar* string)))
        (wrap-gboolean (~f ~pattern ~string))))))
(export g_pattern_match_simple)

;; extern guint g_spaced_primes_closest(guint num);
(define g_spaced_primes_closest
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func
                "g_spaced_primes_closest"
                (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (num)
      (let ((~num (unwrap-guint num)))
        (wrap-guint (~f ~num))))))
(export g_spaced_primes_closest)

;; extern void g_qsort_with_data(gconstpointer pbase, gint total_elems, gsize 
;;     size, GCompareDataFunc compare_func, gpointer user_data);
;; ... failed.

;; typedef struct _GQueue GQueue;
(define GQueue-desc void)
(define GQueue*-desc (bs:pointer (delay GQueue-desc)))
(define-fh-pointer-type GQueue* GQueue*-desc)

;; struct _GQueue {
;;   GList *head;
;;   GList *tail;
;;   guint length;
;; };
(define struct-_GQueue-desc
  (bs:struct
    (list `(head ,(bs:pointer GList*-desc))
          `(tail ,(bs:pointer GList*-desc))
          `(length ,guint-desc))))
(export struct-_GQueue-desc)
(define-fh-compound-type/p struct-_GQueue struct-_GQueue-desc)
(set! GQueue-desc struct-_GQueue-desc)
(define-fh-compound-type GQueue GQueue-desc)

;; extern GQueue *g_queue_new(void);
(define g_queue_new
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_queue_new" (dynamic-link))
              (list))))
    (lambda () (let () (wrap-GQueue* (~f))))))
(export g_queue_new)

;; extern void g_queue_free(GQueue *queue);
(define g_queue_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_queue_free" (dynamic-link))
              (list '*))))
    (lambda (queue)
      (let ((~queue (unwrap-GQueue* queue)))
        (~f ~queue)))))
(export g_queue_free)

;; extern void g_queue_free_full(GQueue *queue, GDestroyNotify free_func);
(define g_queue_free_full
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_queue_free_full" (dynamic-link))
              (list '* '*))))
    (lambda (queue free_func)
      (let ((~queue (unwrap-GQueue* queue))
            (~free_func
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               free_func)))
        (~f ~queue ~free_func)))))
(export g_queue_free_full)

;; extern void g_queue_init(GQueue *queue);
(define g_queue_init
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_queue_init" (dynamic-link))
              (list '*))))
    (lambda (queue)
      (let ((~queue (unwrap-GQueue* queue)))
        (~f ~queue)))))
(export g_queue_init)

;; extern void g_queue_clear(GQueue *queue);
(define g_queue_clear
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_queue_clear" (dynamic-link))
              (list '*))))
    (lambda (queue)
      (let ((~queue (unwrap-GQueue* queue)))
        (~f ~queue)))))
(export g_queue_clear)

;; extern gboolean g_queue_is_empty(GQueue *queue);
(define g_queue_is_empty
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_queue_is_empty" (dynamic-link))
              (list '*))))
    (lambda (queue)
      (let ((~queue (unwrap-GQueue* queue)))
        (wrap-gboolean (~f ~queue))))))
(export g_queue_is_empty)

;; extern guint g_queue_get_length(GQueue *queue);
(define g_queue_get_length
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func
                "g_queue_get_length"
                (dynamic-link))
              (list '*))))
    (lambda (queue)
      (let ((~queue (unwrap-GQueue* queue)))
        (wrap-guint (~f ~queue))))))
(export g_queue_get_length)

;; extern void g_queue_reverse(GQueue *queue);
(define g_queue_reverse
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_queue_reverse" (dynamic-link))
              (list '*))))
    (lambda (queue)
      (let ((~queue (unwrap-GQueue* queue)))
        (~f ~queue)))))
(export g_queue_reverse)

;; extern GQueue *g_queue_copy(GQueue *queue);
(define g_queue_copy
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_queue_copy" (dynamic-link))
              (list '*))))
    (lambda (queue)
      (let ((~queue (unwrap-GQueue* queue)))
        (wrap-GQueue* (~f ~queue))))))
(export g_queue_copy)

;; extern void g_queue_foreach(GQueue *queue, GFunc func, gpointer user_data);
(define g_queue_foreach
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_queue_foreach" (dynamic-link))
              (list '* '* '*))))
    (lambda (queue func user_data)
      (let ((~queue (unwrap-GQueue* queue))
            (~func ((make-ftn-arg-unwrapper ffi:void (list '* '*))
                    func))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~queue ~func ~user_data)))))
(export g_queue_foreach)

;; extern GList *g_queue_find(GQueue *queue, gconstpointer data);
(define g_queue_find
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_queue_find" (dynamic-link))
              (list '* '*))))
    (lambda (queue data)
      (let ((~queue (unwrap-GQueue* queue))
            (~data (unwrap-gconstpointer data)))
        (wrap-GList* (~f ~queue ~data))))))
(export g_queue_find)

;; extern GList *g_queue_find_custom(GQueue *queue, gconstpointer data, 
;;     GCompareFunc func);
;; ... failed.

;; extern void g_queue_sort(GQueue *queue, GCompareDataFunc compare_func, 
;;     gpointer user_data);
;; ... failed.

;; extern void g_queue_push_head(GQueue *queue, gpointer data);
(define g_queue_push_head
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_queue_push_head" (dynamic-link))
              (list '* '*))))
    (lambda (queue data)
      (let ((~queue (unwrap-GQueue* queue))
            (~data (unwrap-gpointer data)))
        (~f ~queue ~data)))))
(export g_queue_push_head)

;; extern void g_queue_push_tail(GQueue *queue, gpointer data);
(define g_queue_push_tail
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_queue_push_tail" (dynamic-link))
              (list '* '*))))
    (lambda (queue data)
      (let ((~queue (unwrap-GQueue* queue))
            (~data (unwrap-gpointer data)))
        (~f ~queue ~data)))))
(export g_queue_push_tail)

;; extern void g_queue_push_nth(GQueue *queue, gpointer data, gint n);
(define g_queue_push_nth
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_queue_push_nth" (dynamic-link))
              (list '* '* ffi:int))))
    (lambda (queue data n)
      (let ((~queue (unwrap-GQueue* queue))
            (~data (unwrap-gpointer data))
            (~n (unwrap-gint n)))
        (~f ~queue ~data ~n)))))
(export g_queue_push_nth)

;; extern gpointer g_queue_pop_head(GQueue *queue);
(define g_queue_pop_head
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_queue_pop_head" (dynamic-link))
              (list '*))))
    (lambda (queue)
      (let ((~queue (unwrap-GQueue* queue)))
        (wrap-gpointer (~f ~queue))))))
(export g_queue_pop_head)

;; extern gpointer g_queue_pop_tail(GQueue *queue);
(define g_queue_pop_tail
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_queue_pop_tail" (dynamic-link))
              (list '*))))
    (lambda (queue)
      (let ((~queue (unwrap-GQueue* queue)))
        (wrap-gpointer (~f ~queue))))))
(export g_queue_pop_tail)

;; extern gpointer g_queue_pop_nth(GQueue *queue, guint n);
(define g_queue_pop_nth
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_queue_pop_nth" (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (queue n)
      (let ((~queue (unwrap-GQueue* queue))
            (~n (unwrap-guint n)))
        (wrap-gpointer (~f ~queue ~n))))))
(export g_queue_pop_nth)

;; extern gpointer g_queue_peek_head(GQueue *queue);
(define g_queue_peek_head
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_queue_peek_head" (dynamic-link))
              (list '*))))
    (lambda (queue)
      (let ((~queue (unwrap-GQueue* queue)))
        (wrap-gpointer (~f ~queue))))))
(export g_queue_peek_head)

;; extern gpointer g_queue_peek_tail(GQueue *queue);
(define g_queue_peek_tail
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_queue_peek_tail" (dynamic-link))
              (list '*))))
    (lambda (queue)
      (let ((~queue (unwrap-GQueue* queue)))
        (wrap-gpointer (~f ~queue))))))
(export g_queue_peek_tail)

;; extern gpointer g_queue_peek_nth(GQueue *queue, guint n);
(define g_queue_peek_nth
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_queue_peek_nth" (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (queue n)
      (let ((~queue (unwrap-GQueue* queue))
            (~n (unwrap-guint n)))
        (wrap-gpointer (~f ~queue ~n))))))
(export g_queue_peek_nth)

;; extern gint g_queue_index(GQueue *queue, gconstpointer data);
(define g_queue_index
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_queue_index" (dynamic-link))
              (list '* '*))))
    (lambda (queue data)
      (let ((~queue (unwrap-GQueue* queue))
            (~data (unwrap-gconstpointer data)))
        (wrap-gint (~f ~queue ~data))))))
(export g_queue_index)

;; extern gboolean g_queue_remove(GQueue *queue, gconstpointer data);
(define g_queue_remove
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_queue_remove" (dynamic-link))
              (list '* '*))))
    (lambda (queue data)
      (let ((~queue (unwrap-GQueue* queue))
            (~data (unwrap-gconstpointer data)))
        (wrap-gboolean (~f ~queue ~data))))))
(export g_queue_remove)

;; extern guint g_queue_remove_all(GQueue *queue, gconstpointer data);
(define g_queue_remove_all
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func
                "g_queue_remove_all"
                (dynamic-link))
              (list '* '*))))
    (lambda (queue data)
      (let ((~queue (unwrap-GQueue* queue))
            (~data (unwrap-gconstpointer data)))
        (wrap-guint (~f ~queue ~data))))))
(export g_queue_remove_all)

;; extern void g_queue_insert_before(GQueue *queue, GList *sibling, gpointer 
;;     data);
(define g_queue_insert_before
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_queue_insert_before"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (queue sibling data)
      (let ((~queue (unwrap-GQueue* queue))
            (~sibling (unwrap-GList* sibling))
            (~data (unwrap-gpointer data)))
        (~f ~queue ~sibling ~data)))))
(export g_queue_insert_before)

;; extern void g_queue_insert_after(GQueue *queue, GList *sibling, gpointer 
;;     data);
(define g_queue_insert_after
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_queue_insert_after"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (queue sibling data)
      (let ((~queue (unwrap-GQueue* queue))
            (~sibling (unwrap-GList* sibling))
            (~data (unwrap-gpointer data)))
        (~f ~queue ~sibling ~data)))))
(export g_queue_insert_after)

;; extern void g_queue_insert_sorted(GQueue *queue, gpointer data, 
;;     GCompareDataFunc func, gpointer user_data);
;; ... failed.

;; extern void g_queue_push_head_link(GQueue *queue, GList *link_);
(define g_queue_push_head_link
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_queue_push_head_link"
                (dynamic-link))
              (list '* '*))))
    (lambda (queue link_)
      (let ((~queue (unwrap-GQueue* queue))
            (~link_ (unwrap-GList* link_)))
        (~f ~queue ~link_)))))
(export g_queue_push_head_link)

;; extern void g_queue_push_tail_link(GQueue *queue, GList *link_);
(define g_queue_push_tail_link
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_queue_push_tail_link"
                (dynamic-link))
              (list '* '*))))
    (lambda (queue link_)
      (let ((~queue (unwrap-GQueue* queue))
            (~link_ (unwrap-GList* link_)))
        (~f ~queue ~link_)))))
(export g_queue_push_tail_link)

;; extern void g_queue_push_nth_link(GQueue *queue, gint n, GList *link_);
(define g_queue_push_nth_link
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_queue_push_nth_link"
                (dynamic-link))
              (list '* ffi:int '*))))
    (lambda (queue n link_)
      (let ((~queue (unwrap-GQueue* queue))
            (~n (unwrap-gint n))
            (~link_ (unwrap-GList* link_)))
        (~f ~queue ~n ~link_)))))
(export g_queue_push_nth_link)

;; extern GList *g_queue_pop_head_link(GQueue *queue);
(define g_queue_pop_head_link
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_queue_pop_head_link"
                (dynamic-link))
              (list '*))))
    (lambda (queue)
      (let ((~queue (unwrap-GQueue* queue)))
        (wrap-GList* (~f ~queue))))))
(export g_queue_pop_head_link)

;; extern GList *g_queue_pop_tail_link(GQueue *queue);
(define g_queue_pop_tail_link
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_queue_pop_tail_link"
                (dynamic-link))
              (list '*))))
    (lambda (queue)
      (let ((~queue (unwrap-GQueue* queue)))
        (wrap-GList* (~f ~queue))))))
(export g_queue_pop_tail_link)

;; extern GList *g_queue_pop_nth_link(GQueue *queue, guint n);
(define g_queue_pop_nth_link
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_queue_pop_nth_link"
                (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (queue n)
      (let ((~queue (unwrap-GQueue* queue))
            (~n (unwrap-guint n)))
        (wrap-GList* (~f ~queue ~n))))))
(export g_queue_pop_nth_link)

;; extern GList *g_queue_peek_head_link(GQueue *queue);
(define g_queue_peek_head_link
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_queue_peek_head_link"
                (dynamic-link))
              (list '*))))
    (lambda (queue)
      (let ((~queue (unwrap-GQueue* queue)))
        (wrap-GList* (~f ~queue))))))
(export g_queue_peek_head_link)

;; extern GList *g_queue_peek_tail_link(GQueue *queue);
(define g_queue_peek_tail_link
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_queue_peek_tail_link"
                (dynamic-link))
              (list '*))))
    (lambda (queue)
      (let ((~queue (unwrap-GQueue* queue)))
        (wrap-GList* (~f ~queue))))))
(export g_queue_peek_tail_link)

;; extern GList *g_queue_peek_nth_link(GQueue *queue, guint n);
(define g_queue_peek_nth_link
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_queue_peek_nth_link"
                (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (queue n)
      (let ((~queue (unwrap-GQueue* queue))
            (~n (unwrap-guint n)))
        (wrap-GList* (~f ~queue ~n))))))
(export g_queue_peek_nth_link)

;; extern gint g_queue_link_index(GQueue *queue, GList *link_);
(define g_queue_link_index
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_queue_link_index"
                (dynamic-link))
              (list '* '*))))
    (lambda (queue link_)
      (let ((~queue (unwrap-GQueue* queue))
            (~link_ (unwrap-GList* link_)))
        (wrap-gint (~f ~queue ~link_))))))
(export g_queue_link_index)

;; extern void g_queue_unlink(GQueue *queue, GList *link_);
(define g_queue_unlink
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_queue_unlink" (dynamic-link))
              (list '* '*))))
    (lambda (queue link_)
      (let ((~queue (unwrap-GQueue* queue))
            (~link_ (unwrap-GList* link_)))
        (~f ~queue ~link_)))))
(export g_queue_unlink)

;; extern void g_queue_delete_link(GQueue *queue, GList *link_);
(define g_queue_delete_link
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_queue_delete_link"
                (dynamic-link))
              (list '* '*))))
    (lambda (queue link_)
      (let ((~queue (unwrap-GQueue* queue))
            (~link_ (unwrap-GList* link_)))
        (~f ~queue ~link_)))))
(export g_queue_delete_link)

;; typedef struct _GRand GRand;
(define GRand-desc void)
(define GRand*-desc (bs:pointer GRand-desc))
(define-fh-pointer-type GRand* GRand*-desc)

;; extern GRand *g_rand_new_with_seed(guint32 seed);
(define g_rand_new_with_seed
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_rand_new_with_seed"
                (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (seed)
      (let ((~seed (unwrap~fixed seed)))
        (wrap-GRand* (~f ~seed))))))
(export g_rand_new_with_seed)

;; extern GRand *g_rand_new_with_seed_array(const guint32 *seed, guint 
;;     seed_length);
(define g_rand_new_with_seed_array
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_rand_new_with_seed_array"
                (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (seed seed_length)
      (let ((~seed (unwrap~pointer seed))
            (~seed_length (unwrap-guint seed_length)))
        (wrap-GRand* (~f ~seed ~seed_length))))))
(export g_rand_new_with_seed_array)

;; extern GRand *g_rand_new(void);
(define g_rand_new
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_rand_new" (dynamic-link))
              (list))))
    (lambda () (let () (wrap-GRand* (~f))))))
(export g_rand_new)

;; extern void g_rand_free(GRand *rand_);
(define g_rand_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_rand_free" (dynamic-link))
              (list '*))))
    (lambda (rand_)
      (let ((~rand_ (unwrap-GRand* rand_)))
        (~f ~rand_)))))
(export g_rand_free)

;; extern GRand *g_rand_copy(GRand *rand_);
(define g_rand_copy
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_rand_copy" (dynamic-link))
              (list '*))))
    (lambda (rand_)
      (let ((~rand_ (unwrap-GRand* rand_)))
        (wrap-GRand* (~f ~rand_))))))
(export g_rand_copy)

;; extern void g_rand_set_seed(GRand *rand_, guint32 seed);
(define g_rand_set_seed
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_rand_set_seed" (dynamic-link))
              (list '* ffi:unsigned-int))))
    (lambda (rand_ seed)
      (let ((~rand_ (unwrap-GRand* rand_))
            (~seed (unwrap~fixed seed)))
        (~f ~rand_ ~seed)))))
(export g_rand_set_seed)

;; extern void g_rand_set_seed_array(GRand *rand_, const guint32 *seed, guint 
;;     seed_length);
(define g_rand_set_seed_array
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_rand_set_seed_array"
                (dynamic-link))
              (list '* '* ffi:unsigned-int))))
    (lambda (rand_ seed seed_length)
      (let ((~rand_ (unwrap-GRand* rand_))
            (~seed (unwrap~pointer seed))
            (~seed_length (unwrap-guint seed_length)))
        (~f ~rand_ ~seed ~seed_length)))))
(export g_rand_set_seed_array)

;; extern guint32 g_rand_int(GRand *rand_);
(define g_rand_int
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func "g_rand_int" (dynamic-link))
              (list '*))))
    (lambda (rand_)
      (let ((~rand_ (unwrap-GRand* rand_)))
        (~f ~rand_)))))
(export g_rand_int)

;; extern gint32 g_rand_int_range(GRand *rand_, gint32 begin, gint32 end);
;; ... failed.

;; extern gdouble g_rand_double(GRand *rand_);
(define g_rand_double
  (let ((~f (ffi:pointer->procedure
              ffi:double
              (dynamic-func "g_rand_double" (dynamic-link))
              (list '*))))
    (lambda (rand_)
      (let ((~rand_ (unwrap-GRand* rand_)))
        (wrap-gdouble (~f ~rand_))))))
(export g_rand_double)

;; extern gdouble g_rand_double_range(GRand *rand_, gdouble begin, gdouble end)
;;     ;
(define g_rand_double_range
  (let ((~f (ffi:pointer->procedure
              ffi:double
              (dynamic-func
                "g_rand_double_range"
                (dynamic-link))
              (list '* ffi:double ffi:double))))
    (lambda (rand_ begin end)
      (let ((~rand_ (unwrap-GRand* rand_))
            (~begin (unwrap-gdouble begin))
            (~end (unwrap-gdouble end)))
        (wrap-gdouble (~f ~rand_ ~begin ~end))))))
(export g_rand_double_range)

;; extern void g_random_set_seed(guint32 seed);
(define g_random_set_seed
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_random_set_seed" (dynamic-link))
              (list ffi:unsigned-int))))
    (lambda (seed)
      (let ((~seed (unwrap~fixed seed))) (~f ~seed)))))
(export g_random_set_seed)

;; extern guint32 g_random_int(void);
(define g_random_int
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func "g_random_int" (dynamic-link))
              (list))))
    (lambda () (let () (~f)))))
(export g_random_int)

;; extern gint32 g_random_int_range(gint32 begin, gint32 end);
;; ... failed.

;; extern gdouble g_random_double(void);
(define g_random_double
  (let ((~f (ffi:pointer->procedure
              ffi:double
              (dynamic-func "g_random_double" (dynamic-link))
              (list))))
    (lambda () (let () (wrap-gdouble (~f))))))
(export g_random_double)

;; extern gdouble g_random_double_range(gdouble begin, gdouble end);
(define g_random_double_range
  (let ((~f (ffi:pointer->procedure
              ffi:double
              (dynamic-func
                "g_random_double_range"
                (dynamic-link))
              (list ffi:double ffi:double))))
    (lambda (begin end)
      (let ((~begin (unwrap-gdouble begin))
            (~end (unwrap-gdouble end)))
        (wrap-gdouble (~f ~begin ~end))))))
(export g_random_double_range)

;; typedef enum {
;;   G_REGEX_ERROR_COMPILE,
;;   G_REGEX_ERROR_OPTIMIZE,
;;   G_REGEX_ERROR_REPLACE,
;;   G_REGEX_ERROR_MATCH,
;;   G_REGEX_ERROR_INTERNAL,
;;   G_REGEX_ERROR_STRAY_BACKSLASH = 101,
;;   G_REGEX_ERROR_MISSING_CONTROL_CHAR = 102,
;;   G_REGEX_ERROR_UNRECOGNIZED_ESCAPE = 103,
;;   G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER = 104,
;;   G_REGEX_ERROR_QUANTIFIER_TOO_BIG = 105,
;;   G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS = 106,
;;   G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS = 107,
;;   G_REGEX_ERROR_RANGE_OUT_OF_ORDER = 108,
;;   G_REGEX_ERROR_NOTHING_TO_REPEAT = 109,
;;   G_REGEX_ERROR_UNRECOGNIZED_CHARACTER = 112,
;;   G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS = 113,
;;   G_REGEX_ERROR_UNMATCHED_PARENTHESIS = 114,
;;   G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE = 115,
;;   G_REGEX_ERROR_UNTERMINATED_COMMENT = 118,
;;   G_REGEX_ERROR_EXPRESSION_TOO_LARGE = 120,
;;   G_REGEX_ERROR_MEMORY_ERROR = 121,
;;   G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND = 125,
;;   G_REGEX_ERROR_MALFORMED_CONDITION = 126,
;;   G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES = 127,
;;   G_REGEX_ERROR_ASSERTION_EXPECTED = 128,
;;   G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME = 130,
;;   G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED = 131,
;;   G_REGEX_ERROR_HEX_CODE_TOO_LARGE = 134,
;;   G_REGEX_ERROR_INVALID_CONDITION = 135,
;;   G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND = 136,
;;   G_REGEX_ERROR_INFINITE_LOOP = 140,
;;   G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR = 142,
;;   G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME = 143,
;;   G_REGEX_ERROR_MALFORMED_PROPERTY = 146,
;;   G_REGEX_ERROR_UNKNOWN_PROPERTY = 147,
;;   G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG = 148,
;;   G_REGEX_ERROR_TOO_MANY_SUBPATTERNS = 149,
;;   G_REGEX_ERROR_INVALID_OCTAL_VALUE = 151,
;;   G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE = 154,
;;   G_REGEX_ERROR_DEFINE_REPETION = 155,
;;   G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS = 156,
;;   G_REGEX_ERROR_MISSING_BACK_REFERENCE = 157,
;;   G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE = 158,
;;   G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN = 159,
;;   G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB = 160,
;;   G_REGEX_ERROR_NUMBER_TOO_BIG = 161,
;;   G_REGEX_ERROR_MISSING_SUBPATTERN_NAME = 162,
;;   G_REGEX_ERROR_MISSING_DIGIT = 163,
;;   G_REGEX_ERROR_INVALID_DATA_CHARACTER = 164,
;;   G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME = 165,
;;   G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED = 166,
;;   G_REGEX_ERROR_INVALID_CONTROL_CHAR = 168,
;;   G_REGEX_ERROR_MISSING_NAME = 169,
;;   G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS = 171,
;;   G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES = 172,
;;   G_REGEX_ERROR_NAME_TOO_LONG = 175,
;;   G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE = 176,
;; } GRegexError;
(define-fh-enum GRegexError
  '((G_REGEX_ERROR_COMPILE . 0)
    (G_REGEX_ERROR_OPTIMIZE . 1)
    (G_REGEX_ERROR_REPLACE . 2)
    (G_REGEX_ERROR_MATCH . 3)
    (G_REGEX_ERROR_INTERNAL . 4)
    (G_REGEX_ERROR_STRAY_BACKSLASH . 101)
    (G_REGEX_ERROR_MISSING_CONTROL_CHAR . 102)
    (G_REGEX_ERROR_UNRECOGNIZED_ESCAPE . 103)
    (G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER . 104)
    (G_REGEX_ERROR_QUANTIFIER_TOO_BIG . 105)
    (G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS
      .
      106)
    (G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS
      .
      107)
    (G_REGEX_ERROR_RANGE_OUT_OF_ORDER . 108)
    (G_REGEX_ERROR_NOTHING_TO_REPEAT . 109)
    (G_REGEX_ERROR_UNRECOGNIZED_CHARACTER . 112)
    (G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS
      .
      113)
    (G_REGEX_ERROR_UNMATCHED_PARENTHESIS . 114)
    (G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE
      .
      115)
    (G_REGEX_ERROR_UNTERMINATED_COMMENT . 118)
    (G_REGEX_ERROR_EXPRESSION_TOO_LARGE . 120)
    (G_REGEX_ERROR_MEMORY_ERROR . 121)
    (G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND . 125)
    (G_REGEX_ERROR_MALFORMED_CONDITION . 126)
    (G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES
      .
      127)
    (G_REGEX_ERROR_ASSERTION_EXPECTED . 128)
    (G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME . 130)
    (G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED
      .
      131)
    (G_REGEX_ERROR_HEX_CODE_TOO_LARGE . 134)
    (G_REGEX_ERROR_INVALID_CONDITION . 135)
    (G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND
      .
      136)
    (G_REGEX_ERROR_INFINITE_LOOP . 140)
    (G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR
      .
      142)
    (G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME . 143)
    (G_REGEX_ERROR_MALFORMED_PROPERTY . 146)
    (G_REGEX_ERROR_UNKNOWN_PROPERTY . 147)
    (G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG . 148)
    (G_REGEX_ERROR_TOO_MANY_SUBPATTERNS . 149)
    (G_REGEX_ERROR_INVALID_OCTAL_VALUE . 151)
    (G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE . 154)
    (G_REGEX_ERROR_DEFINE_REPETION . 155)
    (G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS
      .
      156)
    (G_REGEX_ERROR_MISSING_BACK_REFERENCE . 157)
    (G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE . 158)
    (G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN
      .
      159)
    (G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB
      .
      160)
    (G_REGEX_ERROR_NUMBER_TOO_BIG . 161)
    (G_REGEX_ERROR_MISSING_SUBPATTERN_NAME . 162)
    (G_REGEX_ERROR_MISSING_DIGIT . 163)
    (G_REGEX_ERROR_INVALID_DATA_CHARACTER . 164)
    (G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME . 165)
    (G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED
      .
      166)
    (G_REGEX_ERROR_INVALID_CONTROL_CHAR . 168)
    (G_REGEX_ERROR_MISSING_NAME . 169)
    (G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS . 171)
    (G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES . 172)
    (G_REGEX_ERROR_NAME_TOO_LONG . 175)
    (G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE . 176))
  )

;; extern GQuark g_regex_error_quark(void);
(define g_regex_error_quark
  (let ((~f (ffi:pointer->procedure
              ffi:unsigned-int
              (dynamic-func
                "g_regex_error_quark"
                (dynamic-link))
              (list))))
    (lambda () (let () (wrap-GQuark (~f))))))
(export g_regex_error_quark)

;; typedef enum {
;;   G_REGEX_CASELESS = 1<<0,
;;   G_REGEX_MULTILINE = 1<<1,
;;   G_REGEX_DOTALL = 1<<2,
;;   G_REGEX_EXTENDED = 1<<3,
;;   G_REGEX_ANCHORED = 1<<4,
;;   G_REGEX_DOLLAR_ENDONLY = 1<<5,
;;   G_REGEX_UNGREEDY = 1<<9,
;;   G_REGEX_RAW = 1<<11,
;;   G_REGEX_NO_AUTO_CAPTURE = 1<<12,
;;   G_REGEX_OPTIMIZE = 1<<13,
;;   G_REGEX_FIRSTLINE = 1<<18,
;;   G_REGEX_DUPNAMES = 1<<19,
;;   G_REGEX_NEWLINE_CR = 1<<20,
;;   G_REGEX_NEWLINE_LF = 1<<21,
;;   G_REGEX_NEWLINE_CRLF = G_REGEX_NEWLINE_CR | G_REGEX_NEWLINE_LF,
;;   G_REGEX_NEWLINE_ANYCRLF = G_REGEX_NEWLINE_CR | 1<<22,
;;   G_REGEX_BSR_ANYCRLF = 1<<23,
;;   G_REGEX_JAVASCRIPT_COMPAT = 1<<25,
;; } GRegexCompileFlags;
(define-fh-enum GRegexCompileFlags
  '((G_REGEX_CASELESS . 1)
    (G_REGEX_MULTILINE . 2)
    (G_REGEX_DOTALL . 4)
    (G_REGEX_EXTENDED . 8)
    (G_REGEX_ANCHORED . 16)
    (G_REGEX_DOLLAR_ENDONLY . 32)
    (G_REGEX_UNGREEDY . 512)
    (G_REGEX_RAW . 2048)
    (G_REGEX_NO_AUTO_CAPTURE . 4096)
    (G_REGEX_OPTIMIZE . 8192)
    (G_REGEX_FIRSTLINE . 262144)
    (G_REGEX_DUPNAMES . 524288)
    (G_REGEX_NEWLINE_CR . 1048576)
    (G_REGEX_NEWLINE_LF . 2097152)
    (G_REGEX_NEWLINE_CRLF . 3145728)
    (G_REGEX_NEWLINE_ANYCRLF . 5242880)
    (G_REGEX_BSR_ANYCRLF . 8388608)
    (G_REGEX_JAVASCRIPT_COMPAT . 33554432))
  )

;; typedef enum {
;;   G_REGEX_MATCH_ANCHORED = 1<<4,
;;   G_REGEX_MATCH_NOTBOL = 1<<7,
;;   G_REGEX_MATCH_NOTEOL = 1<<8,
;;   G_REGEX_MATCH_NOTEMPTY = 1<<10,
;;   G_REGEX_MATCH_PARTIAL = 1<<15,
;;   G_REGEX_MATCH_NEWLINE_CR = 1<<20,
;;   G_REGEX_MATCH_NEWLINE_LF = 1<<21,
;;   G_REGEX_MATCH_NEWLINE_CRLF = G_REGEX_MATCH_NEWLINE_CR | 
;;       G_REGEX_MATCH_NEWLINE_LF,
;;   G_REGEX_MATCH_NEWLINE_ANY = 1<<22,
;;   G_REGEX_MATCH_NEWLINE_ANYCRLF = G_REGEX_MATCH_NEWLINE_CR | 
;;       G_REGEX_MATCH_NEWLINE_ANY,
;;   G_REGEX_MATCH_BSR_ANYCRLF = 1<<23,
;;   G_REGEX_MATCH_BSR_ANY = 1<<24,
;;   G_REGEX_MATCH_PARTIAL_SOFT = G_REGEX_MATCH_PARTIAL,
;;   G_REGEX_MATCH_PARTIAL_HARD = 1<<27,
;;   G_REGEX_MATCH_NOTEMPTY_ATSTART = 1<<28,
;; } GRegexMatchFlags;
(define-fh-enum GRegexMatchFlags
  '((G_REGEX_MATCH_ANCHORED . 16)
    (G_REGEX_MATCH_NOTBOL . 128)
    (G_REGEX_MATCH_NOTEOL . 256)
    (G_REGEX_MATCH_NOTEMPTY . 1024)
    (G_REGEX_MATCH_PARTIAL . 32768)
    (G_REGEX_MATCH_NEWLINE_CR . 1048576)
    (G_REGEX_MATCH_NEWLINE_LF . 2097152)
    (G_REGEX_MATCH_NEWLINE_CRLF . 3145728)
    (G_REGEX_MATCH_NEWLINE_ANY . 4194304)
    (G_REGEX_MATCH_NEWLINE_ANYCRLF . 5242880)
    (G_REGEX_MATCH_BSR_ANYCRLF . 8388608)
    (G_REGEX_MATCH_BSR_ANY . 16777216)
    (G_REGEX_MATCH_PARTIAL_SOFT . 32768)
    (G_REGEX_MATCH_PARTIAL_HARD . 134217728)
    (G_REGEX_MATCH_NOTEMPTY_ATSTART . 268435456))
  )

;; typedef struct _GRegex GRegex;
(define GRegex-desc void)
(define GRegex*-desc (bs:pointer GRegex-desc))
(define-fh-pointer-type GRegex* GRegex*-desc)

;; typedef struct _GMatchInfo GMatchInfo;
(define GMatchInfo-desc void)
(define GMatchInfo*-desc (bs:pointer GMatchInfo-desc))
(define-fh-pointer-type GMatchInfo* GMatchInfo*-desc)

;; typedef gboolean (*GRegexEvalCallback)(const GMatchInfo *match_info, GString
;;      *result, gpointer user_data);
(define-fh-function/p GRegexEvalCallback
  ffi:int (list (quote *) (quote *) (quote *)))

;; extern GRegex *g_regex_new(const gchar *pattern, GRegexCompileFlags 
;;     compile_options, GRegexMatchFlags match_options, GError **error);
(define g_regex_new
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_regex_new" (dynamic-link))
              (list '* ffi:int ffi:int '*))))
    (lambda (pattern compile_options match_options error)
      (let ((~pattern (unwrap-gchar* pattern))
            (~compile_options (unwrap~fixed compile_options))
            (~match_options (unwrap~fixed match_options))
            (~error (unwrap~pointer error)))
        (wrap-GRegex*
          (~f ~pattern
              ~compile_options
              ~match_options
              ~error))))))
(export g_regex_new)

;; extern GRegex *g_regex_ref(GRegex *regex);
(define g_regex_ref
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_regex_ref" (dynamic-link))
              (list '*))))
    (lambda (regex)
      (let ((~regex (unwrap-GRegex* regex)))
        (wrap-GRegex* (~f ~regex))))))
(export g_regex_ref)

;; extern void g_regex_unref(GRegex *regex);
(define g_regex_unref
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_regex_unref" (dynamic-link))
              (list '*))))
    (lambda (regex)
      (let ((~regex (unwrap-GRegex* regex)))
        (~f ~regex)))))
(export g_regex_unref)

;; extern const gchar *g_regex_get_pattern(const GRegex *regex);
(define g_regex_get_pattern
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_regex_get_pattern"
                (dynamic-link))
              (list '*))))
    (lambda (regex)
      (let ((~regex (unwrap-GRegex* regex)))
        (wrap-gchar* (~f ~regex))))))
(export g_regex_get_pattern)

;; extern gint g_regex_get_max_backref(const GRegex *regex);
(define g_regex_get_max_backref
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_regex_get_max_backref"
                (dynamic-link))
              (list '*))))
    (lambda (regex)
      (let ((~regex (unwrap-GRegex* regex)))
        (wrap-gint (~f ~regex))))))
(export g_regex_get_max_backref)

;; extern gint g_regex_get_capture_count(const GRegex *regex);
(define g_regex_get_capture_count
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_regex_get_capture_count"
                (dynamic-link))
              (list '*))))
    (lambda (regex)
      (let ((~regex (unwrap-GRegex* regex)))
        (wrap-gint (~f ~regex))))))
(export g_regex_get_capture_count)

;; extern gboolean g_regex_get_has_cr_or_lf(const GRegex *regex);
(define g_regex_get_has_cr_or_lf
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_regex_get_has_cr_or_lf"
                (dynamic-link))
              (list '*))))
    (lambda (regex)
      (let ((~regex (unwrap-GRegex* regex)))
        (wrap-gboolean (~f ~regex))))))
(export g_regex_get_has_cr_or_lf)

;; extern gint g_regex_get_max_lookbehind(const GRegex *regex);
(define g_regex_get_max_lookbehind
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_regex_get_max_lookbehind"
                (dynamic-link))
              (list '*))))
    (lambda (regex)
      (let ((~regex (unwrap-GRegex* regex)))
        (wrap-gint (~f ~regex))))))
(export g_regex_get_max_lookbehind)

;; extern gint g_regex_get_string_number(const GRegex *regex, const gchar *name
;;     );
(define g_regex_get_string_number
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_regex_get_string_number"
                (dynamic-link))
              (list '* '*))))
    (lambda (regex name)
      (let ((~regex (unwrap-GRegex* regex))
            (~name (unwrap-gchar* name)))
        (wrap-gint (~f ~regex ~name))))))
(export g_regex_get_string_number)

;; extern gchar *g_regex_escape_string(const gchar *string, gint length);
(define g_regex_escape_string
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_regex_escape_string"
                (dynamic-link))
              (list '* ffi:int))))
    (lambda (string length)
      (let ((~string (unwrap-gchar* string))
            (~length (unwrap-gint length)))
        (wrap-gchar* (~f ~string ~length))))))
(export g_regex_escape_string)

;; extern gchar *g_regex_escape_nul(const gchar *string, gint length);
(define g_regex_escape_nul
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_regex_escape_nul"
                (dynamic-link))
              (list '* ffi:int))))
    (lambda (string length)
      (let ((~string (unwrap-gchar* string))
            (~length (unwrap-gint length)))
        (wrap-gchar* (~f ~string ~length))))))
(export g_regex_escape_nul)

;; extern GRegexCompileFlags g_regex_get_compile_flags(const GRegex *regex);
(define g_regex_get_compile_flags
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_regex_get_compile_flags"
                (dynamic-link))
              (list '*))))
    (lambda (regex)
      (let ((~regex (unwrap-GRegex* regex)))
        (~f ~regex)))))
(export g_regex_get_compile_flags)

;; extern GRegexMatchFlags g_regex_get_match_flags(const GRegex *regex);
(define g_regex_get_match_flags
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_regex_get_match_flags"
                (dynamic-link))
              (list '*))))
    (lambda (regex)
      (let ((~regex (unwrap-GRegex* regex)))
        (~f ~regex)))))
(export g_regex_get_match_flags)

;; extern gboolean g_regex_match_simple(const gchar *pattern, const gchar *
;;     string, GRegexCompileFlags compile_options, GRegexMatchFlags 
;;     match_options);
(define g_regex_match_simple
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_regex_match_simple"
                (dynamic-link))
              (list '* '* ffi:int ffi:int))))
    (lambda (pattern string compile_options match_options)
      (let ((~pattern (unwrap-gchar* pattern))
            (~string (unwrap-gchar* string))
            (~compile_options (unwrap~fixed compile_options))
            (~match_options (unwrap~fixed match_options)))
        (wrap-gboolean
          (~f ~pattern
              ~string
              ~compile_options
              ~match_options))))))
(export g_regex_match_simple)

;; extern gboolean g_regex_match(const GRegex *regex, const gchar *string, 
;;     GRegexMatchFlags match_options, GMatchInfo **match_info);
(define g_regex_match
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_regex_match" (dynamic-link))
              (list '* '* ffi:int '*))))
    (lambda (regex string match_options match_info)
      (let ((~regex (unwrap-GRegex* regex))
            (~string (unwrap-gchar* string))
            (~match_options (unwrap~fixed match_options))
            (~match_info (unwrap~pointer match_info)))
        (wrap-gboolean
          (~f ~regex ~string ~match_options ~match_info))))))
(export g_regex_match)

;; extern gboolean g_regex_match_full(const GRegex *regex, const gchar *string
;;     , gssize string_len, gint start_position, GRegexMatchFlags match_options
;;     , GMatchInfo **match_info, GError **error);
;; ... failed.

;; extern gboolean g_regex_match_all(const GRegex *regex, const gchar *string, 
;;     GRegexMatchFlags match_options, GMatchInfo **match_info);
(define g_regex_match_all
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_regex_match_all" (dynamic-link))
              (list '* '* ffi:int '*))))
    (lambda (regex string match_options match_info)
      (let ((~regex (unwrap-GRegex* regex))
            (~string (unwrap-gchar* string))
            (~match_options (unwrap~fixed match_options))
            (~match_info (unwrap~pointer match_info)))
        (wrap-gboolean
          (~f ~regex ~string ~match_options ~match_info))))))
(export g_regex_match_all)

;; extern gboolean g_regex_match_all_full(const GRegex *regex, const gchar *
;;     string, gssize string_len, gint start_position, GRegexMatchFlags 
;;     match_options, GMatchInfo **match_info, GError **error);
;; ... failed.

;; extern gchar **g_regex_split_simple(const gchar *pattern, const gchar *
;;     string, GRegexCompileFlags compile_options, GRegexMatchFlags 
;;     match_options);
;; ... failed.

;; extern gchar **g_regex_split(const GRegex *regex, const gchar *string, 
;;     GRegexMatchFlags match_options);
;; ... failed.

;; extern gchar **g_regex_split_full(const GRegex *regex, const gchar *string, 
;;     gssize string_len, gint start_position, GRegexMatchFlags match_options, 
;;     gint max_tokens, GError **error);
;; ... failed.

;; extern gchar *g_regex_replace(const GRegex *regex, const gchar *string, 
;;     gssize string_len, gint start_position, const gchar *replacement, 
;;     GRegexMatchFlags match_options, GError **error);
;; ... failed.

;; extern gchar *g_regex_replace_literal(const GRegex *regex, const gchar *
;;     string, gssize string_len, gint start_position, const gchar *replacement
;;     , GRegexMatchFlags match_options, GError **error);
;; ... failed.

;; extern gchar *g_regex_replace_eval(const GRegex *regex, const gchar *string
;;     , gssize string_len, gint start_position, GRegexMatchFlags match_options
;;     , GRegexEvalCallback eval, gpointer user_data, GError **error);
;; ... failed.

;; extern gboolean g_regex_check_replacement(const gchar *replacement, gboolean
;;      *has_references, GError **error);
(define g_regex_check_replacement
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_regex_check_replacement"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (replacement has_references error)
      (let ((~replacement (unwrap-gchar* replacement))
            (~has_references
              (unwrap-gboolean* has_references))
            (~error (unwrap~pointer error)))
        (wrap-gboolean
          (~f ~replacement ~has_references ~error))))))
(export g_regex_check_replacement)

;; extern GRegex *g_match_info_get_regex(const GMatchInfo *match_info);
(define g_match_info_get_regex
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_match_info_get_regex"
                (dynamic-link))
              (list '*))))
    (lambda (match_info)
      (let ((~match_info (unwrap-GMatchInfo* match_info)))
        (wrap-GRegex* (~f ~match_info))))))
(export g_match_info_get_regex)

;; extern const gchar *g_match_info_get_string(const GMatchInfo *match_info);
(define g_match_info_get_string
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_match_info_get_string"
                (dynamic-link))
              (list '*))))
    (lambda (match_info)
      (let ((~match_info (unwrap-GMatchInfo* match_info)))
        (wrap-gchar* (~f ~match_info))))))
(export g_match_info_get_string)

;; extern GMatchInfo *g_match_info_ref(GMatchInfo *match_info);
(define g_match_info_ref
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_match_info_ref" (dynamic-link))
              (list '*))))
    (lambda (match_info)
      (let ((~match_info (unwrap-GMatchInfo* match_info)))
        (wrap-GMatchInfo* (~f ~match_info))))))
(export g_match_info_ref)

;; extern void g_match_info_unref(GMatchInfo *match_info);
(define g_match_info_unref
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_match_info_unref"
                (dynamic-link))
              (list '*))))
    (lambda (match_info)
      (let ((~match_info (unwrap-GMatchInfo* match_info)))
        (~f ~match_info)))))
(export g_match_info_unref)

;; extern void g_match_info_free(GMatchInfo *match_info);
(define g_match_info_free
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_match_info_free" (dynamic-link))
              (list '*))))
    (lambda (match_info)
      (let ((~match_info (unwrap-GMatchInfo* match_info)))
        (~f ~match_info)))))
(export g_match_info_free)

;; extern gboolean g_match_info_next(GMatchInfo *match_info, GError **error);
(define g_match_info_next
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func "g_match_info_next" (dynamic-link))
              (list '* '*))))
    (lambda (match_info error)
      (let ((~match_info (unwrap-GMatchInfo* match_info))
            (~error (unwrap~pointer error)))
        (wrap-gboolean (~f ~match_info ~error))))))
(export g_match_info_next)

;; extern gboolean g_match_info_matches(const GMatchInfo *match_info);
(define g_match_info_matches
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_match_info_matches"
                (dynamic-link))
              (list '*))))
    (lambda (match_info)
      (let ((~match_info (unwrap-GMatchInfo* match_info)))
        (wrap-gboolean (~f ~match_info))))))
(export g_match_info_matches)

;; extern gint g_match_info_get_match_count(const GMatchInfo *match_info);
(define g_match_info_get_match_count
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_match_info_get_match_count"
                (dynamic-link))
              (list '*))))
    (lambda (match_info)
      (let ((~match_info (unwrap-GMatchInfo* match_info)))
        (wrap-gint (~f ~match_info))))))
(export g_match_info_get_match_count)

;; extern gboolean g_match_info_is_partial_match(const GMatchInfo *match_info)
;;     ;
(define g_match_info_is_partial_match
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_match_info_is_partial_match"
                (dynamic-link))
              (list '*))))
    (lambda (match_info)
      (let ((~match_info (unwrap-GMatchInfo* match_info)))
        (wrap-gboolean (~f ~match_info))))))
(export g_match_info_is_partial_match)

;; extern gchar *g_match_info_expand_references(const GMatchInfo *match_info, 
;;     const gchar *string_to_expand, GError **error);
(define g_match_info_expand_references
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_match_info_expand_references"
                (dynamic-link))
              (list '* '* '*))))
    (lambda (match_info string_to_expand error)
      (let ((~match_info (unwrap-GMatchInfo* match_info))
            (~string_to_expand
              (unwrap-gchar* string_to_expand))
            (~error (unwrap~pointer error)))
        (wrap-gchar*
          (~f ~match_info ~string_to_expand ~error))))))
(export g_match_info_expand_references)

;; extern gchar *g_match_info_fetch(const GMatchInfo *match_info, gint 
;;     match_num);
(define g_match_info_fetch
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_match_info_fetch"
                (dynamic-link))
              (list '* ffi:int))))
    (lambda (match_info match_num)
      (let ((~match_info (unwrap-GMatchInfo* match_info))
            (~match_num (unwrap-gint match_num)))
        (wrap-gchar* (~f ~match_info ~match_num))))))
(export g_match_info_fetch)

;; extern gboolean g_match_info_fetch_pos(const GMatchInfo *match_info, gint 
;;     match_num, gint *start_pos, gint *end_pos);
(define g_match_info_fetch_pos
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_match_info_fetch_pos"
                (dynamic-link))
              (list '* ffi:int '* '*))))
    (lambda (match_info match_num start_pos end_pos)
      (let ((~match_info (unwrap-GMatchInfo* match_info))
            (~match_num (unwrap-gint match_num))
            (~start_pos (unwrap-gint* start_pos))
            (~end_pos (unwrap-gint* end_pos)))
        (wrap-gboolean
          (~f ~match_info ~match_num ~start_pos ~end_pos))))))
(export g_match_info_fetch_pos)

;; extern gchar *g_match_info_fetch_named(const GMatchInfo *match_info, const 
;;     gchar *name);
(define g_match_info_fetch_named
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func
                "g_match_info_fetch_named"
                (dynamic-link))
              (list '* '*))))
    (lambda (match_info name)
      (let ((~match_info (unwrap-GMatchInfo* match_info))
            (~name (unwrap-gchar* name)))
        (wrap-gchar* (~f ~match_info ~name))))))
(export g_match_info_fetch_named)

;; extern gboolean g_match_info_fetch_named_pos(const GMatchInfo *match_info, 
;;     const gchar *name, gint *start_pos, gint *end_pos);
(define g_match_info_fetch_named_pos
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_match_info_fetch_named_pos"
                (dynamic-link))
              (list '* '* '* '*))))
    (lambda (match_info name start_pos end_pos)
      (let ((~match_info (unwrap-GMatchInfo* match_info))
            (~name (unwrap-gchar* name))
            (~start_pos (unwrap-gint* start_pos))
            (~end_pos (unwrap-gint* end_pos)))
        (wrap-gboolean
          (~f ~match_info ~name ~start_pos ~end_pos))))))
(export g_match_info_fetch_named_pos)

;; extern gchar **g_match_info_fetch_all(const GMatchInfo *match_info);
;; ... failed.

;; typedef struct _GScanner GScanner;
(define GScanner-desc void)
(define GScanner*-desc (bs:pointer (delay GScanner-desc)))
(define-fh-pointer-type GScanner* GScanner*-desc)

;; typedef struct _GScannerConfig GScannerConfig;
(define GScannerConfig-desc void)
(define GScannerConfig*-desc (bs:pointer (delay GScannerConfig-desc)))
(define-fh-pointer-type GScannerConfig* GScannerConfig*-desc)

;; typedef union _GTokenValue GTokenValue;
;; union _GTokenValue {
;;   gpointer v_symbol;
;;   gchar *v_identifier;
;;   gulong v_binary;
;;   gulong v_octal;
;;   gulong v_int;
;;   guint64 v_int64;
;;   gdouble v_float;
;;   gulong v_hex;
;;   gchar *v_string;
;;   gchar *v_comment;
;;   guchar v_char;
;;   guint v_error;
;; };
(define GTokenValue-desc
  (bs:union
    (list `(v_symbol ,gpointer-desc)
          `(v_identifier ,(bs:pointer gchar*-desc))
          `(v_binary ,gulong-desc)
          `(v_octal ,gulong-desc)
          `(v_int ,gulong-desc)
          `(v_int64 ,unsigned-long)
          `(v_float ,gdouble-desc)
          `(v_hex ,gulong-desc)
          `(v_string ,(bs:pointer gchar*-desc))
          `(v_comment ,(bs:pointer gchar*-desc))
          `(v_char ,guchar-desc)
          `(v_error ,guint-desc))))
(export GTokenValue-desc)
(define-fh-compound-type/p GTokenValue GTokenValue-desc)
(define union-_GTokenValue GTokenValue)

;; typedef void (*GScannerMsgFunc)(GScanner *scanner, gchar *message, gboolean 
;;     error);
(define-fh-function/p GScannerMsgFunc
  ffi:void (list (quote *) (quote *) ffi:int))

;; typedef enum {
;;   G_ERR_UNKNOWN,
;;   G_ERR_UNEXP_EOF,
;;   G_ERR_UNEXP_EOF_IN_STRING,
;;   G_ERR_UNEXP_EOF_IN_COMMENT,
;;   G_ERR_NON_DIGIT_IN_CONST,
;;   G_ERR_DIGIT_RADIX,
;;   G_ERR_FLOAT_RADIX,
;;   G_ERR_FLOAT_MALFORMED,
;; } GErrorType;
(define-fh-enum GErrorType
  '((G_ERR_UNKNOWN . 0)
    (G_ERR_UNEXP_EOF . 1)
    (G_ERR_UNEXP_EOF_IN_STRING . 2)
    (G_ERR_UNEXP_EOF_IN_COMMENT . 3)
    (G_ERR_NON_DIGIT_IN_CONST . 4)
    (G_ERR_DIGIT_RADIX . 5)
    (G_ERR_FLOAT_RADIX . 6)
    (G_ERR_FLOAT_MALFORMED . 7))
  )

;; typedef enum {
;;   G_TOKEN_EOF = 0,
;;   G_TOKEN_LEFT_PAREN = '(',
;;   G_TOKEN_RIGHT_PAREN = ')',
;;   G_TOKEN_LEFT_CURLY = '{',
;;   G_TOKEN_RIGHT_CURLY = '}',
;;   G_TOKEN_LEFT_BRACE = '[',
;;   G_TOKEN_RIGHT_BRACE = ']',
;;   G_TOKEN_EQUAL_SIGN = '=',
;;   G_TOKEN_COMMA = ',',
;;   G_TOKEN_NONE = 256,
;;   G_TOKEN_ERROR,
;;   G_TOKEN_CHAR,
;;   G_TOKEN_BINARY,
;;   G_TOKEN_OCTAL,
;;   G_TOKEN_INT,
;;   G_TOKEN_HEX,
;;   G_TOKEN_FLOAT,
;;   G_TOKEN_STRING,
;;   G_TOKEN_SYMBOL,
;;   G_TOKEN_IDENTIFIER,
;;   G_TOKEN_IDENTIFIER_NULL,
;;   G_TOKEN_COMMENT_SINGLE,
;;   G_TOKEN_COMMENT_MULTI,
;;   G_TOKEN_LAST,
;; } GTokenType;
(define-fh-enum GTokenType
  '((G_TOKEN_EOF . 0)
    (G_TOKEN_LEFT_PAREN . 40)
    (G_TOKEN_RIGHT_PAREN . 41)
    (G_TOKEN_LEFT_CURLY . 123)
    (G_TOKEN_RIGHT_CURLY . 125)
    (G_TOKEN_LEFT_BRACE . 91)
    (G_TOKEN_RIGHT_BRACE . 93)
    (G_TOKEN_EQUAL_SIGN . 61)
    (G_TOKEN_COMMA . 44)
    (G_TOKEN_NONE . 256)
    (G_TOKEN_ERROR . 257)
    (G_TOKEN_CHAR . 258)
    (G_TOKEN_BINARY . 259)
    (G_TOKEN_OCTAL . 260)
    (G_TOKEN_INT . 261)
    (G_TOKEN_HEX . 262)
    (G_TOKEN_FLOAT . 263)
    (G_TOKEN_STRING . 264)
    (G_TOKEN_SYMBOL . 265)
    (G_TOKEN_IDENTIFIER . 266)
    (G_TOKEN_IDENTIFIER_NULL . 267)
    (G_TOKEN_COMMENT_SINGLE . 268)
    (G_TOKEN_COMMENT_MULTI . 269)
    (G_TOKEN_LAST . 270))
  )

;; struct _GScannerConfig {
;;   /* Character sets
;;    */
;;   gchar *cset_skip_characters; /* default: " \t\n" */
;;   gchar *cset_identifier_first;
;;   gchar *cset_identifier_nth;
;;   gchar *cpair_comment_single; /* default: "#\n" */
;;   /* Should symbol lookup work case sensitive?
;;    */
;;   guint case_sensitive : 1;
;;   /* Boolean values to be adjusted "on the fly"
;;    * to configure scanning behaviour.
;;    */
;;   guint skip_comment_multi : 1; /* C like comment */
;;   guint skip_comment_single : 1; /* single line comment */
;;   guint scan_comment_multi : 1; /* scan multi line comments? */
;;   guint scan_identifier : 1;
;;   guint scan_identifier_1char : 1;
;;   guint scan_identifier_NULL : 1;
;;   guint scan_symbols : 1;
;;   guint scan_binary : 1;
;;   guint scan_octal : 1;
;;   guint scan_float : 1;
;;   guint scan_hex : 1; /* '0x0ff0' */
;;   guint scan_hex_dollar : 1; /* '$0ff0' */
;;   guint scan_string_sq : 1; /* string: 'anything' */
;;   guint scan_string_dq : 1; /* string: "\\-escapes!\n" */
;;   guint numbers_2_int : 1; /* bin, octal, hex => int */
;;   guint int_2_float : 1; /* int => G_TOKEN_FLOAT? */
;;   guint identifier_2_string : 1;
;;   guint char_2_token : 1; /* return G_TOKEN_CHAR? */
;;   guint symbol_2_token : 1;
;;   guint scope_0_fallback : 1; /* try scope 0 on lookups? */
;;   guint store_int64 : 1; /* use value.v_int64 rather than v_int */
;;   /*< private >*/
;;   guint padding_dummy;
;; };
(define struct-_GScannerConfig-desc
  (bs:struct
    (list `(cset_skip_characters ,(bs:pointer gchar*-desc))
          `(cset_identifier_first ,(bs:pointer gchar*-desc))
          `(cset_identifier_nth ,(bs:pointer gchar*-desc))
          `(cpair_comment_single ,(bs:pointer gchar*-desc))
          `(case_sensitive ,guint-desc)
          `(skip_comment_multi ,guint-desc)
          `(skip_comment_single ,guint-desc)
          `(scan_comment_multi ,guint-desc)
          `(scan_identifier ,guint-desc)
          `(scan_identifier_1char ,guint-desc)
          `(scan_identifier_NULL ,guint-desc)
          `(scan_symbols ,guint-desc)
          `(scan_binary ,guint-desc)
          `(scan_octal ,guint-desc)
          `(scan_float ,guint-desc)
          `(scan_hex ,guint-desc)
          `(scan_hex_dollar ,guint-desc)
          `(scan_string_sq ,guint-desc)
          `(scan_string_dq ,guint-desc)
          `(numbers_2_int ,guint-desc)
          `(int_2_float ,guint-desc)
          `(identifier_2_string ,guint-desc)
          `(char_2_token ,guint-desc)
          `(symbol_2_token ,guint-desc)
          `(scope_0_fallback ,guint-desc)
          `(store_int64 ,guint-desc)
          `(padding_dummy ,guint-desc))))
(export struct-_GScannerConfig-desc)
(define-fh-compound-type/p struct-_GScannerConfig struct-_GScannerConfig-desc)
(set! GScannerConfig-desc struct-_GScannerConfig-desc)
(define-fh-compound-type GScannerConfig GScannerConfig-desc)

;; struct _GScanner {
;;   /* unused fields */
;;   gpointer user_data;
;;   guint max_parse_errors;
;;   /* g_scanner_error() increments this field */
;;   guint parse_errors;
;;   /* name of input stream, featured by the default message handler */
;;   const gchar *input_name;
;;   /* quarked data */
;;   GData *qdata;
;;   /* link into the scanner configuration */
;;   GScannerConfig *config;
;;   /* fields filled in after g_scanner_get_next_token() */
;;   GTokenType token;
;;   GTokenValue value;
;;   guint line;
;;   guint position;
;;   /* fields filled in after g_scanner_peek_next_token() */
;;   GTokenType next_token;
;;   GTokenValue next_value;
;;   guint next_line;
;;   guint next_position;
;;   /*< private >*/
;;   /* to be considered private */
;;   GHashTable *symbol_table;
;;   gint input_fd;
;;   const gchar *text;
;;   const gchar *text_end;
;;   gchar *buffer;
;;   guint scope_id;
;;   /*< public >*/
;;   /* handler function for _warn and _error */
;;   GScannerMsgFunc msg_handler;
;; };
(define struct-_GScanner-desc
  (bs:struct
    (list `(user_data ,gpointer-desc)
          `(max_parse_errors ,guint-desc)
          `(parse_errors ,guint-desc)
          `(input_name ,(bs:pointer gchar*-desc))
          `(qdata ,(bs:pointer GData*-desc))
          `(config ,(bs:pointer GScannerConfig*-desc))
          `(token ,int)
          `(value ,GTokenValue-desc)
          `(line ,guint-desc)
          `(position ,guint-desc)
          `(next_token ,int)
          `(next_value ,GTokenValue-desc)
          `(next_line ,guint-desc)
          `(next_position ,guint-desc)
          `(symbol_table ,(bs:pointer GHashTable*-desc))
          `(input_fd ,gint-desc)
          `(text ,(bs:pointer gchar*-desc))
          `(text_end ,(bs:pointer gchar*-desc))
          `(buffer ,(bs:pointer gchar*-desc))
          `(scope_id ,guint-desc)
          `(msg_handler ,(bs:pointer void)))))
(export struct-_GScanner-desc)
(define-fh-compound-type/p struct-_GScanner struct-_GScanner-desc)
(set! GScanner-desc struct-_GScanner-desc)
(define-fh-compound-type GScanner GScanner-desc)

;; extern GScanner *g_scanner_new(const GScannerConfig *config_templ);
(define g_scanner_new
  (let ((~f (ffi:pointer->procedure
              '*
              (dynamic-func "g_scanner_new" (dynamic-link))
              (list '*))))
    (lambda (config_templ)
      (let ((~config_templ
              (unwrap-GScannerConfig* config_templ)))
        (wrap-GScanner* (~f ~config_templ))))))
(export g_scanner_new)

;; extern void g_scanner_destroy(GScanner *scanner);
(define g_scanner_destroy
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func "g_scanner_destroy" (dynamic-link))
              (list '*))))
    (lambda (scanner)
      (let ((~scanner (unwrap-GScanner* scanner)))
        (~f ~scanner)))))
(export g_scanner_destroy)

;; extern void g_scanner_input_file(GScanner *scanner, gint input_fd);
(define g_scanner_input_file
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_scanner_input_file"
                (dynamic-link))
              (list '* ffi:int))))
    (lambda (scanner input_fd)
      (let ((~scanner (unwrap-GScanner* scanner))
            (~input_fd (unwrap-gint input_fd)))
        (~f ~scanner ~input_fd)))))
(export g_scanner_input_file)

;; extern void g_scanner_sync_file_offset(GScanner *scanner);
(define g_scanner_sync_file_offset
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_scanner_sync_file_offset"
                (dynamic-link))
              (list '*))))
    (lambda (scanner)
      (let ((~scanner (unwrap-GScanner* scanner)))
        (~f ~scanner)))))
(export g_scanner_sync_file_offset)

;; extern void g_scanner_input_text(GScanner *scanner, const gchar *text, guint
;;      text_len);
(define g_scanner_input_text
  (let ((~f (ffi:pointer->procedure
              ffi:void
              (dynamic-func
                "g_scanner_input_text"
                (dynamic-link))
              (list '* '* ffi:unsigned-int))))
    (lambda (scanner text text_len)
      (let ((~scanner (unwrap-GScanner* scanner))
            (~text (unwrap-gchar* text))
            (~text_len (unwrap-guint text_len)))
        (~f ~scanner ~text ~text_len)))))
(export g_scanner_input_text)

;; extern GTokenType g_scanner_get_next_token(GScanner *scanner);
(define g_scanner_get_next_token
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_scanner_get_next_token"
                (dynamic-link))
              (list '*))))
    (lambda (scanner)
      (let ((~scanner (unwrap-GScanner* scanner)))
        (~f ~scanner)))))
(export g_scanner_get_next_token)

;; extern GTokenType g_scanner_peek_next_token(GScanner *scanner);
(define g_scanner_peek_next_token
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_scanner_peek_next_token"
                (dynamic-link))
              (list '*))))
    (lambda (scanner)
      (let ((~scanner (unwrap-GScanner* scanner)))
        (~f ~scanner)))))
(export g_scanner_peek_next_token)

;; extern GTokenType g_scanner_cur_token(GScanner *scanner);
(define g_scanner_cur_token
  (let ((~f (ffi:pointer->procedure
              ffi:int
              (dynamic-func
                "g_scanner_cur_token"
                (dynamic-link))
              (list '*))))
    (lambda (scanner)
      (let ((~scanner (unwrap-GScanner* scanner)))
        (~f ~scanner)))))
(export g_scanner_cur_token)

;; extern GTokenValue g_scanner_cur_value(GScanner *scanner);
