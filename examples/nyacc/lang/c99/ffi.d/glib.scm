;; auto-generated by ffi-help.scm

(define-module (glib)
  #:use-module (system ffi-help-rt)
  #:use-module ((system foreign) #:prefix ffi:)
  #:use-module (bytestructures guile)
  )
(dynamic-link "libintl")
(dynamic-link "libglib-2.0")
(define void intptr_t)
(define echo-decls #f)

;; typedef char gchar;
(define gchar-desc int)
(export gchar-desc)
(define unwrap-gchar unwrap~fixed)
(define wrap-gchar identity)
(export gchar-desc unwrap-gchar wrap-gchar)

;; typedef short gshort;
(define gshort-desc short)
(export gshort-desc)
(define unwrap-gshort unwrap~fixed)
(define wrap-gshort identity)
(export gshort-desc unwrap-gshort wrap-gshort)

;; typedef long glong;
(define glong-desc long)
(export glong-desc)
(define unwrap-glong unwrap~fixed)
(define wrap-glong identity)
(export glong-desc unwrap-glong wrap-glong)

;; typedef int gint;
(define gint-desc int)
(export gint-desc)
(define unwrap-gint unwrap~fixed)
(define wrap-gint identity)
(export gint-desc unwrap-gint wrap-gint)

;; typedef gint gboolean;
(define unwrap-gboolean unwrap-gint)
(define wrap-gboolean wrap-gint)

;; typedef unsigned char guchar;
(define guchar-desc unsigned-int)
(export guchar-desc)
(define unwrap-guchar unwrap~fixed)
(define wrap-guchar identity)
(export guchar-desc unwrap-guchar wrap-guchar)

;; typedef unsigned short gushort;
(define gushort-desc unsigned-short)
(export gushort-desc)
(define unwrap-gushort unwrap~fixed)
(define wrap-gushort identity)
(export gushort-desc unwrap-gushort wrap-gushort)

;; typedef unsigned long gulong;
(define gulong-desc unsigned-long)
(export gulong-desc)
(define unwrap-gulong unwrap~fixed)
(define wrap-gulong identity)
(export gulong-desc unwrap-gulong wrap-gulong)

;; typedef unsigned int guint;
(define guint-desc unsigned-int)
(export guint-desc)
(define unwrap-guint unwrap~fixed)
(define wrap-guint identity)
(export guint-desc unwrap-guint wrap-guint)

;; typedef float gfloat;
(define gfloat-desc float)
(define unwrap-gfloat unwrap~float)
(define wrap-gfloat identity)
(export gfloat-desc unwrap-gfloat wrap-gfloat)

;; typedef double gdouble;
(define gdouble-desc double)
(define unwrap-gdouble unwrap~float)
(define wrap-gdouble identity)
(export gdouble-desc unwrap-gdouble wrap-gdouble)

;; typedef void *gpointer;
(define gpointer-desc (bs:pointer void))
(export gpointer-desc)
(define-fh-pointer-type gpointer gpointer-desc)

;; typedef const void *gconstpointer;
(define gconstpointer-desc (bs:pointer void))
(export gconstpointer-desc)
(define-fh-pointer-type gconstpointer gconstpointer-desc)

;; typedef gint (*GCompareFunc)(gconstpointer a, gconstpointer b);
(define-fh-function/p GCompareFunc
  ffi:int (list (quote *) (quote *)))

;; typedef gint (*GCompareDataFunc)(gconstpointer a, gconstpointer b, gpointer 
;;     user_data);
(define-fh-function/p GCompareDataFunc
  ffi:int (list (quote *) (quote *) (quote *)))

;; typedef gboolean (*GEqualFunc)(gconstpointer a, gconstpointer b);
(define-fh-function/p GEqualFunc
  ffi:int (list (quote *) (quote *)))

;; typedef void (*GDestroyNotify)(gpointer data);
(define-fh-function/p GDestroyNotify
  ffi:void (list (quote *)))

;; typedef void (*GFunc)(gpointer data, gpointer user_data);
(define-fh-function/p GFunc
  ffi:void (list (quote *) (quote *)))

;; typedef guint (*GHashFunc)(gconstpointer key);
(define-fh-function/p GHashFunc
  ffi:unsigned-int (list (quote *)))

;; typedef void (*GHFunc)(gpointer key, gpointer value, gpointer user_data);
(define-fh-function/p GHFunc
  ffi:void (list (quote *) (quote *) (quote *)))

;; typedef void (*GFreeFunc)(gpointer data);
(define-fh-function/p GFreeFunc
  ffi:void (list (quote *)))

;; typedef const gchar *(*GTranslateFunc)(const gchar *str, gpointer data);
(define-fh-function/p
  GTranslateFunc
  '*
  (list '* '*))

;; typedef union _GDoubleIEEE754 GDoubleIEEE754;
;; union _GDoubleIEEE754 {
;;   gdouble v_double;
;;   struct {
;;     guint mantissa_low : 32;
;;     guint mantissa_high : 20;
;;     guint biased_exponent : 11;
;;     guint sign : 1;
;;   } mpn;
;; };
(define GDoubleIEEE754-desc
  (bs:union
    (list `(v_double ,gdouble-desc)
          `(mpn ,(bs:struct
                   (list `(mantissa_low ,unsigned-int ,32)
                         `(mantissa_high ,unsigned-int ,20)
                         `(biased_exponent ,unsigned-int ,11)
                         `(sign ,unsigned-int ,1)))))))
(export GDoubleIEEE754-desc)
(define-fh-compound-type/p GDoubleIEEE754 GDoubleIEEE754-desc)
(define union-_GDoubleIEEE754 GDoubleIEEE754)

;; typedef union _GFloatIEEE754 GFloatIEEE754;
;; union _GFloatIEEE754 {
;;   gfloat v_float;
;;   struct {
;;     guint mantissa : 23;
;;     guint biased_exponent : 8;
;;     guint sign : 1;
;;   } mpn;
;; };
(define GFloatIEEE754-desc
  (bs:union
    (list `(v_float ,gfloat-desc)
          `(mpn ,(bs:struct
                   (list `(mantissa ,unsigned-int ,23)
                         `(biased_exponent ,unsigned-int ,8)
                         `(sign ,unsigned-int ,1)))))))
(export GFloatIEEE754-desc)
(define-fh-compound-type/p GFloatIEEE754 GFloatIEEE754-desc)
(define union-_GFloatIEEE754 GFloatIEEE754)

;; typedef struct _GTimeVal GTimeVal;
(define GTimeVal-desc void)
(define GTimeVal*-desc (bs:pointer (delay GTimeVal-desc)))
(export GTimeVal*-desc)
(define-fh-pointer-type GTimeVal* GTimeVal*-desc)

;; struct _GTimeVal {
;;   glong tv_sec;
;;   glong tv_usec;
;; };
(define struct-_GTimeVal-desc
  (bs:struct
    (list `(tv_sec ,long) `(tv_usec ,long))))
(export struct-_GTimeVal-desc)
(define-fh-compound-type/p struct-_GTimeVal struct-_GTimeVal-desc)
(set! GTimeVal-desc struct-_GTimeVal-desc)
(define-fh-compound-type GTimeVal GTimeVal-desc)

;; typedef struct _GBytes GBytes;
(define GBytes-desc void)
(define GBytes*-desc (bs:pointer GBytes-desc))
(export GBytes*-desc)
(define-fh-pointer-type GBytes* GBytes*-desc)

;; typedef struct _GArray GArray;
(define GArray-desc void)
(define GArray*-desc (bs:pointer (delay GArray-desc)))
(export GArray*-desc)
(define-fh-pointer-type GArray* GArray*-desc)

;; typedef struct _GByteArray GByteArray;
(define GByteArray-desc void)
(define GByteArray*-desc (bs:pointer (delay GByteArray-desc)))
(export GByteArray*-desc)
(define-fh-pointer-type GByteArray* GByteArray*-desc)

;; typedef struct _GPtrArray GPtrArray;
(define GPtrArray-desc void)
(define GPtrArray*-desc (bs:pointer (delay GPtrArray-desc)))
(export GPtrArray*-desc)
(define-fh-pointer-type GPtrArray* GPtrArray*-desc)

;; struct _GArray {
;;   gchar *data;
;;   guint len;
;; };
(define struct-_GArray-desc
  (bs:struct
    (list `(data ,(bs:pointer int))
          `(len ,unsigned-int))))
(export struct-_GArray-desc)
(define-fh-compound-type/p struct-_GArray struct-_GArray-desc)
(set! GArray-desc struct-_GArray-desc)
(define-fh-compound-type GArray GArray-desc)

;; struct _GByteArray {
;;   guint8 *data;
;;   guint len;
;; };
(define struct-_GByteArray-desc
  (bs:struct
    (list `(data ,(bs:pointer unsigned-int))
          `(len ,unsigned-int))))
(export struct-_GByteArray-desc)
(define-fh-compound-type/p struct-_GByteArray struct-_GByteArray-desc)
(set! GByteArray-desc struct-_GByteArray-desc)
(define-fh-compound-type GByteArray GByteArray-desc)

;; struct _GPtrArray {
;;   gpointer *pdata;
;;   guint len;
;; };
(define struct-_GPtrArray-desc
  (bs:struct
    (list `(pdata ,(bs:pointer (delay gpointer*-desc)))
          `(len ,unsigned-int))))
(export struct-_GPtrArray-desc)
(define-fh-compound-type/p struct-_GPtrArray struct-_GPtrArray-desc)
(set! GPtrArray-desc struct-_GPtrArray-desc)
(define-fh-compound-type GPtrArray GPtrArray-desc)

;; extern GArray *g_array_new(gboolean zero_terminated, gboolean clear_, guint 
;;     element_size);
(define g_array_new
  (let ((~f #f))
    (lambda (zero_terminated clear_ element_size)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_array_new"
            '*
            (list ffi:int ffi:int ffi:unsigned-int))))
      (let ((~zero_terminated (unwrap~fixed zero_terminated))
            (~clear_ (unwrap~fixed clear_))
            (~element_size (unwrap~fixed element_size)))
        (wrap-GArray*
          (~f ~zero_terminated ~clear_ ~element_size))))))
(export g_array_new)

;; extern GArray *g_array_sized_new(gboolean zero_terminated, gboolean clear_, 
;;     guint element_size, guint reserved_size);
(define g_array_sized_new
  (let ((~f #f))
    (lambda (zero_terminated
             clear_
             element_size
             reserved_size)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_array_sized_new"
            '*
            (list ffi:int
                  ffi:int
                  ffi:unsigned-int
                  ffi:unsigned-int))))
      (let ((~zero_terminated (unwrap~fixed zero_terminated))
            (~clear_ (unwrap~fixed clear_))
            (~element_size (unwrap~fixed element_size))
            (~reserved_size (unwrap~fixed reserved_size)))
        (wrap-GArray*
          (~f ~zero_terminated
              ~clear_
              ~element_size
              ~reserved_size))))))
(export g_array_sized_new)

;; extern gchar *g_array_free(GArray *array, gboolean free_segment);
(define g_array_free
  (let ((~f #f))
    (lambda (array free_segment)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_array_free"
            '*
            (list '* ffi:int))))
      (let ((~array (unwrap-GArray* array))
            (~free_segment (unwrap~fixed free_segment)))
        (~f ~array ~free_segment)))))
(export g_array_free)

;; extern GArray *g_array_ref(GArray *array);
(define g_array_ref
  (let ((~f #f))
    (lambda (array)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_array_ref" '* (list '*))))
      (let ((~array (unwrap-GArray* array)))
        (wrap-GArray* (~f ~array))))))
(export g_array_ref)

;; extern void g_array_unref(GArray *array);
(define g_array_unref
  (let ((~f #f))
    (lambda (array)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_array_unref" ffi:void (list '*))))
      (let ((~array (unwrap-GArray* array)))
        (~f ~array)))))
(export g_array_unref)

;; extern guint g_array_get_element_size(GArray *array);
(define g_array_get_element_size
  (let ((~f #f))
    (lambda (array)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_array_get_element_size"
            ffi:unsigned-int
            (list '*))))
      (let ((~array (unwrap-GArray* array)))
        (~f ~array)))))
(export g_array_get_element_size)

;; extern GArray *g_array_append_vals(GArray *array, gconstpointer data, guint 
;;     len);
(define g_array_append_vals
  (let ((~f #f))
    (lambda (array data len)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_array_append_vals"
            '*
            (list '* '* ffi:unsigned-int))))
      (let ((~array (unwrap-GArray* array))
            (~data (unwrap-gconstpointer data))
            (~len (unwrap~fixed len)))
        (wrap-GArray* (~f ~array ~data ~len))))))
(export g_array_append_vals)

;; extern GArray *g_array_prepend_vals(GArray *array, gconstpointer data, guint
;;      len);
(define g_array_prepend_vals
  (let ((~f #f))
    (lambda (array data len)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_array_prepend_vals"
            '*
            (list '* '* ffi:unsigned-int))))
      (let ((~array (unwrap-GArray* array))
            (~data (unwrap-gconstpointer data))
            (~len (unwrap~fixed len)))
        (wrap-GArray* (~f ~array ~data ~len))))))
(export g_array_prepend_vals)

;; extern GArray *g_array_insert_vals(GArray *array, guint index_, 
;;     gconstpointer data, guint len);
(define g_array_insert_vals
  (let ((~f #f))
    (lambda (array index_ data len)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_array_insert_vals"
            '*
            (list '* ffi:unsigned-int '* ffi:unsigned-int))))
      (let ((~array (unwrap-GArray* array))
            (~index_ (unwrap~fixed index_))
            (~data (unwrap-gconstpointer data))
            (~len (unwrap~fixed len)))
        (wrap-GArray* (~f ~array ~index_ ~data ~len))))))
(export g_array_insert_vals)

;; extern GArray *g_array_set_size(GArray *array, guint length);
(define g_array_set_size
  (let ((~f #f))
    (lambda (array length)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_array_set_size"
            '*
            (list '* ffi:unsigned-int))))
      (let ((~array (unwrap-GArray* array))
            (~length (unwrap~fixed length)))
        (wrap-GArray* (~f ~array ~length))))))
(export g_array_set_size)

;; extern GArray *g_array_remove_index(GArray *array, guint index_);
(define g_array_remove_index
  (let ((~f #f))
    (lambda (array index_)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_array_remove_index"
            '*
            (list '* ffi:unsigned-int))))
      (let ((~array (unwrap-GArray* array))
            (~index_ (unwrap~fixed index_)))
        (wrap-GArray* (~f ~array ~index_))))))
(export g_array_remove_index)

;; extern GArray *g_array_remove_index_fast(GArray *array, guint index_);
(define g_array_remove_index_fast
  (let ((~f #f))
    (lambda (array index_)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_array_remove_index_fast"
            '*
            (list '* ffi:unsigned-int))))
      (let ((~array (unwrap-GArray* array))
            (~index_ (unwrap~fixed index_)))
        (wrap-GArray* (~f ~array ~index_))))))
(export g_array_remove_index_fast)

;; extern GArray *g_array_remove_range(GArray *array, guint index_, guint 
;;     length);
(define g_array_remove_range
  (let ((~f #f))
    (lambda (array index_ length)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_array_remove_range"
            '*
            (list '* ffi:unsigned-int ffi:unsigned-int))))
      (let ((~array (unwrap-GArray* array))
            (~index_ (unwrap~fixed index_))
            (~length (unwrap~fixed length)))
        (wrap-GArray* (~f ~array ~index_ ~length))))))
(export g_array_remove_range)

;; extern void g_array_sort(GArray *array, GCompareFunc compare_func);
(define g_array_sort
  (let ((~f #f))
    (lambda (array compare_func)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_array_sort"
            ffi:void
            (list '* '*))))
      (let ((~array (unwrap-GArray* array))
            (~compare_func
              ((make-ftn-arg-unwrapper ffi:int (list '* '*))
               compare_func)))
        (~f ~array ~compare_func)))))
(export g_array_sort)

;; extern void g_array_sort_with_data(GArray *array, GCompareDataFunc 
;;     compare_func, gpointer user_data);
(define g_array_sort_with_data
  (let ((~f #f))
    (lambda (array compare_func user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_array_sort_with_data"
            ffi:void
            (list '* '* '*))))
      (let ((~array (unwrap-GArray* array))
            (~compare_func
              ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
               compare_func))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~array ~compare_func ~user_data)))))
(export g_array_sort_with_data)

;; extern void g_array_set_clear_func(GArray *array, GDestroyNotify clear_func)
;;     ;
(define g_array_set_clear_func
  (let ((~f #f))
    (lambda (array clear_func)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_array_set_clear_func"
            ffi:void
            (list '* '*))))
      (let ((~array (unwrap-GArray* array))
            (~clear_func
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               clear_func)))
        (~f ~array ~clear_func)))))
(export g_array_set_clear_func)

;; extern GPtrArray *g_ptr_array_new(void);
(define g_ptr_array_new
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_ptr_array_new" '* (list))))
      (let () (wrap-GPtrArray* (~f))))))
(export g_ptr_array_new)

;; extern GPtrArray *g_ptr_array_new_with_free_func(GDestroyNotify 
;;     element_free_func);
(define g_ptr_array_new_with_free_func
  (let ((~f #f))
    (lambda (element_free_func)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_ptr_array_new_with_free_func"
            '*
            (list '*))))
      (let ((~element_free_func
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               element_free_func)))
        (wrap-GPtrArray* (~f ~element_free_func))))))
(export g_ptr_array_new_with_free_func)

;; extern GPtrArray *g_ptr_array_sized_new(guint reserved_size);
(define g_ptr_array_sized_new
  (let ((~f #f))
    (lambda (reserved_size)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_ptr_array_sized_new"
            '*
            (list ffi:unsigned-int))))
      (let ((~reserved_size (unwrap~fixed reserved_size)))
        (wrap-GPtrArray* (~f ~reserved_size))))))
(export g_ptr_array_sized_new)

;; extern GPtrArray *g_ptr_array_new_full(guint reserved_size, GDestroyNotify 
;;     element_free_func);
(define g_ptr_array_new_full
  (let ((~f #f))
    (lambda (reserved_size element_free_func)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_ptr_array_new_full"
            '*
            (list ffi:unsigned-int '*))))
      (let ((~reserved_size (unwrap~fixed reserved_size))
            (~element_free_func
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               element_free_func)))
        (wrap-GPtrArray*
          (~f ~reserved_size ~element_free_func))))))
(export g_ptr_array_new_full)

;; extern gpointer *g_ptr_array_free(GPtrArray *array, gboolean free_seg);
(define g_ptr_array_free
  (let ((~f #f))
    (lambda (array free_seg)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_ptr_array_free"
            '*
            (list '* ffi:int))))
      (let ((~array (unwrap-GPtrArray* array))
            (~free_seg (unwrap~fixed free_seg)))
        (wrap-gpointer* (~f ~array ~free_seg))))))
(export g_ptr_array_free)

;; extern GPtrArray *g_ptr_array_ref(GPtrArray *array);
(define g_ptr_array_ref
  (let ((~f #f))
    (lambda (array)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_ptr_array_ref" '* (list '*))))
      (let ((~array (unwrap-GPtrArray* array)))
        (wrap-GPtrArray* (~f ~array))))))
(export g_ptr_array_ref)

;; extern void g_ptr_array_unref(GPtrArray *array);
(define g_ptr_array_unref
  (let ((~f #f))
    (lambda (array)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_ptr_array_unref"
            ffi:void
            (list '*))))
      (let ((~array (unwrap-GPtrArray* array)))
        (~f ~array)))))
(export g_ptr_array_unref)

;; extern void g_ptr_array_set_free_func(GPtrArray *array, GDestroyNotify 
;;     element_free_func);
(define g_ptr_array_set_free_func
  (let ((~f #f))
    (lambda (array element_free_func)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_ptr_array_set_free_func"
            ffi:void
            (list '* '*))))
      (let ((~array (unwrap-GPtrArray* array))
            (~element_free_func
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               element_free_func)))
        (~f ~array ~element_free_func)))))
(export g_ptr_array_set_free_func)

;; extern void g_ptr_array_set_size(GPtrArray *array, gint length);
(define g_ptr_array_set_size
  (let ((~f #f))
    (lambda (array length)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_ptr_array_set_size"
            ffi:void
            (list '* ffi:int))))
      (let ((~array (unwrap-GPtrArray* array))
            (~length (unwrap~fixed length)))
        (~f ~array ~length)))))
(export g_ptr_array_set_size)

;; extern gpointer g_ptr_array_remove_index(GPtrArray *array, guint index_);
(define g_ptr_array_remove_index
  (let ((~f #f))
    (lambda (array index_)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_ptr_array_remove_index"
            '*
            (list '* ffi:unsigned-int))))
      (let ((~array (unwrap-GPtrArray* array))
            (~index_ (unwrap~fixed index_)))
        (wrap-gpointer (~f ~array ~index_))))))
(export g_ptr_array_remove_index)

;; extern gpointer g_ptr_array_remove_index_fast(GPtrArray *array, guint index_
;;     );
(define g_ptr_array_remove_index_fast
  (let ((~f #f))
    (lambda (array index_)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_ptr_array_remove_index_fast"
            '*
            (list '* ffi:unsigned-int))))
      (let ((~array (unwrap-GPtrArray* array))
            (~index_ (unwrap~fixed index_)))
        (wrap-gpointer (~f ~array ~index_))))))
(export g_ptr_array_remove_index_fast)

;; extern gboolean g_ptr_array_remove(GPtrArray *array, gpointer data);
(define g_ptr_array_remove
  (let ((~f #f))
    (lambda (array data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_ptr_array_remove"
            ffi:int
            (list '* '*))))
      (let ((~array (unwrap-GPtrArray* array))
            (~data (unwrap-gpointer data)))
        (~f ~array ~data)))))
(export g_ptr_array_remove)

;; extern gboolean g_ptr_array_remove_fast(GPtrArray *array, gpointer data);
(define g_ptr_array_remove_fast
  (let ((~f #f))
    (lambda (array data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_ptr_array_remove_fast"
            ffi:int
            (list '* '*))))
      (let ((~array (unwrap-GPtrArray* array))
            (~data (unwrap-gpointer data)))
        (~f ~array ~data)))))
(export g_ptr_array_remove_fast)

;; extern GPtrArray *g_ptr_array_remove_range(GPtrArray *array, guint index_, 
;;     guint length);
(define g_ptr_array_remove_range
  (let ((~f #f))
    (lambda (array index_ length)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_ptr_array_remove_range"
            '*
            (list '* ffi:unsigned-int ffi:unsigned-int))))
      (let ((~array (unwrap-GPtrArray* array))
            (~index_ (unwrap~fixed index_))
            (~length (unwrap~fixed length)))
        (wrap-GPtrArray* (~f ~array ~index_ ~length))))))
(export g_ptr_array_remove_range)

;; extern void g_ptr_array_add(GPtrArray *array, gpointer data);
(define g_ptr_array_add
  (let ((~f #f))
    (lambda (array data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_ptr_array_add"
            ffi:void
            (list '* '*))))
      (let ((~array (unwrap-GPtrArray* array))
            (~data (unwrap-gpointer data)))
        (~f ~array ~data)))))
(export g_ptr_array_add)

;; extern void g_ptr_array_insert(GPtrArray *array, gint index_, gpointer data)
;;     ;
(define g_ptr_array_insert
  (let ((~f #f))
    (lambda (array index_ data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_ptr_array_insert"
            ffi:void
            (list '* ffi:int '*))))
      (let ((~array (unwrap-GPtrArray* array))
            (~index_ (unwrap~fixed index_))
            (~data (unwrap-gpointer data)))
        (~f ~array ~index_ ~data)))))
(export g_ptr_array_insert)

;; extern void g_ptr_array_sort(GPtrArray *array, GCompareFunc compare_func);
(define g_ptr_array_sort
  (let ((~f #f))
    (lambda (array compare_func)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_ptr_array_sort"
            ffi:void
            (list '* '*))))
      (let ((~array (unwrap-GPtrArray* array))
            (~compare_func
              ((make-ftn-arg-unwrapper ffi:int (list '* '*))
               compare_func)))
        (~f ~array ~compare_func)))))
(export g_ptr_array_sort)

;; extern void g_ptr_array_sort_with_data(GPtrArray *array, GCompareDataFunc 
;;     compare_func, gpointer user_data);
(define g_ptr_array_sort_with_data
  (let ((~f #f))
    (lambda (array compare_func user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_ptr_array_sort_with_data"
            ffi:void
            (list '* '* '*))))
      (let ((~array (unwrap-GPtrArray* array))
            (~compare_func
              ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
               compare_func))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~array ~compare_func ~user_data)))))
(export g_ptr_array_sort_with_data)

;; extern void g_ptr_array_foreach(GPtrArray *array, GFunc func, gpointer 
;;     user_data);
(define g_ptr_array_foreach
  (let ((~f #f))
    (lambda (array func user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_ptr_array_foreach"
            ffi:void
            (list '* '* '*))))
      (let ((~array (unwrap-GPtrArray* array))
            (~func ((make-ftn-arg-unwrapper ffi:void (list '* '*))
                    func))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~array ~func ~user_data)))))
(export g_ptr_array_foreach)

;; extern GByteArray *g_byte_array_new(void);
(define g_byte_array_new
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_byte_array_new" '* (list))))
      (let () (wrap-GByteArray* (~f))))))
(export g_byte_array_new)

;; extern GByteArray *g_byte_array_new_take(guint8 *data, gsize len);
(define g_byte_array_new_take
  (let ((~f #f))
    (lambda (data len)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_byte_array_new_take"
            '*
            (list '* ffi:unsigned-long))))
      (let ((~data (unwrap~pointer data))
            (~len (unwrap~fixed len)))
        (wrap-GByteArray* (~f ~data ~len))))))
(export g_byte_array_new_take)

;; extern GByteArray *g_byte_array_sized_new(guint reserved_size);
(define g_byte_array_sized_new
  (let ((~f #f))
    (lambda (reserved_size)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_byte_array_sized_new"
            '*
            (list ffi:unsigned-int))))
      (let ((~reserved_size (unwrap~fixed reserved_size)))
        (wrap-GByteArray* (~f ~reserved_size))))))
(export g_byte_array_sized_new)

;; extern guint8 *g_byte_array_free(GByteArray *array, gboolean free_segment);
(define g_byte_array_free
  (let ((~f #f))
    (lambda (array free_segment)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_byte_array_free"
            '*
            (list '* ffi:int))))
      (let ((~array (unwrap-GByteArray* array))
            (~free_segment (unwrap~fixed free_segment)))
        (~f ~array ~free_segment)))))
(export g_byte_array_free)

;; extern GBytes *g_byte_array_free_to_bytes(GByteArray *array);
(define g_byte_array_free_to_bytes
  (let ((~f #f))
    (lambda (array)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_byte_array_free_to_bytes"
            '*
            (list '*))))
      (let ((~array (unwrap-GByteArray* array)))
        (wrap-GBytes* (~f ~array))))))
(export g_byte_array_free_to_bytes)

;; extern GByteArray *g_byte_array_ref(GByteArray *array);
(define g_byte_array_ref
  (let ((~f #f))
    (lambda (array)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_byte_array_ref" '* (list '*))))
      (let ((~array (unwrap-GByteArray* array)))
        (wrap-GByteArray* (~f ~array))))))
(export g_byte_array_ref)

;; extern void g_byte_array_unref(GByteArray *array);
(define g_byte_array_unref
  (let ((~f #f))
    (lambda (array)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_byte_array_unref"
            ffi:void
            (list '*))))
      (let ((~array (unwrap-GByteArray* array)))
        (~f ~array)))))
(export g_byte_array_unref)

;; extern GByteArray *g_byte_array_append(GByteArray *array, const guint8 *data
;;     , guint len);
(define g_byte_array_append
  (let ((~f #f))
    (lambda (array data len)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_byte_array_append"
            '*
            (list '* '* ffi:unsigned-int))))
      (let ((~array (unwrap-GByteArray* array))
            (~data (unwrap~pointer data))
            (~len (unwrap~fixed len)))
        (wrap-GByteArray* (~f ~array ~data ~len))))))
(export g_byte_array_append)

;; extern GByteArray *g_byte_array_prepend(GByteArray *array, const guint8 *
;;     data, guint len);
(define g_byte_array_prepend
  (let ((~f #f))
    (lambda (array data len)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_byte_array_prepend"
            '*
            (list '* '* ffi:unsigned-int))))
      (let ((~array (unwrap-GByteArray* array))
            (~data (unwrap~pointer data))
            (~len (unwrap~fixed len)))
        (wrap-GByteArray* (~f ~array ~data ~len))))))
(export g_byte_array_prepend)

;; extern GByteArray *g_byte_array_set_size(GByteArray *array, guint length);
(define g_byte_array_set_size
  (let ((~f #f))
    (lambda (array length)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_byte_array_set_size"
            '*
            (list '* ffi:unsigned-int))))
      (let ((~array (unwrap-GByteArray* array))
            (~length (unwrap~fixed length)))
        (wrap-GByteArray* (~f ~array ~length))))))
(export g_byte_array_set_size)

;; extern GByteArray *g_byte_array_remove_index(GByteArray *array, guint index_
;;     );
(define g_byte_array_remove_index
  (let ((~f #f))
    (lambda (array index_)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_byte_array_remove_index"
            '*
            (list '* ffi:unsigned-int))))
      (let ((~array (unwrap-GByteArray* array))
            (~index_ (unwrap~fixed index_)))
        (wrap-GByteArray* (~f ~array ~index_))))))
(export g_byte_array_remove_index)

;; extern GByteArray *g_byte_array_remove_index_fast(GByteArray *array, guint 
;;     index_);
(define g_byte_array_remove_index_fast
  (let ((~f #f))
    (lambda (array index_)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_byte_array_remove_index_fast"
            '*
            (list '* ffi:unsigned-int))))
      (let ((~array (unwrap-GByteArray* array))
            (~index_ (unwrap~fixed index_)))
        (wrap-GByteArray* (~f ~array ~index_))))))
(export g_byte_array_remove_index_fast)

;; extern GByteArray *g_byte_array_remove_range(GByteArray *array, guint index_
;;     , guint length);
(define g_byte_array_remove_range
  (let ((~f #f))
    (lambda (array index_ length)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_byte_array_remove_range"
            '*
            (list '* ffi:unsigned-int ffi:unsigned-int))))
      (let ((~array (unwrap-GByteArray* array))
            (~index_ (unwrap~fixed index_))
            (~length (unwrap~fixed length)))
        (wrap-GByteArray* (~f ~array ~index_ ~length))))))
(export g_byte_array_remove_range)

;; extern void g_byte_array_sort(GByteArray *array, GCompareFunc compare_func)
;;     ;
(define g_byte_array_sort
  (let ((~f #f))
    (lambda (array compare_func)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_byte_array_sort"
            ffi:void
            (list '* '*))))
      (let ((~array (unwrap-GByteArray* array))
            (~compare_func
              ((make-ftn-arg-unwrapper ffi:int (list '* '*))
               compare_func)))
        (~f ~array ~compare_func)))))
(export g_byte_array_sort)

;; extern void g_byte_array_sort_with_data(GByteArray *array, GCompareDataFunc 
;;     compare_func, gpointer user_data);
(define g_byte_array_sort_with_data
  (let ((~f #f))
    (lambda (array compare_func user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_byte_array_sort_with_data"
            ffi:void
            (list '* '* '*))))
      (let ((~array (unwrap-GByteArray* array))
            (~compare_func
              ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
               compare_func))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~array ~compare_func ~user_data)))))
(export g_byte_array_sort_with_data)

;; extern gint g_atomic_int_get(const volatile gint *atomic);
(define g_atomic_int_get
  (let ((~f #f))
    (lambda (atomic)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_atomic_int_get"
            ffi:int
            (list '*))))
      (let ((~atomic (unwrap~pointer atomic)))
        (~f ~atomic)))))
(export g_atomic_int_get)

;; extern void g_atomic_int_set(volatile gint *atomic, gint newval);
(define g_atomic_int_set
  (let ((~f #f))
    (lambda (atomic newval)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_atomic_int_set"
            ffi:void
            (list '* ffi:int))))
      (let ((~atomic (unwrap~pointer atomic))
            (~newval (unwrap~fixed newval)))
        (~f ~atomic ~newval)))))
(export g_atomic_int_set)

;; extern void g_atomic_int_inc(volatile gint *atomic);
(define g_atomic_int_inc
  (let ((~f #f))
    (lambda (atomic)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_atomic_int_inc"
            ffi:void
            (list '*))))
      (let ((~atomic (unwrap~pointer atomic)))
        (~f ~atomic)))))
(export g_atomic_int_inc)

;; extern gboolean g_atomic_int_dec_and_test(volatile gint *atomic);
(define g_atomic_int_dec_and_test
  (let ((~f #f))
    (lambda (atomic)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_atomic_int_dec_and_test"
            ffi:int
            (list '*))))
      (let ((~atomic (unwrap~pointer atomic)))
        (~f ~atomic)))))
(export g_atomic_int_dec_and_test)

;; extern gboolean g_atomic_int_compare_and_exchange(volatile gint *atomic, 
;;     gint oldval, gint newval);
(define g_atomic_int_compare_and_exchange
  (let ((~f #f))
    (lambda (atomic oldval newval)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_atomic_int_compare_and_exchange"
            ffi:int
            (list '* ffi:int ffi:int))))
      (let ((~atomic (unwrap~pointer atomic))
            (~oldval (unwrap~fixed oldval))
            (~newval (unwrap~fixed newval)))
        (~f ~atomic ~oldval ~newval)))))
(export g_atomic_int_compare_and_exchange)

;; extern gint g_atomic_int_add(volatile gint *atomic, gint val);
(define g_atomic_int_add
  (let ((~f #f))
    (lambda (atomic val)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_atomic_int_add"
            ffi:int
            (list '* ffi:int))))
      (let ((~atomic (unwrap~pointer atomic))
            (~val (unwrap~fixed val)))
        (~f ~atomic ~val)))))
(export g_atomic_int_add)

;; extern guint g_atomic_int_and(volatile guint *atomic, guint val);
(define g_atomic_int_and
  (let ((~f #f))
    (lambda (atomic val)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_atomic_int_and"
            ffi:unsigned-int
            (list '* ffi:unsigned-int))))
      (let ((~atomic (unwrap~pointer atomic))
            (~val (unwrap~fixed val)))
        (~f ~atomic ~val)))))
(export g_atomic_int_and)

;; extern guint g_atomic_int_or(volatile guint *atomic, guint val);
(define g_atomic_int_or
  (let ((~f #f))
    (lambda (atomic val)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_atomic_int_or"
            ffi:unsigned-int
            (list '* ffi:unsigned-int))))
      (let ((~atomic (unwrap~pointer atomic))
            (~val (unwrap~fixed val)))
        (~f ~atomic ~val)))))
(export g_atomic_int_or)

;; extern guint g_atomic_int_xor(volatile guint *atomic, guint val);
(define g_atomic_int_xor
  (let ((~f #f))
    (lambda (atomic val)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_atomic_int_xor"
            ffi:unsigned-int
            (list '* ffi:unsigned-int))))
      (let ((~atomic (unwrap~pointer atomic))
            (~val (unwrap~fixed val)))
        (~f ~atomic ~val)))))
(export g_atomic_int_xor)

;; extern gpointer g_atomic_pointer_get(const volatile void *atomic);
(define g_atomic_pointer_get
  (let ((~f #f))
    (lambda (atomic)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_atomic_pointer_get"
            '*
            (list '*))))
      (let ((~atomic (unwrap~pointer atomic)))
        (wrap-gpointer (~f ~atomic))))))
(export g_atomic_pointer_get)

;; extern void g_atomic_pointer_set(volatile void *atomic, gpointer newval);
(define g_atomic_pointer_set
  (let ((~f #f))
    (lambda (atomic newval)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_atomic_pointer_set"
            ffi:void
            (list '* '*))))
      (let ((~atomic (unwrap~pointer atomic))
            (~newval (unwrap-gpointer newval)))
        (~f ~atomic ~newval)))))
(export g_atomic_pointer_set)

;; extern gboolean g_atomic_pointer_compare_and_exchange(volatile void *atomic
;;     , gpointer oldval, gpointer newval);
(define g_atomic_pointer_compare_and_exchange
  (let ((~f #f))
    (lambda (atomic oldval newval)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_atomic_pointer_compare_and_exchange"
            ffi:int
            (list '* '* '*))))
      (let ((~atomic (unwrap~pointer atomic))
            (~oldval (unwrap-gpointer oldval))
            (~newval (unwrap-gpointer newval)))
        (~f ~atomic ~oldval ~newval)))))
(export g_atomic_pointer_compare_and_exchange)

;; extern gssize g_atomic_pointer_add(volatile void *atomic, gssize val);
(define g_atomic_pointer_add
  (let ((~f #f))
    (lambda (atomic val)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_atomic_pointer_add"
            ffi:long
            (list '* ffi:long))))
      (let ((~atomic (unwrap~pointer atomic))
            (~val (unwrap~fixed val)))
        (~f ~atomic ~val)))))
(export g_atomic_pointer_add)

;; extern gsize g_atomic_pointer_and(volatile void *atomic, gsize val);
(define g_atomic_pointer_and
  (let ((~f #f))
    (lambda (atomic val)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_atomic_pointer_and"
            ffi:unsigned-long
            (list '* ffi:unsigned-long))))
      (let ((~atomic (unwrap~pointer atomic))
            (~val (unwrap~fixed val)))
        (~f ~atomic ~val)))))
(export g_atomic_pointer_and)

;; extern gsize g_atomic_pointer_or(volatile void *atomic, gsize val);
(define g_atomic_pointer_or
  (let ((~f #f))
    (lambda (atomic val)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_atomic_pointer_or"
            ffi:unsigned-long
            (list '* ffi:unsigned-long))))
      (let ((~atomic (unwrap~pointer atomic))
            (~val (unwrap~fixed val)))
        (~f ~atomic ~val)))))
(export g_atomic_pointer_or)

;; extern gsize g_atomic_pointer_xor(volatile void *atomic, gsize val);
(define g_atomic_pointer_xor
  (let ((~f #f))
    (lambda (atomic val)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_atomic_pointer_xor"
            ffi:unsigned-long
            (list '* ffi:unsigned-long))))
      (let ((~atomic (unwrap~pointer atomic))
            (~val (unwrap~fixed val)))
        (~f ~atomic ~val)))))
(export g_atomic_pointer_xor)

;; extern gint g_atomic_int_exchange_and_add(volatile gint *atomic, gint val);
(define g_atomic_int_exchange_and_add
  (let ((~f #f))
    (lambda (atomic val)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_atomic_int_exchange_and_add"
            ffi:int
            (list '* ffi:int))))
      (let ((~atomic (unwrap~pointer atomic))
            (~val (unwrap~fixed val)))
        (~f ~atomic ~val)))))
(export g_atomic_int_exchange_and_add)

;; typedef guint32 GQuark;
(define GQuark-desc unsigned-int)
(export GQuark-desc)
(define unwrap-GQuark unwrap~fixed)
(define wrap-GQuark identity)
(export GQuark-desc unwrap-GQuark wrap-GQuark)

;; extern GQuark g_quark_try_string(const gchar *string);
(define g_quark_try_string
  (let ((~f #f))
    (lambda (string)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_quark_try_string"
            ffi:unsigned-int
            (list '*))))
      (let ((~string (unwrap~pointer string)))
        (~f ~string)))))
(export g_quark_try_string)

;; extern GQuark g_quark_from_static_string(const gchar *string);
(define g_quark_from_static_string
  (let ((~f #f))
    (lambda (string)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_quark_from_static_string"
            ffi:unsigned-int
            (list '*))))
      (let ((~string (unwrap~pointer string)))
        (~f ~string)))))
(export g_quark_from_static_string)

;; extern GQuark g_quark_from_string(const gchar *string);
(define g_quark_from_string
  (let ((~f #f))
    (lambda (string)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_quark_from_string"
            ffi:unsigned-int
            (list '*))))
      (let ((~string (unwrap~pointer string)))
        (~f ~string)))))
(export g_quark_from_string)

;; extern const gchar *g_quark_to_string(GQuark quark);
(define g_quark_to_string
  (let ((~f #f))
    (lambda (quark)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_quark_to_string"
            '*
            (list ffi:unsigned-int))))
      (let ((~quark (unwrap~fixed quark))) (~f ~quark)))))
(export g_quark_to_string)

;; extern const gchar *g_intern_string(const gchar *string);
(define g_intern_string
  (let ((~f #f))
    (lambda (string)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_intern_string" '* (list '*))))
      (let ((~string (unwrap~pointer string)))
        (~f ~string)))))
(export g_intern_string)

;; extern const gchar *g_intern_static_string(const gchar *string);
(define g_intern_static_string
  (let ((~f #f))
    (lambda (string)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_intern_static_string"
            '*
            (list '*))))
      (let ((~string (unwrap~pointer string)))
        (~f ~string)))))
(export g_intern_static_string)

;; typedef struct _GError GError;
(define GError-desc void)
(define GError*-desc (bs:pointer (delay GError-desc)))
(export GError*-desc)
(define-fh-pointer-type GError* GError*-desc)

;; struct _GError {
;;   GQuark domain;
;;   gint code;
;;   gchar *message;
;; };
(define struct-_GError-desc
  (bs:struct
    (list `(domain ,unsigned-int)
          `(code ,int)
          `(message ,(bs:pointer int)))))
(export struct-_GError-desc)
(define-fh-compound-type/p struct-_GError struct-_GError-desc)
(set! GError-desc struct-_GError-desc)
(define-fh-compound-type GError GError-desc)

;; extern GError *g_error_new(GQuark domain, gint code, const gchar *format, 
;;     ...);
;; ... failed.

;; extern GError *g_error_new_literal(GQuark domain, gint code, const gchar *
;;     message);
(define g_error_new_literal
  (let ((~f #f))
    (lambda (domain code message)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_error_new_literal"
            '*
            (list ffi:unsigned-int ffi:int '*))))
      (let ((~domain (unwrap~fixed domain))
            (~code (unwrap~fixed code))
            (~message (unwrap~pointer message)))
        (wrap-GError* (~f ~domain ~code ~message))))))
(export g_error_new_literal)

;; extern GError *g_error_new_valist(GQuark domain, gint code, const gchar *
;;     format, va_list args);
(define g_error_new_valist
  (let ((~f #f))
    (lambda (domain code format args)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_error_new_valist"
            '*
            (list ffi:unsigned-int ffi:int '* '*))))
      (let ((~domain (unwrap~fixed domain))
            (~code (unwrap~fixed code))
            (~format (unwrap~pointer format))
            (~args (unwrap~pointer args)))
        (wrap-GError* (~f ~domain ~code ~format ~args))))))
(export g_error_new_valist)

;; extern void g_error_free(GError *error);
(define g_error_free
  (let ((~f #f))
    (lambda (error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_error_free" ffi:void (list '*))))
      (let ((~error (unwrap-GError* error)))
        (~f ~error)))))
(export g_error_free)

;; extern GError *g_error_copy(const GError *error);
(define g_error_copy
  (let ((~f #f))
    (lambda (error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_error_copy" '* (list '*))))
      (let ((~error (unwrap-GError* error)))
        (wrap-GError* (~f ~error))))))
(export g_error_copy)

;; extern gboolean g_error_matches(const GError *error, GQuark domain, gint 
;;     code);
(define g_error_matches
  (let ((~f #f))
    (lambda (error domain code)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_error_matches"
            ffi:int
            (list '* ffi:unsigned-int ffi:int))))
      (let ((~error (unwrap-GError* error))
            (~domain (unwrap~fixed domain))
            (~code (unwrap~fixed code)))
        (~f ~error ~domain ~code)))))
(export g_error_matches)

;; extern void g_set_error(GError **err, GQuark domain, gint code, const gchar 
;;     *format, ...);
;; ... failed.

;; extern void g_set_error_literal(GError **err, GQuark domain, gint code, 
;;     const gchar *message);
(define g_set_error_literal
  (let ((~f #f))
    (lambda (err domain code message)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_set_error_literal"
            ffi:void
            (list '* ffi:unsigned-int ffi:int '*))))
      (let ((~err (unwrap~pointer err))
            (~domain (unwrap~fixed domain))
            (~code (unwrap~fixed code))
            (~message (unwrap~pointer message)))
        (~f ~err ~domain ~code ~message)))))
(export g_set_error_literal)

;; extern void g_propagate_error(GError **dest, GError *src);
(define g_propagate_error
  (let ((~f #f))
    (lambda (dest src)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_propagate_error"
            ffi:void
            (list '* '*))))
      (let ((~dest (unwrap~pointer dest))
            (~src (unwrap-GError* src)))
        (~f ~dest ~src)))))
(export g_propagate_error)

;; extern void g_clear_error(GError **err);
(define g_clear_error
  (let ((~f #f))
    (lambda (err)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_clear_error" ffi:void (list '*))))
      (let ((~err (unwrap~pointer err))) (~f ~err)))))
(export g_clear_error)

;; extern void g_prefix_error(GError **err, const gchar *format, ...);
;; ... failed.

;; extern void g_propagate_prefixed_error(GError **dest, GError *src, const 
;;     gchar *format, ...);
;; ... failed.

;; extern const gchar *g_get_user_name(void);
(define g_get_user_name
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_get_user_name" '* (list))))
      (let () (~f)))))
(export g_get_user_name)

;; extern const gchar *g_get_real_name(void);
(define g_get_real_name
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_get_real_name" '* (list))))
      (let () (~f)))))
(export g_get_real_name)

;; extern const gchar *g_get_home_dir(void);
(define g_get_home_dir
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_get_home_dir" '* (list))))
      (let () (~f)))))
(export g_get_home_dir)

;; extern const gchar *g_get_tmp_dir(void);
(define g_get_tmp_dir
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_get_tmp_dir" '* (list))))
      (let () (~f)))))
(export g_get_tmp_dir)

;; extern const gchar *g_get_host_name(void);
(define g_get_host_name
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_get_host_name" '* (list))))
      (let () (~f)))))
(export g_get_host_name)

;; extern const gchar *g_get_prgname(void);
(define g_get_prgname
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_get_prgname" '* (list))))
      (let () (~f)))))
(export g_get_prgname)

;; extern void g_set_prgname(const gchar *prgname);
(define g_set_prgname
  (let ((~f #f))
    (lambda (prgname)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_set_prgname" ffi:void (list '*))))
      (let ((~prgname (unwrap~pointer prgname)))
        (~f ~prgname)))))
(export g_set_prgname)

;; extern const gchar *g_get_application_name(void);
(define g_get_application_name
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_get_application_name" '* (list))))
      (let () (~f)))))
(export g_get_application_name)

;; extern void g_set_application_name(const gchar *application_name);
(define g_set_application_name
  (let ((~f #f))
    (lambda (application_name)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_set_application_name"
            ffi:void
            (list '*))))
      (let ((~application_name
              (unwrap~pointer application_name)))
        (~f ~application_name)))))
(export g_set_application_name)

;; extern void g_reload_user_special_dirs_cache(void);
(define g_reload_user_special_dirs_cache
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_reload_user_special_dirs_cache"
            ffi:void
            (list))))
      (let () (~f)))))
(export g_reload_user_special_dirs_cache)

;; extern const gchar *g_get_user_data_dir(void);
(define g_get_user_data_dir
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_get_user_data_dir" '* (list))))
      (let () (~f)))))
(export g_get_user_data_dir)

;; extern const gchar *g_get_user_config_dir(void);
(define g_get_user_config_dir
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_get_user_config_dir" '* (list))))
      (let () (~f)))))
(export g_get_user_config_dir)

;; extern const gchar *g_get_user_cache_dir(void);
(define g_get_user_cache_dir
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_get_user_cache_dir" '* (list))))
      (let () (~f)))))
(export g_get_user_cache_dir)

;; extern const gchar *const*g_get_system_data_dirs(void);
(define g_get_system_data_dirs
  (let* ((addr (dynamic-pointer
                 "g_get_system_data_dirs"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer (bs:pointer void)))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_get_system_data_dirs)

;; extern const gchar *const*g_get_system_config_dirs(void);
(define g_get_system_config_dirs
  (let* ((addr (dynamic-pointer
                 "g_get_system_config_dirs"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer (bs:pointer void)))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_get_system_config_dirs)

;; extern const gchar *g_get_user_runtime_dir(void);
(define g_get_user_runtime_dir
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_get_user_runtime_dir" '* (list))))
      (let () (~f)))))
(export g_get_user_runtime_dir)

;; typedef enum {
;;   G_USER_DIRECTORY_DESKTOP,
;;   G_USER_DIRECTORY_DOCUMENTS,
;;   G_USER_DIRECTORY_DOWNLOAD,
;;   G_USER_DIRECTORY_MUSIC,
;;   G_USER_DIRECTORY_PICTURES,
;;   G_USER_DIRECTORY_PUBLIC_SHARE,
;;   G_USER_DIRECTORY_TEMPLATES,
;;   G_USER_DIRECTORY_VIDEOS,
;;   G_USER_N_DIRECTORIES,
;; } GUserDirectory;
(define-fh-enum GUserDirectory
  '((G_USER_DIRECTORY_DESKTOP . 0)
    (G_USER_DIRECTORY_DOCUMENTS . 1)
    (G_USER_DIRECTORY_DOWNLOAD . 2)
    (G_USER_DIRECTORY_MUSIC . 3)
    (G_USER_DIRECTORY_PICTURES . 4)
    (G_USER_DIRECTORY_PUBLIC_SHARE . 5)
    (G_USER_DIRECTORY_TEMPLATES . 6)
    (G_USER_DIRECTORY_VIDEOS . 7)
    (G_USER_N_DIRECTORIES . 8))
  )

;; extern const gchar *g_get_user_special_dir(GUserDirectory directory);
(define g_get_user_special_dir
  (let ((~f #f))
    (lambda (directory)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_get_user_special_dir"
            '*
            (list ffi:int))))
      (let ((~directory (unwrap~fixed directory)))
        (~f ~directory)))))
(export g_get_user_special_dir)

;; typedef struct _GDebugKey GDebugKey;
(define GDebugKey-desc void)
(define GDebugKey*-desc (bs:pointer (delay GDebugKey-desc)))
(export GDebugKey*-desc)
(define-fh-pointer-type GDebugKey* GDebugKey*-desc)

;; struct _GDebugKey {
;;   const gchar *key;
;;   guint value;
;; };
(define struct-_GDebugKey-desc
  (bs:struct
    (list `(key ,(bs:pointer int))
          `(value ,unsigned-int))))
(export struct-_GDebugKey-desc)
(define-fh-compound-type/p struct-_GDebugKey struct-_GDebugKey-desc)
(set! GDebugKey-desc struct-_GDebugKey-desc)
(define-fh-compound-type GDebugKey GDebugKey-desc)

;; extern guint g_parse_debug_string(const gchar *string, const GDebugKey *keys
;;     , guint nkeys);
(define g_parse_debug_string
  (let ((~f #f))
    (lambda (string keys nkeys)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_parse_debug_string"
            ffi:unsigned-int
            (list '* '* ffi:unsigned-int))))
      (let ((~string (unwrap~pointer string))
            (~keys (unwrap-GDebugKey* keys))
            (~nkeys (unwrap~fixed nkeys)))
        (~f ~string ~keys ~nkeys)))))
(export g_parse_debug_string)

;; extern gint g_snprintf(gchar *string, gulong n, gchar const *format, ...);
;; ... failed.

;; extern gint g_vsnprintf(gchar *string, gulong n, gchar const *format, 
;;     va_list args);
(define g_vsnprintf
  (let ((~f #f))
    (lambda (string n format args)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_vsnprintf"
            ffi:int
            (list '* ffi:unsigned-long '* '*))))
      (let ((~string (unwrap~pointer string))
            (~n (unwrap~fixed n))
            (~format (unwrap~pointer format))
            (~args (unwrap~pointer args)))
        (~f ~string ~n ~format ~args)))))
(export g_vsnprintf)

;; extern void g_nullify_pointer(gpointer *nullify_location);
(define g_nullify_pointer
  (let ((~f #f))
    (lambda (nullify_location)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_nullify_pointer"
            ffi:void
            (list '*))))
      (let ((~nullify_location
              (unwrap-gpointer* nullify_location)))
        (~f ~nullify_location)))))
(export g_nullify_pointer)

;; typedef enum {
;;   G_FORMAT_SIZE_DEFAULT = 0,
;;   G_FORMAT_SIZE_LONG_FORMAT = 1<<0,
;;   G_FORMAT_SIZE_IEC_UNITS = 1<<1,
;; } GFormatSizeFlags;
(define-fh-enum GFormatSizeFlags
  '((G_FORMAT_SIZE_DEFAULT . 0)
    (G_FORMAT_SIZE_LONG_FORMAT . 1)
    (G_FORMAT_SIZE_IEC_UNITS . 2))
  )

;; extern gchar *g_format_size_full(guint64 size, GFormatSizeFlags flags);
(define g_format_size_full
  (let ((~f #f))
    (lambda (size flags)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_format_size_full"
            '*
            (list ffi:unsigned-long ffi:int))))
      (let ((~size (unwrap~fixed size))
            (~flags (unwrap~fixed flags)))
        (~f ~size ~flags)))))
(export g_format_size_full)

;; extern gchar *g_format_size(guint64 size);
(define g_format_size
  (let ((~f #f))
    (lambda (size)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_format_size"
            '*
            (list ffi:unsigned-long))))
      (let ((~size (unwrap~fixed size))) (~f ~size)))))
(export g_format_size)

;; extern gchar *g_format_size_for_display(goffset size);
(define g_format_size_for_display
  (let ((~f #f))
    (lambda (size)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_format_size_for_display"
            '*
            (list ffi:long))))
      (let ((~size (unwrap~fixed size))) (~f ~size)))))
(export g_format_size_for_display)

;; typedef void (*GVoidFunc)(void);
(define-fh-function/p GVoidFunc
  ffi:void (list ffi:void))

;; extern void g_atexit(GVoidFunc func);
(define g_atexit
  (let ((~f #f))
    (lambda (func)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_atexit" ffi:void (list '*))))
      (let ((~func ((make-ftn-arg-unwrapper ffi:void (list ffi:void))
                    func)))
        (~f ~func)))))
(export g_atexit)

;; extern gchar *g_find_program_in_path(const gchar *program);
(define g_find_program_in_path
  (let ((~f #f))
    (lambda (program)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_find_program_in_path"
            '*
            (list '*))))
      (let ((~program (unwrap~pointer program)))
        (~f ~program)))))
(export g_find_program_in_path)

;; extern gint (g_bit_nth_lsf)(gulong mask, gint nth_bit);
(define g_bit_nth_lsf
  (let* ((addr (dynamic-pointer "g_bit_nth_lsf" (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer (bs:pointer void)))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_bit_nth_lsf)

;; extern gint (g_bit_nth_msf)(gulong mask, gint nth_bit);
(define g_bit_nth_msf
  (let* ((addr (dynamic-pointer "g_bit_nth_msf" (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer (bs:pointer void)))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_bit_nth_msf)

;; extern guint (g_bit_storage)(gulong number);
(define g_bit_storage
  (let* ((addr (dynamic-pointer "g_bit_storage" (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer (bs:pointer void)))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_bit_storage)

;; extern GQuark g_thread_error_quark(void);
(define g_thread_error_quark
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_thread_error_quark"
            ffi:unsigned-int
            (list))))
      (let () (~f)))))
(export g_thread_error_quark)

;; typedef enum {
;;   G_THREAD_ERROR_AGAIN,
;; } GThreadError;
(define-fh-enum GThreadError
  '((G_THREAD_ERROR_AGAIN . 0))
  )

;; typedef gpointer (*GThreadFunc)(gpointer data);
(define-fh-function/p GThreadFunc
  (quote *) (list (quote *)))

;; typedef struct _GThread GThread;
(define GThread-desc void)
(define GThread*-desc (bs:pointer (delay GThread-desc)))
(export GThread*-desc)
(define-fh-pointer-type GThread* GThread*-desc)

;; typedef union _GMutex GMutex;
;; union _GMutex {
;;   /*< private >*/
;;   gpointer p;
;;   guint i[2];
;; };
(define GMutex-desc
  (bs:union
    (list `(p ,gpointer-desc)
          `(i ,(bs:vector 2 unsigned-int)))))
(export GMutex-desc)
(define-fh-compound-type/p GMutex GMutex-desc)
(define union-_GMutex GMutex)

;; typedef struct _GRecMutex GRecMutex;
(define GRecMutex-desc void)
(define GRecMutex*-desc (bs:pointer (delay GRecMutex-desc)))
(export GRecMutex*-desc)
(define-fh-pointer-type GRecMutex* GRecMutex*-desc)

;; typedef struct _GRWLock GRWLock;
(define GRWLock-desc void)
(define GRWLock*-desc (bs:pointer (delay GRWLock-desc)))
(export GRWLock*-desc)
(define-fh-pointer-type GRWLock* GRWLock*-desc)

;; typedef struct _GCond GCond;
(define GCond-desc void)
(define GCond*-desc (bs:pointer (delay GCond-desc)))
(export GCond*-desc)
(define-fh-pointer-type GCond* GCond*-desc)

;; typedef struct _GPrivate GPrivate;
(define GPrivate-desc void)
(define GPrivate*-desc (bs:pointer (delay GPrivate-desc)))
(export GPrivate*-desc)
(define-fh-pointer-type GPrivate* GPrivate*-desc)

;; typedef struct _GOnce GOnce;
(define GOnce-desc void)
(define GOnce*-desc (bs:pointer (delay GOnce-desc)))
(export GOnce*-desc)
(define-fh-pointer-type GOnce* GOnce*-desc)

;; struct _GRWLock {
;;   /*< private >*/
;;   gpointer p;
;;   guint i[2];
;; };
(define struct-_GRWLock-desc
  (bs:struct
    (list `(p ,gpointer-desc)
          `(i ,(bs:vector 2 unsigned-int)))))
(export struct-_GRWLock-desc)
(define-fh-compound-type/p struct-_GRWLock struct-_GRWLock-desc)
(set! GRWLock-desc struct-_GRWLock-desc)
(define-fh-compound-type GRWLock GRWLock-desc)

;; struct _GCond {
;;   /*< private >*/
;;   gpointer p;
;;   guint i[2];
;; };
(define struct-_GCond-desc
  (bs:struct
    (list `(p ,gpointer-desc)
          `(i ,(bs:vector 2 unsigned-int)))))
(export struct-_GCond-desc)
(define-fh-compound-type/p struct-_GCond struct-_GCond-desc)
(set! GCond-desc struct-_GCond-desc)
(define-fh-compound-type GCond GCond-desc)

;; struct _GRecMutex {
;;   /*< private >*/
;;   gpointer p;
;;   guint i[2];
;; };
(define struct-_GRecMutex-desc
  (bs:struct
    (list `(p ,gpointer-desc)
          `(i ,(bs:vector 2 unsigned-int)))))
(export struct-_GRecMutex-desc)
(define-fh-compound-type/p struct-_GRecMutex struct-_GRecMutex-desc)
(set! GRecMutex-desc struct-_GRecMutex-desc)
(define-fh-compound-type GRecMutex GRecMutex-desc)

;; struct _GPrivate {
;;   /*< private >*/
;;   gpointer p;
;;   GDestroyNotify notify;
;;   gpointer future[2];
;; };
(define struct-_GPrivate-desc
  (bs:struct
    (list `(p ,gpointer-desc)
          `(notify ,(bs:pointer void))
          `(future ,(bs:vector 2 gpointer-desc)))))
(export struct-_GPrivate-desc)
(define-fh-compound-type/p struct-_GPrivate struct-_GPrivate-desc)
(set! GPrivate-desc struct-_GPrivate-desc)
(define-fh-compound-type GPrivate GPrivate-desc)

;; typedef enum {
;;   G_ONCE_STATUS_NOTCALLED,
;;   G_ONCE_STATUS_PROGRESS,
;;   G_ONCE_STATUS_READY,
;; } GOnceStatus;
(define-fh-enum GOnceStatus
  '((G_ONCE_STATUS_NOTCALLED . 0)
    (G_ONCE_STATUS_PROGRESS . 1)
    (G_ONCE_STATUS_READY . 2))
  )

;; struct _GOnce {
;;   volatile GOnceStatus status;
;;   volatile gpointer retval;
;; };
(define struct-_GOnce-desc
  (bs:struct
    (list `(status ,int) `(retval ,gpointer-desc))))
(export struct-_GOnce-desc)
(define-fh-compound-type/p struct-_GOnce struct-_GOnce-desc)
(set! GOnce-desc struct-_GOnce-desc)
(define-fh-compound-type GOnce GOnce-desc)

;; extern GThread *g_thread_ref(GThread *thread);
(define g_thread_ref
  (let ((~f #f))
    (lambda (thread)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_thread_ref" '* (list '*))))
      (let ((~thread (unwrap-GThread* thread)))
        (wrap-GThread* (~f ~thread))))))
(export g_thread_ref)

;; extern void g_thread_unref(GThread *thread);
(define g_thread_unref
  (let ((~f #f))
    (lambda (thread)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_thread_unref"
            ffi:void
            (list '*))))
      (let ((~thread (unwrap-GThread* thread)))
        (~f ~thread)))))
(export g_thread_unref)

;; extern GThread *g_thread_new(const gchar *name, GThreadFunc func, gpointer 
;;     data);
(define g_thread_new
  (let ((~f #f))
    (lambda (name func data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_thread_new" '* (list '* '* '*))))
      (let ((~name (unwrap~pointer name))
            (~func ((make-ftn-arg-unwrapper '* (list '*)) func))
            (~data (unwrap-gpointer data)))
        (wrap-GThread* (~f ~name ~func ~data))))))
(export g_thread_new)

;; extern GThread *g_thread_try_new(const gchar *name, GThreadFunc func, 
;;     gpointer data, GError **error);
(define g_thread_try_new
  (let ((~f #f))
    (lambda (name func data error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_thread_try_new"
            '*
            (list '* '* '* '*))))
      (let ((~name (unwrap~pointer name))
            (~func ((make-ftn-arg-unwrapper '* (list '*)) func))
            (~data (unwrap-gpointer data))
            (~error (unwrap~pointer error)))
        (wrap-GThread* (~f ~name ~func ~data ~error))))))
(export g_thread_try_new)

;; extern GThread *g_thread_self(void);
(define g_thread_self
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_thread_self" '* (list))))
      (let () (wrap-GThread* (~f))))))
(export g_thread_self)

;; extern void g_thread_exit(gpointer retval);
(define g_thread_exit
  (let ((~f #f))
    (lambda (retval)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_thread_exit" ffi:void (list '*))))
      (let ((~retval (unwrap-gpointer retval)))
        (~f ~retval)))))
(export g_thread_exit)

;; extern gpointer g_thread_join(GThread *thread);
(define g_thread_join
  (let ((~f #f))
    (lambda (thread)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_thread_join" '* (list '*))))
      (let ((~thread (unwrap-GThread* thread)))
        (wrap-gpointer (~f ~thread))))))
(export g_thread_join)

;; extern void g_thread_yield(void);
(define g_thread_yield
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_thread_yield" ffi:void (list))))
      (let () (~f)))))
(export g_thread_yield)

;; extern void g_mutex_init(GMutex *mutex);
(define g_mutex_init
  (let ((~f #f))
    (lambda (mutex)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_mutex_init" ffi:void (list '*))))
      (let ((~mutex (unwrap-GMutex* mutex)))
        (~f ~mutex)))))
(export g_mutex_init)

;; extern void g_mutex_clear(GMutex *mutex);
(define g_mutex_clear
  (let ((~f #f))
    (lambda (mutex)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_mutex_clear" ffi:void (list '*))))
      (let ((~mutex (unwrap-GMutex* mutex)))
        (~f ~mutex)))))
(export g_mutex_clear)

;; extern void g_mutex_lock(GMutex *mutex);
(define g_mutex_lock
  (let ((~f #f))
    (lambda (mutex)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_mutex_lock" ffi:void (list '*))))
      (let ((~mutex (unwrap-GMutex* mutex)))
        (~f ~mutex)))))
(export g_mutex_lock)

;; extern gboolean g_mutex_trylock(GMutex *mutex);
(define g_mutex_trylock
  (let ((~f #f))
    (lambda (mutex)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_mutex_trylock"
            ffi:int
            (list '*))))
      (let ((~mutex (unwrap-GMutex* mutex)))
        (~f ~mutex)))))
(export g_mutex_trylock)

;; extern void g_mutex_unlock(GMutex *mutex);
(define g_mutex_unlock
  (let ((~f #f))
    (lambda (mutex)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_mutex_unlock"
            ffi:void
            (list '*))))
      (let ((~mutex (unwrap-GMutex* mutex)))
        (~f ~mutex)))))
(export g_mutex_unlock)

;; extern void g_rw_lock_init(GRWLock *rw_lock);
(define g_rw_lock_init
  (let ((~f #f))
    (lambda (rw_lock)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_rw_lock_init"
            ffi:void
            (list '*))))
      (let ((~rw_lock (unwrap-GRWLock* rw_lock)))
        (~f ~rw_lock)))))
(export g_rw_lock_init)

;; extern void g_rw_lock_clear(GRWLock *rw_lock);
(define g_rw_lock_clear
  (let ((~f #f))
    (lambda (rw_lock)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_rw_lock_clear"
            ffi:void
            (list '*))))
      (let ((~rw_lock (unwrap-GRWLock* rw_lock)))
        (~f ~rw_lock)))))
(export g_rw_lock_clear)

;; extern void g_rw_lock_writer_lock(GRWLock *rw_lock);
(define g_rw_lock_writer_lock
  (let ((~f #f))
    (lambda (rw_lock)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_rw_lock_writer_lock"
            ffi:void
            (list '*))))
      (let ((~rw_lock (unwrap-GRWLock* rw_lock)))
        (~f ~rw_lock)))))
(export g_rw_lock_writer_lock)

;; extern gboolean g_rw_lock_writer_trylock(GRWLock *rw_lock);
(define g_rw_lock_writer_trylock
  (let ((~f #f))
    (lambda (rw_lock)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_rw_lock_writer_trylock"
            ffi:int
            (list '*))))
      (let ((~rw_lock (unwrap-GRWLock* rw_lock)))
        (~f ~rw_lock)))))
(export g_rw_lock_writer_trylock)

;; extern void g_rw_lock_writer_unlock(GRWLock *rw_lock);
(define g_rw_lock_writer_unlock
  (let ((~f #f))
    (lambda (rw_lock)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_rw_lock_writer_unlock"
            ffi:void
            (list '*))))
      (let ((~rw_lock (unwrap-GRWLock* rw_lock)))
        (~f ~rw_lock)))))
(export g_rw_lock_writer_unlock)

;; extern void g_rw_lock_reader_lock(GRWLock *rw_lock);
(define g_rw_lock_reader_lock
  (let ((~f #f))
    (lambda (rw_lock)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_rw_lock_reader_lock"
            ffi:void
            (list '*))))
      (let ((~rw_lock (unwrap-GRWLock* rw_lock)))
        (~f ~rw_lock)))))
(export g_rw_lock_reader_lock)

;; extern gboolean g_rw_lock_reader_trylock(GRWLock *rw_lock);
(define g_rw_lock_reader_trylock
  (let ((~f #f))
    (lambda (rw_lock)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_rw_lock_reader_trylock"
            ffi:int
            (list '*))))
      (let ((~rw_lock (unwrap-GRWLock* rw_lock)))
        (~f ~rw_lock)))))
(export g_rw_lock_reader_trylock)

;; extern void g_rw_lock_reader_unlock(GRWLock *rw_lock);
(define g_rw_lock_reader_unlock
  (let ((~f #f))
    (lambda (rw_lock)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_rw_lock_reader_unlock"
            ffi:void
            (list '*))))
      (let ((~rw_lock (unwrap-GRWLock* rw_lock)))
        (~f ~rw_lock)))))
(export g_rw_lock_reader_unlock)

;; extern void g_rec_mutex_init(GRecMutex *rec_mutex);
(define g_rec_mutex_init
  (let ((~f #f))
    (lambda (rec_mutex)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_rec_mutex_init"
            ffi:void
            (list '*))))
      (let ((~rec_mutex (unwrap-GRecMutex* rec_mutex)))
        (~f ~rec_mutex)))))
(export g_rec_mutex_init)

;; extern void g_rec_mutex_clear(GRecMutex *rec_mutex);
(define g_rec_mutex_clear
  (let ((~f #f))
    (lambda (rec_mutex)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_rec_mutex_clear"
            ffi:void
            (list '*))))
      (let ((~rec_mutex (unwrap-GRecMutex* rec_mutex)))
        (~f ~rec_mutex)))))
(export g_rec_mutex_clear)

;; extern void g_rec_mutex_lock(GRecMutex *rec_mutex);
(define g_rec_mutex_lock
  (let ((~f #f))
    (lambda (rec_mutex)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_rec_mutex_lock"
            ffi:void
            (list '*))))
      (let ((~rec_mutex (unwrap-GRecMutex* rec_mutex)))
        (~f ~rec_mutex)))))
(export g_rec_mutex_lock)

;; extern gboolean g_rec_mutex_trylock(GRecMutex *rec_mutex);
(define g_rec_mutex_trylock
  (let ((~f #f))
    (lambda (rec_mutex)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_rec_mutex_trylock"
            ffi:int
            (list '*))))
      (let ((~rec_mutex (unwrap-GRecMutex* rec_mutex)))
        (~f ~rec_mutex)))))
(export g_rec_mutex_trylock)

;; extern void g_rec_mutex_unlock(GRecMutex *rec_mutex);
(define g_rec_mutex_unlock
  (let ((~f #f))
    (lambda (rec_mutex)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_rec_mutex_unlock"
            ffi:void
            (list '*))))
      (let ((~rec_mutex (unwrap-GRecMutex* rec_mutex)))
        (~f ~rec_mutex)))))
(export g_rec_mutex_unlock)

;; extern void g_cond_init(GCond *cond);
(define g_cond_init
  (let ((~f #f))
    (lambda (cond)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_cond_init" ffi:void (list '*))))
      (let ((~cond (unwrap-GCond* cond))) (~f ~cond)))))
(export g_cond_init)

;; extern void g_cond_clear(GCond *cond);
(define g_cond_clear
  (let ((~f #f))
    (lambda (cond)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_cond_clear" ffi:void (list '*))))
      (let ((~cond (unwrap-GCond* cond))) (~f ~cond)))))
(export g_cond_clear)

;; extern void g_cond_wait(GCond *cond, GMutex *mutex);
(define g_cond_wait
  (let ((~f #f))
    (lambda (cond mutex)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_cond_wait"
            ffi:void
            (list '* '*))))
      (let ((~cond (unwrap-GCond* cond))
            (~mutex (unwrap-GMutex* mutex)))
        (~f ~cond ~mutex)))))
(export g_cond_wait)

;; extern void g_cond_signal(GCond *cond);
(define g_cond_signal
  (let ((~f #f))
    (lambda (cond)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_cond_signal" ffi:void (list '*))))
      (let ((~cond (unwrap-GCond* cond))) (~f ~cond)))))
(export g_cond_signal)

;; extern void g_cond_broadcast(GCond *cond);
(define g_cond_broadcast
  (let ((~f #f))
    (lambda (cond)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_cond_broadcast"
            ffi:void
            (list '*))))
      (let ((~cond (unwrap-GCond* cond))) (~f ~cond)))))
(export g_cond_broadcast)

;; extern gboolean g_cond_wait_until(GCond *cond, GMutex *mutex, gint64 
;;     end_time);
(define g_cond_wait_until
  (let ((~f #f))
    (lambda (cond mutex end_time)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_cond_wait_until"
            ffi:int
            (list '* '* ffi:long))))
      (let ((~cond (unwrap-GCond* cond))
            (~mutex (unwrap-GMutex* mutex))
            (~end_time (unwrap~fixed end_time)))
        (~f ~cond ~mutex ~end_time)))))
(export g_cond_wait_until)

;; extern gpointer g_private_get(GPrivate *key);
(define g_private_get
  (let ((~f #f))
    (lambda (key)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_private_get" '* (list '*))))
      (let ((~key (unwrap-GPrivate* key)))
        (wrap-gpointer (~f ~key))))))
(export g_private_get)

;; extern void g_private_set(GPrivate *key, gpointer value);
(define g_private_set
  (let ((~f #f))
    (lambda (key value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_private_set"
            ffi:void
            (list '* '*))))
      (let ((~key (unwrap-GPrivate* key))
            (~value (unwrap-gpointer value)))
        (~f ~key ~value)))))
(export g_private_set)

;; extern void g_private_replace(GPrivate *key, gpointer value);
(define g_private_replace
  (let ((~f #f))
    (lambda (key value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_private_replace"
            ffi:void
            (list '* '*))))
      (let ((~key (unwrap-GPrivate* key))
            (~value (unwrap-gpointer value)))
        (~f ~key ~value)))))
(export g_private_replace)

;; extern gpointer g_once_impl(GOnce *once, GThreadFunc func, gpointer arg);
(define g_once_impl
  (let ((~f #f))
    (lambda (once func arg)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_once_impl" '* (list '* '* '*))))
      (let ((~once (unwrap-GOnce* once))
            (~func ((make-ftn-arg-unwrapper '* (list '*)) func))
            (~arg (unwrap-gpointer arg)))
        (wrap-gpointer (~f ~once ~func ~arg))))))
(export g_once_impl)

;; extern gboolean g_once_init_enter(volatile void *location);
(define g_once_init_enter
  (let ((~f #f))
    (lambda (location)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_once_init_enter"
            ffi:int
            (list '*))))
      (let ((~location (unwrap~pointer location)))
        (~f ~location)))))
(export g_once_init_enter)

;; extern void g_once_init_leave(volatile void *location, gsize result);
(define g_once_init_leave
  (let ((~f #f))
    (lambda (location result)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_once_init_leave"
            ffi:void
            (list '* ffi:unsigned-long))))
      (let ((~location (unwrap~pointer location))
            (~result (unwrap~fixed result)))
        (~f ~location ~result)))))
(export g_once_init_leave)

;; extern guint g_get_num_processors(void);
(define g_get_num_processors
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_get_num_processors"
            ffi:unsigned-int
            (list))))
      (let () (~f)))))
(export g_get_num_processors)

;; typedef void GMutexLocker;
(define GMutexLocker-desc void)
(define GMutexLocker*-desc (bs:pointer GMutexLocker-desc))
(export GMutexLocker-desc GMutexLocker*-desc)
(define-fh-pointer-type GMutexLocker* GMutexLocker-desc)

;; typedef struct _GAsyncQueue GAsyncQueue;
(define GAsyncQueue-desc void)
(define GAsyncQueue*-desc (bs:pointer GAsyncQueue-desc))
(export GAsyncQueue*-desc)
(define-fh-pointer-type GAsyncQueue* GAsyncQueue*-desc)

;; extern GAsyncQueue *g_async_queue_new(void);
(define g_async_queue_new
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_async_queue_new" '* (list))))
      (let () (wrap-GAsyncQueue* (~f))))))
(export g_async_queue_new)

;; extern GAsyncQueue *g_async_queue_new_full(GDestroyNotify item_free_func);
(define g_async_queue_new_full
  (let ((~f #f))
    (lambda (item_free_func)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_async_queue_new_full"
            '*
            (list '*))))
      (let ((~item_free_func
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               item_free_func)))
        (wrap-GAsyncQueue* (~f ~item_free_func))))))
(export g_async_queue_new_full)

;; extern void g_async_queue_lock(GAsyncQueue *queue);
(define g_async_queue_lock
  (let ((~f #f))
    (lambda (queue)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_async_queue_lock"
            ffi:void
            (list '*))))
      (let ((~queue (unwrap-GAsyncQueue* queue)))
        (~f ~queue)))))
(export g_async_queue_lock)

;; extern void g_async_queue_unlock(GAsyncQueue *queue);
(define g_async_queue_unlock
  (let ((~f #f))
    (lambda (queue)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_async_queue_unlock"
            ffi:void
            (list '*))))
      (let ((~queue (unwrap-GAsyncQueue* queue)))
        (~f ~queue)))))
(export g_async_queue_unlock)

;; extern GAsyncQueue *g_async_queue_ref(GAsyncQueue *queue);
(define g_async_queue_ref
  (let ((~f #f))
    (lambda (queue)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_async_queue_ref" '* (list '*))))
      (let ((~queue (unwrap-GAsyncQueue* queue)))
        (wrap-GAsyncQueue* (~f ~queue))))))
(export g_async_queue_ref)

;; extern void g_async_queue_unref(GAsyncQueue *queue);
(define g_async_queue_unref
  (let ((~f #f))
    (lambda (queue)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_async_queue_unref"
            ffi:void
            (list '*))))
      (let ((~queue (unwrap-GAsyncQueue* queue)))
        (~f ~queue)))))
(export g_async_queue_unref)

;; extern void g_async_queue_ref_unlocked(GAsyncQueue *queue);
(define g_async_queue_ref_unlocked
  (let ((~f #f))
    (lambda (queue)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_async_queue_ref_unlocked"
            ffi:void
            (list '*))))
      (let ((~queue (unwrap-GAsyncQueue* queue)))
        (~f ~queue)))))
(export g_async_queue_ref_unlocked)

;; extern void g_async_queue_unref_and_unlock(GAsyncQueue *queue);
(define g_async_queue_unref_and_unlock
  (let ((~f #f))
    (lambda (queue)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_async_queue_unref_and_unlock"
            ffi:void
            (list '*))))
      (let ((~queue (unwrap-GAsyncQueue* queue)))
        (~f ~queue)))))
(export g_async_queue_unref_and_unlock)

;; extern void g_async_queue_push(GAsyncQueue *queue, gpointer data);
(define g_async_queue_push
  (let ((~f #f))
    (lambda (queue data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_async_queue_push"
            ffi:void
            (list '* '*))))
      (let ((~queue (unwrap-GAsyncQueue* queue))
            (~data (unwrap-gpointer data)))
        (~f ~queue ~data)))))
(export g_async_queue_push)

;; extern void g_async_queue_push_unlocked(GAsyncQueue *queue, gpointer data);
(define g_async_queue_push_unlocked
  (let ((~f #f))
    (lambda (queue data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_async_queue_push_unlocked"
            ffi:void
            (list '* '*))))
      (let ((~queue (unwrap-GAsyncQueue* queue))
            (~data (unwrap-gpointer data)))
        (~f ~queue ~data)))))
(export g_async_queue_push_unlocked)

;; extern void g_async_queue_push_sorted(GAsyncQueue *queue, gpointer data, 
;;     GCompareDataFunc func, gpointer user_data);
(define g_async_queue_push_sorted
  (let ((~f #f))
    (lambda (queue data func user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_async_queue_push_sorted"
            ffi:void
            (list '* '* '* '*))))
      (let ((~queue (unwrap-GAsyncQueue* queue))
            (~data (unwrap-gpointer data))
            (~func ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
                    func))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~queue ~data ~func ~user_data)))))
(export g_async_queue_push_sorted)

;; extern void g_async_queue_push_sorted_unlocked(GAsyncQueue *queue, gpointer 
;;     data, GCompareDataFunc func, gpointer user_data);
(define g_async_queue_push_sorted_unlocked
  (let ((~f #f))
    (lambda (queue data func user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_async_queue_push_sorted_unlocked"
            ffi:void
            (list '* '* '* '*))))
      (let ((~queue (unwrap-GAsyncQueue* queue))
            (~data (unwrap-gpointer data))
            (~func ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
                    func))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~queue ~data ~func ~user_data)))))
(export g_async_queue_push_sorted_unlocked)

;; extern gpointer g_async_queue_pop(GAsyncQueue *queue);
(define g_async_queue_pop
  (let ((~f #f))
    (lambda (queue)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_async_queue_pop" '* (list '*))))
      (let ((~queue (unwrap-GAsyncQueue* queue)))
        (wrap-gpointer (~f ~queue))))))
(export g_async_queue_pop)

;; extern gpointer g_async_queue_pop_unlocked(GAsyncQueue *queue);
(define g_async_queue_pop_unlocked
  (let ((~f #f))
    (lambda (queue)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_async_queue_pop_unlocked"
            '*
            (list '*))))
      (let ((~queue (unwrap-GAsyncQueue* queue)))
        (wrap-gpointer (~f ~queue))))))
(export g_async_queue_pop_unlocked)

;; extern gpointer g_async_queue_try_pop(GAsyncQueue *queue);
(define g_async_queue_try_pop
  (let ((~f #f))
    (lambda (queue)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_async_queue_try_pop"
            '*
            (list '*))))
      (let ((~queue (unwrap-GAsyncQueue* queue)))
        (wrap-gpointer (~f ~queue))))))
(export g_async_queue_try_pop)

;; extern gpointer g_async_queue_try_pop_unlocked(GAsyncQueue *queue);
(define g_async_queue_try_pop_unlocked
  (let ((~f #f))
    (lambda (queue)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_async_queue_try_pop_unlocked"
            '*
            (list '*))))
      (let ((~queue (unwrap-GAsyncQueue* queue)))
        (wrap-gpointer (~f ~queue))))))
(export g_async_queue_try_pop_unlocked)

;; extern gpointer g_async_queue_timeout_pop(GAsyncQueue *queue, guint64 
;;     timeout);
(define g_async_queue_timeout_pop
  (let ((~f #f))
    (lambda (queue timeout)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_async_queue_timeout_pop"
            '*
            (list '* ffi:unsigned-long))))
      (let ((~queue (unwrap-GAsyncQueue* queue))
            (~timeout (unwrap~fixed timeout)))
        (wrap-gpointer (~f ~queue ~timeout))))))
(export g_async_queue_timeout_pop)

;; extern gpointer g_async_queue_timeout_pop_unlocked(GAsyncQueue *queue, 
;;     guint64 timeout);
(define g_async_queue_timeout_pop_unlocked
  (let ((~f #f))
    (lambda (queue timeout)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_async_queue_timeout_pop_unlocked"
            '*
            (list '* ffi:unsigned-long))))
      (let ((~queue (unwrap-GAsyncQueue* queue))
            (~timeout (unwrap~fixed timeout)))
        (wrap-gpointer (~f ~queue ~timeout))))))
(export g_async_queue_timeout_pop_unlocked)

;; extern gint g_async_queue_length(GAsyncQueue *queue);
(define g_async_queue_length
  (let ((~f #f))
    (lambda (queue)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_async_queue_length"
            ffi:int
            (list '*))))
      (let ((~queue (unwrap-GAsyncQueue* queue)))
        (~f ~queue)))))
(export g_async_queue_length)

;; extern gint g_async_queue_length_unlocked(GAsyncQueue *queue);
(define g_async_queue_length_unlocked
  (let ((~f #f))
    (lambda (queue)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_async_queue_length_unlocked"
            ffi:int
            (list '*))))
      (let ((~queue (unwrap-GAsyncQueue* queue)))
        (~f ~queue)))))
(export g_async_queue_length_unlocked)

;; extern void g_async_queue_sort(GAsyncQueue *queue, GCompareDataFunc func, 
;;     gpointer user_data);
(define g_async_queue_sort
  (let ((~f #f))
    (lambda (queue func user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_async_queue_sort"
            ffi:void
            (list '* '* '*))))
      (let ((~queue (unwrap-GAsyncQueue* queue))
            (~func ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
                    func))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~queue ~func ~user_data)))))
(export g_async_queue_sort)

;; extern void g_async_queue_sort_unlocked(GAsyncQueue *queue, GCompareDataFunc
;;      func, gpointer user_data);
(define g_async_queue_sort_unlocked
  (let ((~f #f))
    (lambda (queue func user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_async_queue_sort_unlocked"
            ffi:void
            (list '* '* '*))))
      (let ((~queue (unwrap-GAsyncQueue* queue))
            (~func ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
                    func))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~queue ~func ~user_data)))))
(export g_async_queue_sort_unlocked)

;; extern gboolean g_async_queue_remove(GAsyncQueue *queue, gpointer item);
(define g_async_queue_remove
  (let ((~f #f))
    (lambda (queue item)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_async_queue_remove"
            ffi:int
            (list '* '*))))
      (let ((~queue (unwrap-GAsyncQueue* queue))
            (~item (unwrap-gpointer item)))
        (~f ~queue ~item)))))
(export g_async_queue_remove)

;; extern gboolean g_async_queue_remove_unlocked(GAsyncQueue *queue, gpointer 
;;     item);
(define g_async_queue_remove_unlocked
  (let ((~f #f))
    (lambda (queue item)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_async_queue_remove_unlocked"
            ffi:int
            (list '* '*))))
      (let ((~queue (unwrap-GAsyncQueue* queue))
            (~item (unwrap-gpointer item)))
        (~f ~queue ~item)))))
(export g_async_queue_remove_unlocked)

;; extern void g_async_queue_push_front(GAsyncQueue *queue, gpointer item);
(define g_async_queue_push_front
  (let ((~f #f))
    (lambda (queue item)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_async_queue_push_front"
            ffi:void
            (list '* '*))))
      (let ((~queue (unwrap-GAsyncQueue* queue))
            (~item (unwrap-gpointer item)))
        (~f ~queue ~item)))))
(export g_async_queue_push_front)

;; extern void g_async_queue_push_front_unlocked(GAsyncQueue *queue, gpointer 
;;     item);
(define g_async_queue_push_front_unlocked
  (let ((~f #f))
    (lambda (queue item)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_async_queue_push_front_unlocked"
            ffi:void
            (list '* '*))))
      (let ((~queue (unwrap-GAsyncQueue* queue))
            (~item (unwrap-gpointer item)))
        (~f ~queue ~item)))))
(export g_async_queue_push_front_unlocked)

;; extern gpointer g_async_queue_timed_pop(GAsyncQueue *queue, GTimeVal *
;;     end_time);
(define g_async_queue_timed_pop
  (let ((~f #f))
    (lambda (queue end_time)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_async_queue_timed_pop"
            '*
            (list '* '*))))
      (let ((~queue (unwrap-GAsyncQueue* queue))
            (~end_time (unwrap-GTimeVal* end_time)))
        (wrap-gpointer (~f ~queue ~end_time))))))
(export g_async_queue_timed_pop)

;; extern gpointer g_async_queue_timed_pop_unlocked(GAsyncQueue *queue, 
;;     GTimeVal *end_time);
(define g_async_queue_timed_pop_unlocked
  (let ((~f #f))
    (lambda (queue end_time)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_async_queue_timed_pop_unlocked"
            '*
            (list '* '*))))
      (let ((~queue (unwrap-GAsyncQueue* queue))
            (~end_time (unwrap-GTimeVal* end_time)))
        (wrap-gpointer (~f ~queue ~end_time))))))
(export g_async_queue_timed_pop_unlocked)

;; extern void g_on_error_query(const gchar *prg_name);
(define g_on_error_query
  (let ((~f #f))
    (lambda (prg_name)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_on_error_query"
            ffi:void
            (list '*))))
      (let ((~prg_name (unwrap~pointer prg_name)))
        (~f ~prg_name)))))
(export g_on_error_query)

;; extern void g_on_error_stack_trace(const gchar *prg_name);
(define g_on_error_stack_trace
  (let ((~f #f))
    (lambda (prg_name)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_on_error_stack_trace"
            ffi:void
            (list '*))))
      (let ((~prg_name (unwrap~pointer prg_name)))
        (~f ~prg_name)))))
(export g_on_error_stack_trace)

;; extern gsize g_base64_encode_step(const guchar *in, gsize len, gboolean 
;;     break_lines, gchar *out, gint *state, gint *save);
(define g_base64_encode_step
  (let ((~f #f))
    (lambda (in len break_lines out state save)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_base64_encode_step"
            ffi:unsigned-long
            (list '* ffi:unsigned-long ffi:int '* '* '*))))
      (let ((~in (unwrap~pointer in))
            (~len (unwrap~fixed len))
            (~break_lines (unwrap~fixed break_lines))
            (~out (unwrap~pointer out))
            (~state (unwrap~pointer state))
            (~save (unwrap~pointer save)))
        (~f ~in ~len ~break_lines ~out ~state ~save)))))
(export g_base64_encode_step)

;; extern gsize g_base64_encode_close(gboolean break_lines, gchar *out, gint *
;;     state, gint *save);
(define g_base64_encode_close
  (let ((~f #f))
    (lambda (break_lines out state save)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_base64_encode_close"
            ffi:unsigned-long
            (list ffi:int '* '* '*))))
      (let ((~break_lines (unwrap~fixed break_lines))
            (~out (unwrap~pointer out))
            (~state (unwrap~pointer state))
            (~save (unwrap~pointer save)))
        (~f ~break_lines ~out ~state ~save)))))
(export g_base64_encode_close)

;; extern gchar *g_base64_encode(const guchar *data, gsize len);
(define g_base64_encode
  (let ((~f #f))
    (lambda (data len)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_base64_encode"
            '*
            (list '* ffi:unsigned-long))))
      (let ((~data (unwrap~pointer data))
            (~len (unwrap~fixed len)))
        (~f ~data ~len)))))
(export g_base64_encode)

;; extern gsize g_base64_decode_step(const gchar *in, gsize len, guchar *out, 
;;     gint *state, guint *save);
(define g_base64_decode_step
  (let ((~f #f))
    (lambda (in len out state save)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_base64_decode_step"
            ffi:unsigned-long
            (list '* ffi:unsigned-long '* '* '*))))
      (let ((~in (unwrap~pointer in))
            (~len (unwrap~fixed len))
            (~out (unwrap~pointer out))
            (~state (unwrap~pointer state))
            (~save (unwrap~pointer save)))
        (~f ~in ~len ~out ~state ~save)))))
(export g_base64_decode_step)

;; extern guchar *g_base64_decode(const gchar *text, gsize *out_len);
(define g_base64_decode
  (let ((~f #f))
    (lambda (text out_len)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_base64_decode" '* (list '* '*))))
      (let ((~text (unwrap~pointer text))
            (~out_len (unwrap~pointer out_len)))
        (~f ~text ~out_len)))))
(export g_base64_decode)

;; extern guchar *g_base64_decode_inplace(gchar *text, gsize *out_len);
(define g_base64_decode_inplace
  (let ((~f #f))
    (lambda (text out_len)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_base64_decode_inplace"
            '*
            (list '* '*))))
      (let ((~text (unwrap~pointer text))
            (~out_len (unwrap~pointer out_len)))
        (~f ~text ~out_len)))))
(export g_base64_decode_inplace)

;; extern void g_bit_lock(volatile gint *address, gint lock_bit);
(define g_bit_lock
  (let ((~f #f))
    (lambda (address lock_bit)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bit_lock"
            ffi:void
            (list '* ffi:int))))
      (let ((~address (unwrap~pointer address))
            (~lock_bit (unwrap~fixed lock_bit)))
        (~f ~address ~lock_bit)))))
(export g_bit_lock)

;; extern gboolean g_bit_trylock(volatile gint *address, gint lock_bit);
(define g_bit_trylock
  (let ((~f #f))
    (lambda (address lock_bit)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bit_trylock"
            ffi:int
            (list '* ffi:int))))
      (let ((~address (unwrap~pointer address))
            (~lock_bit (unwrap~fixed lock_bit)))
        (~f ~address ~lock_bit)))))
(export g_bit_trylock)

;; extern void g_bit_unlock(volatile gint *address, gint lock_bit);
(define g_bit_unlock
  (let ((~f #f))
    (lambda (address lock_bit)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bit_unlock"
            ffi:void
            (list '* ffi:int))))
      (let ((~address (unwrap~pointer address))
            (~lock_bit (unwrap~fixed lock_bit)))
        (~f ~address ~lock_bit)))))
(export g_bit_unlock)

;; extern void g_pointer_bit_lock(volatile void *address, gint lock_bit);
(define g_pointer_bit_lock
  (let ((~f #f))
    (lambda (address lock_bit)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_pointer_bit_lock"
            ffi:void
            (list '* ffi:int))))
      (let ((~address (unwrap~pointer address))
            (~lock_bit (unwrap~fixed lock_bit)))
        (~f ~address ~lock_bit)))))
(export g_pointer_bit_lock)

;; extern gboolean g_pointer_bit_trylock(volatile void *address, gint lock_bit)
;;     ;
(define g_pointer_bit_trylock
  (let ((~f #f))
    (lambda (address lock_bit)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_pointer_bit_trylock"
            ffi:int
            (list '* ffi:int))))
      (let ((~address (unwrap~pointer address))
            (~lock_bit (unwrap~fixed lock_bit)))
        (~f ~address ~lock_bit)))))
(export g_pointer_bit_trylock)

;; extern void g_pointer_bit_unlock(volatile void *address, gint lock_bit);
(define g_pointer_bit_unlock
  (let ((~f #f))
    (lambda (address lock_bit)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_pointer_bit_unlock"
            ffi:void
            (list '* ffi:int))))
      (let ((~address (unwrap~pointer address))
            (~lock_bit (unwrap~fixed lock_bit)))
        (~f ~address ~lock_bit)))))
(export g_pointer_bit_unlock)

;; typedef enum {
;;   G_BOOKMARK_FILE_ERROR_INVALID_URI,
;;   G_BOOKMARK_FILE_ERROR_INVALID_VALUE,
;;   G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED,
;;   G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,
;;   G_BOOKMARK_FILE_ERROR_READ,
;;   G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING,
;;   G_BOOKMARK_FILE_ERROR_WRITE,
;;   G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND,
;; } GBookmarkFileError;
(define-fh-enum GBookmarkFileError
  '((G_BOOKMARK_FILE_ERROR_INVALID_URI . 0)
    (G_BOOKMARK_FILE_ERROR_INVALID_VALUE . 1)
    (G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED . 2)
    (G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND . 3)
    (G_BOOKMARK_FILE_ERROR_READ . 4)
    (G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING . 5)
    (G_BOOKMARK_FILE_ERROR_WRITE . 6)
    (G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND . 7))
  )

;; extern GQuark g_bookmark_file_error_quark(void);
(define g_bookmark_file_error_quark
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bookmark_file_error_quark"
            ffi:unsigned-int
            (list))))
      (let () (~f)))))
(export g_bookmark_file_error_quark)

;; typedef struct _GBookmarkFile GBookmarkFile;
(define GBookmarkFile-desc void)
(define GBookmarkFile*-desc (bs:pointer GBookmarkFile-desc))
(export GBookmarkFile*-desc)
(define-fh-pointer-type GBookmarkFile* GBookmarkFile*-desc)

;; extern GBookmarkFile *g_bookmark_file_new(void);
(define g_bookmark_file_new
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_bookmark_file_new" '* (list))))
      (let () (wrap-GBookmarkFile* (~f))))))
(export g_bookmark_file_new)

;; extern void g_bookmark_file_free(GBookmarkFile *bookmark);
(define g_bookmark_file_free
  (let ((~f #f))
    (lambda (bookmark)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bookmark_file_free"
            ffi:void
            (list '*))))
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark)))
        (~f ~bookmark)))))
(export g_bookmark_file_free)

;; extern gboolean g_bookmark_file_load_from_file(GBookmarkFile *bookmark, 
;;     const gchar *filename, GError **error);
(define g_bookmark_file_load_from_file
  (let ((~f #f))
    (lambda (bookmark filename error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bookmark_file_load_from_file"
            ffi:int
            (list '* '* '*))))
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~filename (unwrap~pointer filename))
            (~error (unwrap~pointer error)))
        (~f ~bookmark ~filename ~error)))))
(export g_bookmark_file_load_from_file)

;; extern gboolean g_bookmark_file_load_from_data(GBookmarkFile *bookmark, 
;;     const gchar *data, gsize length, GError **error);
(define g_bookmark_file_load_from_data
  (let ((~f #f))
    (lambda (bookmark data length error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bookmark_file_load_from_data"
            ffi:int
            (list '* '* ffi:unsigned-long '*))))
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~data (unwrap~pointer data))
            (~length (unwrap~fixed length))
            (~error (unwrap~pointer error)))
        (~f ~bookmark ~data ~length ~error)))))
(export g_bookmark_file_load_from_data)

;; extern gboolean g_bookmark_file_load_from_data_dirs(GBookmarkFile *bookmark
;;     , const gchar *file, gchar **full_path, GError **error);
(define g_bookmark_file_load_from_data_dirs
  (let ((~f #f))
    (lambda (bookmark file full_path error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bookmark_file_load_from_data_dirs"
            ffi:int
            (list '* '* '* '*))))
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~file (unwrap~pointer file))
            (~full_path (unwrap~pointer full_path))
            (~error (unwrap~pointer error)))
        (~f ~bookmark ~file ~full_path ~error)))))
(export g_bookmark_file_load_from_data_dirs)

;; extern gchar *g_bookmark_file_to_data(GBookmarkFile *bookmark, gsize *length
;;     , GError **error);
(define g_bookmark_file_to_data
  (let ((~f #f))
    (lambda (bookmark length error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bookmark_file_to_data"
            '*
            (list '* '* '*))))
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~length (unwrap~pointer length))
            (~error (unwrap~pointer error)))
        (~f ~bookmark ~length ~error)))))
(export g_bookmark_file_to_data)

;; extern gboolean g_bookmark_file_to_file(GBookmarkFile *bookmark, const gchar
;;      *filename, GError **error);
(define g_bookmark_file_to_file
  (let ((~f #f))
    (lambda (bookmark filename error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bookmark_file_to_file"
            ffi:int
            (list '* '* '*))))
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~filename (unwrap~pointer filename))
            (~error (unwrap~pointer error)))
        (~f ~bookmark ~filename ~error)))))
(export g_bookmark_file_to_file)

;; extern void g_bookmark_file_set_title(GBookmarkFile *bookmark, const gchar *
;;     uri, const gchar *title);
(define g_bookmark_file_set_title
  (let ((~f #f))
    (lambda (bookmark uri title)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bookmark_file_set_title"
            ffi:void
            (list '* '* '*))))
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap~pointer uri))
            (~title (unwrap~pointer title)))
        (~f ~bookmark ~uri ~title)))))
(export g_bookmark_file_set_title)

;; extern gchar *g_bookmark_file_get_title(GBookmarkFile *bookmark, const gchar
;;      *uri, GError **error);
(define g_bookmark_file_get_title
  (let ((~f #f))
    (lambda (bookmark uri error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bookmark_file_get_title"
            '*
            (list '* '* '*))))
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap~pointer uri))
            (~error (unwrap~pointer error)))
        (~f ~bookmark ~uri ~error)))))
(export g_bookmark_file_get_title)

;; extern void g_bookmark_file_set_description(GBookmarkFile *bookmark, const 
;;     gchar *uri, const gchar *description);
(define g_bookmark_file_set_description
  (let ((~f #f))
    (lambda (bookmark uri description)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bookmark_file_set_description"
            ffi:void
            (list '* '* '*))))
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap~pointer uri))
            (~description (unwrap~pointer description)))
        (~f ~bookmark ~uri ~description)))))
(export g_bookmark_file_set_description)

;; extern gchar *g_bookmark_file_get_description(GBookmarkFile *bookmark, const
;;      gchar *uri, GError **error);
(define g_bookmark_file_get_description
  (let ((~f #f))
    (lambda (bookmark uri error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bookmark_file_get_description"
            '*
            (list '* '* '*))))
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap~pointer uri))
            (~error (unwrap~pointer error)))
        (~f ~bookmark ~uri ~error)))))
(export g_bookmark_file_get_description)

;; extern void g_bookmark_file_set_mime_type(GBookmarkFile *bookmark, const 
;;     gchar *uri, const gchar *mime_type);
(define g_bookmark_file_set_mime_type
  (let ((~f #f))
    (lambda (bookmark uri mime_type)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bookmark_file_set_mime_type"
            ffi:void
            (list '* '* '*))))
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap~pointer uri))
            (~mime_type (unwrap~pointer mime_type)))
        (~f ~bookmark ~uri ~mime_type)))))
(export g_bookmark_file_set_mime_type)

;; extern gchar *g_bookmark_file_get_mime_type(GBookmarkFile *bookmark, const 
;;     gchar *uri, GError **error);
(define g_bookmark_file_get_mime_type
  (let ((~f #f))
    (lambda (bookmark uri error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bookmark_file_get_mime_type"
            '*
            (list '* '* '*))))
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap~pointer uri))
            (~error (unwrap~pointer error)))
        (~f ~bookmark ~uri ~error)))))
(export g_bookmark_file_get_mime_type)

;; extern void g_bookmark_file_set_groups(GBookmarkFile *bookmark, const gchar 
;;     *uri, const gchar **groups, gsize length);
(define g_bookmark_file_set_groups
  (let ((~f #f))
    (lambda (bookmark uri groups length)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bookmark_file_set_groups"
            ffi:void
            (list '* '* '* ffi:unsigned-long))))
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap~pointer uri))
            (~groups (unwrap~pointer groups))
            (~length (unwrap~fixed length)))
        (~f ~bookmark ~uri ~groups ~length)))))
(export g_bookmark_file_set_groups)

;; extern void g_bookmark_file_add_group(GBookmarkFile *bookmark, const gchar *
;;     uri, const gchar *group);
(define g_bookmark_file_add_group
  (let ((~f #f))
    (lambda (bookmark uri group)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bookmark_file_add_group"
            ffi:void
            (list '* '* '*))))
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap~pointer uri))
            (~group (unwrap~pointer group)))
        (~f ~bookmark ~uri ~group)))))
(export g_bookmark_file_add_group)

;; extern gboolean g_bookmark_file_has_group(GBookmarkFile *bookmark, const 
;;     gchar *uri, const gchar *group, GError **error);
(define g_bookmark_file_has_group
  (let ((~f #f))
    (lambda (bookmark uri group error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bookmark_file_has_group"
            ffi:int
            (list '* '* '* '*))))
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap~pointer uri))
            (~group (unwrap~pointer group))
            (~error (unwrap~pointer error)))
        (~f ~bookmark ~uri ~group ~error)))))
(export g_bookmark_file_has_group)

;; extern gchar **g_bookmark_file_get_groups(GBookmarkFile *bookmark, const 
;;     gchar *uri, gsize *length, GError **error);
(define g_bookmark_file_get_groups
  (let* ((addr (dynamic-pointer
                 "g_bookmark_file_get_groups"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer (bs:pointer void)))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_bookmark_file_get_groups)

;; extern void g_bookmark_file_add_application(GBookmarkFile *bookmark, const 
;;     gchar *uri, const gchar *name, const gchar *exec);
(define g_bookmark_file_add_application
  (let ((~f #f))
    (lambda (bookmark uri name exec)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bookmark_file_add_application"
            ffi:void
            (list '* '* '* '*))))
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap~pointer uri))
            (~name (unwrap~pointer name))
            (~exec (unwrap~pointer exec)))
        (~f ~bookmark ~uri ~name ~exec)))))
(export g_bookmark_file_add_application)

;; extern gboolean g_bookmark_file_has_application(GBookmarkFile *bookmark, 
;;     const gchar *uri, const gchar *name, GError **error);
(define g_bookmark_file_has_application
  (let ((~f #f))
    (lambda (bookmark uri name error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bookmark_file_has_application"
            ffi:int
            (list '* '* '* '*))))
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap~pointer uri))
            (~name (unwrap~pointer name))
            (~error (unwrap~pointer error)))
        (~f ~bookmark ~uri ~name ~error)))))
(export g_bookmark_file_has_application)

;; extern gchar **g_bookmark_file_get_applications(GBookmarkFile *bookmark, 
;;     const gchar *uri, gsize *length, GError **error);
(define g_bookmark_file_get_applications
  (let* ((addr (dynamic-pointer
                 "g_bookmark_file_get_applications"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer (bs:pointer void)))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_bookmark_file_get_applications)

;; extern gboolean g_bookmark_file_set_app_info(GBookmarkFile *bookmark, const 
;;     gchar *uri, const gchar *name, const gchar *exec, gint count, time_t 
;;     stamp, GError **error);
(define g_bookmark_file_set_app_info
  (let ((~f #f))
    (lambda (bookmark uri name exec count stamp error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bookmark_file_set_app_info"
            ffi:int
            (list '* '* '* '* ffi:int ffi:long '*))))
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap~pointer uri))
            (~name (unwrap~pointer name))
            (~exec (unwrap~pointer exec))
            (~count (unwrap~fixed count))
            (~stamp (unwrap~fixed stamp))
            (~error (unwrap~pointer error)))
        (~f ~bookmark
            ~uri
            ~name
            ~exec
            ~count
            ~stamp
            ~error)))))
(export g_bookmark_file_set_app_info)

;; extern gboolean g_bookmark_file_get_app_info(GBookmarkFile *bookmark, const 
;;     gchar *uri, const gchar *name, gchar **exec, guint *count, time_t *stamp
;;     , GError **error);
(define g_bookmark_file_get_app_info
  (let ((~f #f))
    (lambda (bookmark uri name exec count stamp error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bookmark_file_get_app_info"
            ffi:int
            (list '* '* '* '* '* '* '*))))
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap~pointer uri))
            (~name (unwrap~pointer name))
            (~exec (unwrap~pointer exec))
            (~count (unwrap~pointer count))
            (~stamp (unwrap~pointer stamp))
            (~error (unwrap~pointer error)))
        (~f ~bookmark
            ~uri
            ~name
            ~exec
            ~count
            ~stamp
            ~error)))))
(export g_bookmark_file_get_app_info)

;; extern void g_bookmark_file_set_is_private(GBookmarkFile *bookmark, const 
;;     gchar *uri, gboolean is_private);
(define g_bookmark_file_set_is_private
  (let ((~f #f))
    (lambda (bookmark uri is_private)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bookmark_file_set_is_private"
            ffi:void
            (list '* '* ffi:int))))
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap~pointer uri))
            (~is_private (unwrap~fixed is_private)))
        (~f ~bookmark ~uri ~is_private)))))
(export g_bookmark_file_set_is_private)

;; extern gboolean g_bookmark_file_get_is_private(GBookmarkFile *bookmark, 
;;     const gchar *uri, GError **error);
(define g_bookmark_file_get_is_private
  (let ((~f #f))
    (lambda (bookmark uri error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bookmark_file_get_is_private"
            ffi:int
            (list '* '* '*))))
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap~pointer uri))
            (~error (unwrap~pointer error)))
        (~f ~bookmark ~uri ~error)))))
(export g_bookmark_file_get_is_private)

;; extern void g_bookmark_file_set_icon(GBookmarkFile *bookmark, const gchar *
;;     uri, const gchar *href, const gchar *mime_type);
(define g_bookmark_file_set_icon
  (let ((~f #f))
    (lambda (bookmark uri href mime_type)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bookmark_file_set_icon"
            ffi:void
            (list '* '* '* '*))))
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap~pointer uri))
            (~href (unwrap~pointer href))
            (~mime_type (unwrap~pointer mime_type)))
        (~f ~bookmark ~uri ~href ~mime_type)))))
(export g_bookmark_file_set_icon)

;; extern gboolean g_bookmark_file_get_icon(GBookmarkFile *bookmark, const 
;;     gchar *uri, gchar **href, gchar **mime_type, GError **error);
(define g_bookmark_file_get_icon
  (let ((~f #f))
    (lambda (bookmark uri href mime_type error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bookmark_file_get_icon"
            ffi:int
            (list '* '* '* '* '*))))
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap~pointer uri))
            (~href (unwrap~pointer href))
            (~mime_type (unwrap~pointer mime_type))
            (~error (unwrap~pointer error)))
        (~f ~bookmark ~uri ~href ~mime_type ~error)))))
(export g_bookmark_file_get_icon)

;; extern void g_bookmark_file_set_added(GBookmarkFile *bookmark, const gchar *
;;     uri, time_t added);
(define g_bookmark_file_set_added
  (let ((~f #f))
    (lambda (bookmark uri added)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bookmark_file_set_added"
            ffi:void
            (list '* '* ffi:long))))
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap~pointer uri))
            (~added (unwrap~fixed added)))
        (~f ~bookmark ~uri ~added)))))
(export g_bookmark_file_set_added)

;; extern time_t g_bookmark_file_get_added(GBookmarkFile *bookmark, const gchar
;;      *uri, GError **error);
(define g_bookmark_file_get_added
  (let ((~f #f))
    (lambda (bookmark uri error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bookmark_file_get_added"
            ffi:long
            (list '* '* '*))))
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap~pointer uri))
            (~error (unwrap~pointer error)))
        (~f ~bookmark ~uri ~error)))))
(export g_bookmark_file_get_added)

;; extern void g_bookmark_file_set_modified(GBookmarkFile *bookmark, const 
;;     gchar *uri, time_t modified);
(define g_bookmark_file_set_modified
  (let ((~f #f))
    (lambda (bookmark uri modified)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bookmark_file_set_modified"
            ffi:void
            (list '* '* ffi:long))))
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap~pointer uri))
            (~modified (unwrap~fixed modified)))
        (~f ~bookmark ~uri ~modified)))))
(export g_bookmark_file_set_modified)

;; extern time_t g_bookmark_file_get_modified(GBookmarkFile *bookmark, const 
;;     gchar *uri, GError **error);
(define g_bookmark_file_get_modified
  (let ((~f #f))
    (lambda (bookmark uri error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bookmark_file_get_modified"
            ffi:long
            (list '* '* '*))))
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap~pointer uri))
            (~error (unwrap~pointer error)))
        (~f ~bookmark ~uri ~error)))))
(export g_bookmark_file_get_modified)

;; extern void g_bookmark_file_set_visited(GBookmarkFile *bookmark, const gchar
;;      *uri, time_t visited);
(define g_bookmark_file_set_visited
  (let ((~f #f))
    (lambda (bookmark uri visited)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bookmark_file_set_visited"
            ffi:void
            (list '* '* ffi:long))))
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap~pointer uri))
            (~visited (unwrap~fixed visited)))
        (~f ~bookmark ~uri ~visited)))))
(export g_bookmark_file_set_visited)

;; extern time_t g_bookmark_file_get_visited(GBookmarkFile *bookmark, const 
;;     gchar *uri, GError **error);
(define g_bookmark_file_get_visited
  (let ((~f #f))
    (lambda (bookmark uri error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bookmark_file_get_visited"
            ffi:long
            (list '* '* '*))))
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap~pointer uri))
            (~error (unwrap~pointer error)))
        (~f ~bookmark ~uri ~error)))))
(export g_bookmark_file_get_visited)

;; extern gboolean g_bookmark_file_has_item(GBookmarkFile *bookmark, const 
;;     gchar *uri);
(define g_bookmark_file_has_item
  (let ((~f #f))
    (lambda (bookmark uri)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bookmark_file_has_item"
            ffi:int
            (list '* '*))))
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap~pointer uri)))
        (~f ~bookmark ~uri)))))
(export g_bookmark_file_has_item)

;; extern gint g_bookmark_file_get_size(GBookmarkFile *bookmark);
(define g_bookmark_file_get_size
  (let ((~f #f))
    (lambda (bookmark)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bookmark_file_get_size"
            ffi:int
            (list '*))))
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark)))
        (~f ~bookmark)))))
(export g_bookmark_file_get_size)

;; extern gchar **g_bookmark_file_get_uris(GBookmarkFile *bookmark, gsize *
;;     length);
(define g_bookmark_file_get_uris
  (let* ((addr (dynamic-pointer
                 "g_bookmark_file_get_uris"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer (bs:pointer void)))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_bookmark_file_get_uris)

;; extern gboolean g_bookmark_file_remove_group(GBookmarkFile *bookmark, const 
;;     gchar *uri, const gchar *group, GError **error);
(define g_bookmark_file_remove_group
  (let ((~f #f))
    (lambda (bookmark uri group error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bookmark_file_remove_group"
            ffi:int
            (list '* '* '* '*))))
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap~pointer uri))
            (~group (unwrap~pointer group))
            (~error (unwrap~pointer error)))
        (~f ~bookmark ~uri ~group ~error)))))
(export g_bookmark_file_remove_group)

;; extern gboolean g_bookmark_file_remove_application(GBookmarkFile *bookmark, 
;;     const gchar *uri, const gchar *name, GError **error);
(define g_bookmark_file_remove_application
  (let ((~f #f))
    (lambda (bookmark uri name error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bookmark_file_remove_application"
            ffi:int
            (list '* '* '* '*))))
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap~pointer uri))
            (~name (unwrap~pointer name))
            (~error (unwrap~pointer error)))
        (~f ~bookmark ~uri ~name ~error)))))
(export g_bookmark_file_remove_application)

;; extern gboolean g_bookmark_file_remove_item(GBookmarkFile *bookmark, const 
;;     gchar *uri, GError **error);
(define g_bookmark_file_remove_item
  (let ((~f #f))
    (lambda (bookmark uri error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bookmark_file_remove_item"
            ffi:int
            (list '* '* '*))))
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~uri (unwrap~pointer uri))
            (~error (unwrap~pointer error)))
        (~f ~bookmark ~uri ~error)))))
(export g_bookmark_file_remove_item)

;; extern gboolean g_bookmark_file_move_item(GBookmarkFile *bookmark, const 
;;     gchar *old_uri, const gchar *new_uri, GError **error);
(define g_bookmark_file_move_item
  (let ((~f #f))
    (lambda (bookmark old_uri new_uri error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bookmark_file_move_item"
            ffi:int
            (list '* '* '* '*))))
      (let ((~bookmark (unwrap-GBookmarkFile* bookmark))
            (~old_uri (unwrap~pointer old_uri))
            (~new_uri (unwrap~pointer new_uri))
            (~error (unwrap~pointer error)))
        (~f ~bookmark ~old_uri ~new_uri ~error)))))
(export g_bookmark_file_move_item)

;; extern GBytes *g_bytes_new(gconstpointer data, gsize size);
(define g_bytes_new
  (let ((~f #f))
    (lambda (data size)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bytes_new"
            '*
            (list '* ffi:unsigned-long))))
      (let ((~data (unwrap-gconstpointer data))
            (~size (unwrap~fixed size)))
        (wrap-GBytes* (~f ~data ~size))))))
(export g_bytes_new)

;; extern GBytes *g_bytes_new_take(gpointer data, gsize size);
(define g_bytes_new_take
  (let ((~f #f))
    (lambda (data size)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bytes_new_take"
            '*
            (list '* ffi:unsigned-long))))
      (let ((~data (unwrap-gpointer data))
            (~size (unwrap~fixed size)))
        (wrap-GBytes* (~f ~data ~size))))))
(export g_bytes_new_take)

;; extern GBytes *g_bytes_new_static(gconstpointer data, gsize size);
(define g_bytes_new_static
  (let ((~f #f))
    (lambda (data size)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bytes_new_static"
            '*
            (list '* ffi:unsigned-long))))
      (let ((~data (unwrap-gconstpointer data))
            (~size (unwrap~fixed size)))
        (wrap-GBytes* (~f ~data ~size))))))
(export g_bytes_new_static)

;; extern GBytes *g_bytes_new_with_free_func(gconstpointer data, gsize size, 
;;     GDestroyNotify free_func, gpointer user_data);
(define g_bytes_new_with_free_func
  (let ((~f #f))
    (lambda (data size free_func user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bytes_new_with_free_func"
            '*
            (list '* ffi:unsigned-long '* '*))))
      (let ((~data (unwrap-gconstpointer data))
            (~size (unwrap~fixed size))
            (~free_func
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               free_func))
            (~user_data (unwrap-gpointer user_data)))
        (wrap-GBytes*
          (~f ~data ~size ~free_func ~user_data))))))
(export g_bytes_new_with_free_func)

;; extern GBytes *g_bytes_new_from_bytes(GBytes *bytes, gsize offset, gsize 
;;     length);
(define g_bytes_new_from_bytes
  (let ((~f #f))
    (lambda (bytes offset length)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bytes_new_from_bytes"
            '*
            (list '* ffi:unsigned-long ffi:unsigned-long))))
      (let ((~bytes (unwrap-GBytes* bytes))
            (~offset (unwrap~fixed offset))
            (~length (unwrap~fixed length)))
        (wrap-GBytes* (~f ~bytes ~offset ~length))))))
(export g_bytes_new_from_bytes)

;; extern gconstpointer g_bytes_get_data(GBytes *bytes, gsize *size);
(define g_bytes_get_data
  (let ((~f #f))
    (lambda (bytes size)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_bytes_get_data" '* (list '* '*))))
      (let ((~bytes (unwrap-GBytes* bytes))
            (~size (unwrap~pointer size)))
        (wrap-gconstpointer (~f ~bytes ~size))))))
(export g_bytes_get_data)

;; extern gsize g_bytes_get_size(GBytes *bytes);
(define g_bytes_get_size
  (let ((~f #f))
    (lambda (bytes)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bytes_get_size"
            ffi:unsigned-long
            (list '*))))
      (let ((~bytes (unwrap-GBytes* bytes)))
        (~f ~bytes)))))
(export g_bytes_get_size)

;; extern GBytes *g_bytes_ref(GBytes *bytes);
(define g_bytes_ref
  (let ((~f #f))
    (lambda (bytes)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_bytes_ref" '* (list '*))))
      (let ((~bytes (unwrap-GBytes* bytes)))
        (wrap-GBytes* (~f ~bytes))))))
(export g_bytes_ref)

;; extern void g_bytes_unref(GBytes *bytes);
(define g_bytes_unref
  (let ((~f #f))
    (lambda (bytes)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_bytes_unref" ffi:void (list '*))))
      (let ((~bytes (unwrap-GBytes* bytes)))
        (~f ~bytes)))))
(export g_bytes_unref)

;; extern gpointer g_bytes_unref_to_data(GBytes *bytes, gsize *size);
(define g_bytes_unref_to_data
  (let ((~f #f))
    (lambda (bytes size)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bytes_unref_to_data"
            '*
            (list '* '*))))
      (let ((~bytes (unwrap-GBytes* bytes))
            (~size (unwrap~pointer size)))
        (wrap-gpointer (~f ~bytes ~size))))))
(export g_bytes_unref_to_data)

;; extern GByteArray *g_bytes_unref_to_array(GBytes *bytes);
(define g_bytes_unref_to_array
  (let ((~f #f))
    (lambda (bytes)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bytes_unref_to_array"
            '*
            (list '*))))
      (let ((~bytes (unwrap-GBytes* bytes)))
        (wrap-GByteArray* (~f ~bytes))))))
(export g_bytes_unref_to_array)

;; extern guint g_bytes_hash(gconstpointer bytes);
(define g_bytes_hash
  (let ((~f #f))
    (lambda (bytes)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bytes_hash"
            ffi:unsigned-int
            (list '*))))
      (let ((~bytes (unwrap-gconstpointer bytes)))
        (~f ~bytes)))))
(export g_bytes_hash)

;; extern gboolean g_bytes_equal(gconstpointer bytes1, gconstpointer bytes2);
(define g_bytes_equal
  (let ((~f #f))
    (lambda (bytes1 bytes2)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bytes_equal"
            ffi:int
            (list '* '*))))
      (let ((~bytes1 (unwrap-gconstpointer bytes1))
            (~bytes2 (unwrap-gconstpointer bytes2)))
        (~f ~bytes1 ~bytes2)))))
(export g_bytes_equal)

;; extern gint g_bytes_compare(gconstpointer bytes1, gconstpointer bytes2);
(define g_bytes_compare
  (let ((~f #f))
    (lambda (bytes1 bytes2)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_bytes_compare"
            ffi:int
            (list '* '*))))
      (let ((~bytes1 (unwrap-gconstpointer bytes1))
            (~bytes2 (unwrap-gconstpointer bytes2)))
        (~f ~bytes1 ~bytes2)))))
(export g_bytes_compare)

;; extern gboolean g_get_charset(const char **charset);
(define g_get_charset
  (let ((~f #f))
    (lambda (charset)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_get_charset" ffi:int (list '*))))
      (let ((~charset (unwrap~pointer charset)))
        (~f ~charset)))))
(export g_get_charset)

;; extern gchar *g_get_codeset(void);
(define g_get_codeset
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_get_codeset" '* (list))))
      (let () (~f)))))
(export g_get_codeset)

;; extern const gchar *const*g_get_language_names(void);
(define g_get_language_names
  (let* ((addr (dynamic-pointer
                 "g_get_language_names"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer (bs:pointer void)))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_get_language_names)

;; extern gchar **g_get_locale_variants(const gchar *locale);
(define g_get_locale_variants
  (let* ((addr (dynamic-pointer
                 "g_get_locale_variants"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer (bs:pointer void)))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_get_locale_variants)

;; typedef enum {
;;   G_CHECKSUM_MD5,
;;   G_CHECKSUM_SHA1,
;;   G_CHECKSUM_SHA256,
;;   G_CHECKSUM_SHA512,
;;   G_CHECKSUM_SHA384,
;; } GChecksumType;
(define-fh-enum GChecksumType
  '((G_CHECKSUM_MD5 . 0)
    (G_CHECKSUM_SHA1 . 1)
    (G_CHECKSUM_SHA256 . 2)
    (G_CHECKSUM_SHA512 . 3)
    (G_CHECKSUM_SHA384 . 4))
  )

;; typedef struct _GChecksum GChecksum;
(define GChecksum-desc void)
(define GChecksum*-desc (bs:pointer GChecksum-desc))
(export GChecksum*-desc)
(define-fh-pointer-type GChecksum* GChecksum*-desc)

;; extern gssize g_checksum_type_get_length(GChecksumType checksum_type);
(define g_checksum_type_get_length
  (let ((~f #f))
    (lambda (checksum_type)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_checksum_type_get_length"
            ffi:long
            (list ffi:int))))
      (let ((~checksum_type (unwrap~fixed checksum_type)))
        (~f ~checksum_type)))))
(export g_checksum_type_get_length)

;; extern GChecksum *g_checksum_new(GChecksumType checksum_type);
(define g_checksum_new
  (let ((~f #f))
    (lambda (checksum_type)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_checksum_new" '* (list ffi:int))))
      (let ((~checksum_type (unwrap~fixed checksum_type)))
        (wrap-GChecksum* (~f ~checksum_type))))))
(export g_checksum_new)

;; extern void g_checksum_reset(GChecksum *checksum);
(define g_checksum_reset
  (let ((~f #f))
    (lambda (checksum)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_checksum_reset"
            ffi:void
            (list '*))))
      (let ((~checksum (unwrap-GChecksum* checksum)))
        (~f ~checksum)))))
(export g_checksum_reset)

;; extern GChecksum *g_checksum_copy(const GChecksum *checksum);
(define g_checksum_copy
  (let ((~f #f))
    (lambda (checksum)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_checksum_copy" '* (list '*))))
      (let ((~checksum (unwrap-GChecksum* checksum)))
        (wrap-GChecksum* (~f ~checksum))))))
(export g_checksum_copy)

;; extern void g_checksum_free(GChecksum *checksum);
(define g_checksum_free
  (let ((~f #f))
    (lambda (checksum)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_checksum_free"
            ffi:void
            (list '*))))
      (let ((~checksum (unwrap-GChecksum* checksum)))
        (~f ~checksum)))))
(export g_checksum_free)

;; extern void g_checksum_update(GChecksum *checksum, const guchar *data, 
;;     gssize length);
(define g_checksum_update
  (let ((~f #f))
    (lambda (checksum data length)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_checksum_update"
            ffi:void
            (list '* '* ffi:long))))
      (let ((~checksum (unwrap-GChecksum* checksum))
            (~data (unwrap~pointer data))
            (~length (unwrap~fixed length)))
        (~f ~checksum ~data ~length)))))
(export g_checksum_update)

;; extern const gchar *g_checksum_get_string(GChecksum *checksum);
(define g_checksum_get_string
  (let ((~f #f))
    (lambda (checksum)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_checksum_get_string"
            '*
            (list '*))))
      (let ((~checksum (unwrap-GChecksum* checksum)))
        (~f ~checksum)))))
(export g_checksum_get_string)

;; extern void g_checksum_get_digest(GChecksum *checksum, guint8 *buffer, gsize
;;      *digest_len);
(define g_checksum_get_digest
  (let ((~f #f))
    (lambda (checksum buffer digest_len)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_checksum_get_digest"
            ffi:void
            (list '* '* '*))))
      (let ((~checksum (unwrap-GChecksum* checksum))
            (~buffer (unwrap~pointer buffer))
            (~digest_len (unwrap~pointer digest_len)))
        (~f ~checksum ~buffer ~digest_len)))))
(export g_checksum_get_digest)

;; extern gchar *g_compute_checksum_for_data(GChecksumType checksum_type, const
;;      guchar *data, gsize length);
(define g_compute_checksum_for_data
  (let ((~f #f))
    (lambda (checksum_type data length)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_compute_checksum_for_data"
            '*
            (list ffi:int '* ffi:unsigned-long))))
      (let ((~checksum_type (unwrap~fixed checksum_type))
            (~data (unwrap~pointer data))
            (~length (unwrap~fixed length)))
        (~f ~checksum_type ~data ~length)))))
(export g_compute_checksum_for_data)

;; extern gchar *g_compute_checksum_for_string(GChecksumType checksum_type, 
;;     const gchar *str, gssize length);
(define g_compute_checksum_for_string
  (let ((~f #f))
    (lambda (checksum_type str length)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_compute_checksum_for_string"
            '*
            (list ffi:int '* ffi:long))))
      (let ((~checksum_type (unwrap~fixed checksum_type))
            (~str (unwrap~pointer str))
            (~length (unwrap~fixed length)))
        (~f ~checksum_type ~str ~length)))))
(export g_compute_checksum_for_string)

;; extern gchar *g_compute_checksum_for_bytes(GChecksumType checksum_type, 
;;     GBytes *data);
(define g_compute_checksum_for_bytes
  (let ((~f #f))
    (lambda (checksum_type data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_compute_checksum_for_bytes"
            '*
            (list ffi:int '*))))
      (let ((~checksum_type (unwrap~fixed checksum_type))
            (~data (unwrap-GBytes* data)))
        (~f ~checksum_type ~data)))))
(export g_compute_checksum_for_bytes)

;; typedef enum {
;;   G_CONVERT_ERROR_NO_CONVERSION,
;;   G_CONVERT_ERROR_ILLEGAL_SEQUENCE,
;;   G_CONVERT_ERROR_FAILED,
;;   G_CONVERT_ERROR_PARTIAL_INPUT,
;;   G_CONVERT_ERROR_BAD_URI,
;;   G_CONVERT_ERROR_NOT_ABSOLUTE_PATH,
;;   G_CONVERT_ERROR_NO_MEMORY,
;; } GConvertError;
(define-fh-enum GConvertError
  '((G_CONVERT_ERROR_NO_CONVERSION . 0)
    (G_CONVERT_ERROR_ILLEGAL_SEQUENCE . 1)
    (G_CONVERT_ERROR_FAILED . 2)
    (G_CONVERT_ERROR_PARTIAL_INPUT . 3)
    (G_CONVERT_ERROR_BAD_URI . 4)
    (G_CONVERT_ERROR_NOT_ABSOLUTE_PATH . 5)
    (G_CONVERT_ERROR_NO_MEMORY . 6))
  )

;; extern GQuark g_convert_error_quark(void);
(define g_convert_error_quark
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_convert_error_quark"
            ffi:unsigned-int
            (list))))
      (let () (~f)))))
(export g_convert_error_quark)

;; typedef struct _GIConv *GIConv;
(define-fh-pointer-type GIConv)

;; extern GIConv g_iconv_open(const gchar *to_codeset, const gchar *
;;     from_codeset);
(define g_iconv_open
  (let ((~f #f))
    (lambda (to_codeset from_codeset)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_iconv_open" '* (list '* '*))))
      (let ((~to_codeset (unwrap~pointer to_codeset))
            (~from_codeset (unwrap~pointer from_codeset)))
        (~f ~to_codeset ~from_codeset)))))
(export g_iconv_open)

;; extern gsize g_iconv(GIConv converter, gchar **inbuf, gsize *inbytes_left, 
;;     gchar **outbuf, gsize *outbytes_left);
(define g_iconv
  (let ((~f #f))
    (lambda (converter
             inbuf
             inbytes_left
             outbuf
             outbytes_left)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_iconv"
            ffi:unsigned-long
            (list '* '* '* '* '*))))
      (let ((~converter (unwrap~pointer converter))
            (~inbuf (unwrap~pointer inbuf))
            (~inbytes_left (unwrap~pointer inbytes_left))
            (~outbuf (unwrap~pointer outbuf))
            (~outbytes_left (unwrap~pointer outbytes_left)))
        (~f ~converter
            ~inbuf
            ~inbytes_left
            ~outbuf
            ~outbytes_left)))))
(export g_iconv)

;; extern gint g_iconv_close(GIConv converter);
(define g_iconv_close
  (let ((~f #f))
    (lambda (converter)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_iconv_close" ffi:int (list '*))))
      (let ((~converter (unwrap~pointer converter)))
        (~f ~converter)))))
(export g_iconv_close)

;; extern gchar *g_convert(const gchar *str, gssize len, const gchar *
;;     to_codeset, const gchar *from_codeset, gsize *bytes_read, gsize *
;;     bytes_written, GError **error);
(define g_convert
  (let ((~f #f))
    (lambda (str
             len
             to_codeset
             from_codeset
             bytes_read
             bytes_written
             error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_convert"
            '*
            (list '* ffi:long '* '* '* '* '*))))
      (let ((~str (unwrap~pointer str))
            (~len (unwrap~fixed len))
            (~to_codeset (unwrap~pointer to_codeset))
            (~from_codeset (unwrap~pointer from_codeset))
            (~bytes_read (unwrap~pointer bytes_read))
            (~bytes_written (unwrap~pointer bytes_written))
            (~error (unwrap~pointer error)))
        (~f ~str
            ~len
            ~to_codeset
            ~from_codeset
            ~bytes_read
            ~bytes_written
            ~error)))))
(export g_convert)

;; extern gchar *g_convert_with_iconv(const gchar *str, gssize len, GIConv 
;;     converter, gsize *bytes_read, gsize *bytes_written, GError **error);
(define g_convert_with_iconv
  (let ((~f #f))
    (lambda (str
             len
             converter
             bytes_read
             bytes_written
             error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_convert_with_iconv"
            '*
            (list '* ffi:long '* '* '* '*))))
      (let ((~str (unwrap~pointer str))
            (~len (unwrap~fixed len))
            (~converter (unwrap~pointer converter))
            (~bytes_read (unwrap~pointer bytes_read))
            (~bytes_written (unwrap~pointer bytes_written))
            (~error (unwrap~pointer error)))
        (~f ~str
            ~len
            ~converter
            ~bytes_read
            ~bytes_written
            ~error)))))
(export g_convert_with_iconv)

;; extern gchar *g_convert_with_fallback(const gchar *str, gssize len, const 
;;     gchar *to_codeset, const gchar *from_codeset, const gchar *fallback, 
;;     gsize *bytes_read, gsize *bytes_written, GError **error);
(define g_convert_with_fallback
  (let ((~f #f))
    (lambda (str
             len
             to_codeset
             from_codeset
             fallback
             bytes_read
             bytes_written
             error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_convert_with_fallback"
            '*
            (list '* ffi:long '* '* '* '* '* '*))))
      (let ((~str (unwrap~pointer str))
            (~len (unwrap~fixed len))
            (~to_codeset (unwrap~pointer to_codeset))
            (~from_codeset (unwrap~pointer from_codeset))
            (~fallback (unwrap~pointer fallback))
            (~bytes_read (unwrap~pointer bytes_read))
            (~bytes_written (unwrap~pointer bytes_written))
            (~error (unwrap~pointer error)))
        (~f ~str
            ~len
            ~to_codeset
            ~from_codeset
            ~fallback
            ~bytes_read
            ~bytes_written
            ~error)))))
(export g_convert_with_fallback)

;; extern gchar *g_locale_to_utf8(const gchar *opsysstring, gssize len, gsize *
;;     bytes_read, gsize *bytes_written, GError **error);
(define g_locale_to_utf8
  (let ((~f #f))
    (lambda (opsysstring len bytes_read bytes_written error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_locale_to_utf8"
            '*
            (list '* ffi:long '* '* '*))))
      (let ((~opsysstring (unwrap~pointer opsysstring))
            (~len (unwrap~fixed len))
            (~bytes_read (unwrap~pointer bytes_read))
            (~bytes_written (unwrap~pointer bytes_written))
            (~error (unwrap~pointer error)))
        (~f ~opsysstring
            ~len
            ~bytes_read
            ~bytes_written
            ~error)))))
(export g_locale_to_utf8)

;; extern gchar *g_locale_from_utf8(const gchar *utf8string, gssize len, gsize 
;;     *bytes_read, gsize *bytes_written, GError **error);
(define g_locale_from_utf8
  (let ((~f #f))
    (lambda (utf8string len bytes_read bytes_written error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_locale_from_utf8"
            '*
            (list '* ffi:long '* '* '*))))
      (let ((~utf8string (unwrap~pointer utf8string))
            (~len (unwrap~fixed len))
            (~bytes_read (unwrap~pointer bytes_read))
            (~bytes_written (unwrap~pointer bytes_written))
            (~error (unwrap~pointer error)))
        (~f ~utf8string
            ~len
            ~bytes_read
            ~bytes_written
            ~error)))))
(export g_locale_from_utf8)

;; extern gchar *g_filename_to_utf8(const gchar *opsysstring, gssize len, gsize
;;      *bytes_read, gsize *bytes_written, GError **error);
(define g_filename_to_utf8
  (let ((~f #f))
    (lambda (opsysstring len bytes_read bytes_written error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_filename_to_utf8"
            '*
            (list '* ffi:long '* '* '*))))
      (let ((~opsysstring (unwrap~pointer opsysstring))
            (~len (unwrap~fixed len))
            (~bytes_read (unwrap~pointer bytes_read))
            (~bytes_written (unwrap~pointer bytes_written))
            (~error (unwrap~pointer error)))
        (~f ~opsysstring
            ~len
            ~bytes_read
            ~bytes_written
            ~error)))))
(export g_filename_to_utf8)

;; extern gchar *g_filename_from_utf8(const gchar *utf8string, gssize len, 
;;     gsize *bytes_read, gsize *bytes_written, GError **error);
(define g_filename_from_utf8
  (let ((~f #f))
    (lambda (utf8string len bytes_read bytes_written error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_filename_from_utf8"
            '*
            (list '* ffi:long '* '* '*))))
      (let ((~utf8string (unwrap~pointer utf8string))
            (~len (unwrap~fixed len))
            (~bytes_read (unwrap~pointer bytes_read))
            (~bytes_written (unwrap~pointer bytes_written))
            (~error (unwrap~pointer error)))
        (~f ~utf8string
            ~len
            ~bytes_read
            ~bytes_written
            ~error)))))
(export g_filename_from_utf8)

;; extern gchar *g_filename_from_uri(const gchar *uri, gchar **hostname, GError
;;      **error);
(define g_filename_from_uri
  (let ((~f #f))
    (lambda (uri hostname error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_filename_from_uri"
            '*
            (list '* '* '*))))
      (let ((~uri (unwrap~pointer uri))
            (~hostname (unwrap~pointer hostname))
            (~error (unwrap~pointer error)))
        (~f ~uri ~hostname ~error)))))
(export g_filename_from_uri)

;; extern gchar *g_filename_to_uri(const gchar *filename, const gchar *hostname
;;     , GError **error);
(define g_filename_to_uri
  (let ((~f #f))
    (lambda (filename hostname error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_filename_to_uri"
            '*
            (list '* '* '*))))
      (let ((~filename (unwrap~pointer filename))
            (~hostname (unwrap~pointer hostname))
            (~error (unwrap~pointer error)))
        (~f ~filename ~hostname ~error)))))
(export g_filename_to_uri)

;; extern gchar *g_filename_display_name(const gchar *filename);
(define g_filename_display_name
  (let ((~f #f))
    (lambda (filename)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_filename_display_name"
            '*
            (list '*))))
      (let ((~filename (unwrap~pointer filename)))
        (~f ~filename)))))
(export g_filename_display_name)

;; extern gboolean g_get_filename_charsets(const gchar ***charsets);
(define g_get_filename_charsets
  (let ((~f #f))
    (lambda (charsets)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_get_filename_charsets"
            ffi:int
            (list '*))))
      (let ((~charsets (unwrap~pointer charsets)))
        (~f ~charsets)))))
(export g_get_filename_charsets)

;; extern gchar *g_filename_display_basename(const gchar *filename);
(define g_filename_display_basename
  (let ((~f #f))
    (lambda (filename)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_filename_display_basename"
            '*
            (list '*))))
      (let ((~filename (unwrap~pointer filename)))
        (~f ~filename)))))
(export g_filename_display_basename)

;; extern gchar **g_uri_list_extract_uris(const gchar *uri_list);
(define g_uri_list_extract_uris
  (let* ((addr (dynamic-pointer
                 "g_uri_list_extract_uris"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer (bs:pointer void)))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_uri_list_extract_uris)

;; typedef struct _GData GData;
(define GData-desc void)
(define GData*-desc (bs:pointer GData-desc))
(export GData*-desc)
(define-fh-pointer-type GData* GData*-desc)

;; typedef void (*GDataForeachFunc)(GQuark key_id, gpointer data, gpointer 
;;     user_data);
(define-fh-function/p GDataForeachFunc
  ffi:void (list ffi:unsigned-int (quote *) (quote *)))

;; extern void g_datalist_init(GData **datalist);
(define g_datalist_init
  (let ((~f #f))
    (lambda (datalist)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_datalist_init"
            ffi:void
            (list '*))))
      (let ((~datalist (unwrap~pointer datalist)))
        (~f ~datalist)))))
(export g_datalist_init)

;; extern void g_datalist_clear(GData **datalist);
(define g_datalist_clear
  (let ((~f #f))
    (lambda (datalist)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_datalist_clear"
            ffi:void
            (list '*))))
      (let ((~datalist (unwrap~pointer datalist)))
        (~f ~datalist)))))
(export g_datalist_clear)

;; extern gpointer g_datalist_id_get_data(GData **datalist, GQuark key_id);
(define g_datalist_id_get_data
  (let ((~f #f))
    (lambda (datalist key_id)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_datalist_id_get_data"
            '*
            (list '* ffi:unsigned-int))))
      (let ((~datalist (unwrap~pointer datalist))
            (~key_id (unwrap~fixed key_id)))
        (wrap-gpointer (~f ~datalist ~key_id))))))
(export g_datalist_id_get_data)

;; extern void g_datalist_id_set_data_full(GData **datalist, GQuark key_id, 
;;     gpointer data, GDestroyNotify destroy_func);
(define g_datalist_id_set_data_full
  (let ((~f #f))
    (lambda (datalist key_id data destroy_func)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_datalist_id_set_data_full"
            ffi:void
            (list '* ffi:unsigned-int '* '*))))
      (let ((~datalist (unwrap~pointer datalist))
            (~key_id (unwrap~fixed key_id))
            (~data (unwrap-gpointer data))
            (~destroy_func
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               destroy_func)))
        (~f ~datalist ~key_id ~data ~destroy_func)))))
(export g_datalist_id_set_data_full)

;; typedef gpointer (*GDuplicateFunc)(gpointer data, gpointer user_data);
(define-fh-function/p GDuplicateFunc
  (quote *) (list (quote *) (quote *)))

;; extern gpointer g_datalist_id_dup_data(GData **datalist, GQuark key_id, 
;;     GDuplicateFunc dup_func, gpointer user_data);
(define g_datalist_id_dup_data
  (let ((~f #f))
    (lambda (datalist key_id dup_func user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_datalist_id_dup_data"
            '*
            (list '* ffi:unsigned-int '* '*))))
      (let ((~datalist (unwrap~pointer datalist))
            (~key_id (unwrap~fixed key_id))
            (~dup_func
              ((make-ftn-arg-unwrapper '* (list '* '*))
               dup_func))
            (~user_data (unwrap-gpointer user_data)))
        (wrap-gpointer
          (~f ~datalist ~key_id ~dup_func ~user_data))))))
(export g_datalist_id_dup_data)

;; extern gboolean g_datalist_id_replace_data(GData **datalist, GQuark key_id, 
;;     gpointer oldval, gpointer newval, GDestroyNotify destroy, GDestroyNotify
;;      *old_destroy);
(define g_datalist_id_replace_data
  (let ((~f #f))
    (lambda (datalist
             key_id
             oldval
             newval
             destroy
             old_destroy)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_datalist_id_replace_data"
            ffi:int
            (list '* ffi:unsigned-int '* '* '* '*))))
      (let ((~datalist (unwrap~pointer datalist))
            (~key_id (unwrap~fixed key_id))
            (~oldval (unwrap-gpointer oldval))
            (~newval (unwrap-gpointer newval))
            (~destroy
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               destroy))
            (~old_destroy (unwrap~pointer old_destroy)))
        (~f ~datalist
            ~key_id
            ~oldval
            ~newval
            ~destroy
            ~old_destroy)))))
(export g_datalist_id_replace_data)

;; extern gpointer g_datalist_id_remove_no_notify(GData **datalist, GQuark 
;;     key_id);
(define g_datalist_id_remove_no_notify
  (let ((~f #f))
    (lambda (datalist key_id)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_datalist_id_remove_no_notify"
            '*
            (list '* ffi:unsigned-int))))
      (let ((~datalist (unwrap~pointer datalist))
            (~key_id (unwrap~fixed key_id)))
        (wrap-gpointer (~f ~datalist ~key_id))))))
(export g_datalist_id_remove_no_notify)

;; extern void g_datalist_foreach(GData **datalist, GDataForeachFunc func, 
;;     gpointer user_data);
(define g_datalist_foreach
  (let ((~f #f))
    (lambda (datalist func user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_datalist_foreach"
            ffi:void
            (list '* '* '*))))
      (let ((~datalist (unwrap~pointer datalist))
            (~func ((make-ftn-arg-unwrapper
                      ffi:void
                      (list ffi:unsigned-int '* '*))
                    func))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~datalist ~func ~user_data)))))
(export g_datalist_foreach)

;; extern void g_datalist_set_flags(GData **datalist, guint flags);
(define g_datalist_set_flags
  (let ((~f #f))
    (lambda (datalist flags)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_datalist_set_flags"
            ffi:void
            (list '* ffi:unsigned-int))))
      (let ((~datalist (unwrap~pointer datalist))
            (~flags (unwrap~fixed flags)))
        (~f ~datalist ~flags)))))
(export g_datalist_set_flags)

;; extern void g_datalist_unset_flags(GData **datalist, guint flags);
(define g_datalist_unset_flags
  (let ((~f #f))
    (lambda (datalist flags)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_datalist_unset_flags"
            ffi:void
            (list '* ffi:unsigned-int))))
      (let ((~datalist (unwrap~pointer datalist))
            (~flags (unwrap~fixed flags)))
        (~f ~datalist ~flags)))))
(export g_datalist_unset_flags)

;; extern guint g_datalist_get_flags(GData **datalist);
(define g_datalist_get_flags
  (let ((~f #f))
    (lambda (datalist)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_datalist_get_flags"
            ffi:unsigned-int
            (list '*))))
      (let ((~datalist (unwrap~pointer datalist)))
        (~f ~datalist)))))
(export g_datalist_get_flags)

;; extern void g_dataset_destroy(gconstpointer dataset_location);
(define g_dataset_destroy
  (let ((~f #f))
    (lambda (dataset_location)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_dataset_destroy"
            ffi:void
            (list '*))))
      (let ((~dataset_location
              (unwrap-gconstpointer dataset_location)))
        (~f ~dataset_location)))))
(export g_dataset_destroy)

;; extern gpointer g_dataset_id_get_data(gconstpointer dataset_location, GQuark
;;      key_id);
(define g_dataset_id_get_data
  (let ((~f #f))
    (lambda (dataset_location key_id)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_dataset_id_get_data"
            '*
            (list '* ffi:unsigned-int))))
      (let ((~dataset_location
              (unwrap-gconstpointer dataset_location))
            (~key_id (unwrap~fixed key_id)))
        (wrap-gpointer (~f ~dataset_location ~key_id))))))
(export g_dataset_id_get_data)

;; extern gpointer g_datalist_get_data(GData **datalist, const gchar *key);
(define g_datalist_get_data
  (let ((~f #f))
    (lambda (datalist key)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_datalist_get_data"
            '*
            (list '* '*))))
      (let ((~datalist (unwrap~pointer datalist))
            (~key (unwrap~pointer key)))
        (wrap-gpointer (~f ~datalist ~key))))))
(export g_datalist_get_data)

;; extern void g_dataset_id_set_data_full(gconstpointer dataset_location, 
;;     GQuark key_id, gpointer data, GDestroyNotify destroy_func);
(define g_dataset_id_set_data_full
  (let ((~f #f))
    (lambda (dataset_location key_id data destroy_func)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_dataset_id_set_data_full"
            ffi:void
            (list '* ffi:unsigned-int '* '*))))
      (let ((~dataset_location
              (unwrap-gconstpointer dataset_location))
            (~key_id (unwrap~fixed key_id))
            (~data (unwrap-gpointer data))
            (~destroy_func
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               destroy_func)))
        (~f ~dataset_location
            ~key_id
            ~data
            ~destroy_func)))))
(export g_dataset_id_set_data_full)

;; extern gpointer g_dataset_id_remove_no_notify(gconstpointer dataset_location
;;     , GQuark key_id);
(define g_dataset_id_remove_no_notify
  (let ((~f #f))
    (lambda (dataset_location key_id)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_dataset_id_remove_no_notify"
            '*
            (list '* ffi:unsigned-int))))
      (let ((~dataset_location
              (unwrap-gconstpointer dataset_location))
            (~key_id (unwrap~fixed key_id)))
        (wrap-gpointer (~f ~dataset_location ~key_id))))))
(export g_dataset_id_remove_no_notify)

;; extern void g_dataset_foreach(gconstpointer dataset_location, 
;;     GDataForeachFunc func, gpointer user_data);
(define g_dataset_foreach
  (let ((~f #f))
    (lambda (dataset_location func user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_dataset_foreach"
            ffi:void
            (list '* '* '*))))
      (let ((~dataset_location
              (unwrap-gconstpointer dataset_location))
            (~func ((make-ftn-arg-unwrapper
                      ffi:void
                      (list ffi:unsigned-int '* '*))
                    func))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~dataset_location ~func ~user_data)))))
(export g_dataset_foreach)

;; typedef gint32 GTime;
(define GTime-desc int)
(export GTime-desc)
(define unwrap-GTime unwrap~fixed)
(define wrap-GTime identity)
(export GTime-desc unwrap-GTime wrap-GTime)

;; typedef guint16 GDateYear;
(define GDateYear-desc unsigned-short)
(export GDateYear-desc)
(define unwrap-GDateYear unwrap~fixed)
(define wrap-GDateYear identity)
(export GDateYear-desc unwrap-GDateYear wrap-GDateYear)

;; typedef guint8 GDateDay; /* day of the month */
(define GDateDay-desc unsigned-int)
(export GDateDay-desc)
(define unwrap-GDateDay unwrap~fixed)
(define wrap-GDateDay identity)
(export GDateDay-desc unwrap-GDateDay wrap-GDateDay)

;; typedef struct _GDate GDate;
(define GDate-desc void)
(define GDate*-desc (bs:pointer (delay GDate-desc)))
(export GDate*-desc)
(define-fh-pointer-type GDate* GDate*-desc)

;; typedef enum {
;;   G_DATE_DAY = 0,
;;   G_DATE_MONTH = 1,
;;   G_DATE_YEAR = 2,
;; } GDateDMY;
(define-fh-enum GDateDMY
  '((G_DATE_DAY . 0)
    (G_DATE_MONTH . 1)
    (G_DATE_YEAR . 2))
  )

;; typedef enum {
;;   G_DATE_BAD_WEEKDAY = 0,
;;   G_DATE_MONDAY = 1,
;;   G_DATE_TUESDAY = 2,
;;   G_DATE_WEDNESDAY = 3,
;;   G_DATE_THURSDAY = 4,
;;   G_DATE_FRIDAY = 5,
;;   G_DATE_SATURDAY = 6,
;;   G_DATE_SUNDAY = 7,
;; } GDateWeekday;
(define-fh-enum GDateWeekday
  '((G_DATE_BAD_WEEKDAY . 0)
    (G_DATE_MONDAY . 1)
    (G_DATE_TUESDAY . 2)
    (G_DATE_WEDNESDAY . 3)
    (G_DATE_THURSDAY . 4)
    (G_DATE_FRIDAY . 5)
    (G_DATE_SATURDAY . 6)
    (G_DATE_SUNDAY . 7))
  )

;; typedef enum {
;;   G_DATE_BAD_MONTH = 0,
;;   G_DATE_JANUARY = 1,
;;   G_DATE_FEBRUARY = 2,
;;   G_DATE_MARCH = 3,
;;   G_DATE_APRIL = 4,
;;   G_DATE_MAY = 5,
;;   G_DATE_JUNE = 6,
;;   G_DATE_JULY = 7,
;;   G_DATE_AUGUST = 8,
;;   G_DATE_SEPTEMBER = 9,
;;   G_DATE_OCTOBER = 10,
;;   G_DATE_NOVEMBER = 11,
;;   G_DATE_DECEMBER = 12,
;; } GDateMonth;
(define-fh-enum GDateMonth
  '((G_DATE_BAD_MONTH . 0)
    (G_DATE_JANUARY . 1)
    (G_DATE_FEBRUARY . 2)
    (G_DATE_MARCH . 3)
    (G_DATE_APRIL . 4)
    (G_DATE_MAY . 5)
    (G_DATE_JUNE . 6)
    (G_DATE_JULY . 7)
    (G_DATE_AUGUST . 8)
    (G_DATE_SEPTEMBER . 9)
    (G_DATE_OCTOBER . 10)
    (G_DATE_NOVEMBER . 11)
    (G_DATE_DECEMBER . 12))
  )

;; struct _GDate {
;;   guint julian_days : 32; /* julian days representation - we use a
;;    *  bitfield hoping that 64 bit platforms
;;    *  will pack this whole struct in one big
;;    *  int
;;    */
;;   guint julian : 1; /* julian is valid */
;;   guint dmy : 1; /* dmy is valid */
;;   /* DMY representation */
;;   guint day : 6;
;;   guint month : 4;
;;   guint year : 16;
;; };
(define struct-_GDate-desc
  (bs:struct
    (list `(julian_days ,unsigned-int ,32)
          `(julian ,unsigned-int ,1)
          `(dmy ,unsigned-int ,1)
          `(day ,unsigned-int ,6)
          `(month ,unsigned-int ,4)
          `(year ,unsigned-int ,16))))
(export struct-_GDate-desc)
(define-fh-compound-type/p struct-_GDate struct-_GDate-desc)
(set! GDate-desc struct-_GDate-desc)
(define-fh-compound-type GDate GDate-desc)

;; extern GDate *g_date_new(void);
(define g_date_new
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f (fh-link-proc "g_date_new" '* (list))))
      (let () (wrap-GDate* (~f))))))
(export g_date_new)

;; extern GDate *g_date_new_dmy(GDateDay day, GDateMonth month, GDateYear year)
;;     ;
(define g_date_new_dmy
  (let ((~f #f))
    (lambda (day month year)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_new_dmy"
            '*
            (list ffi:unsigned-int
                  ffi:int
                  ffi:unsigned-short))))
      (let ((~day (unwrap~fixed day))
            (~month (unwrap~fixed month))
            (~year (unwrap~fixed year)))
        (wrap-GDate* (~f ~day ~month ~year))))))
(export g_date_new_dmy)

;; extern GDate *g_date_new_julian(guint32 julian_day);
(define g_date_new_julian
  (let ((~f #f))
    (lambda (julian_day)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_new_julian"
            '*
            (list ffi:unsigned-int))))
      (let ((~julian_day (unwrap~fixed julian_day)))
        (wrap-GDate* (~f ~julian_day))))))
(export g_date_new_julian)

;; extern void g_date_free(GDate *date);
(define g_date_free
  (let ((~f #f))
    (lambda (date)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_date_free" ffi:void (list '*))))
      (let ((~date (unwrap-GDate* date))) (~f ~date)))))
(export g_date_free)

;; extern gboolean g_date_valid(const GDate *date);
(define g_date_valid
  (let ((~f #f))
    (lambda (date)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_date_valid" ffi:int (list '*))))
      (let ((~date (unwrap-GDate* date))) (~f ~date)))))
(export g_date_valid)

;; extern gboolean g_date_valid_day(GDateDay day);
(define g_date_valid_day
  (let ((~f #f))
    (lambda (day)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_valid_day"
            ffi:int
            (list ffi:unsigned-int))))
      (let ((~day (unwrap~fixed day))) (~f ~day)))))
(export g_date_valid_day)

;; extern gboolean g_date_valid_month(GDateMonth month);
(define g_date_valid_month
  (let ((~f #f))
    (lambda (month)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_valid_month"
            ffi:int
            (list ffi:int))))
      (let ((~month (unwrap~fixed month))) (~f ~month)))))
(export g_date_valid_month)

;; extern gboolean g_date_valid_year(GDateYear year);
(define g_date_valid_year
  (let ((~f #f))
    (lambda (year)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_valid_year"
            ffi:int
            (list ffi:unsigned-short))))
      (let ((~year (unwrap~fixed year))) (~f ~year)))))
(export g_date_valid_year)

;; extern gboolean g_date_valid_weekday(GDateWeekday weekday);
(define g_date_valid_weekday
  (let ((~f #f))
    (lambda (weekday)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_valid_weekday"
            ffi:int
            (list ffi:int))))
      (let ((~weekday (unwrap~fixed weekday)))
        (~f ~weekday)))))
(export g_date_valid_weekday)

;; extern gboolean g_date_valid_julian(guint32 julian_date);
(define g_date_valid_julian
  (let ((~f #f))
    (lambda (julian_date)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_valid_julian"
            ffi:int
            (list ffi:unsigned-int))))
      (let ((~julian_date (unwrap~fixed julian_date)))
        (~f ~julian_date)))))
(export g_date_valid_julian)

;; extern gboolean g_date_valid_dmy(GDateDay day, GDateMonth month, GDateYear 
;;     year);
(define g_date_valid_dmy
  (let ((~f #f))
    (lambda (day month year)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_valid_dmy"
            ffi:int
            (list ffi:unsigned-int
                  ffi:int
                  ffi:unsigned-short))))
      (let ((~day (unwrap~fixed day))
            (~month (unwrap~fixed month))
            (~year (unwrap~fixed year)))
        (~f ~day ~month ~year)))))
(export g_date_valid_dmy)

;; extern GDateWeekday g_date_get_weekday(const GDate *date);
(define g_date_get_weekday
  (let ((~f #f))
    (lambda (date)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_get_weekday"
            ffi:int
            (list '*))))
      (let ((~date (unwrap-GDate* date))) (~f ~date)))))
(export g_date_get_weekday)

;; extern GDateMonth g_date_get_month(const GDate *date);
(define g_date_get_month
  (let ((~f #f))
    (lambda (date)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_get_month"
            ffi:int
            (list '*))))
      (let ((~date (unwrap-GDate* date))) (~f ~date)))))
(export g_date_get_month)

;; extern GDateYear g_date_get_year(const GDate *date);
(define g_date_get_year
  (let ((~f #f))
    (lambda (date)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_get_year"
            ffi:unsigned-short
            (list '*))))
      (let ((~date (unwrap-GDate* date))) (~f ~date)))))
(export g_date_get_year)

;; extern GDateDay g_date_get_day(const GDate *date);
(define g_date_get_day
  (let ((~f #f))
    (lambda (date)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_get_day"
            ffi:unsigned-int
            (list '*))))
      (let ((~date (unwrap-GDate* date))) (~f ~date)))))
(export g_date_get_day)

;; extern guint32 g_date_get_julian(const GDate *date);
(define g_date_get_julian
  (let ((~f #f))
    (lambda (date)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_get_julian"
            ffi:unsigned-int
            (list '*))))
      (let ((~date (unwrap-GDate* date))) (~f ~date)))))
(export g_date_get_julian)

;; extern guint g_date_get_day_of_year(const GDate *date);
(define g_date_get_day_of_year
  (let ((~f #f))
    (lambda (date)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_get_day_of_year"
            ffi:unsigned-int
            (list '*))))
      (let ((~date (unwrap-GDate* date))) (~f ~date)))))
(export g_date_get_day_of_year)

;; extern guint g_date_get_monday_week_of_year(const GDate *date);
(define g_date_get_monday_week_of_year
  (let ((~f #f))
    (lambda (date)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_get_monday_week_of_year"
            ffi:unsigned-int
            (list '*))))
      (let ((~date (unwrap-GDate* date))) (~f ~date)))))
(export g_date_get_monday_week_of_year)

;; extern guint g_date_get_sunday_week_of_year(const GDate *date);
(define g_date_get_sunday_week_of_year
  (let ((~f #f))
    (lambda (date)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_get_sunday_week_of_year"
            ffi:unsigned-int
            (list '*))))
      (let ((~date (unwrap-GDate* date))) (~f ~date)))))
(export g_date_get_sunday_week_of_year)

;; extern guint g_date_get_iso8601_week_of_year(const GDate *date);
(define g_date_get_iso8601_week_of_year
  (let ((~f #f))
    (lambda (date)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_get_iso8601_week_of_year"
            ffi:unsigned-int
            (list '*))))
      (let ((~date (unwrap-GDate* date))) (~f ~date)))))
(export g_date_get_iso8601_week_of_year)

;; extern void g_date_clear(GDate *date, guint n_dates);
(define g_date_clear
  (let ((~f #f))
    (lambda (date n_dates)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_clear"
            ffi:void
            (list '* ffi:unsigned-int))))
      (let ((~date (unwrap-GDate* date))
            (~n_dates (unwrap~fixed n_dates)))
        (~f ~date ~n_dates)))))
(export g_date_clear)

;; extern void g_date_set_parse(GDate *date, const gchar *str);
(define g_date_set_parse
  (let ((~f #f))
    (lambda (date str)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_set_parse"
            ffi:void
            (list '* '*))))
      (let ((~date (unwrap-GDate* date))
            (~str (unwrap~pointer str)))
        (~f ~date ~str)))))
(export g_date_set_parse)

;; extern void g_date_set_time_t(GDate *date, time_t timet);
(define g_date_set_time_t
  (let ((~f #f))
    (lambda (date timet)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_set_time_t"
            ffi:void
            (list '* ffi:long))))
      (let ((~date (unwrap-GDate* date))
            (~timet (unwrap~fixed timet)))
        (~f ~date ~timet)))))
(export g_date_set_time_t)

;; extern void g_date_set_time_val(GDate *date, GTimeVal *timeval);
(define g_date_set_time_val
  (let ((~f #f))
    (lambda (date timeval)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_set_time_val"
            ffi:void
            (list '* '*))))
      (let ((~date (unwrap-GDate* date))
            (~timeval (unwrap-GTimeVal* timeval)))
        (~f ~date ~timeval)))))
(export g_date_set_time_val)

;; extern void g_date_set_time(GDate *date, GTime time_);
(define g_date_set_time
  (let ((~f #f))
    (lambda (date time_)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_set_time"
            ffi:void
            (list '* ffi:int))))
      (let ((~date (unwrap-GDate* date))
            (~time_ (unwrap~fixed time_)))
        (~f ~date ~time_)))))
(export g_date_set_time)

;; extern void g_date_set_month(GDate *date, GDateMonth month);
(define g_date_set_month
  (let ((~f #f))
    (lambda (date month)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_set_month"
            ffi:void
            (list '* ffi:int))))
      (let ((~date (unwrap-GDate* date))
            (~month (unwrap~fixed month)))
        (~f ~date ~month)))))
(export g_date_set_month)

;; extern void g_date_set_day(GDate *date, GDateDay day);
(define g_date_set_day
  (let ((~f #f))
    (lambda (date day)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_set_day"
            ffi:void
            (list '* ffi:unsigned-int))))
      (let ((~date (unwrap-GDate* date))
            (~day (unwrap~fixed day)))
        (~f ~date ~day)))))
(export g_date_set_day)

;; extern void g_date_set_year(GDate *date, GDateYear year);
(define g_date_set_year
  (let ((~f #f))
    (lambda (date year)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_set_year"
            ffi:void
            (list '* ffi:unsigned-short))))
      (let ((~date (unwrap-GDate* date))
            (~year (unwrap~fixed year)))
        (~f ~date ~year)))))
(export g_date_set_year)

;; extern void g_date_set_dmy(GDate *date, GDateDay day, GDateMonth month, 
;;     GDateYear y);
(define g_date_set_dmy
  (let ((~f #f))
    (lambda (date day month y)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_set_dmy"
            ffi:void
            (list '*
                  ffi:unsigned-int
                  ffi:int
                  ffi:unsigned-short))))
      (let ((~date (unwrap-GDate* date))
            (~day (unwrap~fixed day))
            (~month (unwrap~fixed month))
            (~y (unwrap~fixed y)))
        (~f ~date ~day ~month ~y)))))
(export g_date_set_dmy)

;; extern void g_date_set_julian(GDate *date, guint32 julian_date);
(define g_date_set_julian
  (let ((~f #f))
    (lambda (date julian_date)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_set_julian"
            ffi:void
            (list '* ffi:unsigned-int))))
      (let ((~date (unwrap-GDate* date))
            (~julian_date (unwrap~fixed julian_date)))
        (~f ~date ~julian_date)))))
(export g_date_set_julian)

;; extern gboolean g_date_is_first_of_month(const GDate *date);
(define g_date_is_first_of_month
  (let ((~f #f))
    (lambda (date)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_is_first_of_month"
            ffi:int
            (list '*))))
      (let ((~date (unwrap-GDate* date))) (~f ~date)))))
(export g_date_is_first_of_month)

;; extern gboolean g_date_is_last_of_month(const GDate *date);
(define g_date_is_last_of_month
  (let ((~f #f))
    (lambda (date)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_is_last_of_month"
            ffi:int
            (list '*))))
      (let ((~date (unwrap-GDate* date))) (~f ~date)))))
(export g_date_is_last_of_month)

;; extern void g_date_add_days(GDate *date, guint n_days);
(define g_date_add_days
  (let ((~f #f))
    (lambda (date n_days)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_add_days"
            ffi:void
            (list '* ffi:unsigned-int))))
      (let ((~date (unwrap-GDate* date))
            (~n_days (unwrap~fixed n_days)))
        (~f ~date ~n_days)))))
(export g_date_add_days)

;; extern void g_date_subtract_days(GDate *date, guint n_days);
(define g_date_subtract_days
  (let ((~f #f))
    (lambda (date n_days)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_subtract_days"
            ffi:void
            (list '* ffi:unsigned-int))))
      (let ((~date (unwrap-GDate* date))
            (~n_days (unwrap~fixed n_days)))
        (~f ~date ~n_days)))))
(export g_date_subtract_days)

;; extern void g_date_add_months(GDate *date, guint n_months);
(define g_date_add_months
  (let ((~f #f))
    (lambda (date n_months)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_add_months"
            ffi:void
            (list '* ffi:unsigned-int))))
      (let ((~date (unwrap-GDate* date))
            (~n_months (unwrap~fixed n_months)))
        (~f ~date ~n_months)))))
(export g_date_add_months)

;; extern void g_date_subtract_months(GDate *date, guint n_months);
(define g_date_subtract_months
  (let ((~f #f))
    (lambda (date n_months)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_subtract_months"
            ffi:void
            (list '* ffi:unsigned-int))))
      (let ((~date (unwrap-GDate* date))
            (~n_months (unwrap~fixed n_months)))
        (~f ~date ~n_months)))))
(export g_date_subtract_months)

;; extern void g_date_add_years(GDate *date, guint n_years);
(define g_date_add_years
  (let ((~f #f))
    (lambda (date n_years)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_add_years"
            ffi:void
            (list '* ffi:unsigned-int))))
      (let ((~date (unwrap-GDate* date))
            (~n_years (unwrap~fixed n_years)))
        (~f ~date ~n_years)))))
(export g_date_add_years)

;; extern void g_date_subtract_years(GDate *date, guint n_years);
(define g_date_subtract_years
  (let ((~f #f))
    (lambda (date n_years)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_subtract_years"
            ffi:void
            (list '* ffi:unsigned-int))))
      (let ((~date (unwrap-GDate* date))
            (~n_years (unwrap~fixed n_years)))
        (~f ~date ~n_years)))))
(export g_date_subtract_years)

;; extern gboolean g_date_is_leap_year(GDateYear year);
(define g_date_is_leap_year
  (let ((~f #f))
    (lambda (year)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_is_leap_year"
            ffi:int
            (list ffi:unsigned-short))))
      (let ((~year (unwrap~fixed year))) (~f ~year)))))
(export g_date_is_leap_year)

;; extern guint8 g_date_get_days_in_month(GDateMonth month, GDateYear year);
(define g_date_get_days_in_month
  (let ((~f #f))
    (lambda (month year)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_get_days_in_month"
            ffi:unsigned-int
            (list ffi:int ffi:unsigned-short))))
      (let ((~month (unwrap~fixed month))
            (~year (unwrap~fixed year)))
        (~f ~month ~year)))))
(export g_date_get_days_in_month)

;; extern guint8 g_date_get_monday_weeks_in_year(GDateYear year);
(define g_date_get_monday_weeks_in_year
  (let ((~f #f))
    (lambda (year)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_get_monday_weeks_in_year"
            ffi:unsigned-int
            (list ffi:unsigned-short))))
      (let ((~year (unwrap~fixed year))) (~f ~year)))))
(export g_date_get_monday_weeks_in_year)

;; extern guint8 g_date_get_sunday_weeks_in_year(GDateYear year);
(define g_date_get_sunday_weeks_in_year
  (let ((~f #f))
    (lambda (year)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_get_sunday_weeks_in_year"
            ffi:unsigned-int
            (list ffi:unsigned-short))))
      (let ((~year (unwrap~fixed year))) (~f ~year)))))
(export g_date_get_sunday_weeks_in_year)

;; extern gint g_date_days_between(const GDate *date1, const GDate *date2);
(define g_date_days_between
  (let ((~f #f))
    (lambda (date1 date2)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_days_between"
            ffi:int
            (list '* '*))))
      (let ((~date1 (unwrap-GDate* date1))
            (~date2 (unwrap-GDate* date2)))
        (~f ~date1 ~date2)))))
(export g_date_days_between)

;; extern gint g_date_compare(const GDate *lhs, const GDate *rhs);
(define g_date_compare
  (let ((~f #f))
    (lambda (lhs rhs)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_compare"
            ffi:int
            (list '* '*))))
      (let ((~lhs (unwrap-GDate* lhs))
            (~rhs (unwrap-GDate* rhs)))
        (~f ~lhs ~rhs)))))
(export g_date_compare)

;; extern void g_date_to_struct_tm(const GDate *date, struct tm *tm);
(define g_date_to_struct_tm
  (let ((~f #f))
    (lambda (date tm)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_to_struct_tm"
            ffi:void
            (list '* '*))))
      (let ((~date (unwrap-GDate* date))
            (~tm (unwrap~pointer tm)))
        (~f ~date ~tm)))))
(export g_date_to_struct_tm)

;; extern void g_date_clamp(GDate *date, const GDate *min_date, const GDate *
;;     max_date);
(define g_date_clamp
  (let ((~f #f))
    (lambda (date min_date max_date)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_clamp"
            ffi:void
            (list '* '* '*))))
      (let ((~date (unwrap-GDate* date))
            (~min_date (unwrap-GDate* min_date))
            (~max_date (unwrap-GDate* max_date)))
        (~f ~date ~min_date ~max_date)))))
(export g_date_clamp)

;; extern void g_date_order(GDate *date1, GDate *date2);
(define g_date_order
  (let ((~f #f))
    (lambda (date1 date2)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_order"
            ffi:void
            (list '* '*))))
      (let ((~date1 (unwrap-GDate* date1))
            (~date2 (unwrap-GDate* date2)))
        (~f ~date1 ~date2)))))
(export g_date_order)

;; extern gsize g_date_strftime(gchar *s, gsize slen, const gchar *format, 
;;     const GDate *date);
(define g_date_strftime
  (let ((~f #f))
    (lambda (s slen format date)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_strftime"
            ffi:unsigned-long
            (list '* ffi:unsigned-long '* '*))))
      (let ((~s (unwrap~pointer s))
            (~slen (unwrap~fixed slen))
            (~format (unwrap~pointer format))
            (~date (unwrap-GDate* date)))
        (~f ~s ~slen ~format ~date)))))
(export g_date_strftime)

;; typedef struct _GTimeZone GTimeZone;
(define GTimeZone-desc void)
(define GTimeZone*-desc (bs:pointer GTimeZone-desc))
(export GTimeZone*-desc)
(define-fh-pointer-type GTimeZone* GTimeZone*-desc)

;; typedef enum {
;;   G_TIME_TYPE_STANDARD,
;;   G_TIME_TYPE_DAYLIGHT,
;;   G_TIME_TYPE_UNIVERSAL,
;; } GTimeType;
(define-fh-enum GTimeType
  '((G_TIME_TYPE_STANDARD . 0)
    (G_TIME_TYPE_DAYLIGHT . 1)
    (G_TIME_TYPE_UNIVERSAL . 2))
  )

;; extern GTimeZone *g_time_zone_new(const gchar *identifier);
(define g_time_zone_new
  (let ((~f #f))
    (lambda (identifier)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_time_zone_new" '* (list '*))))
      (let ((~identifier (unwrap~pointer identifier)))
        (wrap-GTimeZone* (~f ~identifier))))))
(export g_time_zone_new)

;; extern GTimeZone *g_time_zone_new_utc(void);
(define g_time_zone_new_utc
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_time_zone_new_utc" '* (list))))
      (let () (wrap-GTimeZone* (~f))))))
(export g_time_zone_new_utc)

;; extern GTimeZone *g_time_zone_new_local(void);
(define g_time_zone_new_local
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_time_zone_new_local" '* (list))))
      (let () (wrap-GTimeZone* (~f))))))
(export g_time_zone_new_local)

;; extern GTimeZone *g_time_zone_ref(GTimeZone *tz);
(define g_time_zone_ref
  (let ((~f #f))
    (lambda (tz)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_time_zone_ref" '* (list '*))))
      (let ((~tz (unwrap-GTimeZone* tz)))
        (wrap-GTimeZone* (~f ~tz))))))
(export g_time_zone_ref)

;; extern void g_time_zone_unref(GTimeZone *tz);
(define g_time_zone_unref
  (let ((~f #f))
    (lambda (tz)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_time_zone_unref"
            ffi:void
            (list '*))))
      (let ((~tz (unwrap-GTimeZone* tz))) (~f ~tz)))))
(export g_time_zone_unref)

;; extern gint g_time_zone_find_interval(GTimeZone *tz, GTimeType type, gint64 
;;     time_);
(define g_time_zone_find_interval
  (let ((~f #f))
    (lambda (tz type time_)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_time_zone_find_interval"
            ffi:int
            (list '* ffi:int ffi:long))))
      (let ((~tz (unwrap-GTimeZone* tz))
            (~type (unwrap~fixed type))
            (~time_ (unwrap~fixed time_)))
        (~f ~tz ~type ~time_)))))
(export g_time_zone_find_interval)

;; extern gint g_time_zone_adjust_time(GTimeZone *tz, GTimeType type, gint64 *
;;     time_);
(define g_time_zone_adjust_time
  (let ((~f #f))
    (lambda (tz type time_)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_time_zone_adjust_time"
            ffi:int
            (list '* ffi:int '*))))
      (let ((~tz (unwrap-GTimeZone* tz))
            (~type (unwrap~fixed type))
            (~time_ (unwrap~pointer time_)))
        (~f ~tz ~type ~time_)))))
(export g_time_zone_adjust_time)

;; extern const gchar *g_time_zone_get_abbreviation(GTimeZone *tz, gint 
;;     interval);
(define g_time_zone_get_abbreviation
  (let ((~f #f))
    (lambda (tz interval)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_time_zone_get_abbreviation"
            '*
            (list '* ffi:int))))
      (let ((~tz (unwrap-GTimeZone* tz))
            (~interval (unwrap~fixed interval)))
        (~f ~tz ~interval)))))
(export g_time_zone_get_abbreviation)

;; extern gint32 g_time_zone_get_offset(GTimeZone *tz, gint interval);
(define g_time_zone_get_offset
  (let ((~f #f))
    (lambda (tz interval)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_time_zone_get_offset"
            ffi:int
            (list '* ffi:int))))
      (let ((~tz (unwrap-GTimeZone* tz))
            (~interval (unwrap~fixed interval)))
        (~f ~tz ~interval)))))
(export g_time_zone_get_offset)

;; extern gboolean g_time_zone_is_dst(GTimeZone *tz, gint interval);
(define g_time_zone_is_dst
  (let ((~f #f))
    (lambda (tz interval)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_time_zone_is_dst"
            ffi:int
            (list '* ffi:int))))
      (let ((~tz (unwrap-GTimeZone* tz))
            (~interval (unwrap~fixed interval)))
        (~f ~tz ~interval)))))
(export g_time_zone_is_dst)

;; typedef gint64 GTimeSpan;
(define GTimeSpan-desc long)
(export GTimeSpan-desc)
(define unwrap-GTimeSpan unwrap~fixed)
(define wrap-GTimeSpan identity)
(export GTimeSpan-desc unwrap-GTimeSpan wrap-GTimeSpan)

;; typedef struct _GDateTime GDateTime;
(define GDateTime-desc void)
(define GDateTime*-desc (bs:pointer GDateTime-desc))
(export GDateTime*-desc)
(define-fh-pointer-type GDateTime* GDateTime*-desc)

;; extern void g_date_time_unref(GDateTime *datetime);
(define g_date_time_unref
  (let ((~f #f))
    (lambda (datetime)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_unref"
            ffi:void
            (list '*))))
      (let ((~datetime (unwrap-GDateTime* datetime)))
        (~f ~datetime)))))
(export g_date_time_unref)

;; extern GDateTime *g_date_time_ref(GDateTime *datetime);
(define g_date_time_ref
  (let ((~f #f))
    (lambda (datetime)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_date_time_ref" '* (list '*))))
      (let ((~datetime (unwrap-GDateTime* datetime)))
        (wrap-GDateTime* (~f ~datetime))))))
(export g_date_time_ref)

;; extern GDateTime *g_date_time_new_now(GTimeZone *tz);
(define g_date_time_new_now
  (let ((~f #f))
    (lambda (tz)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_date_time_new_now" '* (list '*))))
      (let ((~tz (unwrap-GTimeZone* tz)))
        (wrap-GDateTime* (~f ~tz))))))
(export g_date_time_new_now)

;; extern GDateTime *g_date_time_new_now_local(void);
(define g_date_time_new_now_local
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_new_now_local"
            '*
            (list))))
      (let () (wrap-GDateTime* (~f))))))
(export g_date_time_new_now_local)

;; extern GDateTime *g_date_time_new_now_utc(void);
(define g_date_time_new_now_utc
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_new_now_utc"
            '*
            (list))))
      (let () (wrap-GDateTime* (~f))))))
(export g_date_time_new_now_utc)

;; extern GDateTime *g_date_time_new_from_unix_local(gint64 t);
(define g_date_time_new_from_unix_local
  (let ((~f #f))
    (lambda (t)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_new_from_unix_local"
            '*
            (list ffi:long))))
      (let ((~t (unwrap~fixed t)))
        (wrap-GDateTime* (~f ~t))))))
(export g_date_time_new_from_unix_local)

;; extern GDateTime *g_date_time_new_from_unix_utc(gint64 t);
(define g_date_time_new_from_unix_utc
  (let ((~f #f))
    (lambda (t)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_new_from_unix_utc"
            '*
            (list ffi:long))))
      (let ((~t (unwrap~fixed t)))
        (wrap-GDateTime* (~f ~t))))))
(export g_date_time_new_from_unix_utc)

;; extern GDateTime *g_date_time_new_from_timeval_local(const GTimeVal *tv);
(define g_date_time_new_from_timeval_local
  (let ((~f #f))
    (lambda (tv)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_new_from_timeval_local"
            '*
            (list '*))))
      (let ((~tv (unwrap-GTimeVal* tv)))
        (wrap-GDateTime* (~f ~tv))))))
(export g_date_time_new_from_timeval_local)

;; extern GDateTime *g_date_time_new_from_timeval_utc(const GTimeVal *tv);
(define g_date_time_new_from_timeval_utc
  (let ((~f #f))
    (lambda (tv)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_new_from_timeval_utc"
            '*
            (list '*))))
      (let ((~tv (unwrap-GTimeVal* tv)))
        (wrap-GDateTime* (~f ~tv))))))
(export g_date_time_new_from_timeval_utc)

;; extern GDateTime *g_date_time_new(GTimeZone *tz, gint year, gint month, gint
;;      day, gint hour, gint minute, gdouble seconds);
(define g_date_time_new
  (let ((~f #f))
    (lambda (tz year month day hour minute seconds)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_new"
            '*
            (list '*
                  ffi:int
                  ffi:int
                  ffi:int
                  ffi:int
                  ffi:int
                  ffi:double))))
      (let ((~tz (unwrap-GTimeZone* tz))
            (~year (unwrap~fixed year))
            (~month (unwrap~fixed month))
            (~day (unwrap~fixed day))
            (~hour (unwrap~fixed hour))
            (~minute (unwrap~fixed minute))
            (~seconds (unwrap-gdouble seconds)))
        (wrap-GDateTime*
          (~f ~tz ~year ~month ~day ~hour ~minute ~seconds))))))
(export g_date_time_new)

;; extern GDateTime *g_date_time_new_local(gint year, gint month, gint day, 
;;     gint hour, gint minute, gdouble seconds);
(define g_date_time_new_local
  (let ((~f #f))
    (lambda (year month day hour minute seconds)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_new_local"
            '*
            (list ffi:int
                  ffi:int
                  ffi:int
                  ffi:int
                  ffi:int
                  ffi:double))))
      (let ((~year (unwrap~fixed year))
            (~month (unwrap~fixed month))
            (~day (unwrap~fixed day))
            (~hour (unwrap~fixed hour))
            (~minute (unwrap~fixed minute))
            (~seconds (unwrap-gdouble seconds)))
        (wrap-GDateTime*
          (~f ~year ~month ~day ~hour ~minute ~seconds))))))
(export g_date_time_new_local)

;; extern GDateTime *g_date_time_new_utc(gint year, gint month, gint day, gint 
;;     hour, gint minute, gdouble seconds);
(define g_date_time_new_utc
  (let ((~f #f))
    (lambda (year month day hour minute seconds)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_new_utc"
            '*
            (list ffi:int
                  ffi:int
                  ffi:int
                  ffi:int
                  ffi:int
                  ffi:double))))
      (let ((~year (unwrap~fixed year))
            (~month (unwrap~fixed month))
            (~day (unwrap~fixed day))
            (~hour (unwrap~fixed hour))
            (~minute (unwrap~fixed minute))
            (~seconds (unwrap-gdouble seconds)))
        (wrap-GDateTime*
          (~f ~year ~month ~day ~hour ~minute ~seconds))))))
(export g_date_time_new_utc)

;; extern GDateTime *g_date_time_add(GDateTime *datetime, GTimeSpan timespan);
(define g_date_time_add
  (let ((~f #f))
    (lambda (datetime timespan)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_add"
            '*
            (list '* ffi:long))))
      (let ((~datetime (unwrap-GDateTime* datetime))
            (~timespan (unwrap~fixed timespan)))
        (wrap-GDateTime* (~f ~datetime ~timespan))))))
(export g_date_time_add)

;; extern GDateTime *g_date_time_add_years(GDateTime *datetime, gint years);
(define g_date_time_add_years
  (let ((~f #f))
    (lambda (datetime years)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_add_years"
            '*
            (list '* ffi:int))))
      (let ((~datetime (unwrap-GDateTime* datetime))
            (~years (unwrap~fixed years)))
        (wrap-GDateTime* (~f ~datetime ~years))))))
(export g_date_time_add_years)

;; extern GDateTime *g_date_time_add_months(GDateTime *datetime, gint months);
(define g_date_time_add_months
  (let ((~f #f))
    (lambda (datetime months)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_add_months"
            '*
            (list '* ffi:int))))
      (let ((~datetime (unwrap-GDateTime* datetime))
            (~months (unwrap~fixed months)))
        (wrap-GDateTime* (~f ~datetime ~months))))))
(export g_date_time_add_months)

;; extern GDateTime *g_date_time_add_weeks(GDateTime *datetime, gint weeks);
(define g_date_time_add_weeks
  (let ((~f #f))
    (lambda (datetime weeks)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_add_weeks"
            '*
            (list '* ffi:int))))
      (let ((~datetime (unwrap-GDateTime* datetime))
            (~weeks (unwrap~fixed weeks)))
        (wrap-GDateTime* (~f ~datetime ~weeks))))))
(export g_date_time_add_weeks)

;; extern GDateTime *g_date_time_add_days(GDateTime *datetime, gint days);
(define g_date_time_add_days
  (let ((~f #f))
    (lambda (datetime days)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_add_days"
            '*
            (list '* ffi:int))))
      (let ((~datetime (unwrap-GDateTime* datetime))
            (~days (unwrap~fixed days)))
        (wrap-GDateTime* (~f ~datetime ~days))))))
(export g_date_time_add_days)

;; extern GDateTime *g_date_time_add_hours(GDateTime *datetime, gint hours);
(define g_date_time_add_hours
  (let ((~f #f))
    (lambda (datetime hours)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_add_hours"
            '*
            (list '* ffi:int))))
      (let ((~datetime (unwrap-GDateTime* datetime))
            (~hours (unwrap~fixed hours)))
        (wrap-GDateTime* (~f ~datetime ~hours))))))
(export g_date_time_add_hours)

;; extern GDateTime *g_date_time_add_minutes(GDateTime *datetime, gint minutes)
;;     ;
(define g_date_time_add_minutes
  (let ((~f #f))
    (lambda (datetime minutes)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_add_minutes"
            '*
            (list '* ffi:int))))
      (let ((~datetime (unwrap-GDateTime* datetime))
            (~minutes (unwrap~fixed minutes)))
        (wrap-GDateTime* (~f ~datetime ~minutes))))))
(export g_date_time_add_minutes)

;; extern GDateTime *g_date_time_add_seconds(GDateTime *datetime, gdouble 
;;     seconds);
(define g_date_time_add_seconds
  (let ((~f #f))
    (lambda (datetime seconds)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_add_seconds"
            '*
            (list '* ffi:double))))
      (let ((~datetime (unwrap-GDateTime* datetime))
            (~seconds (unwrap-gdouble seconds)))
        (wrap-GDateTime* (~f ~datetime ~seconds))))))
(export g_date_time_add_seconds)

;; extern GDateTime *g_date_time_add_full(GDateTime *datetime, gint years, gint
;;      months, gint days, gint hours, gint minutes, gdouble seconds);
(define g_date_time_add_full
  (let ((~f #f))
    (lambda (datetime
             years
             months
             days
             hours
             minutes
             seconds)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_add_full"
            '*
            (list '*
                  ffi:int
                  ffi:int
                  ffi:int
                  ffi:int
                  ffi:int
                  ffi:double))))
      (let ((~datetime (unwrap-GDateTime* datetime))
            (~years (unwrap~fixed years))
            (~months (unwrap~fixed months))
            (~days (unwrap~fixed days))
            (~hours (unwrap~fixed hours))
            (~minutes (unwrap~fixed minutes))
            (~seconds (unwrap-gdouble seconds)))
        (wrap-GDateTime*
          (~f ~datetime
              ~years
              ~months
              ~days
              ~hours
              ~minutes
              ~seconds))))))
(export g_date_time_add_full)

;; extern gint g_date_time_compare(gconstpointer dt1, gconstpointer dt2);
(define g_date_time_compare
  (let ((~f #f))
    (lambda (dt1 dt2)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_compare"
            ffi:int
            (list '* '*))))
      (let ((~dt1 (unwrap-gconstpointer dt1))
            (~dt2 (unwrap-gconstpointer dt2)))
        (~f ~dt1 ~dt2)))))
(export g_date_time_compare)

;; extern GTimeSpan g_date_time_difference(GDateTime *end, GDateTime *begin);
(define g_date_time_difference
  (let ((~f #f))
    (lambda (end begin)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_difference"
            ffi:long
            (list '* '*))))
      (let ((~end (unwrap-GDateTime* end))
            (~begin (unwrap-GDateTime* begin)))
        (~f ~end ~begin)))))
(export g_date_time_difference)

;; extern guint g_date_time_hash(gconstpointer datetime);
(define g_date_time_hash
  (let ((~f #f))
    (lambda (datetime)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_hash"
            ffi:unsigned-int
            (list '*))))
      (let ((~datetime (unwrap-gconstpointer datetime)))
        (~f ~datetime)))))
(export g_date_time_hash)

;; extern gboolean g_date_time_equal(gconstpointer dt1, gconstpointer dt2);
(define g_date_time_equal
  (let ((~f #f))
    (lambda (dt1 dt2)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_equal"
            ffi:int
            (list '* '*))))
      (let ((~dt1 (unwrap-gconstpointer dt1))
            (~dt2 (unwrap-gconstpointer dt2)))
        (~f ~dt1 ~dt2)))))
(export g_date_time_equal)

;; extern void g_date_time_get_ymd(GDateTime *datetime, gint *year, gint *month
;;     , gint *day);
(define g_date_time_get_ymd
  (let ((~f #f))
    (lambda (datetime year month day)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_get_ymd"
            ffi:void
            (list '* '* '* '*))))
      (let ((~datetime (unwrap-GDateTime* datetime))
            (~year (unwrap~pointer year))
            (~month (unwrap~pointer month))
            (~day (unwrap~pointer day)))
        (~f ~datetime ~year ~month ~day)))))
(export g_date_time_get_ymd)

;; extern gint g_date_time_get_year(GDateTime *datetime);
(define g_date_time_get_year
  (let ((~f #f))
    (lambda (datetime)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_get_year"
            ffi:int
            (list '*))))
      (let ((~datetime (unwrap-GDateTime* datetime)))
        (~f ~datetime)))))
(export g_date_time_get_year)

;; extern gint g_date_time_get_month(GDateTime *datetime);
(define g_date_time_get_month
  (let ((~f #f))
    (lambda (datetime)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_get_month"
            ffi:int
            (list '*))))
      (let ((~datetime (unwrap-GDateTime* datetime)))
        (~f ~datetime)))))
(export g_date_time_get_month)

;; extern gint g_date_time_get_day_of_month(GDateTime *datetime);
(define g_date_time_get_day_of_month
  (let ((~f #f))
    (lambda (datetime)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_get_day_of_month"
            ffi:int
            (list '*))))
      (let ((~datetime (unwrap-GDateTime* datetime)))
        (~f ~datetime)))))
(export g_date_time_get_day_of_month)

;; extern gint g_date_time_get_week_numbering_year(GDateTime *datetime);
(define g_date_time_get_week_numbering_year
  (let ((~f #f))
    (lambda (datetime)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_get_week_numbering_year"
            ffi:int
            (list '*))))
      (let ((~datetime (unwrap-GDateTime* datetime)))
        (~f ~datetime)))))
(export g_date_time_get_week_numbering_year)

;; extern gint g_date_time_get_week_of_year(GDateTime *datetime);
(define g_date_time_get_week_of_year
  (let ((~f #f))
    (lambda (datetime)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_get_week_of_year"
            ffi:int
            (list '*))))
      (let ((~datetime (unwrap-GDateTime* datetime)))
        (~f ~datetime)))))
(export g_date_time_get_week_of_year)

;; extern gint g_date_time_get_day_of_week(GDateTime *datetime);
(define g_date_time_get_day_of_week
  (let ((~f #f))
    (lambda (datetime)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_get_day_of_week"
            ffi:int
            (list '*))))
      (let ((~datetime (unwrap-GDateTime* datetime)))
        (~f ~datetime)))))
(export g_date_time_get_day_of_week)

;; extern gint g_date_time_get_day_of_year(GDateTime *datetime);
(define g_date_time_get_day_of_year
  (let ((~f #f))
    (lambda (datetime)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_get_day_of_year"
            ffi:int
            (list '*))))
      (let ((~datetime (unwrap-GDateTime* datetime)))
        (~f ~datetime)))))
(export g_date_time_get_day_of_year)

;; extern gint g_date_time_get_hour(GDateTime *datetime);
(define g_date_time_get_hour
  (let ((~f #f))
    (lambda (datetime)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_get_hour"
            ffi:int
            (list '*))))
      (let ((~datetime (unwrap-GDateTime* datetime)))
        (~f ~datetime)))))
(export g_date_time_get_hour)

;; extern gint g_date_time_get_minute(GDateTime *datetime);
(define g_date_time_get_minute
  (let ((~f #f))
    (lambda (datetime)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_get_minute"
            ffi:int
            (list '*))))
      (let ((~datetime (unwrap-GDateTime* datetime)))
        (~f ~datetime)))))
(export g_date_time_get_minute)

;; extern gint g_date_time_get_second(GDateTime *datetime);
(define g_date_time_get_second
  (let ((~f #f))
    (lambda (datetime)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_get_second"
            ffi:int
            (list '*))))
      (let ((~datetime (unwrap-GDateTime* datetime)))
        (~f ~datetime)))))
(export g_date_time_get_second)

;; extern gint g_date_time_get_microsecond(GDateTime *datetime);
(define g_date_time_get_microsecond
  (let ((~f #f))
    (lambda (datetime)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_get_microsecond"
            ffi:int
            (list '*))))
      (let ((~datetime (unwrap-GDateTime* datetime)))
        (~f ~datetime)))))
(export g_date_time_get_microsecond)

;; extern gdouble g_date_time_get_seconds(GDateTime *datetime);
(define g_date_time_get_seconds
  (let ((~f #f))
    (lambda (datetime)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_get_seconds"
            ffi:double
            (list '*))))
      (let ((~datetime (unwrap-GDateTime* datetime)))
        (wrap-gdouble (~f ~datetime))))))
(export g_date_time_get_seconds)

;; extern gint64 g_date_time_to_unix(GDateTime *datetime);
(define g_date_time_to_unix
  (let ((~f #f))
    (lambda (datetime)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_to_unix"
            ffi:long
            (list '*))))
      (let ((~datetime (unwrap-GDateTime* datetime)))
        (~f ~datetime)))))
(export g_date_time_to_unix)

;; extern gboolean g_date_time_to_timeval(GDateTime *datetime, GTimeVal *tv);
(define g_date_time_to_timeval
  (let ((~f #f))
    (lambda (datetime tv)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_to_timeval"
            ffi:int
            (list '* '*))))
      (let ((~datetime (unwrap-GDateTime* datetime))
            (~tv (unwrap-GTimeVal* tv)))
        (~f ~datetime ~tv)))))
(export g_date_time_to_timeval)

;; extern GTimeSpan g_date_time_get_utc_offset(GDateTime *datetime);
(define g_date_time_get_utc_offset
  (let ((~f #f))
    (lambda (datetime)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_get_utc_offset"
            ffi:long
            (list '*))))
      (let ((~datetime (unwrap-GDateTime* datetime)))
        (~f ~datetime)))))
(export g_date_time_get_utc_offset)

;; extern const gchar *g_date_time_get_timezone_abbreviation(GDateTime *
;;     datetime);
(define g_date_time_get_timezone_abbreviation
  (let ((~f #f))
    (lambda (datetime)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_get_timezone_abbreviation"
            '*
            (list '*))))
      (let ((~datetime (unwrap-GDateTime* datetime)))
        (~f ~datetime)))))
(export g_date_time_get_timezone_abbreviation)

;; extern gboolean g_date_time_is_daylight_savings(GDateTime *datetime);
(define g_date_time_is_daylight_savings
  (let ((~f #f))
    (lambda (datetime)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_is_daylight_savings"
            ffi:int
            (list '*))))
      (let ((~datetime (unwrap-GDateTime* datetime)))
        (~f ~datetime)))))
(export g_date_time_is_daylight_savings)

;; extern GDateTime *g_date_time_to_timezone(GDateTime *datetime, GTimeZone *tz
;;     );
(define g_date_time_to_timezone
  (let ((~f #f))
    (lambda (datetime tz)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_to_timezone"
            '*
            (list '* '*))))
      (let ((~datetime (unwrap-GDateTime* datetime))
            (~tz (unwrap-GTimeZone* tz)))
        (wrap-GDateTime* (~f ~datetime ~tz))))))
(export g_date_time_to_timezone)

;; extern GDateTime *g_date_time_to_local(GDateTime *datetime);
(define g_date_time_to_local
  (let ((~f #f))
    (lambda (datetime)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_to_local"
            '*
            (list '*))))
      (let ((~datetime (unwrap-GDateTime* datetime)))
        (wrap-GDateTime* (~f ~datetime))))))
(export g_date_time_to_local)

;; extern GDateTime *g_date_time_to_utc(GDateTime *datetime);
(define g_date_time_to_utc
  (let ((~f #f))
    (lambda (datetime)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_date_time_to_utc" '* (list '*))))
      (let ((~datetime (unwrap-GDateTime* datetime)))
        (wrap-GDateTime* (~f ~datetime))))))
(export g_date_time_to_utc)

;; extern gchar *g_date_time_format(GDateTime *datetime, const gchar *format);
(define g_date_time_format
  (let ((~f #f))
    (lambda (datetime format)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_date_time_format"
            '*
            (list '* '*))))
      (let ((~datetime (unwrap-GDateTime* datetime))
            (~format (unwrap~pointer format)))
        (~f ~datetime ~format)))))
(export g_date_time_format)

;; typedef struct _GDir GDir;
(define GDir-desc void)
(define GDir*-desc (bs:pointer GDir-desc))
(export GDir*-desc)
(define-fh-pointer-type GDir* GDir*-desc)

;; extern GDir *g_dir_open(const gchar *path, guint flags, GError **error);
(define g_dir_open
  (let ((~f #f))
    (lambda (path flags error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_dir_open"
            '*
            (list '* ffi:unsigned-int '*))))
      (let ((~path (unwrap~pointer path))
            (~flags (unwrap~fixed flags))
            (~error (unwrap~pointer error)))
        (wrap-GDir* (~f ~path ~flags ~error))))))
(export g_dir_open)

;; extern const gchar *g_dir_read_name(GDir *dir);
(define g_dir_read_name
  (let ((~f #f))
    (lambda (dir)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_dir_read_name" '* (list '*))))
      (let ((~dir (unwrap-GDir* dir))) (~f ~dir)))))
(export g_dir_read_name)

;; extern void g_dir_rewind(GDir *dir);
(define g_dir_rewind
  (let ((~f #f))
    (lambda (dir)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_dir_rewind" ffi:void (list '*))))
      (let ((~dir (unwrap-GDir* dir))) (~f ~dir)))))
(export g_dir_rewind)

;; extern void g_dir_close(GDir *dir);
(define g_dir_close
  (let ((~f #f))
    (lambda (dir)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_dir_close" ffi:void (list '*))))
      (let ((~dir (unwrap-GDir* dir))) (~f ~dir)))))
(export g_dir_close)

;; extern const gchar *g_getenv(const gchar *variable);
(define g_getenv
  (let ((~f #f))
    (lambda (variable)
      (if (not ~f)
        (set! ~f (fh-link-proc "g_getenv" '* (list '*))))
      (let ((~variable (unwrap~pointer variable)))
        (~f ~variable)))))
(export g_getenv)

;; extern gboolean g_setenv(const gchar *variable, const gchar *value, gboolean
;;      overwrite);
(define g_setenv
  (let ((~f #f))
    (lambda (variable value overwrite)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_setenv"
            ffi:int
            (list '* '* ffi:int))))
      (let ((~variable (unwrap~pointer variable))
            (~value (unwrap~pointer value))
            (~overwrite (unwrap~fixed overwrite)))
        (~f ~variable ~value ~overwrite)))))
(export g_setenv)

;; extern void g_unsetenv(const gchar *variable);
(define g_unsetenv
  (let ((~f #f))
    (lambda (variable)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_unsetenv" ffi:void (list '*))))
      (let ((~variable (unwrap~pointer variable)))
        (~f ~variable)))))
(export g_unsetenv)

;; extern gchar **g_listenv(void);
(define g_listenv
  (let* ((addr (dynamic-pointer "g_listenv" (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer (bs:pointer void)))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_listenv)

;; extern gchar **g_get_environ(void);
(define g_get_environ
  (let* ((addr (dynamic-pointer "g_get_environ" (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer (bs:pointer void)))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_get_environ)

;; extern const gchar *g_environ_getenv(gchar **envp, const gchar *variable);
(define g_environ_getenv
  (let ((~f #f))
    (lambda (envp variable)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_environ_getenv" '* (list '* '*))))
      (let ((~envp (unwrap~pointer envp))
            (~variable (unwrap~pointer variable)))
        (~f ~envp ~variable)))))
(export g_environ_getenv)

;; extern gchar **g_environ_setenv(gchar **envp, const gchar *variable, const 
;;     gchar *value, gboolean overwrite);
(define g_environ_setenv
  (let* ((addr (dynamic-pointer
                 "g_environ_setenv"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer (bs:pointer void)))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_environ_setenv)

;; extern gchar **g_environ_unsetenv(gchar **envp, const gchar *variable);
(define g_environ_unsetenv
  (let* ((addr (dynamic-pointer
                 "g_environ_unsetenv"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer (bs:pointer void)))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_environ_unsetenv)

;; typedef enum {
;;   G_FILE_ERROR_EXIST,
;;   G_FILE_ERROR_ISDIR,
;;   G_FILE_ERROR_ACCES,
;;   G_FILE_ERROR_NAMETOOLONG,
;;   G_FILE_ERROR_NOENT,
;;   G_FILE_ERROR_NOTDIR,
;;   G_FILE_ERROR_NXIO,
;;   G_FILE_ERROR_NODEV,
;;   G_FILE_ERROR_ROFS,
;;   G_FILE_ERROR_TXTBSY,
;;   G_FILE_ERROR_FAULT,
;;   G_FILE_ERROR_LOOP,
;;   G_FILE_ERROR_NOSPC,
;;   G_FILE_ERROR_NOMEM,
;;   G_FILE_ERROR_MFILE,
;;   G_FILE_ERROR_NFILE,
;;   G_FILE_ERROR_BADF,
;;   G_FILE_ERROR_INVAL,
;;   G_FILE_ERROR_PIPE,
;;   G_FILE_ERROR_AGAIN,
;;   G_FILE_ERROR_INTR,
;;   G_FILE_ERROR_IO,
;;   G_FILE_ERROR_PERM,
;;   G_FILE_ERROR_NOSYS,
;;   G_FILE_ERROR_FAILED,
;; } GFileError;
(define-fh-enum GFileError
  '((G_FILE_ERROR_EXIST . 0)
    (G_FILE_ERROR_ISDIR . 1)
    (G_FILE_ERROR_ACCES . 2)
    (G_FILE_ERROR_NAMETOOLONG . 3)
    (G_FILE_ERROR_NOENT . 4)
    (G_FILE_ERROR_NOTDIR . 5)
    (G_FILE_ERROR_NXIO . 6)
    (G_FILE_ERROR_NODEV . 7)
    (G_FILE_ERROR_ROFS . 8)
    (G_FILE_ERROR_TXTBSY . 9)
    (G_FILE_ERROR_FAULT . 10)
    (G_FILE_ERROR_LOOP . 11)
    (G_FILE_ERROR_NOSPC . 12)
    (G_FILE_ERROR_NOMEM . 13)
    (G_FILE_ERROR_MFILE . 14)
    (G_FILE_ERROR_NFILE . 15)
    (G_FILE_ERROR_BADF . 16)
    (G_FILE_ERROR_INVAL . 17)
    (G_FILE_ERROR_PIPE . 18)
    (G_FILE_ERROR_AGAIN . 19)
    (G_FILE_ERROR_INTR . 20)
    (G_FILE_ERROR_IO . 21)
    (G_FILE_ERROR_PERM . 22)
    (G_FILE_ERROR_NOSYS . 23)
    (G_FILE_ERROR_FAILED . 24))
  )

;; typedef enum {
;;   G_FILE_TEST_IS_REGULAR = 1<<0,
;;   G_FILE_TEST_IS_SYMLINK = 1<<1,
;;   G_FILE_TEST_IS_DIR = 1<<2,
;;   G_FILE_TEST_IS_EXECUTABLE = 1<<3,
;;   G_FILE_TEST_EXISTS = 1<<4,
;; } GFileTest;
(define-fh-enum GFileTest
  '((G_FILE_TEST_IS_REGULAR . 1)
    (G_FILE_TEST_IS_SYMLINK . 2)
    (G_FILE_TEST_IS_DIR . 4)
    (G_FILE_TEST_IS_EXECUTABLE . 8)
    (G_FILE_TEST_EXISTS . 16))
  )

;; extern GQuark g_file_error_quark(void);
(define g_file_error_quark
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_file_error_quark"
            ffi:unsigned-int
            (list))))
      (let () (~f)))))
(export g_file_error_quark)

;; extern GFileError g_file_error_from_errno(gint err_no);
(define g_file_error_from_errno
  (let ((~f #f))
    (lambda (err_no)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_file_error_from_errno"
            ffi:int
            (list ffi:int))))
      (let ((~err_no (unwrap~fixed err_no)))
        (~f ~err_no)))))
(export g_file_error_from_errno)

;; extern gboolean g_file_test(const gchar *filename, GFileTest test);
(define g_file_test
  (let ((~f #f))
    (lambda (filename test)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_file_test"
            ffi:int
            (list '* ffi:int))))
      (let ((~filename (unwrap~pointer filename))
            (~test (unwrap~fixed test)))
        (~f ~filename ~test)))))
(export g_file_test)

;; extern gboolean g_file_get_contents(const gchar *filename, gchar **contents
;;     , gsize *length, GError **error);
(define g_file_get_contents
  (let ((~f #f))
    (lambda (filename contents length error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_file_get_contents"
            ffi:int
            (list '* '* '* '*))))
      (let ((~filename (unwrap~pointer filename))
            (~contents (unwrap~pointer contents))
            (~length (unwrap~pointer length))
            (~error (unwrap~pointer error)))
        (~f ~filename ~contents ~length ~error)))))
(export g_file_get_contents)

;; extern gboolean g_file_set_contents(const gchar *filename, const gchar *
;;     contents, gssize length, GError **error);
(define g_file_set_contents
  (let ((~f #f))
    (lambda (filename contents length error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_file_set_contents"
            ffi:int
            (list '* '* ffi:long '*))))
      (let ((~filename (unwrap~pointer filename))
            (~contents (unwrap~pointer contents))
            (~length (unwrap~fixed length))
            (~error (unwrap~pointer error)))
        (~f ~filename ~contents ~length ~error)))))
(export g_file_set_contents)

;; extern gchar *g_file_read_link(const gchar *filename, GError **error);
(define g_file_read_link
  (let ((~f #f))
    (lambda (filename error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_file_read_link" '* (list '* '*))))
      (let ((~filename (unwrap~pointer filename))
            (~error (unwrap~pointer error)))
        (~f ~filename ~error)))))
(export g_file_read_link)

;; extern gchar *g_mkdtemp(gchar *tmpl);
(define g_mkdtemp
  (let ((~f #f))
    (lambda (tmpl)
      (if (not ~f)
        (set! ~f (fh-link-proc "g_mkdtemp" '* (list '*))))
      (let ((~tmpl (unwrap~pointer tmpl))) (~f ~tmpl)))))
(export g_mkdtemp)

;; extern gchar *g_mkdtemp_full(gchar *tmpl, gint mode);
(define g_mkdtemp_full
  (let ((~f #f))
    (lambda (tmpl mode)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_mkdtemp_full"
            '*
            (list '* ffi:int))))
      (let ((~tmpl (unwrap~pointer tmpl))
            (~mode (unwrap~fixed mode)))
        (~f ~tmpl ~mode)))))
(export g_mkdtemp_full)

;; extern gint g_mkstemp(gchar *tmpl);
(define g_mkstemp
  (let ((~f #f))
    (lambda (tmpl)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_mkstemp" ffi:int (list '*))))
      (let ((~tmpl (unwrap~pointer tmpl))) (~f ~tmpl)))))
(export g_mkstemp)

;; extern gint g_mkstemp_full(gchar *tmpl, gint flags, gint mode);
(define g_mkstemp_full
  (let ((~f #f))
    (lambda (tmpl flags mode)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_mkstemp_full"
            ffi:int
            (list '* ffi:int ffi:int))))
      (let ((~tmpl (unwrap~pointer tmpl))
            (~flags (unwrap~fixed flags))
            (~mode (unwrap~fixed mode)))
        (~f ~tmpl ~flags ~mode)))))
(export g_mkstemp_full)

;; extern gint g_file_open_tmp(const gchar *tmpl, gchar **name_used, GError **
;;     error);
(define g_file_open_tmp
  (let ((~f #f))
    (lambda (tmpl name_used error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_file_open_tmp"
            ffi:int
            (list '* '* '*))))
      (let ((~tmpl (unwrap~pointer tmpl))
            (~name_used (unwrap~pointer name_used))
            (~error (unwrap~pointer error)))
        (~f ~tmpl ~name_used ~error)))))
(export g_file_open_tmp)

;; extern gchar *g_dir_make_tmp(const gchar *tmpl, GError **error);
(define g_dir_make_tmp
  (let ((~f #f))
    (lambda (tmpl error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_dir_make_tmp" '* (list '* '*))))
      (let ((~tmpl (unwrap~pointer tmpl))
            (~error (unwrap~pointer error)))
        (~f ~tmpl ~error)))))
(export g_dir_make_tmp)

;; extern gchar *g_build_path(const gchar *separator, const gchar *
;;     first_element, ...);
;; ... failed.

;; extern gchar *g_build_pathv(const gchar *separator, gchar **args);
(define g_build_pathv
  (let ((~f #f))
    (lambda (separator args)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_build_pathv" '* (list '* '*))))
      (let ((~separator (unwrap~pointer separator))
            (~args (unwrap~pointer args)))
        (~f ~separator ~args)))))
(export g_build_pathv)

;; extern gchar *g_build_filename(const gchar *first_element, ...);
;; ... failed.

;; extern gchar *g_build_filenamev(gchar **args);
(define g_build_filenamev
  (let ((~f #f))
    (lambda (args)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_build_filenamev" '* (list '*))))
      (let ((~args (unwrap~pointer args))) (~f ~args)))))
(export g_build_filenamev)

;; extern gint g_mkdir_with_parents(const gchar *pathname, gint mode);
(define g_mkdir_with_parents
  (let ((~f #f))
    (lambda (pathname mode)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_mkdir_with_parents"
            ffi:int
            (list '* ffi:int))))
      (let ((~pathname (unwrap~pointer pathname))
            (~mode (unwrap~fixed mode)))
        (~f ~pathname ~mode)))))
(export g_mkdir_with_parents)

;; extern gboolean g_path_is_absolute(const gchar *file_name);
(define g_path_is_absolute
  (let ((~f #f))
    (lambda (file_name)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_path_is_absolute"
            ffi:int
            (list '*))))
      (let ((~file_name (unwrap~pointer file_name)))
        (~f ~file_name)))))
(export g_path_is_absolute)

;; extern const gchar *g_path_skip_root(const gchar *file_name);
(define g_path_skip_root
  (let ((~f #f))
    (lambda (file_name)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_path_skip_root" '* (list '*))))
      (let ((~file_name (unwrap~pointer file_name)))
        (~f ~file_name)))))
(export g_path_skip_root)

;; extern const gchar *g_basename(const gchar *file_name);
(define g_basename
  (let ((~f #f))
    (lambda (file_name)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_basename" '* (list '*))))
      (let ((~file_name (unwrap~pointer file_name)))
        (~f ~file_name)))))
(export g_basename)

;; extern gchar *g_get_current_dir(void);
(define g_get_current_dir
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_get_current_dir" '* (list))))
      (let () (~f)))))
(export g_get_current_dir)

;; extern gchar *g_path_get_basename(const gchar *file_name);
(define g_path_get_basename
  (let ((~f #f))
    (lambda (file_name)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_path_get_basename" '* (list '*))))
      (let ((~file_name (unwrap~pointer file_name)))
        (~f ~file_name)))))
(export g_path_get_basename)

;; extern gchar *g_path_get_dirname(const gchar *file_name);
(define g_path_get_dirname
  (let ((~f #f))
    (lambda (file_name)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_path_get_dirname" '* (list '*))))
      (let ((~file_name (unwrap~pointer file_name)))
        (~f ~file_name)))))
(export g_path_get_dirname)

;; extern const gchar *g_strip_context(const gchar *msgid, const gchar *msgval)
;;     ;
(define g_strip_context
  (let ((~f #f))
    (lambda (msgid msgval)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_strip_context" '* (list '* '*))))
      (let ((~msgid (unwrap~pointer msgid))
            (~msgval (unwrap~pointer msgval)))
        (~f ~msgid ~msgval)))))
(export g_strip_context)

;; extern const gchar *g_dgettext(const gchar *domain, const gchar *msgid);
(define g_dgettext
  (let ((~f #f))
    (lambda (domain msgid)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_dgettext" '* (list '* '*))))
      (let ((~domain (unwrap~pointer domain))
            (~msgid (unwrap~pointer msgid)))
        (~f ~domain ~msgid)))))
(export g_dgettext)

;; extern const gchar *g_dcgettext(const gchar *domain, const gchar *msgid, 
;;     gint category);
(define g_dcgettext
  (let ((~f #f))
    (lambda (domain msgid category)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_dcgettext"
            '*
            (list '* '* ffi:int))))
      (let ((~domain (unwrap~pointer domain))
            (~msgid (unwrap~pointer msgid))
            (~category (unwrap~fixed category)))
        (~f ~domain ~msgid ~category)))))
(export g_dcgettext)

;; extern const gchar *g_dngettext(const gchar *domain, const gchar *msgid, 
;;     const gchar *msgid_plural, gulong n);
(define g_dngettext
  (let ((~f #f))
    (lambda (domain msgid msgid_plural n)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_dngettext"
            '*
            (list '* '* '* ffi:unsigned-long))))
      (let ((~domain (unwrap~pointer domain))
            (~msgid (unwrap~pointer msgid))
            (~msgid_plural (unwrap~pointer msgid_plural))
            (~n (unwrap~fixed n)))
        (~f ~domain ~msgid ~msgid_plural ~n)))))
(export g_dngettext)

;; extern const gchar *g_dpgettext(const gchar *domain, const gchar *msgctxtid
;;     , gsize msgidoffset);
(define g_dpgettext
  (let ((~f #f))
    (lambda (domain msgctxtid msgidoffset)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_dpgettext"
            '*
            (list '* '* ffi:unsigned-long))))
      (let ((~domain (unwrap~pointer domain))
            (~msgctxtid (unwrap~pointer msgctxtid))
            (~msgidoffset (unwrap~fixed msgidoffset)))
        (~f ~domain ~msgctxtid ~msgidoffset)))))
(export g_dpgettext)

;; extern const gchar *g_dpgettext2(const gchar *domain, const gchar *context, 
;;     const gchar *msgid);
(define g_dpgettext2
  (let ((~f #f))
    (lambda (domain context msgid)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_dpgettext2" '* (list '* '* '*))))
      (let ((~domain (unwrap~pointer domain))
            (~context (unwrap~pointer context))
            (~msgid (unwrap~pointer msgid)))
        (~f ~domain ~context ~msgid)))))
(export g_dpgettext2)

;; typedef struct _GMemVTable GMemVTable;
(define GMemVTable-desc void)
(define GMemVTable*-desc (bs:pointer (delay GMemVTable-desc)))
(export GMemVTable*-desc)
(define-fh-pointer-type GMemVTable* GMemVTable*-desc)

;; extern void g_free(gpointer mem);
(define g_free
  (let ((~f #f))
    (lambda (mem)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_free" ffi:void (list '*))))
      (let ((~mem (unwrap-gpointer mem))) (~f ~mem)))))
(export g_free)

;; extern void g_clear_pointer(gpointer *pp, GDestroyNotify destroy);
(define g_clear_pointer
  (let ((~f #f))
    (lambda (pp destroy)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_clear_pointer"
            ffi:void
            (list '* '*))))
      (let ((~pp (unwrap-gpointer* pp))
            (~destroy
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               destroy)))
        (~f ~pp ~destroy)))))
(export g_clear_pointer)

;; extern gpointer g_malloc(gsize n_bytes);
(define g_malloc
  (let ((~f #f))
    (lambda (n_bytes)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_malloc"
            '*
            (list ffi:unsigned-long))))
      (let ((~n_bytes (unwrap~fixed n_bytes)))
        (wrap-gpointer (~f ~n_bytes))))))
(export g_malloc)

;; extern gpointer g_malloc0(gsize n_bytes);
(define g_malloc0
  (let ((~f #f))
    (lambda (n_bytes)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_malloc0"
            '*
            (list ffi:unsigned-long))))
      (let ((~n_bytes (unwrap~fixed n_bytes)))
        (wrap-gpointer (~f ~n_bytes))))))
(export g_malloc0)

;; extern gpointer g_realloc(gpointer mem, gsize n_bytes);
(define g_realloc
  (let ((~f #f))
    (lambda (mem n_bytes)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_realloc"
            '*
            (list '* ffi:unsigned-long))))
      (let ((~mem (unwrap-gpointer mem))
            (~n_bytes (unwrap~fixed n_bytes)))
        (wrap-gpointer (~f ~mem ~n_bytes))))))
(export g_realloc)

;; extern gpointer g_try_malloc(gsize n_bytes);
(define g_try_malloc
  (let ((~f #f))
    (lambda (n_bytes)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_try_malloc"
            '*
            (list ffi:unsigned-long))))
      (let ((~n_bytes (unwrap~fixed n_bytes)))
        (wrap-gpointer (~f ~n_bytes))))))
(export g_try_malloc)

;; extern gpointer g_try_malloc0(gsize n_bytes);
(define g_try_malloc0
  (let ((~f #f))
    (lambda (n_bytes)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_try_malloc0"
            '*
            (list ffi:unsigned-long))))
      (let ((~n_bytes (unwrap~fixed n_bytes)))
        (wrap-gpointer (~f ~n_bytes))))))
(export g_try_malloc0)

;; extern gpointer g_try_realloc(gpointer mem, gsize n_bytes);
(define g_try_realloc
  (let ((~f #f))
    (lambda (mem n_bytes)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_try_realloc"
            '*
            (list '* ffi:unsigned-long))))
      (let ((~mem (unwrap-gpointer mem))
            (~n_bytes (unwrap~fixed n_bytes)))
        (wrap-gpointer (~f ~mem ~n_bytes))))))
(export g_try_realloc)

;; extern gpointer g_malloc_n(gsize n_blocks, gsize n_block_bytes);
(define g_malloc_n
  (let ((~f #f))
    (lambda (n_blocks n_block_bytes)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_malloc_n"
            '*
            (list ffi:unsigned-long ffi:unsigned-long))))
      (let ((~n_blocks (unwrap~fixed n_blocks))
            (~n_block_bytes (unwrap~fixed n_block_bytes)))
        (wrap-gpointer (~f ~n_blocks ~n_block_bytes))))))
(export g_malloc_n)

;; extern gpointer g_malloc0_n(gsize n_blocks, gsize n_block_bytes);
(define g_malloc0_n
  (let ((~f #f))
    (lambda (n_blocks n_block_bytes)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_malloc0_n"
            '*
            (list ffi:unsigned-long ffi:unsigned-long))))
      (let ((~n_blocks (unwrap~fixed n_blocks))
            (~n_block_bytes (unwrap~fixed n_block_bytes)))
        (wrap-gpointer (~f ~n_blocks ~n_block_bytes))))))
(export g_malloc0_n)

;; extern gpointer g_realloc_n(gpointer mem, gsize n_blocks, gsize 
;;     n_block_bytes);
(define g_realloc_n
  (let ((~f #f))
    (lambda (mem n_blocks n_block_bytes)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_realloc_n"
            '*
            (list '* ffi:unsigned-long ffi:unsigned-long))))
      (let ((~mem (unwrap-gpointer mem))
            (~n_blocks (unwrap~fixed n_blocks))
            (~n_block_bytes (unwrap~fixed n_block_bytes)))
        (wrap-gpointer
          (~f ~mem ~n_blocks ~n_block_bytes))))))
(export g_realloc_n)

;; extern gpointer g_try_malloc_n(gsize n_blocks, gsize n_block_bytes);
(define g_try_malloc_n
  (let ((~f #f))
    (lambda (n_blocks n_block_bytes)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_try_malloc_n"
            '*
            (list ffi:unsigned-long ffi:unsigned-long))))
      (let ((~n_blocks (unwrap~fixed n_blocks))
            (~n_block_bytes (unwrap~fixed n_block_bytes)))
        (wrap-gpointer (~f ~n_blocks ~n_block_bytes))))))
(export g_try_malloc_n)

;; extern gpointer g_try_malloc0_n(gsize n_blocks, gsize n_block_bytes);
(define g_try_malloc0_n
  (let ((~f #f))
    (lambda (n_blocks n_block_bytes)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_try_malloc0_n"
            '*
            (list ffi:unsigned-long ffi:unsigned-long))))
      (let ((~n_blocks (unwrap~fixed n_blocks))
            (~n_block_bytes (unwrap~fixed n_block_bytes)))
        (wrap-gpointer (~f ~n_blocks ~n_block_bytes))))))
(export g_try_malloc0_n)

;; extern gpointer g_try_realloc_n(gpointer mem, gsize n_blocks, gsize 
;;     n_block_bytes);
(define g_try_realloc_n
  (let ((~f #f))
    (lambda (mem n_blocks n_block_bytes)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_try_realloc_n"
            '*
            (list '* ffi:unsigned-long ffi:unsigned-long))))
      (let ((~mem (unwrap-gpointer mem))
            (~n_blocks (unwrap~fixed n_blocks))
            (~n_block_bytes (unwrap~fixed n_block_bytes)))
        (wrap-gpointer
          (~f ~mem ~n_blocks ~n_block_bytes))))))
(export g_try_realloc_n)

;; struct _GMemVTable {
;;   gpointer (*malloc)(gsize n_bytes);
;;   gpointer (*realloc)(gpointer mem, gsize n_bytes);
;;   void (*free)(gpointer mem);
;;   /* optional; set to NULL if not used ! */
;;   gpointer (*calloc)(gsize n_blocks, gsize n_block_bytes);
;;   gpointer (*try_malloc)(gsize n_bytes);
;;   gpointer (*try_realloc)(gpointer mem, gsize n_bytes);
;; };
(define struct-_GMemVTable-desc
  (bs:struct
    (list `(malloc ,(bs:pointer void))
          `(realloc ,(bs:pointer void))
          `(free ,(bs:pointer void))
          `(calloc ,(bs:pointer void))
          `(try_malloc ,(bs:pointer void))
          `(try_realloc ,(bs:pointer void)))))
(export struct-_GMemVTable-desc)
(define-fh-compound-type/p struct-_GMemVTable struct-_GMemVTable-desc)
(set! GMemVTable-desc struct-_GMemVTable-desc)
(define-fh-compound-type GMemVTable GMemVTable-desc)

;; extern void g_mem_set_vtable(GMemVTable *vtable);
(define g_mem_set_vtable
  (let ((~f #f))
    (lambda (vtable)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_mem_set_vtable"
            ffi:void
            (list '*))))
      (let ((~vtable (unwrap-GMemVTable* vtable)))
        (~f ~vtable)))))
(export g_mem_set_vtable)

;; extern gboolean g_mem_is_system_malloc(void);
(define g_mem_is_system_malloc
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_mem_is_system_malloc"
            ffi:int
            (list))))
      (let () (~f)))))
(export g_mem_is_system_malloc)

;; extern gboolean g_mem_gc_friendly;
(define g_mem_gc_friendly
  (let* ((addr (dynamic-pointer
                 "g_mem_gc_friendly"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer int))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_mem_gc_friendly)

;; extern GMemVTable *glib_mem_profiler_table;
(define glib_mem_profiler_table (dynamic-pointer "glib_mem_profiler_table" (dynamic-link)))

;; extern void g_mem_profile(void);
(define g_mem_profile
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_mem_profile" ffi:void (list))))
      (let () (~f)))))
(export g_mem_profile)

;; typedef struct _GNode GNode;
(define GNode-desc void)
(define GNode*-desc (bs:pointer (delay GNode-desc)))
(export GNode*-desc)
(define-fh-pointer-type GNode* GNode*-desc)

;; typedef enum {
;;   G_TRAVERSE_LEAVES = 1<<0,
;;   G_TRAVERSE_NON_LEAVES = 1<<1,
;;   G_TRAVERSE_ALL = G_TRAVERSE_LEAVES | G_TRAVERSE_NON_LEAVES,
;;   G_TRAVERSE_MASK = 0x03,
;;   G_TRAVERSE_LEAFS = G_TRAVERSE_LEAVES,
;;   G_TRAVERSE_NON_LEAFS = G_TRAVERSE_NON_LEAVES,
;; } GTraverseFlags;
(define-fh-enum GTraverseFlags
  '((G_TRAVERSE_LEAVES . 1)
    (G_TRAVERSE_NON_LEAVES . 2)
    (G_TRAVERSE_ALL . 3)
    (G_TRAVERSE_MASK . 3)
    (G_TRAVERSE_LEAFS . 1)
    (G_TRAVERSE_NON_LEAFS . 2))
  )

;; typedef enum {
;;   G_IN_ORDER,
;;   G_PRE_ORDER,
;;   G_POST_ORDER,
;;   G_LEVEL_ORDER,
;; } GTraverseType;
(define-fh-enum GTraverseType
  '((G_IN_ORDER . 0)
    (G_PRE_ORDER . 1)
    (G_POST_ORDER . 2)
    (G_LEVEL_ORDER . 3))
  )

;; typedef gboolean (*GNodeTraverseFunc)(GNode *node, gpointer data);
(define-fh-function/p GNodeTraverseFunc
  ffi:int (list (quote *) (quote *)))

;; typedef void (*GNodeForeachFunc)(GNode *node, gpointer data);
(define-fh-function/p GNodeForeachFunc
  ffi:void (list (quote *) (quote *)))

;; typedef gpointer (*GCopyFunc)(gconstpointer src, gpointer data);
(define-fh-function/p GCopyFunc
  (quote *) (list (quote *) (quote *)))

;; struct _GNode {
;;   gpointer data;
;;   GNode *next;
;;   GNode *prev;
;;   GNode *parent;
;;   GNode *children;
;; };
(define struct-_GNode-desc
  (bs:struct
    (list `(data ,gpointer-desc)
          `(next ,(bs:pointer (delay GNode*-desc)))
          `(prev ,(bs:pointer (delay GNode*-desc)))
          `(parent ,(bs:pointer (delay GNode*-desc)))
          `(children ,(bs:pointer (delay GNode*-desc))))))
(export struct-_GNode-desc)
(define-fh-compound-type/p struct-_GNode struct-_GNode-desc)
(set! GNode-desc struct-_GNode-desc)
(define-fh-compound-type GNode GNode-desc)

;; extern GNode *g_node_new(gpointer data);
(define g_node_new
  (let ((~f #f))
    (lambda (data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_node_new" '* (list '*))))
      (let ((~data (unwrap-gpointer data)))
        (wrap-GNode* (~f ~data))))))
(export g_node_new)

;; extern void g_node_destroy(GNode *root);
(define g_node_destroy
  (let ((~f #f))
    (lambda (root)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_node_destroy"
            ffi:void
            (list '*))))
      (let ((~root (unwrap-GNode* root))) (~f ~root)))))
(export g_node_destroy)

;; extern void g_node_unlink(GNode *node);
(define g_node_unlink
  (let ((~f #f))
    (lambda (node)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_node_unlink" ffi:void (list '*))))
      (let ((~node (unwrap-GNode* node))) (~f ~node)))))
(export g_node_unlink)

;; extern GNode *g_node_copy_deep(GNode *node, GCopyFunc copy_func, gpointer 
;;     data);
(define g_node_copy_deep
  (let ((~f #f))
    (lambda (node copy_func data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_node_copy_deep"
            '*
            (list '* '* '*))))
      (let ((~node (unwrap-GNode* node))
            (~copy_func
              ((make-ftn-arg-unwrapper '* (list '* '*))
               copy_func))
            (~data (unwrap-gpointer data)))
        (wrap-GNode* (~f ~node ~copy_func ~data))))))
(export g_node_copy_deep)

;; extern GNode *g_node_copy(GNode *node);
(define g_node_copy
  (let ((~f #f))
    (lambda (node)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_node_copy" '* (list '*))))
      (let ((~node (unwrap-GNode* node)))
        (wrap-GNode* (~f ~node))))))
(export g_node_copy)

;; extern GNode *g_node_insert(GNode *parent, gint position, GNode *node);
(define g_node_insert
  (let ((~f #f))
    (lambda (parent position node)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_node_insert"
            '*
            (list '* ffi:int '*))))
      (let ((~parent (unwrap-GNode* parent))
            (~position (unwrap~fixed position))
            (~node (unwrap-GNode* node)))
        (wrap-GNode* (~f ~parent ~position ~node))))))
(export g_node_insert)

;; extern GNode *g_node_insert_before(GNode *parent, GNode *sibling, GNode *
;;     node);
(define g_node_insert_before
  (let ((~f #f))
    (lambda (parent sibling node)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_node_insert_before"
            '*
            (list '* '* '*))))
      (let ((~parent (unwrap-GNode* parent))
            (~sibling (unwrap-GNode* sibling))
            (~node (unwrap-GNode* node)))
        (wrap-GNode* (~f ~parent ~sibling ~node))))))
(export g_node_insert_before)

;; extern GNode *g_node_insert_after(GNode *parent, GNode *sibling, GNode *node
;;     );
(define g_node_insert_after
  (let ((~f #f))
    (lambda (parent sibling node)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_node_insert_after"
            '*
            (list '* '* '*))))
      (let ((~parent (unwrap-GNode* parent))
            (~sibling (unwrap-GNode* sibling))
            (~node (unwrap-GNode* node)))
        (wrap-GNode* (~f ~parent ~sibling ~node))))))
(export g_node_insert_after)

;; extern GNode *g_node_prepend(GNode *parent, GNode *node);
(define g_node_prepend
  (let ((~f #f))
    (lambda (parent node)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_node_prepend" '* (list '* '*))))
      (let ((~parent (unwrap-GNode* parent))
            (~node (unwrap-GNode* node)))
        (wrap-GNode* (~f ~parent ~node))))))
(export g_node_prepend)

;; extern guint g_node_n_nodes(GNode *root, GTraverseFlags flags);
(define g_node_n_nodes
  (let ((~f #f))
    (lambda (root flags)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_node_n_nodes"
            ffi:unsigned-int
            (list '* ffi:int))))
      (let ((~root (unwrap-GNode* root))
            (~flags (unwrap~fixed flags)))
        (~f ~root ~flags)))))
(export g_node_n_nodes)

;; extern GNode *g_node_get_root(GNode *node);
(define g_node_get_root
  (let ((~f #f))
    (lambda (node)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_node_get_root" '* (list '*))))
      (let ((~node (unwrap-GNode* node)))
        (wrap-GNode* (~f ~node))))))
(export g_node_get_root)

;; extern gboolean g_node_is_ancestor(GNode *node, GNode *descendant);
(define g_node_is_ancestor
  (let ((~f #f))
    (lambda (node descendant)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_node_is_ancestor"
            ffi:int
            (list '* '*))))
      (let ((~node (unwrap-GNode* node))
            (~descendant (unwrap-GNode* descendant)))
        (~f ~node ~descendant)))))
(export g_node_is_ancestor)

;; extern guint g_node_depth(GNode *node);
(define g_node_depth
  (let ((~f #f))
    (lambda (node)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_node_depth"
            ffi:unsigned-int
            (list '*))))
      (let ((~node (unwrap-GNode* node))) (~f ~node)))))
(export g_node_depth)

;; extern GNode *g_node_find(GNode *root, GTraverseType order, GTraverseFlags 
;;     flags, gpointer data);
(define g_node_find
  (let ((~f #f))
    (lambda (root order flags data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_node_find"
            '*
            (list '* ffi:int ffi:int '*))))
      (let ((~root (unwrap-GNode* root))
            (~order (unwrap~fixed order))
            (~flags (unwrap~fixed flags))
            (~data (unwrap-gpointer data)))
        (wrap-GNode* (~f ~root ~order ~flags ~data))))))
(export g_node_find)

;; extern void g_node_traverse(GNode *root, GTraverseType order, GTraverseFlags
;;      flags, gint max_depth, GNodeTraverseFunc func, gpointer data);
(define g_node_traverse
  (let ((~f #f))
    (lambda (root order flags max_depth func data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_node_traverse"
            ffi:void
            (list '* ffi:int ffi:int ffi:int '* '*))))
      (let ((~root (unwrap-GNode* root))
            (~order (unwrap~fixed order))
            (~flags (unwrap~fixed flags))
            (~max_depth (unwrap~fixed max_depth))
            (~func ((make-ftn-arg-unwrapper ffi:int (list '* '*))
                    func))
            (~data (unwrap-gpointer data)))
        (~f ~root ~order ~flags ~max_depth ~func ~data)))))
(export g_node_traverse)

;; extern guint g_node_max_height(GNode *root);
(define g_node_max_height
  (let ((~f #f))
    (lambda (root)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_node_max_height"
            ffi:unsigned-int
            (list '*))))
      (let ((~root (unwrap-GNode* root))) (~f ~root)))))
(export g_node_max_height)

;; extern void g_node_children_foreach(GNode *node, GTraverseFlags flags, 
;;     GNodeForeachFunc func, gpointer data);
(define g_node_children_foreach
  (let ((~f #f))
    (lambda (node flags func data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_node_children_foreach"
            ffi:void
            (list '* ffi:int '* '*))))
      (let ((~node (unwrap-GNode* node))
            (~flags (unwrap~fixed flags))
            (~func ((make-ftn-arg-unwrapper ffi:void (list '* '*))
                    func))
            (~data (unwrap-gpointer data)))
        (~f ~node ~flags ~func ~data)))))
(export g_node_children_foreach)

;; extern void g_node_reverse_children(GNode *node);
(define g_node_reverse_children
  (let ((~f #f))
    (lambda (node)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_node_reverse_children"
            ffi:void
            (list '*))))
      (let ((~node (unwrap-GNode* node))) (~f ~node)))))
(export g_node_reverse_children)

;; extern guint g_node_n_children(GNode *node);
(define g_node_n_children
  (let ((~f #f))
    (lambda (node)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_node_n_children"
            ffi:unsigned-int
            (list '*))))
      (let ((~node (unwrap-GNode* node))) (~f ~node)))))
(export g_node_n_children)

;; extern GNode *g_node_nth_child(GNode *node, guint n);
(define g_node_nth_child
  (let ((~f #f))
    (lambda (node n)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_node_nth_child"
            '*
            (list '* ffi:unsigned-int))))
      (let ((~node (unwrap-GNode* node))
            (~n (unwrap~fixed n)))
        (wrap-GNode* (~f ~node ~n))))))
(export g_node_nth_child)

;; extern GNode *g_node_last_child(GNode *node);
(define g_node_last_child
  (let ((~f #f))
    (lambda (node)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_node_last_child" '* (list '*))))
      (let ((~node (unwrap-GNode* node)))
        (wrap-GNode* (~f ~node))))))
(export g_node_last_child)

;; extern GNode *g_node_find_child(GNode *node, GTraverseFlags flags, gpointer 
;;     data);
(define g_node_find_child
  (let ((~f #f))
    (lambda (node flags data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_node_find_child"
            '*
            (list '* ffi:int '*))))
      (let ((~node (unwrap-GNode* node))
            (~flags (unwrap~fixed flags))
            (~data (unwrap-gpointer data)))
        (wrap-GNode* (~f ~node ~flags ~data))))))
(export g_node_find_child)

;; extern gint g_node_child_position(GNode *node, GNode *child);
(define g_node_child_position
  (let ((~f #f))
    (lambda (node child)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_node_child_position"
            ffi:int
            (list '* '*))))
      (let ((~node (unwrap-GNode* node))
            (~child (unwrap-GNode* child)))
        (~f ~node ~child)))))
(export g_node_child_position)

;; extern gint g_node_child_index(GNode *node, gpointer data);
(define g_node_child_index
  (let ((~f #f))
    (lambda (node data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_node_child_index"
            ffi:int
            (list '* '*))))
      (let ((~node (unwrap-GNode* node))
            (~data (unwrap-gpointer data)))
        (~f ~node ~data)))))
(export g_node_child_index)

;; extern GNode *g_node_first_sibling(GNode *node);
(define g_node_first_sibling
  (let ((~f #f))
    (lambda (node)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_node_first_sibling"
            '*
            (list '*))))
      (let ((~node (unwrap-GNode* node)))
        (wrap-GNode* (~f ~node))))))
(export g_node_first_sibling)

;; extern GNode *g_node_last_sibling(GNode *node);
(define g_node_last_sibling
  (let ((~f #f))
    (lambda (node)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_node_last_sibling" '* (list '*))))
      (let ((~node (unwrap-GNode* node)))
        (wrap-GNode* (~f ~node))))))
(export g_node_last_sibling)

;; typedef struct _GList GList;
(define GList-desc void)
(define GList*-desc (bs:pointer (delay GList-desc)))
(export GList*-desc)
(define-fh-pointer-type GList* GList*-desc)

;; struct _GList {
;;   gpointer data;
;;   GList *next;
;;   GList *prev;
;; };
(define struct-_GList-desc
  (bs:struct
    (list `(data ,gpointer-desc)
          `(next ,(bs:pointer (delay GList*-desc)))
          `(prev ,(bs:pointer (delay GList*-desc))))))
(export struct-_GList-desc)
(define-fh-compound-type/p struct-_GList struct-_GList-desc)
(set! GList-desc struct-_GList-desc)
(define-fh-compound-type GList GList-desc)

;; extern GList *g_list_alloc(void);
(define g_list_alloc
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f (fh-link-proc "g_list_alloc" '* (list))))
      (let () (wrap-GList* (~f))))))
(export g_list_alloc)

;; extern void g_list_free(GList *list);
(define g_list_free
  (let ((~f #f))
    (lambda (list)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_list_free" ffi:void (list '*))))
      (let ((~list (unwrap-GList* list))) (~f ~list)))))
(export g_list_free)

;; extern void g_list_free_1(GList *list);
(define g_list_free_1
  (let ((~f #f))
    (lambda (list)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_list_free_1" ffi:void (list '*))))
      (let ((~list (unwrap-GList* list))) (~f ~list)))))
(export g_list_free_1)

;; extern void g_list_free_full(GList *list, GDestroyNotify free_func);
(define g_list_free_full
  (let ((~f #f))
    (lambda (list free_func)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_list_free_full"
            ffi:void
            (list '* '*))))
      (let ((~list (unwrap-GList* list))
            (~free_func
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               free_func)))
        (~f ~list ~free_func)))))
(export g_list_free_full)

;; extern GList *g_list_append(GList *list, gpointer data);
(define g_list_append
  (let ((~f #f))
    (lambda (list data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_list_append" '* (list '* '*))))
      (let ((~list (unwrap-GList* list))
            (~data (unwrap-gpointer data)))
        (wrap-GList* (~f ~list ~data))))))
(export g_list_append)

;; extern GList *g_list_prepend(GList *list, gpointer data);
(define g_list_prepend
  (let ((~f #f))
    (lambda (list data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_list_prepend" '* (list '* '*))))
      (let ((~list (unwrap-GList* list))
            (~data (unwrap-gpointer data)))
        (wrap-GList* (~f ~list ~data))))))
(export g_list_prepend)

;; extern GList *g_list_insert(GList *list, gpointer data, gint position);
(define g_list_insert
  (let ((~f #f))
    (lambda (list data position)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_list_insert"
            '*
            (list '* '* ffi:int))))
      (let ((~list (unwrap-GList* list))
            (~data (unwrap-gpointer data))
            (~position (unwrap~fixed position)))
        (wrap-GList* (~f ~list ~data ~position))))))
(export g_list_insert)

;; extern GList *g_list_insert_sorted(GList *list, gpointer data, GCompareFunc 
;;     func);
(define g_list_insert_sorted
  (let ((~f #f))
    (lambda (list data func)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_list_insert_sorted"
            '*
            (list '* '* '*))))
      (let ((~list (unwrap-GList* list))
            (~data (unwrap-gpointer data))
            (~func ((make-ftn-arg-unwrapper ffi:int (list '* '*))
                    func)))
        (wrap-GList* (~f ~list ~data ~func))))))
(export g_list_insert_sorted)

;; extern GList *g_list_insert_sorted_with_data(GList *list, gpointer data, 
;;     GCompareDataFunc func, gpointer user_data);
(define g_list_insert_sorted_with_data
  (let ((~f #f))
    (lambda (list data func user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_list_insert_sorted_with_data"
            '*
            (list '* '* '* '*))))
      (let ((~list (unwrap-GList* list))
            (~data (unwrap-gpointer data))
            (~func ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
                    func))
            (~user_data (unwrap-gpointer user_data)))
        (wrap-GList* (~f ~list ~data ~func ~user_data))))))
(export g_list_insert_sorted_with_data)

;; extern GList *g_list_insert_before(GList *list, GList *sibling, gpointer 
;;     data);
(define g_list_insert_before
  (let ((~f #f))
    (lambda (list sibling data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_list_insert_before"
            '*
            (list '* '* '*))))
      (let ((~list (unwrap-GList* list))
            (~sibling (unwrap-GList* sibling))
            (~data (unwrap-gpointer data)))
        (wrap-GList* (~f ~list ~sibling ~data))))))
(export g_list_insert_before)

;; extern GList *g_list_concat(GList *list1, GList *list2);
(define g_list_concat
  (let ((~f #f))
    (lambda (list1 list2)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_list_concat" '* (list '* '*))))
      (let ((~list1 (unwrap-GList* list1))
            (~list2 (unwrap-GList* list2)))
        (wrap-GList* (~f ~list1 ~list2))))))
(export g_list_concat)

;; extern GList *g_list_remove(GList *list, gconstpointer data);
(define g_list_remove
  (let ((~f #f))
    (lambda (list data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_list_remove" '* (list '* '*))))
      (let ((~list (unwrap-GList* list))
            (~data (unwrap-gconstpointer data)))
        (wrap-GList* (~f ~list ~data))))))
(export g_list_remove)

;; extern GList *g_list_remove_all(GList *list, gconstpointer data);
(define g_list_remove_all
  (let ((~f #f))
    (lambda (list data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_list_remove_all"
            '*
            (list '* '*))))
      (let ((~list (unwrap-GList* list))
            (~data (unwrap-gconstpointer data)))
        (wrap-GList* (~f ~list ~data))))))
(export g_list_remove_all)

;; extern GList *g_list_remove_link(GList *list, GList *llink);
(define g_list_remove_link
  (let ((~f #f))
    (lambda (list llink)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_list_remove_link"
            '*
            (list '* '*))))
      (let ((~list (unwrap-GList* list))
            (~llink (unwrap-GList* llink)))
        (wrap-GList* (~f ~list ~llink))))))
(export g_list_remove_link)

;; extern GList *g_list_delete_link(GList *list, GList *link_);
(define g_list_delete_link
  (let ((~f #f))
    (lambda (list link_)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_list_delete_link"
            '*
            (list '* '*))))
      (let ((~list (unwrap-GList* list))
            (~link_ (unwrap-GList* link_)))
        (wrap-GList* (~f ~list ~link_))))))
(export g_list_delete_link)

;; extern GList *g_list_reverse(GList *list);
(define g_list_reverse
  (let ((~f #f))
    (lambda (list)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_list_reverse" '* (list '*))))
      (let ((~list (unwrap-GList* list)))
        (wrap-GList* (~f ~list))))))
(export g_list_reverse)

;; extern GList *g_list_copy(GList *list);
(define g_list_copy
  (let ((~f #f))
    (lambda (list)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_list_copy" '* (list '*))))
      (let ((~list (unwrap-GList* list)))
        (wrap-GList* (~f ~list))))))
(export g_list_copy)

;; extern GList *g_list_copy_deep(GList *list, GCopyFunc func, gpointer 
;;     user_data);
(define g_list_copy_deep
  (let ((~f #f))
    (lambda (list func user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_list_copy_deep"
            '*
            (list '* '* '*))))
      (let ((~list (unwrap-GList* list))
            (~func ((make-ftn-arg-unwrapper '* (list '* '*)) func))
            (~user_data (unwrap-gpointer user_data)))
        (wrap-GList* (~f ~list ~func ~user_data))))))
(export g_list_copy_deep)

;; extern GList *g_list_nth(GList *list, guint n);
(define g_list_nth
  (let ((~f #f))
    (lambda (list n)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_list_nth"
            '*
            (list '* ffi:unsigned-int))))
      (let ((~list (unwrap-GList* list))
            (~n (unwrap~fixed n)))
        (wrap-GList* (~f ~list ~n))))))
(export g_list_nth)

;; extern GList *g_list_nth_prev(GList *list, guint n);
(define g_list_nth_prev
  (let ((~f #f))
    (lambda (list n)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_list_nth_prev"
            '*
            (list '* ffi:unsigned-int))))
      (let ((~list (unwrap-GList* list))
            (~n (unwrap~fixed n)))
        (wrap-GList* (~f ~list ~n))))))
(export g_list_nth_prev)

;; extern GList *g_list_find(GList *list, gconstpointer data);
(define g_list_find
  (let ((~f #f))
    (lambda (list data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_list_find" '* (list '* '*))))
      (let ((~list (unwrap-GList* list))
            (~data (unwrap-gconstpointer data)))
        (wrap-GList* (~f ~list ~data))))))
(export g_list_find)

;; extern GList *g_list_find_custom(GList *list, gconstpointer data, 
;;     GCompareFunc func);
(define g_list_find_custom
  (let ((~f #f))
    (lambda (list data func)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_list_find_custom"
            '*
            (list '* '* '*))))
      (let ((~list (unwrap-GList* list))
            (~data (unwrap-gconstpointer data))
            (~func ((make-ftn-arg-unwrapper ffi:int (list '* '*))
                    func)))
        (wrap-GList* (~f ~list ~data ~func))))))
(export g_list_find_custom)

;; extern gint g_list_position(GList *list, GList *llink);
(define g_list_position
  (let ((~f #f))
    (lambda (list llink)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_list_position"
            ffi:int
            (list '* '*))))
      (let ((~list (unwrap-GList* list))
            (~llink (unwrap-GList* llink)))
        (~f ~list ~llink)))))
(export g_list_position)

;; extern gint g_list_index(GList *list, gconstpointer data);
(define g_list_index
  (let ((~f #f))
    (lambda (list data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_list_index"
            ffi:int
            (list '* '*))))
      (let ((~list (unwrap-GList* list))
            (~data (unwrap-gconstpointer data)))
        (~f ~list ~data)))))
(export g_list_index)

;; extern GList *g_list_last(GList *list);
(define g_list_last
  (let ((~f #f))
    (lambda (list)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_list_last" '* (list '*))))
      (let ((~list (unwrap-GList* list)))
        (wrap-GList* (~f ~list))))))
(export g_list_last)

;; extern GList *g_list_first(GList *list);
(define g_list_first
  (let ((~f #f))
    (lambda (list)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_list_first" '* (list '*))))
      (let ((~list (unwrap-GList* list)))
        (wrap-GList* (~f ~list))))))
(export g_list_first)

;; extern guint g_list_length(GList *list);
(define g_list_length
  (let ((~f #f))
    (lambda (list)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_list_length"
            ffi:unsigned-int
            (list '*))))
      (let ((~list (unwrap-GList* list))) (~f ~list)))))
(export g_list_length)

;; extern void g_list_foreach(GList *list, GFunc func, gpointer user_data);
(define g_list_foreach
  (let ((~f #f))
    (lambda (list func user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_list_foreach"
            ffi:void
            (list '* '* '*))))
      (let ((~list (unwrap-GList* list))
            (~func ((make-ftn-arg-unwrapper ffi:void (list '* '*))
                    func))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~list ~func ~user_data)))))
(export g_list_foreach)

;; extern GList *g_list_sort(GList *list, GCompareFunc compare_func);
(define g_list_sort
  (let ((~f #f))
    (lambda (list compare_func)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_list_sort" '* (list '* '*))))
      (let ((~list (unwrap-GList* list))
            (~compare_func
              ((make-ftn-arg-unwrapper ffi:int (list '* '*))
               compare_func)))
        (wrap-GList* (~f ~list ~compare_func))))))
(export g_list_sort)

;; extern GList *g_list_sort_with_data(GList *list, GCompareDataFunc 
;;     compare_func, gpointer user_data);
(define g_list_sort_with_data
  (let ((~f #f))
    (lambda (list compare_func user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_list_sort_with_data"
            '*
            (list '* '* '*))))
      (let ((~list (unwrap-GList* list))
            (~compare_func
              ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
               compare_func))
            (~user_data (unwrap-gpointer user_data)))
        (wrap-GList* (~f ~list ~compare_func ~user_data))))))
(export g_list_sort_with_data)

;; extern gpointer g_list_nth_data(GList *list, guint n);
(define g_list_nth_data
  (let ((~f #f))
    (lambda (list n)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_list_nth_data"
            '*
            (list '* ffi:unsigned-int))))
      (let ((~list (unwrap-GList* list))
            (~n (unwrap~fixed n)))
        (wrap-gpointer (~f ~list ~n))))))
(export g_list_nth_data)

;; typedef struct _GHashTable GHashTable;
(define GHashTable-desc void)
(define GHashTable*-desc (bs:pointer GHashTable-desc))
(export GHashTable*-desc)
(define-fh-pointer-type GHashTable* GHashTable*-desc)

;; typedef gboolean (*GHRFunc)(gpointer key, gpointer value, gpointer user_data
;;     );
(define-fh-function/p GHRFunc
  ffi:int (list (quote *) (quote *) (quote *)))

;; typedef struct _GHashTableIter GHashTableIter;
(define GHashTableIter-desc void)
(define GHashTableIter*-desc (bs:pointer (delay GHashTableIter-desc)))
(export GHashTableIter*-desc)
(define-fh-pointer-type GHashTableIter* GHashTableIter*-desc)

;; struct _GHashTableIter {
;;   /*< private >*/
;;   gpointer dummy1;
;;   gpointer dummy2;
;;   gpointer dummy3;
;;   int dummy4;
;;   gboolean dummy5;
;;   gpointer dummy6;
;; };
(define struct-_GHashTableIter-desc
  (bs:struct
    (list `(dummy1 ,gpointer-desc)
          `(dummy2 ,gpointer-desc)
          `(dummy3 ,gpointer-desc)
          `(dummy4 ,int)
          `(dummy5 ,int)
          `(dummy6 ,gpointer-desc))))
(export struct-_GHashTableIter-desc)
(define-fh-compound-type/p struct-_GHashTableIter struct-_GHashTableIter-desc)
(set! GHashTableIter-desc struct-_GHashTableIter-desc)
(define-fh-compound-type GHashTableIter GHashTableIter-desc)

;; extern GHashTable *g_hash_table_new(GHashFunc hash_func, GEqualFunc 
;;     key_equal_func);
(define g_hash_table_new
  (let ((~f #f))
    (lambda (hash_func key_equal_func)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_hash_table_new" '* (list '* '*))))
      (let ((~hash_func
              ((make-ftn-arg-unwrapper
                 ffi:unsigned-int
                 (list '*))
               hash_func))
            (~key_equal_func
              ((make-ftn-arg-unwrapper ffi:int (list '* '*))
               key_equal_func)))
        (wrap-GHashTable*
          (~f ~hash_func ~key_equal_func))))))
(export g_hash_table_new)

;; extern GHashTable *g_hash_table_new_full(GHashFunc hash_func, GEqualFunc 
;;     key_equal_func, GDestroyNotify key_destroy_func, GDestroyNotify 
;;     value_destroy_func);
(define g_hash_table_new_full
  (let ((~f #f))
    (lambda (hash_func
             key_equal_func
             key_destroy_func
             value_destroy_func)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hash_table_new_full"
            '*
            (list '* '* '* '*))))
      (let ((~hash_func
              ((make-ftn-arg-unwrapper
                 ffi:unsigned-int
                 (list '*))
               hash_func))
            (~key_equal_func
              ((make-ftn-arg-unwrapper ffi:int (list '* '*))
               key_equal_func))
            (~key_destroy_func
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               key_destroy_func))
            (~value_destroy_func
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               value_destroy_func)))
        (wrap-GHashTable*
          (~f ~hash_func
              ~key_equal_func
              ~key_destroy_func
              ~value_destroy_func))))))
(export g_hash_table_new_full)

;; extern void g_hash_table_destroy(GHashTable *hash_table);
(define g_hash_table_destroy
  (let ((~f #f))
    (lambda (hash_table)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hash_table_destroy"
            ffi:void
            (list '*))))
      (let ((~hash_table (unwrap-GHashTable* hash_table)))
        (~f ~hash_table)))))
(export g_hash_table_destroy)

;; extern gboolean g_hash_table_insert(GHashTable *hash_table, gpointer key, 
;;     gpointer value);
(define g_hash_table_insert
  (let ((~f #f))
    (lambda (hash_table key value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hash_table_insert"
            ffi:int
            (list '* '* '*))))
      (let ((~hash_table (unwrap-GHashTable* hash_table))
            (~key (unwrap-gpointer key))
            (~value (unwrap-gpointer value)))
        (~f ~hash_table ~key ~value)))))
(export g_hash_table_insert)

;; extern gboolean g_hash_table_replace(GHashTable *hash_table, gpointer key, 
;;     gpointer value);
(define g_hash_table_replace
  (let ((~f #f))
    (lambda (hash_table key value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hash_table_replace"
            ffi:int
            (list '* '* '*))))
      (let ((~hash_table (unwrap-GHashTable* hash_table))
            (~key (unwrap-gpointer key))
            (~value (unwrap-gpointer value)))
        (~f ~hash_table ~key ~value)))))
(export g_hash_table_replace)

;; extern gboolean g_hash_table_add(GHashTable *hash_table, gpointer key);
(define g_hash_table_add
  (let ((~f #f))
    (lambda (hash_table key)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hash_table_add"
            ffi:int
            (list '* '*))))
      (let ((~hash_table (unwrap-GHashTable* hash_table))
            (~key (unwrap-gpointer key)))
        (~f ~hash_table ~key)))))
(export g_hash_table_add)

;; extern gboolean g_hash_table_remove(GHashTable *hash_table, gconstpointer 
;;     key);
(define g_hash_table_remove
  (let ((~f #f))
    (lambda (hash_table key)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hash_table_remove"
            ffi:int
            (list '* '*))))
      (let ((~hash_table (unwrap-GHashTable* hash_table))
            (~key (unwrap-gconstpointer key)))
        (~f ~hash_table ~key)))))
(export g_hash_table_remove)

;; extern void g_hash_table_remove_all(GHashTable *hash_table);
(define g_hash_table_remove_all
  (let ((~f #f))
    (lambda (hash_table)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hash_table_remove_all"
            ffi:void
            (list '*))))
      (let ((~hash_table (unwrap-GHashTable* hash_table)))
        (~f ~hash_table)))))
(export g_hash_table_remove_all)

;; extern gboolean g_hash_table_steal(GHashTable *hash_table, gconstpointer key
;;     );
(define g_hash_table_steal
  (let ((~f #f))
    (lambda (hash_table key)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hash_table_steal"
            ffi:int
            (list '* '*))))
      (let ((~hash_table (unwrap-GHashTable* hash_table))
            (~key (unwrap-gconstpointer key)))
        (~f ~hash_table ~key)))))
(export g_hash_table_steal)

;; extern void g_hash_table_steal_all(GHashTable *hash_table);
(define g_hash_table_steal_all
  (let ((~f #f))
    (lambda (hash_table)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hash_table_steal_all"
            ffi:void
            (list '*))))
      (let ((~hash_table (unwrap-GHashTable* hash_table)))
        (~f ~hash_table)))))
(export g_hash_table_steal_all)

;; extern gpointer g_hash_table_lookup(GHashTable *hash_table, gconstpointer 
;;     key);
(define g_hash_table_lookup
  (let ((~f #f))
    (lambda (hash_table key)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hash_table_lookup"
            '*
            (list '* '*))))
      (let ((~hash_table (unwrap-GHashTable* hash_table))
            (~key (unwrap-gconstpointer key)))
        (wrap-gpointer (~f ~hash_table ~key))))))
(export g_hash_table_lookup)

;; extern gboolean g_hash_table_contains(GHashTable *hash_table, gconstpointer 
;;     key);
(define g_hash_table_contains
  (let ((~f #f))
    (lambda (hash_table key)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hash_table_contains"
            ffi:int
            (list '* '*))))
      (let ((~hash_table (unwrap-GHashTable* hash_table))
            (~key (unwrap-gconstpointer key)))
        (~f ~hash_table ~key)))))
(export g_hash_table_contains)

;; extern gboolean g_hash_table_lookup_extended(GHashTable *hash_table, 
;;     gconstpointer lookup_key, gpointer *orig_key, gpointer *value);
(define g_hash_table_lookup_extended
  (let ((~f #f))
    (lambda (hash_table lookup_key orig_key value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hash_table_lookup_extended"
            ffi:int
            (list '* '* '* '*))))
      (let ((~hash_table (unwrap-GHashTable* hash_table))
            (~lookup_key (unwrap-gconstpointer lookup_key))
            (~orig_key (unwrap-gpointer* orig_key))
            (~value (unwrap-gpointer* value)))
        (~f ~hash_table ~lookup_key ~orig_key ~value)))))
(export g_hash_table_lookup_extended)

;; extern void g_hash_table_foreach(GHashTable *hash_table, GHFunc func, 
;;     gpointer user_data);
(define g_hash_table_foreach
  (let ((~f #f))
    (lambda (hash_table func user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hash_table_foreach"
            ffi:void
            (list '* '* '*))))
      (let ((~hash_table (unwrap-GHashTable* hash_table))
            (~func ((make-ftn-arg-unwrapper ffi:void (list '* '* '*))
                    func))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~hash_table ~func ~user_data)))))
(export g_hash_table_foreach)

;; extern gpointer g_hash_table_find(GHashTable *hash_table, GHRFunc predicate
;;     , gpointer user_data);
(define g_hash_table_find
  (let ((~f #f))
    (lambda (hash_table predicate user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hash_table_find"
            '*
            (list '* '* '*))))
      (let ((~hash_table (unwrap-GHashTable* hash_table))
            (~predicate
              ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
               predicate))
            (~user_data (unwrap-gpointer user_data)))
        (wrap-gpointer
          (~f ~hash_table ~predicate ~user_data))))))
(export g_hash_table_find)

;; extern guint g_hash_table_foreach_remove(GHashTable *hash_table, GHRFunc 
;;     func, gpointer user_data);
(define g_hash_table_foreach_remove
  (let ((~f #f))
    (lambda (hash_table func user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hash_table_foreach_remove"
            ffi:unsigned-int
            (list '* '* '*))))
      (let ((~hash_table (unwrap-GHashTable* hash_table))
            (~func ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
                    func))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~hash_table ~func ~user_data)))))
(export g_hash_table_foreach_remove)

;; extern guint g_hash_table_foreach_steal(GHashTable *hash_table, GHRFunc func
;;     , gpointer user_data);
(define g_hash_table_foreach_steal
  (let ((~f #f))
    (lambda (hash_table func user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hash_table_foreach_steal"
            ffi:unsigned-int
            (list '* '* '*))))
      (let ((~hash_table (unwrap-GHashTable* hash_table))
            (~func ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
                    func))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~hash_table ~func ~user_data)))))
(export g_hash_table_foreach_steal)

;; extern guint g_hash_table_size(GHashTable *hash_table);
(define g_hash_table_size
  (let ((~f #f))
    (lambda (hash_table)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hash_table_size"
            ffi:unsigned-int
            (list '*))))
      (let ((~hash_table (unwrap-GHashTable* hash_table)))
        (~f ~hash_table)))))
(export g_hash_table_size)

;; extern GList *g_hash_table_get_keys(GHashTable *hash_table);
(define g_hash_table_get_keys
  (let ((~f #f))
    (lambda (hash_table)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hash_table_get_keys"
            '*
            (list '*))))
      (let ((~hash_table (unwrap-GHashTable* hash_table)))
        (wrap-GList* (~f ~hash_table))))))
(export g_hash_table_get_keys)

;; extern GList *g_hash_table_get_values(GHashTable *hash_table);
(define g_hash_table_get_values
  (let ((~f #f))
    (lambda (hash_table)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hash_table_get_values"
            '*
            (list '*))))
      (let ((~hash_table (unwrap-GHashTable* hash_table)))
        (wrap-GList* (~f ~hash_table))))))
(export g_hash_table_get_values)

;; extern gpointer *g_hash_table_get_keys_as_array(GHashTable *hash_table, 
;;     guint *length);
(define g_hash_table_get_keys_as_array
  (let ((~f #f))
    (lambda (hash_table length)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hash_table_get_keys_as_array"
            '*
            (list '* '*))))
      (let ((~hash_table (unwrap-GHashTable* hash_table))
            (~length (unwrap~pointer length)))
        (wrap-gpointer* (~f ~hash_table ~length))))))
(export g_hash_table_get_keys_as_array)

;; extern void g_hash_table_iter_init(GHashTableIter *iter, GHashTable *
;;     hash_table);
(define g_hash_table_iter_init
  (let ((~f #f))
    (lambda (iter hash_table)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hash_table_iter_init"
            ffi:void
            (list '* '*))))
      (let ((~iter (unwrap-GHashTableIter* iter))
            (~hash_table (unwrap-GHashTable* hash_table)))
        (~f ~iter ~hash_table)))))
(export g_hash_table_iter_init)

;; extern gboolean g_hash_table_iter_next(GHashTableIter *iter, gpointer *key, 
;;     gpointer *value);
(define g_hash_table_iter_next
  (let ((~f #f))
    (lambda (iter key value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hash_table_iter_next"
            ffi:int
            (list '* '* '*))))
      (let ((~iter (unwrap-GHashTableIter* iter))
            (~key (unwrap-gpointer* key))
            (~value (unwrap-gpointer* value)))
        (~f ~iter ~key ~value)))))
(export g_hash_table_iter_next)

;; extern GHashTable *g_hash_table_iter_get_hash_table(GHashTableIter *iter);
(define g_hash_table_iter_get_hash_table
  (let ((~f #f))
    (lambda (iter)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hash_table_iter_get_hash_table"
            '*
            (list '*))))
      (let ((~iter (unwrap-GHashTableIter* iter)))
        (wrap-GHashTable* (~f ~iter))))))
(export g_hash_table_iter_get_hash_table)

;; extern void g_hash_table_iter_remove(GHashTableIter *iter);
(define g_hash_table_iter_remove
  (let ((~f #f))
    (lambda (iter)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hash_table_iter_remove"
            ffi:void
            (list '*))))
      (let ((~iter (unwrap-GHashTableIter* iter)))
        (~f ~iter)))))
(export g_hash_table_iter_remove)

;; extern void g_hash_table_iter_replace(GHashTableIter *iter, gpointer value)
;;     ;
(define g_hash_table_iter_replace
  (let ((~f #f))
    (lambda (iter value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hash_table_iter_replace"
            ffi:void
            (list '* '*))))
      (let ((~iter (unwrap-GHashTableIter* iter))
            (~value (unwrap-gpointer value)))
        (~f ~iter ~value)))))
(export g_hash_table_iter_replace)

;; extern void g_hash_table_iter_steal(GHashTableIter *iter);
(define g_hash_table_iter_steal
  (let ((~f #f))
    (lambda (iter)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hash_table_iter_steal"
            ffi:void
            (list '*))))
      (let ((~iter (unwrap-GHashTableIter* iter)))
        (~f ~iter)))))
(export g_hash_table_iter_steal)

;; extern GHashTable *g_hash_table_ref(GHashTable *hash_table);
(define g_hash_table_ref
  (let ((~f #f))
    (lambda (hash_table)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_hash_table_ref" '* (list '*))))
      (let ((~hash_table (unwrap-GHashTable* hash_table)))
        (wrap-GHashTable* (~f ~hash_table))))))
(export g_hash_table_ref)

;; extern void g_hash_table_unref(GHashTable *hash_table);
(define g_hash_table_unref
  (let ((~f #f))
    (lambda (hash_table)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hash_table_unref"
            ffi:void
            (list '*))))
      (let ((~hash_table (unwrap-GHashTable* hash_table)))
        (~f ~hash_table)))))
(export g_hash_table_unref)

;; extern gboolean g_str_equal(gconstpointer v1, gconstpointer v2);
(define g_str_equal
  (let ((~f #f))
    (lambda (v1 v2)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_str_equal" ffi:int (list '* '*))))
      (let ((~v1 (unwrap-gconstpointer v1))
            (~v2 (unwrap-gconstpointer v2)))
        (~f ~v1 ~v2)))))
(export g_str_equal)

;; extern guint g_str_hash(gconstpointer v);
(define g_str_hash
  (let ((~f #f))
    (lambda (v)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_str_hash"
            ffi:unsigned-int
            (list '*))))
      (let ((~v (unwrap-gconstpointer v))) (~f ~v)))))
(export g_str_hash)

;; extern gboolean g_int_equal(gconstpointer v1, gconstpointer v2);
(define g_int_equal
  (let ((~f #f))
    (lambda (v1 v2)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_int_equal" ffi:int (list '* '*))))
      (let ((~v1 (unwrap-gconstpointer v1))
            (~v2 (unwrap-gconstpointer v2)))
        (~f ~v1 ~v2)))))
(export g_int_equal)

;; extern guint g_int_hash(gconstpointer v);
(define g_int_hash
  (let ((~f #f))
    (lambda (v)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_int_hash"
            ffi:unsigned-int
            (list '*))))
      (let ((~v (unwrap-gconstpointer v))) (~f ~v)))))
(export g_int_hash)

;; extern gboolean g_int64_equal(gconstpointer v1, gconstpointer v2);
(define g_int64_equal
  (let ((~f #f))
    (lambda (v1 v2)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_int64_equal"
            ffi:int
            (list '* '*))))
      (let ((~v1 (unwrap-gconstpointer v1))
            (~v2 (unwrap-gconstpointer v2)))
        (~f ~v1 ~v2)))))
(export g_int64_equal)

;; extern guint g_int64_hash(gconstpointer v);
(define g_int64_hash
  (let ((~f #f))
    (lambda (v)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_int64_hash"
            ffi:unsigned-int
            (list '*))))
      (let ((~v (unwrap-gconstpointer v))) (~f ~v)))))
(export g_int64_hash)

;; extern gboolean g_double_equal(gconstpointer v1, gconstpointer v2);
(define g_double_equal
  (let ((~f #f))
    (lambda (v1 v2)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_double_equal"
            ffi:int
            (list '* '*))))
      (let ((~v1 (unwrap-gconstpointer v1))
            (~v2 (unwrap-gconstpointer v2)))
        (~f ~v1 ~v2)))))
(export g_double_equal)

;; extern guint g_double_hash(gconstpointer v);
(define g_double_hash
  (let ((~f #f))
    (lambda (v)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_double_hash"
            ffi:unsigned-int
            (list '*))))
      (let ((~v (unwrap-gconstpointer v))) (~f ~v)))))
(export g_double_hash)

;; extern guint g_direct_hash(gconstpointer v);
(define g_direct_hash
  (let ((~f #f))
    (lambda (v)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_direct_hash"
            ffi:unsigned-int
            (list '*))))
      (let ((~v (unwrap-gconstpointer v))) (~f ~v)))))
(export g_direct_hash)

;; extern gboolean g_direct_equal(gconstpointer v1, gconstpointer v2);
(define g_direct_equal
  (let ((~f #f))
    (lambda (v1 v2)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_direct_equal"
            ffi:int
            (list '* '*))))
      (let ((~v1 (unwrap-gconstpointer v1))
            (~v2 (unwrap-gconstpointer v2)))
        (~f ~v1 ~v2)))))
(export g_direct_equal)

;; typedef struct _GHmac GHmac;
(define GHmac-desc void)
(define GHmac*-desc (bs:pointer GHmac-desc))
(export GHmac*-desc)
(define-fh-pointer-type GHmac* GHmac*-desc)

;; extern GHmac *g_hmac_new(GChecksumType digest_type, const guchar *key, gsize
;;      key_len);
(define g_hmac_new
  (let ((~f #f))
    (lambda (digest_type key key_len)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hmac_new"
            '*
            (list ffi:int '* ffi:unsigned-long))))
      (let ((~digest_type (unwrap~fixed digest_type))
            (~key (unwrap~pointer key))
            (~key_len (unwrap~fixed key_len)))
        (wrap-GHmac* (~f ~digest_type ~key ~key_len))))))
(export g_hmac_new)

;; extern GHmac *g_hmac_copy(const GHmac *hmac);
(define g_hmac_copy
  (let ((~f #f))
    (lambda (hmac)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_hmac_copy" '* (list '*))))
      (let ((~hmac (unwrap-GHmac* hmac)))
        (wrap-GHmac* (~f ~hmac))))))
(export g_hmac_copy)

;; extern GHmac *g_hmac_ref(GHmac *hmac);
(define g_hmac_ref
  (let ((~f #f))
    (lambda (hmac)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_hmac_ref" '* (list '*))))
      (let ((~hmac (unwrap-GHmac* hmac)))
        (wrap-GHmac* (~f ~hmac))))))
(export g_hmac_ref)

;; extern void g_hmac_unref(GHmac *hmac);
(define g_hmac_unref
  (let ((~f #f))
    (lambda (hmac)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_hmac_unref" ffi:void (list '*))))
      (let ((~hmac (unwrap-GHmac* hmac))) (~f ~hmac)))))
(export g_hmac_unref)

;; extern void g_hmac_update(GHmac *hmac, const guchar *data, gssize length);
(define g_hmac_update
  (let ((~f #f))
    (lambda (hmac data length)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hmac_update"
            ffi:void
            (list '* '* ffi:long))))
      (let ((~hmac (unwrap-GHmac* hmac))
            (~data (unwrap~pointer data))
            (~length (unwrap~fixed length)))
        (~f ~hmac ~data ~length)))))
(export g_hmac_update)

;; extern const gchar *g_hmac_get_string(GHmac *hmac);
(define g_hmac_get_string
  (let ((~f #f))
    (lambda (hmac)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_hmac_get_string" '* (list '*))))
      (let ((~hmac (unwrap-GHmac* hmac))) (~f ~hmac)))))
(export g_hmac_get_string)

;; extern void g_hmac_get_digest(GHmac *hmac, guint8 *buffer, gsize *digest_len
;;     );
(define g_hmac_get_digest
  (let ((~f #f))
    (lambda (hmac buffer digest_len)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hmac_get_digest"
            ffi:void
            (list '* '* '*))))
      (let ((~hmac (unwrap-GHmac* hmac))
            (~buffer (unwrap~pointer buffer))
            (~digest_len (unwrap~pointer digest_len)))
        (~f ~hmac ~buffer ~digest_len)))))
(export g_hmac_get_digest)

;; extern gchar *g_compute_hmac_for_data(GChecksumType digest_type, const 
;;     guchar *key, gsize key_len, const guchar *data, gsize length);
(define g_compute_hmac_for_data
  (let ((~f #f))
    (lambda (digest_type key key_len data length)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_compute_hmac_for_data"
            '*
            (list ffi:int
                  '*
                  ffi:unsigned-long
                  '*
                  ffi:unsigned-long))))
      (let ((~digest_type (unwrap~fixed digest_type))
            (~key (unwrap~pointer key))
            (~key_len (unwrap~fixed key_len))
            (~data (unwrap~pointer data))
            (~length (unwrap~fixed length)))
        (~f ~digest_type ~key ~key_len ~data ~length)))))
(export g_compute_hmac_for_data)

;; extern gchar *g_compute_hmac_for_string(GChecksumType digest_type, const 
;;     guchar *key, gsize key_len, const gchar *str, gssize length);
(define g_compute_hmac_for_string
  (let ((~f #f))
    (lambda (digest_type key key_len str length)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_compute_hmac_for_string"
            '*
            (list ffi:int '* ffi:unsigned-long '* ffi:long))))
      (let ((~digest_type (unwrap~fixed digest_type))
            (~key (unwrap~pointer key))
            (~key_len (unwrap~fixed key_len))
            (~str (unwrap~pointer str))
            (~length (unwrap~fixed length)))
        (~f ~digest_type ~key ~key_len ~str ~length)))))
(export g_compute_hmac_for_string)

;; extern gchar *g_compute_hmac_for_bytes(GChecksumType digest_type, GBytes *
;;     key, GBytes *data);
(define g_compute_hmac_for_bytes
  (let ((~f #f))
    (lambda (digest_type key data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_compute_hmac_for_bytes"
            '*
            (list ffi:int '* '*))))
      (let ((~digest_type (unwrap~fixed digest_type))
            (~key (unwrap-GBytes* key))
            (~data (unwrap-GBytes* data)))
        (~f ~digest_type ~key ~data)))))
(export g_compute_hmac_for_bytes)

;; typedef struct _GHook GHook;
(define GHook-desc void)
(define GHook*-desc (bs:pointer (delay GHook-desc)))
(export GHook*-desc)
(define-fh-pointer-type GHook* GHook*-desc)

;; typedef struct _GHookList GHookList;
(define GHookList-desc void)
(define GHookList*-desc (bs:pointer (delay GHookList-desc)))
(export GHookList*-desc)
(define-fh-pointer-type GHookList* GHookList*-desc)

;; typedef gint (*GHookCompareFunc)(GHook *new_hook, GHook *sibling);
(define-fh-function/p GHookCompareFunc
  ffi:int (list (quote *) (quote *)))

;; typedef gboolean (*GHookFindFunc)(GHook *hook, gpointer data);
(define-fh-function/p GHookFindFunc
  ffi:int (list (quote *) (quote *)))

;; typedef void (*GHookMarshaller)(GHook *hook, gpointer marshal_data);
(define-fh-function/p GHookMarshaller
  ffi:void (list (quote *) (quote *)))

;; typedef gboolean (*GHookCheckMarshaller)(GHook *hook, gpointer marshal_data)
;;     ;
(define-fh-function/p GHookCheckMarshaller
  ffi:int (list (quote *) (quote *)))

;; typedef void (*GHookFunc)(gpointer data);
(define-fh-function/p GHookFunc
  ffi:void (list (quote *)))

;; typedef gboolean (*GHookCheckFunc)(gpointer data);
(define-fh-function/p GHookCheckFunc
  ffi:int (list (quote *)))

;; typedef void (*GHookFinalizeFunc)(GHookList *hook_list, GHook *hook);
(define-fh-function/p GHookFinalizeFunc
  ffi:void (list (quote *) (quote *)))

;; typedef enum {
;;   G_HOOK_FLAG_ACTIVE = 1<<0,
;;   G_HOOK_FLAG_IN_CALL = 1<<1,
;;   G_HOOK_FLAG_MASK = 0x0f,
;; } GHookFlagMask;
(define-fh-enum GHookFlagMask
  '((G_HOOK_FLAG_ACTIVE . 1)
    (G_HOOK_FLAG_IN_CALL . 2)
    (G_HOOK_FLAG_MASK . 15))
  )

;; struct _GHookList {
;;   gulong seq_id;
;;   guint hook_size : 16;
;;   guint is_setup : 1;
;;   GHook *hooks;
;;   gpointer dummy3;
;;   GHookFinalizeFunc finalize_hook;
;;   gpointer dummy[2];
;; };
(define struct-_GHookList-desc
  (bs:struct
    (list `(seq_id ,unsigned-long)
          `(hook_size ,unsigned-int ,16)
          `(is_setup ,unsigned-int ,1)
          `(hooks ,(bs:pointer (delay GHook*-desc)))
          `(dummy3 ,gpointer-desc)
          `(finalize_hook ,(bs:pointer void))
          `(dummy ,(bs:vector 2 gpointer-desc)))))
(export struct-_GHookList-desc)
(define-fh-compound-type/p struct-_GHookList struct-_GHookList-desc)
(set! GHookList-desc struct-_GHookList-desc)
(define-fh-compound-type GHookList GHookList-desc)

;; struct _GHook {
;;   gpointer data;
;;   GHook *next;
;;   GHook *prev;
;;   guint ref_count;
;;   gulong hook_id;
;;   guint flags;
;;   gpointer func;
;;   GDestroyNotify destroy;
;; };
(define struct-_GHook-desc
  (bs:struct
    (list `(data ,gpointer-desc)
          `(next ,(bs:pointer (delay GHook*-desc)))
          `(prev ,(bs:pointer (delay GHook*-desc)))
          `(ref_count ,unsigned-int)
          `(hook_id ,unsigned-long)
          `(flags ,unsigned-int)
          `(func ,gpointer-desc)
          `(destroy ,(bs:pointer void)))))
(export struct-_GHook-desc)
(define-fh-compound-type/p struct-_GHook struct-_GHook-desc)
(set! GHook-desc struct-_GHook-desc)
(define-fh-compound-type GHook GHook-desc)

;; extern void g_hook_list_init(GHookList *hook_list, guint hook_size);
(define g_hook_list_init
  (let ((~f #f))
    (lambda (hook_list hook_size)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hook_list_init"
            ffi:void
            (list '* ffi:unsigned-int))))
      (let ((~hook_list (unwrap-GHookList* hook_list))
            (~hook_size (unwrap~fixed hook_size)))
        (~f ~hook_list ~hook_size)))))
(export g_hook_list_init)

;; extern void g_hook_list_clear(GHookList *hook_list);
(define g_hook_list_clear
  (let ((~f #f))
    (lambda (hook_list)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hook_list_clear"
            ffi:void
            (list '*))))
      (let ((~hook_list (unwrap-GHookList* hook_list)))
        (~f ~hook_list)))))
(export g_hook_list_clear)

;; extern GHook *g_hook_alloc(GHookList *hook_list);
(define g_hook_alloc
  (let ((~f #f))
    (lambda (hook_list)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_hook_alloc" '* (list '*))))
      (let ((~hook_list (unwrap-GHookList* hook_list)))
        (wrap-GHook* (~f ~hook_list))))))
(export g_hook_alloc)

;; extern void g_hook_free(GHookList *hook_list, GHook *hook);
(define g_hook_free
  (let ((~f #f))
    (lambda (hook_list hook)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hook_free"
            ffi:void
            (list '* '*))))
      (let ((~hook_list (unwrap-GHookList* hook_list))
            (~hook (unwrap-GHook* hook)))
        (~f ~hook_list ~hook)))))
(export g_hook_free)

;; extern GHook *g_hook_ref(GHookList *hook_list, GHook *hook);
(define g_hook_ref
  (let ((~f #f))
    (lambda (hook_list hook)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_hook_ref" '* (list '* '*))))
      (let ((~hook_list (unwrap-GHookList* hook_list))
            (~hook (unwrap-GHook* hook)))
        (wrap-GHook* (~f ~hook_list ~hook))))))
(export g_hook_ref)

;; extern void g_hook_unref(GHookList *hook_list, GHook *hook);
(define g_hook_unref
  (let ((~f #f))
    (lambda (hook_list hook)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hook_unref"
            ffi:void
            (list '* '*))))
      (let ((~hook_list (unwrap-GHookList* hook_list))
            (~hook (unwrap-GHook* hook)))
        (~f ~hook_list ~hook)))))
(export g_hook_unref)

;; extern gboolean g_hook_destroy(GHookList *hook_list, gulong hook_id);
(define g_hook_destroy
  (let ((~f #f))
    (lambda (hook_list hook_id)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hook_destroy"
            ffi:int
            (list '* ffi:unsigned-long))))
      (let ((~hook_list (unwrap-GHookList* hook_list))
            (~hook_id (unwrap~fixed hook_id)))
        (~f ~hook_list ~hook_id)))))
(export g_hook_destroy)

;; extern void g_hook_destroy_link(GHookList *hook_list, GHook *hook);
(define g_hook_destroy_link
  (let ((~f #f))
    (lambda (hook_list hook)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hook_destroy_link"
            ffi:void
            (list '* '*))))
      (let ((~hook_list (unwrap-GHookList* hook_list))
            (~hook (unwrap-GHook* hook)))
        (~f ~hook_list ~hook)))))
(export g_hook_destroy_link)

;; extern void g_hook_prepend(GHookList *hook_list, GHook *hook);
(define g_hook_prepend
  (let ((~f #f))
    (lambda (hook_list hook)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hook_prepend"
            ffi:void
            (list '* '*))))
      (let ((~hook_list (unwrap-GHookList* hook_list))
            (~hook (unwrap-GHook* hook)))
        (~f ~hook_list ~hook)))))
(export g_hook_prepend)

;; extern void g_hook_insert_before(GHookList *hook_list, GHook *sibling, GHook
;;      *hook);
(define g_hook_insert_before
  (let ((~f #f))
    (lambda (hook_list sibling hook)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hook_insert_before"
            ffi:void
            (list '* '* '*))))
      (let ((~hook_list (unwrap-GHookList* hook_list))
            (~sibling (unwrap-GHook* sibling))
            (~hook (unwrap-GHook* hook)))
        (~f ~hook_list ~sibling ~hook)))))
(export g_hook_insert_before)

;; extern void g_hook_insert_sorted(GHookList *hook_list, GHook *hook, 
;;     GHookCompareFunc func);
(define g_hook_insert_sorted
  (let ((~f #f))
    (lambda (hook_list hook func)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hook_insert_sorted"
            ffi:void
            (list '* '* '*))))
      (let ((~hook_list (unwrap-GHookList* hook_list))
            (~hook (unwrap-GHook* hook))
            (~func ((make-ftn-arg-unwrapper ffi:int (list '* '*))
                    func)))
        (~f ~hook_list ~hook ~func)))))
(export g_hook_insert_sorted)

;; extern GHook *g_hook_get(GHookList *hook_list, gulong hook_id);
(define g_hook_get
  (let ((~f #f))
    (lambda (hook_list hook_id)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hook_get"
            '*
            (list '* ffi:unsigned-long))))
      (let ((~hook_list (unwrap-GHookList* hook_list))
            (~hook_id (unwrap~fixed hook_id)))
        (wrap-GHook* (~f ~hook_list ~hook_id))))))
(export g_hook_get)

;; extern GHook *g_hook_find(GHookList *hook_list, gboolean need_valids, 
;;     GHookFindFunc func, gpointer data);
(define g_hook_find
  (let ((~f #f))
    (lambda (hook_list need_valids func data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hook_find"
            '*
            (list '* ffi:int '* '*))))
      (let ((~hook_list (unwrap-GHookList* hook_list))
            (~need_valids (unwrap~fixed need_valids))
            (~func ((make-ftn-arg-unwrapper ffi:int (list '* '*))
                    func))
            (~data (unwrap-gpointer data)))
        (wrap-GHook*
          (~f ~hook_list ~need_valids ~func ~data))))))
(export g_hook_find)

;; extern GHook *g_hook_find_data(GHookList *hook_list, gboolean need_valids, 
;;     gpointer data);
(define g_hook_find_data
  (let ((~f #f))
    (lambda (hook_list need_valids data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hook_find_data"
            '*
            (list '* ffi:int '*))))
      (let ((~hook_list (unwrap-GHookList* hook_list))
            (~need_valids (unwrap~fixed need_valids))
            (~data (unwrap-gpointer data)))
        (wrap-GHook* (~f ~hook_list ~need_valids ~data))))))
(export g_hook_find_data)

;; extern GHook *g_hook_find_func(GHookList *hook_list, gboolean need_valids, 
;;     gpointer func);
(define g_hook_find_func
  (let ((~f #f))
    (lambda (hook_list need_valids func)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hook_find_func"
            '*
            (list '* ffi:int '*))))
      (let ((~hook_list (unwrap-GHookList* hook_list))
            (~need_valids (unwrap~fixed need_valids))
            (~func (unwrap-gpointer func)))
        (wrap-GHook* (~f ~hook_list ~need_valids ~func))))))
(export g_hook_find_func)

;; extern GHook *g_hook_find_func_data(GHookList *hook_list, gboolean 
;;     need_valids, gpointer func, gpointer data);
(define g_hook_find_func_data
  (let ((~f #f))
    (lambda (hook_list need_valids func data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hook_find_func_data"
            '*
            (list '* ffi:int '* '*))))
      (let ((~hook_list (unwrap-GHookList* hook_list))
            (~need_valids (unwrap~fixed need_valids))
            (~func (unwrap-gpointer func))
            (~data (unwrap-gpointer data)))
        (wrap-GHook*
          (~f ~hook_list ~need_valids ~func ~data))))))
(export g_hook_find_func_data)

;; extern GHook *g_hook_first_valid(GHookList *hook_list, gboolean 
;;     may_be_in_call);
(define g_hook_first_valid
  (let ((~f #f))
    (lambda (hook_list may_be_in_call)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hook_first_valid"
            '*
            (list '* ffi:int))))
      (let ((~hook_list (unwrap-GHookList* hook_list))
            (~may_be_in_call (unwrap~fixed may_be_in_call)))
        (wrap-GHook* (~f ~hook_list ~may_be_in_call))))))
(export g_hook_first_valid)

;; extern GHook *g_hook_next_valid(GHookList *hook_list, GHook *hook, gboolean 
;;     may_be_in_call);
(define g_hook_next_valid
  (let ((~f #f))
    (lambda (hook_list hook may_be_in_call)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hook_next_valid"
            '*
            (list '* '* ffi:int))))
      (let ((~hook_list (unwrap-GHookList* hook_list))
            (~hook (unwrap-GHook* hook))
            (~may_be_in_call (unwrap~fixed may_be_in_call)))
        (wrap-GHook*
          (~f ~hook_list ~hook ~may_be_in_call))))))
(export g_hook_next_valid)

;; extern gint g_hook_compare_ids(GHook *new_hook, GHook *sibling);
(define g_hook_compare_ids
  (let ((~f #f))
    (lambda (new_hook sibling)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hook_compare_ids"
            ffi:int
            (list '* '*))))
      (let ((~new_hook (unwrap-GHook* new_hook))
            (~sibling (unwrap-GHook* sibling)))
        (~f ~new_hook ~sibling)))))
(export g_hook_compare_ids)

;; extern void g_hook_list_invoke(GHookList *hook_list, gboolean may_recurse);
(define g_hook_list_invoke
  (let ((~f #f))
    (lambda (hook_list may_recurse)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hook_list_invoke"
            ffi:void
            (list '* ffi:int))))
      (let ((~hook_list (unwrap-GHookList* hook_list))
            (~may_recurse (unwrap~fixed may_recurse)))
        (~f ~hook_list ~may_recurse)))))
(export g_hook_list_invoke)

;; extern void g_hook_list_invoke_check(GHookList *hook_list, gboolean 
;;     may_recurse);
(define g_hook_list_invoke_check
  (let ((~f #f))
    (lambda (hook_list may_recurse)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hook_list_invoke_check"
            ffi:void
            (list '* ffi:int))))
      (let ((~hook_list (unwrap-GHookList* hook_list))
            (~may_recurse (unwrap~fixed may_recurse)))
        (~f ~hook_list ~may_recurse)))))
(export g_hook_list_invoke_check)

;; extern void g_hook_list_marshal(GHookList *hook_list, gboolean may_recurse, 
;;     GHookMarshaller marshaller, gpointer marshal_data);
(define g_hook_list_marshal
  (let ((~f #f))
    (lambda (hook_list may_recurse marshaller marshal_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hook_list_marshal"
            ffi:void
            (list '* ffi:int '* '*))))
      (let ((~hook_list (unwrap-GHookList* hook_list))
            (~may_recurse (unwrap~fixed may_recurse))
            (~marshaller
              ((make-ftn-arg-unwrapper ffi:void (list '* '*))
               marshaller))
            (~marshal_data (unwrap-gpointer marshal_data)))
        (~f ~hook_list
            ~may_recurse
            ~marshaller
            ~marshal_data)))))
(export g_hook_list_marshal)

;; extern void g_hook_list_marshal_check(GHookList *hook_list, gboolean 
;;     may_recurse, GHookCheckMarshaller marshaller, gpointer marshal_data);
(define g_hook_list_marshal_check
  (let ((~f #f))
    (lambda (hook_list may_recurse marshaller marshal_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hook_list_marshal_check"
            ffi:void
            (list '* ffi:int '* '*))))
      (let ((~hook_list (unwrap-GHookList* hook_list))
            (~may_recurse (unwrap~fixed may_recurse))
            (~marshaller
              ((make-ftn-arg-unwrapper ffi:int (list '* '*))
               marshaller))
            (~marshal_data (unwrap-gpointer marshal_data)))
        (~f ~hook_list
            ~may_recurse
            ~marshaller
            ~marshal_data)))))
(export g_hook_list_marshal_check)

;; extern gboolean g_hostname_is_non_ascii(const gchar *hostname);
(define g_hostname_is_non_ascii
  (let ((~f #f))
    (lambda (hostname)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hostname_is_non_ascii"
            ffi:int
            (list '*))))
      (let ((~hostname (unwrap~pointer hostname)))
        (~f ~hostname)))))
(export g_hostname_is_non_ascii)

;; extern gboolean g_hostname_is_ascii_encoded(const gchar *hostname);
(define g_hostname_is_ascii_encoded
  (let ((~f #f))
    (lambda (hostname)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hostname_is_ascii_encoded"
            ffi:int
            (list '*))))
      (let ((~hostname (unwrap~pointer hostname)))
        (~f ~hostname)))))
(export g_hostname_is_ascii_encoded)

;; extern gboolean g_hostname_is_ip_address(const gchar *hostname);
(define g_hostname_is_ip_address
  (let ((~f #f))
    (lambda (hostname)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hostname_is_ip_address"
            ffi:int
            (list '*))))
      (let ((~hostname (unwrap~pointer hostname)))
        (~f ~hostname)))))
(export g_hostname_is_ip_address)

;; extern gchar *g_hostname_to_ascii(const gchar *hostname);
(define g_hostname_to_ascii
  (let ((~f #f))
    (lambda (hostname)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_hostname_to_ascii" '* (list '*))))
      (let ((~hostname (unwrap~pointer hostname)))
        (~f ~hostname)))))
(export g_hostname_to_ascii)

;; extern gchar *g_hostname_to_unicode(const gchar *hostname);
(define g_hostname_to_unicode
  (let ((~f #f))
    (lambda (hostname)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_hostname_to_unicode"
            '*
            (list '*))))
      (let ((~hostname (unwrap~pointer hostname)))
        (~f ~hostname)))))
(export g_hostname_to_unicode)

;; typedef struct _GPollFD GPollFD;
(define GPollFD-desc void)
(define GPollFD*-desc (bs:pointer (delay GPollFD-desc)))
(export GPollFD*-desc)
(define-fh-pointer-type GPollFD* GPollFD*-desc)

;; typedef gint (*GPollFunc)(GPollFD *ufds, guint nfsd, gint timeout_);
(define-fh-function/p GPollFunc
  ffi:int (list (quote *) ffi:unsigned-int ffi:int))

;; struct _GPollFD {
;;   gint fd;
;;   gushort events;
;;   gushort revents;
;; };
(define struct-_GPollFD-desc
  (bs:struct
    (list `(fd ,int)
          `(events ,unsigned-short)
          `(revents ,unsigned-short))))
(export struct-_GPollFD-desc)
(define-fh-compound-type/p struct-_GPollFD struct-_GPollFD-desc)
(set! GPollFD-desc struct-_GPollFD-desc)
(define-fh-compound-type GPollFD GPollFD-desc)

;; extern gint g_poll(GPollFD *fds, guint nfds, gint timeout);
(define g_poll
  (let ((~f #f))
    (lambda (fds nfds timeout)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_poll"
            ffi:int
            (list '* ffi:unsigned-int ffi:int))))
      (let ((~fds (unwrap-GPollFD* fds))
            (~nfds (unwrap~fixed nfds))
            (~timeout (unwrap~fixed timeout)))
        (~f ~fds ~nfds ~timeout)))))
(export g_poll)

;; typedef struct _GSList GSList;
(define GSList-desc void)
(define GSList*-desc (bs:pointer (delay GSList-desc)))
(export GSList*-desc)
(define-fh-pointer-type GSList* GSList*-desc)

;; struct _GSList {
;;   gpointer data;
;;   GSList *next;
;; };
(define struct-_GSList-desc
  (bs:struct
    (list `(data ,gpointer-desc)
          `(next ,(bs:pointer (delay GSList*-desc))))))
(export struct-_GSList-desc)
(define-fh-compound-type/p struct-_GSList struct-_GSList-desc)
(set! GSList-desc struct-_GSList-desc)
(define-fh-compound-type GSList GSList-desc)

;; extern GSList *g_slist_alloc(void);
(define g_slist_alloc
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_slist_alloc" '* (list))))
      (let () (wrap-GSList* (~f))))))
(export g_slist_alloc)

;; extern void g_slist_free(GSList *list);
(define g_slist_free
  (let ((~f #f))
    (lambda (list)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_slist_free" ffi:void (list '*))))
      (let ((~list (unwrap-GSList* list))) (~f ~list)))))
(export g_slist_free)

;; extern void g_slist_free_1(GSList *list);
(define g_slist_free_1
  (let ((~f #f))
    (lambda (list)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_slist_free_1"
            ffi:void
            (list '*))))
      (let ((~list (unwrap-GSList* list))) (~f ~list)))))
(export g_slist_free_1)

;; extern void g_slist_free_full(GSList *list, GDestroyNotify free_func);
(define g_slist_free_full
  (let ((~f #f))
    (lambda (list free_func)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_slist_free_full"
            ffi:void
            (list '* '*))))
      (let ((~list (unwrap-GSList* list))
            (~free_func
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               free_func)))
        (~f ~list ~free_func)))))
(export g_slist_free_full)

;; extern GSList *g_slist_append(GSList *list, gpointer data);
(define g_slist_append
  (let ((~f #f))
    (lambda (list data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_slist_append" '* (list '* '*))))
      (let ((~list (unwrap-GSList* list))
            (~data (unwrap-gpointer data)))
        (wrap-GSList* (~f ~list ~data))))))
(export g_slist_append)

;; extern GSList *g_slist_prepend(GSList *list, gpointer data);
(define g_slist_prepend
  (let ((~f #f))
    (lambda (list data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_slist_prepend" '* (list '* '*))))
      (let ((~list (unwrap-GSList* list))
            (~data (unwrap-gpointer data)))
        (wrap-GSList* (~f ~list ~data))))))
(export g_slist_prepend)

;; extern GSList *g_slist_insert(GSList *list, gpointer data, gint position);
(define g_slist_insert
  (let ((~f #f))
    (lambda (list data position)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_slist_insert"
            '*
            (list '* '* ffi:int))))
      (let ((~list (unwrap-GSList* list))
            (~data (unwrap-gpointer data))
            (~position (unwrap~fixed position)))
        (wrap-GSList* (~f ~list ~data ~position))))))
(export g_slist_insert)

;; extern GSList *g_slist_insert_sorted(GSList *list, gpointer data, 
;;     GCompareFunc func);
(define g_slist_insert_sorted
  (let ((~f #f))
    (lambda (list data func)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_slist_insert_sorted"
            '*
            (list '* '* '*))))
      (let ((~list (unwrap-GSList* list))
            (~data (unwrap-gpointer data))
            (~func ((make-ftn-arg-unwrapper ffi:int (list '* '*))
                    func)))
        (wrap-GSList* (~f ~list ~data ~func))))))
(export g_slist_insert_sorted)

;; extern GSList *g_slist_insert_sorted_with_data(GSList *list, gpointer data, 
;;     GCompareDataFunc func, gpointer user_data);
(define g_slist_insert_sorted_with_data
  (let ((~f #f))
    (lambda (list data func user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_slist_insert_sorted_with_data"
            '*
            (list '* '* '* '*))))
      (let ((~list (unwrap-GSList* list))
            (~data (unwrap-gpointer data))
            (~func ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
                    func))
            (~user_data (unwrap-gpointer user_data)))
        (wrap-GSList* (~f ~list ~data ~func ~user_data))))))
(export g_slist_insert_sorted_with_data)

;; extern GSList *g_slist_insert_before(GSList *slist, GSList *sibling, 
;;     gpointer data);
(define g_slist_insert_before
  (let ((~f #f))
    (lambda (slist sibling data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_slist_insert_before"
            '*
            (list '* '* '*))))
      (let ((~slist (unwrap-GSList* slist))
            (~sibling (unwrap-GSList* sibling))
            (~data (unwrap-gpointer data)))
        (wrap-GSList* (~f ~slist ~sibling ~data))))))
(export g_slist_insert_before)

;; extern GSList *g_slist_concat(GSList *list1, GSList *list2);
(define g_slist_concat
  (let ((~f #f))
    (lambda (list1 list2)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_slist_concat" '* (list '* '*))))
      (let ((~list1 (unwrap-GSList* list1))
            (~list2 (unwrap-GSList* list2)))
        (wrap-GSList* (~f ~list1 ~list2))))))
(export g_slist_concat)

;; extern GSList *g_slist_remove(GSList *list, gconstpointer data);
(define g_slist_remove
  (let ((~f #f))
    (lambda (list data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_slist_remove" '* (list '* '*))))
      (let ((~list (unwrap-GSList* list))
            (~data (unwrap-gconstpointer data)))
        (wrap-GSList* (~f ~list ~data))))))
(export g_slist_remove)

;; extern GSList *g_slist_remove_all(GSList *list, gconstpointer data);
(define g_slist_remove_all
  (let ((~f #f))
    (lambda (list data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_slist_remove_all"
            '*
            (list '* '*))))
      (let ((~list (unwrap-GSList* list))
            (~data (unwrap-gconstpointer data)))
        (wrap-GSList* (~f ~list ~data))))))
(export g_slist_remove_all)

;; extern GSList *g_slist_remove_link(GSList *list, GSList *link_);
(define g_slist_remove_link
  (let ((~f #f))
    (lambda (list link_)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_slist_remove_link"
            '*
            (list '* '*))))
      (let ((~list (unwrap-GSList* list))
            (~link_ (unwrap-GSList* link_)))
        (wrap-GSList* (~f ~list ~link_))))))
(export g_slist_remove_link)

;; extern GSList *g_slist_delete_link(GSList *list, GSList *link_);
(define g_slist_delete_link
  (let ((~f #f))
    (lambda (list link_)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_slist_delete_link"
            '*
            (list '* '*))))
      (let ((~list (unwrap-GSList* list))
            (~link_ (unwrap-GSList* link_)))
        (wrap-GSList* (~f ~list ~link_))))))
(export g_slist_delete_link)

;; extern GSList *g_slist_reverse(GSList *list);
(define g_slist_reverse
  (let ((~f #f))
    (lambda (list)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_slist_reverse" '* (list '*))))
      (let ((~list (unwrap-GSList* list)))
        (wrap-GSList* (~f ~list))))))
(export g_slist_reverse)

;; extern GSList *g_slist_copy(GSList *list);
(define g_slist_copy
  (let ((~f #f))
    (lambda (list)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_slist_copy" '* (list '*))))
      (let ((~list (unwrap-GSList* list)))
        (wrap-GSList* (~f ~list))))))
(export g_slist_copy)

;; extern GSList *g_slist_copy_deep(GSList *list, GCopyFunc func, gpointer 
;;     user_data);
(define g_slist_copy_deep
  (let ((~f #f))
    (lambda (list func user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_slist_copy_deep"
            '*
            (list '* '* '*))))
      (let ((~list (unwrap-GSList* list))
            (~func ((make-ftn-arg-unwrapper '* (list '* '*)) func))
            (~user_data (unwrap-gpointer user_data)))
        (wrap-GSList* (~f ~list ~func ~user_data))))))
(export g_slist_copy_deep)

;; extern GSList *g_slist_nth(GSList *list, guint n);
(define g_slist_nth
  (let ((~f #f))
    (lambda (list n)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_slist_nth"
            '*
            (list '* ffi:unsigned-int))))
      (let ((~list (unwrap-GSList* list))
            (~n (unwrap~fixed n)))
        (wrap-GSList* (~f ~list ~n))))))
(export g_slist_nth)

;; extern GSList *g_slist_find(GSList *list, gconstpointer data);
(define g_slist_find
  (let ((~f #f))
    (lambda (list data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_slist_find" '* (list '* '*))))
      (let ((~list (unwrap-GSList* list))
            (~data (unwrap-gconstpointer data)))
        (wrap-GSList* (~f ~list ~data))))))
(export g_slist_find)

;; extern GSList *g_slist_find_custom(GSList *list, gconstpointer data, 
;;     GCompareFunc func);
(define g_slist_find_custom
  (let ((~f #f))
    (lambda (list data func)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_slist_find_custom"
            '*
            (list '* '* '*))))
      (let ((~list (unwrap-GSList* list))
            (~data (unwrap-gconstpointer data))
            (~func ((make-ftn-arg-unwrapper ffi:int (list '* '*))
                    func)))
        (wrap-GSList* (~f ~list ~data ~func))))))
(export g_slist_find_custom)

;; extern gint g_slist_position(GSList *list, GSList *llink);
(define g_slist_position
  (let ((~f #f))
    (lambda (list llink)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_slist_position"
            ffi:int
            (list '* '*))))
      (let ((~list (unwrap-GSList* list))
            (~llink (unwrap-GSList* llink)))
        (~f ~list ~llink)))))
(export g_slist_position)

;; extern gint g_slist_index(GSList *list, gconstpointer data);
(define g_slist_index
  (let ((~f #f))
    (lambda (list data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_slist_index"
            ffi:int
            (list '* '*))))
      (let ((~list (unwrap-GSList* list))
            (~data (unwrap-gconstpointer data)))
        (~f ~list ~data)))))
(export g_slist_index)

;; extern GSList *g_slist_last(GSList *list);
(define g_slist_last
  (let ((~f #f))
    (lambda (list)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_slist_last" '* (list '*))))
      (let ((~list (unwrap-GSList* list)))
        (wrap-GSList* (~f ~list))))))
(export g_slist_last)

;; extern guint g_slist_length(GSList *list);
(define g_slist_length
  (let ((~f #f))
    (lambda (list)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_slist_length"
            ffi:unsigned-int
            (list '*))))
      (let ((~list (unwrap-GSList* list))) (~f ~list)))))
(export g_slist_length)

;; extern void g_slist_foreach(GSList *list, GFunc func, gpointer user_data);
(define g_slist_foreach
  (let ((~f #f))
    (lambda (list func user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_slist_foreach"
            ffi:void
            (list '* '* '*))))
      (let ((~list (unwrap-GSList* list))
            (~func ((make-ftn-arg-unwrapper ffi:void (list '* '*))
                    func))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~list ~func ~user_data)))))
(export g_slist_foreach)

;; extern GSList *g_slist_sort(GSList *list, GCompareFunc compare_func);
(define g_slist_sort
  (let ((~f #f))
    (lambda (list compare_func)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_slist_sort" '* (list '* '*))))
      (let ((~list (unwrap-GSList* list))
            (~compare_func
              ((make-ftn-arg-unwrapper ffi:int (list '* '*))
               compare_func)))
        (wrap-GSList* (~f ~list ~compare_func))))))
(export g_slist_sort)

;; extern GSList *g_slist_sort_with_data(GSList *list, GCompareDataFunc 
;;     compare_func, gpointer user_data);
(define g_slist_sort_with_data
  (let ((~f #f))
    (lambda (list compare_func user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_slist_sort_with_data"
            '*
            (list '* '* '*))))
      (let ((~list (unwrap-GSList* list))
            (~compare_func
              ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
               compare_func))
            (~user_data (unwrap-gpointer user_data)))
        (wrap-GSList*
          (~f ~list ~compare_func ~user_data))))))
(export g_slist_sort_with_data)

;; extern gpointer g_slist_nth_data(GSList *list, guint n);
(define g_slist_nth_data
  (let ((~f #f))
    (lambda (list n)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_slist_nth_data"
            '*
            (list '* ffi:unsigned-int))))
      (let ((~list (unwrap-GSList* list))
            (~n (unwrap~fixed n)))
        (wrap-gpointer (~f ~list ~n))))))
(export g_slist_nth_data)

;; typedef enum {
;;   G_IO_IN = 1,
;;   G_IO_OUT = 4,
;;   G_IO_PRI = 2,
;;   G_IO_ERR = 8,
;;   G_IO_HUP = 16,
;;   G_IO_NVAL = 32,
;; } GIOCondition;
(define-fh-enum GIOCondition
  '((G_IO_IN . 1)
    (G_IO_OUT . 4)
    (G_IO_PRI . 2)
    (G_IO_ERR . 8)
    (G_IO_HUP . 16)
    (G_IO_NVAL . 32))
  )

;; typedef struct _GMainContext GMainContext;
(define GMainContext-desc void)
(define GMainContext*-desc (bs:pointer GMainContext-desc))
(export GMainContext*-desc)
(define-fh-pointer-type GMainContext* GMainContext*-desc)

;; typedef struct _GMainLoop GMainLoop;
(define GMainLoop-desc void)
(define GMainLoop*-desc (bs:pointer GMainLoop-desc))
(export GMainLoop*-desc)
(define-fh-pointer-type GMainLoop* GMainLoop*-desc)

;; typedef struct _GSource GSource;
(define GSource-desc void)
(define GSource*-desc (bs:pointer (delay GSource-desc)))
(export GSource*-desc)
(define-fh-pointer-type GSource* GSource*-desc)

;; typedef struct _GSourcePrivate GSourcePrivate;
(define GSourcePrivate-desc void)
(define GSourcePrivate*-desc (bs:pointer GSourcePrivate-desc))
(export GSourcePrivate*-desc)
(define-fh-pointer-type GSourcePrivate* GSourcePrivate*-desc)

;; typedef struct _GSourceCallbackFuncs GSourceCallbackFuncs;
(define GSourceCallbackFuncs-desc void)
(define GSourceCallbackFuncs*-desc (bs:pointer (delay GSourceCallbackFuncs-desc)))
(export GSourceCallbackFuncs*-desc)
(define-fh-pointer-type GSourceCallbackFuncs* GSourceCallbackFuncs*-desc)

;; typedef struct _GSourceFuncs GSourceFuncs;
(define GSourceFuncs-desc void)
(define GSourceFuncs*-desc (bs:pointer (delay GSourceFuncs-desc)))
(export GSourceFuncs*-desc)
(define-fh-pointer-type GSourceFuncs* GSourceFuncs*-desc)

;; typedef gboolean (*GSourceFunc)(gpointer user_data);
(define-fh-function/p GSourceFunc
  ffi:int (list (quote *)))

;; typedef void (*GChildWatchFunc)(GPid pid, gint status, gpointer user_data);
(define-fh-function/p GChildWatchFunc
  ffi:void (list ffi:int ffi:int (quote *)))

;; struct _GSource {
;;   /*< private >*/
;;   gpointer callback_data;
;;   GSourceCallbackFuncs *callback_funcs;
;;   const GSourceFuncs *source_funcs;
;;   guint ref_count;
;;   GMainContext *context;
;;   gint priority;
;;   guint flags;
;;   guint source_id;
;;   GSList *poll_fds;
;;   GSource *prev;
;;   GSource *next;
;;   char *name;
;;   GSourcePrivate *priv;
;; };
(define struct-_GSource-desc
  (bs:struct
    (list `(callback_data ,gpointer-desc)
          `(callback_funcs
             ,(bs:pointer (delay GSourceCallbackFuncs*-desc)))
          `(source_funcs
             ,(bs:pointer (delay GSourceFuncs*-desc)))
          `(ref_count ,unsigned-int)
          `(context
             ,(bs:pointer (delay GMainContext*-desc)))
          `(priority ,int)
          `(flags ,unsigned-int)
          `(source_id ,unsigned-int)
          `(poll_fds ,(bs:pointer (delay GSList*-desc)))
          `(prev ,(bs:pointer (delay GSource*-desc)))
          `(next ,(bs:pointer (delay GSource*-desc)))
          `(name ,(bs:pointer int))
          `(priv ,(bs:pointer (delay GSourcePrivate*-desc))))))
(export struct-_GSource-desc)
(define-fh-compound-type/p struct-_GSource struct-_GSource-desc)
(set! GSource-desc struct-_GSource-desc)
(define-fh-compound-type GSource GSource-desc)

;; struct _GSourceCallbackFuncs {
;;   void (*ref)(gpointer cb_data);
;;   void (*unref)(gpointer cb_data);
;;   void (*get)(gpointer cb_data, GSource *source, GSourceFunc *func, gpointer
;;        *data);
;; };
(define struct-_GSourceCallbackFuncs-desc
  (bs:struct
    (list `(ref ,(bs:pointer void))
          `(unref ,(bs:pointer void))
          `(get ,(bs:pointer void)))))
(export struct-_GSourceCallbackFuncs-desc)
(define-fh-compound-type/p struct-_GSourceCallbackFuncs struct-_GSourceCallbackFuncs-desc)
(set! GSourceCallbackFuncs-desc struct-_GSourceCallbackFuncs-desc)
(define-fh-compound-type GSourceCallbackFuncs GSourceCallbackFuncs-desc)

;; typedef void (*GSourceDummyMarshal)(void);
(define-fh-function/p GSourceDummyMarshal
  ffi:void (list ffi:void))

;; struct _GSourceFuncs {
;;   gboolean (*prepare)(GSource *source, gint *timeout_);
;;   gboolean (*check)(GSource *source);
;;   gboolean (*dispatch)(GSource *source, GSourceFunc callback, gpointer 
;;       user_data);
;;   void (*finalize)(GSource *source); /* Can be NULL */
;;   /*< private >*/
;;   /* For use by g_source_set_closure */
;;   GSourceFunc closure_callback;
;;   GSourceDummyMarshal closure_marshal; 
;;       /* Really is of type GClosureMarshal */
;; };
(define struct-_GSourceFuncs-desc
  (bs:struct
    (list `(prepare ,(bs:pointer void))
          `(check ,(bs:pointer void))
          `(dispatch ,(bs:pointer void))
          `(finalize ,(bs:pointer void))
          `(closure_callback ,(bs:pointer void))
          `(closure_marshal ,(bs:pointer void)))))
(export struct-_GSourceFuncs-desc)
(define-fh-compound-type/p struct-_GSourceFuncs struct-_GSourceFuncs-desc)
(set! GSourceFuncs-desc struct-_GSourceFuncs-desc)
(define-fh-compound-type GSourceFuncs GSourceFuncs-desc)

;; extern GMainContext *g_main_context_new(void);
(define g_main_context_new
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_main_context_new" '* (list))))
      (let () (wrap-GMainContext* (~f))))))
(export g_main_context_new)

;; extern GMainContext *g_main_context_ref(GMainContext *context);
(define g_main_context_ref
  (let ((~f #f))
    (lambda (context)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_main_context_ref" '* (list '*))))
      (let ((~context (unwrap-GMainContext* context)))
        (wrap-GMainContext* (~f ~context))))))
(export g_main_context_ref)

;; extern void g_main_context_unref(GMainContext *context);
(define g_main_context_unref
  (let ((~f #f))
    (lambda (context)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_main_context_unref"
            ffi:void
            (list '*))))
      (let ((~context (unwrap-GMainContext* context)))
        (~f ~context)))))
(export g_main_context_unref)

;; extern GMainContext *g_main_context_default(void);
(define g_main_context_default
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_main_context_default" '* (list))))
      (let () (wrap-GMainContext* (~f))))))
(export g_main_context_default)

;; extern gboolean g_main_context_iteration(GMainContext *context, gboolean 
;;     may_block);
(define g_main_context_iteration
  (let ((~f #f))
    (lambda (context may_block)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_main_context_iteration"
            ffi:int
            (list '* ffi:int))))
      (let ((~context (unwrap-GMainContext* context))
            (~may_block (unwrap~fixed may_block)))
        (~f ~context ~may_block)))))
(export g_main_context_iteration)

;; extern gboolean g_main_context_pending(GMainContext *context);
(define g_main_context_pending
  (let ((~f #f))
    (lambda (context)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_main_context_pending"
            ffi:int
            (list '*))))
      (let ((~context (unwrap-GMainContext* context)))
        (~f ~context)))))
(export g_main_context_pending)

;; extern GSource *g_main_context_find_source_by_id(GMainContext *context, 
;;     guint source_id);
(define g_main_context_find_source_by_id
  (let ((~f #f))
    (lambda (context source_id)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_main_context_find_source_by_id"
            '*
            (list '* ffi:unsigned-int))))
      (let ((~context (unwrap-GMainContext* context))
            (~source_id (unwrap~fixed source_id)))
        (wrap-GSource* (~f ~context ~source_id))))))
(export g_main_context_find_source_by_id)

;; extern GSource *g_main_context_find_source_by_user_data(GMainContext *
;;     context, gpointer user_data);
(define g_main_context_find_source_by_user_data
  (let ((~f #f))
    (lambda (context user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_main_context_find_source_by_user_data"
            '*
            (list '* '*))))
      (let ((~context (unwrap-GMainContext* context))
            (~user_data (unwrap-gpointer user_data)))
        (wrap-GSource* (~f ~context ~user_data))))))
(export g_main_context_find_source_by_user_data)

;; extern GSource *g_main_context_find_source_by_funcs_user_data(GMainContext *
;;     context, GSourceFuncs *funcs, gpointer user_data);
(define g_main_context_find_source_by_funcs_user_data
  (let ((~f #f))
    (lambda (context funcs user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_main_context_find_source_by_funcs_user_data"
            '*
            (list '* '* '*))))
      (let ((~context (unwrap-GMainContext* context))
            (~funcs (unwrap-GSourceFuncs* funcs))
            (~user_data (unwrap-gpointer user_data)))
        (wrap-GSource* (~f ~context ~funcs ~user_data))))))
(export g_main_context_find_source_by_funcs_user_data)

;; extern void g_main_context_wakeup(GMainContext *context);
(define g_main_context_wakeup
  (let ((~f #f))
    (lambda (context)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_main_context_wakeup"
            ffi:void
            (list '*))))
      (let ((~context (unwrap-GMainContext* context)))
        (~f ~context)))))
(export g_main_context_wakeup)

;; extern gboolean g_main_context_acquire(GMainContext *context);
(define g_main_context_acquire
  (let ((~f #f))
    (lambda (context)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_main_context_acquire"
            ffi:int
            (list '*))))
      (let ((~context (unwrap-GMainContext* context)))
        (~f ~context)))))
(export g_main_context_acquire)

;; extern void g_main_context_release(GMainContext *context);
(define g_main_context_release
  (let ((~f #f))
    (lambda (context)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_main_context_release"
            ffi:void
            (list '*))))
      (let ((~context (unwrap-GMainContext* context)))
        (~f ~context)))))
(export g_main_context_release)

;; extern gboolean g_main_context_is_owner(GMainContext *context);
(define g_main_context_is_owner
  (let ((~f #f))
    (lambda (context)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_main_context_is_owner"
            ffi:int
            (list '*))))
      (let ((~context (unwrap-GMainContext* context)))
        (~f ~context)))))
(export g_main_context_is_owner)

;; extern gboolean g_main_context_wait(GMainContext *context, GCond *cond, 
;;     GMutex *mutex);
(define g_main_context_wait
  (let ((~f #f))
    (lambda (context cond mutex)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_main_context_wait"
            ffi:int
            (list '* '* '*))))
      (let ((~context (unwrap-GMainContext* context))
            (~cond (unwrap-GCond* cond))
            (~mutex (unwrap-GMutex* mutex)))
        (~f ~context ~cond ~mutex)))))
(export g_main_context_wait)

;; extern gboolean g_main_context_prepare(GMainContext *context, gint *priority
;;     );
(define g_main_context_prepare
  (let ((~f #f))
    (lambda (context priority)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_main_context_prepare"
            ffi:int
            (list '* '*))))
      (let ((~context (unwrap-GMainContext* context))
            (~priority (unwrap~pointer priority)))
        (~f ~context ~priority)))))
(export g_main_context_prepare)

;; extern gint g_main_context_query(GMainContext *context, gint max_priority, 
;;     gint *timeout_, GPollFD *fds, gint n_fds);
(define g_main_context_query
  (let ((~f #f))
    (lambda (context max_priority timeout_ fds n_fds)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_main_context_query"
            ffi:int
            (list '* ffi:int '* '* ffi:int))))
      (let ((~context (unwrap-GMainContext* context))
            (~max_priority (unwrap~fixed max_priority))
            (~timeout_ (unwrap~pointer timeout_))
            (~fds (unwrap-GPollFD* fds))
            (~n_fds (unwrap~fixed n_fds)))
        (~f ~context ~max_priority ~timeout_ ~fds ~n_fds)))))
(export g_main_context_query)

;; extern gboolean g_main_context_check(GMainContext *context, gint 
;;     max_priority, GPollFD *fds, gint n_fds);
(define g_main_context_check
  (let ((~f #f))
    (lambda (context max_priority fds n_fds)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_main_context_check"
            ffi:int
            (list '* ffi:int '* ffi:int))))
      (let ((~context (unwrap-GMainContext* context))
            (~max_priority (unwrap~fixed max_priority))
            (~fds (unwrap-GPollFD* fds))
            (~n_fds (unwrap~fixed n_fds)))
        (~f ~context ~max_priority ~fds ~n_fds)))))
(export g_main_context_check)

;; extern void g_main_context_dispatch(GMainContext *context);
(define g_main_context_dispatch
  (let ((~f #f))
    (lambda (context)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_main_context_dispatch"
            ffi:void
            (list '*))))
      (let ((~context (unwrap-GMainContext* context)))
        (~f ~context)))))
(export g_main_context_dispatch)

;; extern void g_main_context_set_poll_func(GMainContext *context, GPollFunc 
;;     func);
(define g_main_context_set_poll_func
  (let ((~f #f))
    (lambda (context func)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_main_context_set_poll_func"
            ffi:void
            (list '* '*))))
      (let ((~context (unwrap-GMainContext* context))
            (~func ((make-ftn-arg-unwrapper
                      ffi:int
                      (list '* ffi:unsigned-int ffi:int))
                    func)))
        (~f ~context ~func)))))
(export g_main_context_set_poll_func)

;; extern GPollFunc g_main_context_get_poll_func(GMainContext *context);
(define g_main_context_get_poll_func
  (let ((~f #f))
    (lambda (context)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_main_context_get_poll_func"
            '*
            (list '*))))
      (let ((~context (unwrap-GMainContext* context)))
        (~f ~context)))))
(export g_main_context_get_poll_func)

;; extern void g_main_context_add_poll(GMainContext *context, GPollFD *fd, gint
;;      priority);
(define g_main_context_add_poll
  (let ((~f #f))
    (lambda (context fd priority)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_main_context_add_poll"
            ffi:void
            (list '* '* ffi:int))))
      (let ((~context (unwrap-GMainContext* context))
            (~fd (unwrap-GPollFD* fd))
            (~priority (unwrap~fixed priority)))
        (~f ~context ~fd ~priority)))))
(export g_main_context_add_poll)

;; extern void g_main_context_remove_poll(GMainContext *context, GPollFD *fd);
(define g_main_context_remove_poll
  (let ((~f #f))
    (lambda (context fd)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_main_context_remove_poll"
            ffi:void
            (list '* '*))))
      (let ((~context (unwrap-GMainContext* context))
            (~fd (unwrap-GPollFD* fd)))
        (~f ~context ~fd)))))
(export g_main_context_remove_poll)

;; extern gint g_main_depth(void);
(define g_main_depth
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_main_depth" ffi:int (list))))
      (let () (~f)))))
(export g_main_depth)

;; extern GSource *g_main_current_source(void);
(define g_main_current_source
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_main_current_source" '* (list))))
      (let () (wrap-GSource* (~f))))))
(export g_main_current_source)

;; extern void g_main_context_push_thread_default(GMainContext *context);
(define g_main_context_push_thread_default
  (let ((~f #f))
    (lambda (context)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_main_context_push_thread_default"
            ffi:void
            (list '*))))
      (let ((~context (unwrap-GMainContext* context)))
        (~f ~context)))))
(export g_main_context_push_thread_default)

;; extern void g_main_context_pop_thread_default(GMainContext *context);
(define g_main_context_pop_thread_default
  (let ((~f #f))
    (lambda (context)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_main_context_pop_thread_default"
            ffi:void
            (list '*))))
      (let ((~context (unwrap-GMainContext* context)))
        (~f ~context)))))
(export g_main_context_pop_thread_default)

;; extern GMainContext *g_main_context_get_thread_default(void);
(define g_main_context_get_thread_default
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_main_context_get_thread_default"
            '*
            (list))))
      (let () (wrap-GMainContext* (~f))))))
(export g_main_context_get_thread_default)

;; extern GMainContext *g_main_context_ref_thread_default(void);
(define g_main_context_ref_thread_default
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_main_context_ref_thread_default"
            '*
            (list))))
      (let () (wrap-GMainContext* (~f))))))
(export g_main_context_ref_thread_default)

;; extern GMainLoop *g_main_loop_new(GMainContext *context, gboolean is_running
;;     );
(define g_main_loop_new
  (let ((~f #f))
    (lambda (context is_running)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_main_loop_new"
            '*
            (list '* ffi:int))))
      (let ((~context (unwrap-GMainContext* context))
            (~is_running (unwrap~fixed is_running)))
        (wrap-GMainLoop* (~f ~context ~is_running))))))
(export g_main_loop_new)

;; extern void g_main_loop_run(GMainLoop *loop);
(define g_main_loop_run
  (let ((~f #f))
    (lambda (loop)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_main_loop_run"
            ffi:void
            (list '*))))
      (let ((~loop (unwrap-GMainLoop* loop)))
        (~f ~loop)))))
(export g_main_loop_run)

;; extern void g_main_loop_quit(GMainLoop *loop);
(define g_main_loop_quit
  (let ((~f #f))
    (lambda (loop)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_main_loop_quit"
            ffi:void
            (list '*))))
      (let ((~loop (unwrap-GMainLoop* loop)))
        (~f ~loop)))))
(export g_main_loop_quit)

;; extern GMainLoop *g_main_loop_ref(GMainLoop *loop);
(define g_main_loop_ref
  (let ((~f #f))
    (lambda (loop)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_main_loop_ref" '* (list '*))))
      (let ((~loop (unwrap-GMainLoop* loop)))
        (wrap-GMainLoop* (~f ~loop))))))
(export g_main_loop_ref)

;; extern void g_main_loop_unref(GMainLoop *loop);
(define g_main_loop_unref
  (let ((~f #f))
    (lambda (loop)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_main_loop_unref"
            ffi:void
            (list '*))))
      (let ((~loop (unwrap-GMainLoop* loop)))
        (~f ~loop)))))
(export g_main_loop_unref)

;; extern gboolean g_main_loop_is_running(GMainLoop *loop);
(define g_main_loop_is_running
  (let ((~f #f))
    (lambda (loop)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_main_loop_is_running"
            ffi:int
            (list '*))))
      (let ((~loop (unwrap-GMainLoop* loop)))
        (~f ~loop)))))
(export g_main_loop_is_running)

;; extern GMainContext *g_main_loop_get_context(GMainLoop *loop);
(define g_main_loop_get_context
  (let ((~f #f))
    (lambda (loop)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_main_loop_get_context"
            '*
            (list '*))))
      (let ((~loop (unwrap-GMainLoop* loop)))
        (wrap-GMainContext* (~f ~loop))))))
(export g_main_loop_get_context)

;; extern GSource *g_source_new(GSourceFuncs *source_funcs, guint struct_size)
;;     ;
(define g_source_new
  (let ((~f #f))
    (lambda (source_funcs struct_size)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_source_new"
            '*
            (list '* ffi:unsigned-int))))
      (let ((~source_funcs
              (unwrap-GSourceFuncs* source_funcs))
            (~struct_size (unwrap~fixed struct_size)))
        (wrap-GSource* (~f ~source_funcs ~struct_size))))))
(export g_source_new)

;; extern GSource *g_source_ref(GSource *source);
(define g_source_ref
  (let ((~f #f))
    (lambda (source)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_source_ref" '* (list '*))))
      (let ((~source (unwrap-GSource* source)))
        (wrap-GSource* (~f ~source))))))
(export g_source_ref)

;; extern void g_source_unref(GSource *source);
(define g_source_unref
  (let ((~f #f))
    (lambda (source)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_source_unref"
            ffi:void
            (list '*))))
      (let ((~source (unwrap-GSource* source)))
        (~f ~source)))))
(export g_source_unref)

;; extern guint g_source_attach(GSource *source, GMainContext *context);
(define g_source_attach
  (let ((~f #f))
    (lambda (source context)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_source_attach"
            ffi:unsigned-int
            (list '* '*))))
      (let ((~source (unwrap-GSource* source))
            (~context (unwrap-GMainContext* context)))
        (~f ~source ~context)))))
(export g_source_attach)

;; extern void g_source_destroy(GSource *source);
(define g_source_destroy
  (let ((~f #f))
    (lambda (source)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_source_destroy"
            ffi:void
            (list '*))))
      (let ((~source (unwrap-GSource* source)))
        (~f ~source)))))
(export g_source_destroy)

;; extern void g_source_set_priority(GSource *source, gint priority);
(define g_source_set_priority
  (let ((~f #f))
    (lambda (source priority)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_source_set_priority"
            ffi:void
            (list '* ffi:int))))
      (let ((~source (unwrap-GSource* source))
            (~priority (unwrap~fixed priority)))
        (~f ~source ~priority)))))
(export g_source_set_priority)

;; extern gint g_source_get_priority(GSource *source);
(define g_source_get_priority
  (let ((~f #f))
    (lambda (source)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_source_get_priority"
            ffi:int
            (list '*))))
      (let ((~source (unwrap-GSource* source)))
        (~f ~source)))))
(export g_source_get_priority)

;; extern void g_source_set_can_recurse(GSource *source, gboolean can_recurse)
;;     ;
(define g_source_set_can_recurse
  (let ((~f #f))
    (lambda (source can_recurse)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_source_set_can_recurse"
            ffi:void
            (list '* ffi:int))))
      (let ((~source (unwrap-GSource* source))
            (~can_recurse (unwrap~fixed can_recurse)))
        (~f ~source ~can_recurse)))))
(export g_source_set_can_recurse)

;; extern gboolean g_source_get_can_recurse(GSource *source);
(define g_source_get_can_recurse
  (let ((~f #f))
    (lambda (source)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_source_get_can_recurse"
            ffi:int
            (list '*))))
      (let ((~source (unwrap-GSource* source)))
        (~f ~source)))))
(export g_source_get_can_recurse)

;; extern guint g_source_get_id(GSource *source);
(define g_source_get_id
  (let ((~f #f))
    (lambda (source)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_source_get_id"
            ffi:unsigned-int
            (list '*))))
      (let ((~source (unwrap-GSource* source)))
        (~f ~source)))))
(export g_source_get_id)

;; extern GMainContext *g_source_get_context(GSource *source);
(define g_source_get_context
  (let ((~f #f))
    (lambda (source)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_source_get_context"
            '*
            (list '*))))
      (let ((~source (unwrap-GSource* source)))
        (wrap-GMainContext* (~f ~source))))))
(export g_source_get_context)

;; extern void g_source_set_callback(GSource *source, GSourceFunc func, 
;;     gpointer data, GDestroyNotify notify);
(define g_source_set_callback
  (let ((~f #f))
    (lambda (source func data notify)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_source_set_callback"
            ffi:void
            (list '* '* '* '*))))
      (let ((~source (unwrap-GSource* source))
            (~func ((make-ftn-arg-unwrapper ffi:int (list '*)) func))
            (~data (unwrap-gpointer data))
            (~notify
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               notify)))
        (~f ~source ~func ~data ~notify)))))
(export g_source_set_callback)

;; extern void g_source_set_funcs(GSource *source, GSourceFuncs *funcs);
(define g_source_set_funcs
  (let ((~f #f))
    (lambda (source funcs)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_source_set_funcs"
            ffi:void
            (list '* '*))))
      (let ((~source (unwrap-GSource* source))
            (~funcs (unwrap-GSourceFuncs* funcs)))
        (~f ~source ~funcs)))))
(export g_source_set_funcs)

;; extern gboolean g_source_is_destroyed(GSource *source);
(define g_source_is_destroyed
  (let ((~f #f))
    (lambda (source)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_source_is_destroyed"
            ffi:int
            (list '*))))
      (let ((~source (unwrap-GSource* source)))
        (~f ~source)))))
(export g_source_is_destroyed)

;; extern void g_source_set_name(GSource *source, const char *name);
(define g_source_set_name
  (let ((~f #f))
    (lambda (source name)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_source_set_name"
            ffi:void
            (list '* '*))))
      (let ((~source (unwrap-GSource* source))
            (~name (unwrap~pointer name)))
        (~f ~source ~name)))))
(export g_source_set_name)

;; extern const char *g_source_get_name(GSource *source);
(define g_source_get_name
  (let ((~f #f))
    (lambda (source)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_source_get_name" '* (list '*))))
      (let ((~source (unwrap-GSource* source)))
        (~f ~source)))))
(export g_source_get_name)

;; extern void g_source_set_name_by_id(guint tag, const char *name);
(define g_source_set_name_by_id
  (let ((~f #f))
    (lambda (tag name)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_source_set_name_by_id"
            ffi:void
            (list ffi:unsigned-int '*))))
      (let ((~tag (unwrap~fixed tag))
            (~name (unwrap~pointer name)))
        (~f ~tag ~name)))))
(export g_source_set_name_by_id)

;; extern void g_source_set_ready_time(GSource *source, gint64 ready_time);
(define g_source_set_ready_time
  (let ((~f #f))
    (lambda (source ready_time)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_source_set_ready_time"
            ffi:void
            (list '* ffi:long))))
      (let ((~source (unwrap-GSource* source))
            (~ready_time (unwrap~fixed ready_time)))
        (~f ~source ~ready_time)))))
(export g_source_set_ready_time)

;; extern gint64 g_source_get_ready_time(GSource *source);
(define g_source_get_ready_time
  (let ((~f #f))
    (lambda (source)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_source_get_ready_time"
            ffi:long
            (list '*))))
      (let ((~source (unwrap-GSource* source)))
        (~f ~source)))))
(export g_source_get_ready_time)

;; extern gpointer g_source_add_unix_fd(GSource *source, gint fd, GIOCondition 
;;     events);
(define g_source_add_unix_fd
  (let ((~f #f))
    (lambda (source fd events)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_source_add_unix_fd"
            '*
            (list '* ffi:int ffi:int))))
      (let ((~source (unwrap-GSource* source))
            (~fd (unwrap~fixed fd))
            (~events (unwrap~fixed events)))
        (wrap-gpointer (~f ~source ~fd ~events))))))
(export g_source_add_unix_fd)

;; extern void g_source_modify_unix_fd(GSource *source, gpointer tag, 
;;     GIOCondition new_events);
(define g_source_modify_unix_fd
  (let ((~f #f))
    (lambda (source tag new_events)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_source_modify_unix_fd"
            ffi:void
            (list '* '* ffi:int))))
      (let ((~source (unwrap-GSource* source))
            (~tag (unwrap-gpointer tag))
            (~new_events (unwrap~fixed new_events)))
        (~f ~source ~tag ~new_events)))))
(export g_source_modify_unix_fd)

;; extern void g_source_remove_unix_fd(GSource *source, gpointer tag);
(define g_source_remove_unix_fd
  (let ((~f #f))
    (lambda (source tag)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_source_remove_unix_fd"
            ffi:void
            (list '* '*))))
      (let ((~source (unwrap-GSource* source))
            (~tag (unwrap-gpointer tag)))
        (~f ~source ~tag)))))
(export g_source_remove_unix_fd)

;; extern GIOCondition g_source_query_unix_fd(GSource *source, gpointer tag);
(define g_source_query_unix_fd
  (let ((~f #f))
    (lambda (source tag)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_source_query_unix_fd"
            ffi:int
            (list '* '*))))
      (let ((~source (unwrap-GSource* source))
            (~tag (unwrap-gpointer tag)))
        (~f ~source ~tag)))))
(export g_source_query_unix_fd)

;; extern void g_source_set_callback_indirect(GSource *source, gpointer 
;;     callback_data, GSourceCallbackFuncs *callback_funcs);
(define g_source_set_callback_indirect
  (let ((~f #f))
    (lambda (source callback_data callback_funcs)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_source_set_callback_indirect"
            ffi:void
            (list '* '* '*))))
      (let ((~source (unwrap-GSource* source))
            (~callback_data (unwrap-gpointer callback_data))
            (~callback_funcs
              (unwrap-GSourceCallbackFuncs* callback_funcs)))
        (~f ~source ~callback_data ~callback_funcs)))))
(export g_source_set_callback_indirect)

;; extern void g_source_add_poll(GSource *source, GPollFD *fd);
(define g_source_add_poll
  (let ((~f #f))
    (lambda (source fd)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_source_add_poll"
            ffi:void
            (list '* '*))))
      (let ((~source (unwrap-GSource* source))
            (~fd (unwrap-GPollFD* fd)))
        (~f ~source ~fd)))))
(export g_source_add_poll)

;; extern void g_source_remove_poll(GSource *source, GPollFD *fd);
(define g_source_remove_poll
  (let ((~f #f))
    (lambda (source fd)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_source_remove_poll"
            ffi:void
            (list '* '*))))
      (let ((~source (unwrap-GSource* source))
            (~fd (unwrap-GPollFD* fd)))
        (~f ~source ~fd)))))
(export g_source_remove_poll)

;; extern void g_source_add_child_source(GSource *source, GSource *child_source
;;     );
(define g_source_add_child_source
  (let ((~f #f))
    (lambda (source child_source)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_source_add_child_source"
            ffi:void
            (list '* '*))))
      (let ((~source (unwrap-GSource* source))
            (~child_source (unwrap-GSource* child_source)))
        (~f ~source ~child_source)))))
(export g_source_add_child_source)

;; extern void g_source_remove_child_source(GSource *source, GSource *
;;     child_source);
(define g_source_remove_child_source
  (let ((~f #f))
    (lambda (source child_source)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_source_remove_child_source"
            ffi:void
            (list '* '*))))
      (let ((~source (unwrap-GSource* source))
            (~child_source (unwrap-GSource* child_source)))
        (~f ~source ~child_source)))))
(export g_source_remove_child_source)

;; extern void g_source_get_current_time(GSource *source, GTimeVal *timeval);
(define g_source_get_current_time
  (let ((~f #f))
    (lambda (source timeval)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_source_get_current_time"
            ffi:void
            (list '* '*))))
      (let ((~source (unwrap-GSource* source))
            (~timeval (unwrap-GTimeVal* timeval)))
        (~f ~source ~timeval)))))
(export g_source_get_current_time)

;; extern gint64 g_source_get_time(GSource *source);
(define g_source_get_time
  (let ((~f #f))
    (lambda (source)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_source_get_time"
            ffi:long
            (list '*))))
      (let ((~source (unwrap-GSource* source)))
        (~f ~source)))))
(export g_source_get_time)

;; extern GSource *g_idle_source_new(void);
(define g_idle_source_new
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_idle_source_new" '* (list))))
      (let () (wrap-GSource* (~f))))))
(export g_idle_source_new)

;; extern GSource *g_child_watch_source_new(GPid pid);
(define g_child_watch_source_new
  (let ((~f #f))
    (lambda (pid)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_child_watch_source_new"
            '*
            (list ffi:int))))
      (let ((~pid (unwrap~fixed pid)))
        (wrap-GSource* (~f ~pid))))))
(export g_child_watch_source_new)

;; extern GSource *g_timeout_source_new(guint interval);
(define g_timeout_source_new
  (let ((~f #f))
    (lambda (interval)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_timeout_source_new"
            '*
            (list ffi:unsigned-int))))
      (let ((~interval (unwrap~fixed interval)))
        (wrap-GSource* (~f ~interval))))))
(export g_timeout_source_new)

;; extern GSource *g_timeout_source_new_seconds(guint interval);
(define g_timeout_source_new_seconds
  (let ((~f #f))
    (lambda (interval)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_timeout_source_new_seconds"
            '*
            (list ffi:unsigned-int))))
      (let ((~interval (unwrap~fixed interval)))
        (wrap-GSource* (~f ~interval))))))
(export g_timeout_source_new_seconds)

;; extern void g_get_current_time(GTimeVal *result);
(define g_get_current_time
  (let ((~f #f))
    (lambda (result)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_get_current_time"
            ffi:void
            (list '*))))
      (let ((~result (unwrap-GTimeVal* result)))
        (~f ~result)))))
(export g_get_current_time)

;; extern gint64 g_get_monotonic_time(void);
(define g_get_monotonic_time
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_get_monotonic_time"
            ffi:long
            (list))))
      (let () (~f)))))
(export g_get_monotonic_time)

;; extern gint64 g_get_real_time(void);
(define g_get_real_time
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_get_real_time" ffi:long (list))))
      (let () (~f)))))
(export g_get_real_time)

;; extern gboolean g_source_remove(guint tag);
(define g_source_remove
  (let ((~f #f))
    (lambda (tag)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_source_remove"
            ffi:int
            (list ffi:unsigned-int))))
      (let ((~tag (unwrap~fixed tag))) (~f ~tag)))))
(export g_source_remove)

;; extern gboolean g_source_remove_by_user_data(gpointer user_data);
(define g_source_remove_by_user_data
  (let ((~f #f))
    (lambda (user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_source_remove_by_user_data"
            ffi:int
            (list '*))))
      (let ((~user_data (unwrap-gpointer user_data)))
        (~f ~user_data)))))
(export g_source_remove_by_user_data)

;; extern gboolean g_source_remove_by_funcs_user_data(GSourceFuncs *funcs, 
;;     gpointer user_data);
(define g_source_remove_by_funcs_user_data
  (let ((~f #f))
    (lambda (funcs user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_source_remove_by_funcs_user_data"
            ffi:int
            (list '* '*))))
      (let ((~funcs (unwrap-GSourceFuncs* funcs))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~funcs ~user_data)))))
(export g_source_remove_by_funcs_user_data)

;; extern guint g_timeout_add_full(gint priority, guint interval, GSourceFunc 
;;     function, gpointer data, GDestroyNotify notify);
(define g_timeout_add_full
  (let ((~f #f))
    (lambda (priority interval function data notify)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_timeout_add_full"
            ffi:unsigned-int
            (list ffi:int ffi:unsigned-int '* '* '*))))
      (let ((~priority (unwrap~fixed priority))
            (~interval (unwrap~fixed interval))
            (~function
              ((make-ftn-arg-unwrapper ffi:int (list '*))
               function))
            (~data (unwrap-gpointer data))
            (~notify
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               notify)))
        (~f ~priority ~interval ~function ~data ~notify)))))
(export g_timeout_add_full)

;; extern guint g_timeout_add(guint interval, GSourceFunc function, gpointer 
;;     data);
(define g_timeout_add
  (let ((~f #f))
    (lambda (interval function data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_timeout_add"
            ffi:unsigned-int
            (list ffi:unsigned-int '* '*))))
      (let ((~interval (unwrap~fixed interval))
            (~function
              ((make-ftn-arg-unwrapper ffi:int (list '*))
               function))
            (~data (unwrap-gpointer data)))
        (~f ~interval ~function ~data)))))
(export g_timeout_add)

;; extern guint g_timeout_add_seconds_full(gint priority, guint interval, 
;;     GSourceFunc function, gpointer data, GDestroyNotify notify);
(define g_timeout_add_seconds_full
  (let ((~f #f))
    (lambda (priority interval function data notify)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_timeout_add_seconds_full"
            ffi:unsigned-int
            (list ffi:int ffi:unsigned-int '* '* '*))))
      (let ((~priority (unwrap~fixed priority))
            (~interval (unwrap~fixed interval))
            (~function
              ((make-ftn-arg-unwrapper ffi:int (list '*))
               function))
            (~data (unwrap-gpointer data))
            (~notify
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               notify)))
        (~f ~priority ~interval ~function ~data ~notify)))))
(export g_timeout_add_seconds_full)

;; extern guint g_timeout_add_seconds(guint interval, GSourceFunc function, 
;;     gpointer data);
(define g_timeout_add_seconds
  (let ((~f #f))
    (lambda (interval function data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_timeout_add_seconds"
            ffi:unsigned-int
            (list ffi:unsigned-int '* '*))))
      (let ((~interval (unwrap~fixed interval))
            (~function
              ((make-ftn-arg-unwrapper ffi:int (list '*))
               function))
            (~data (unwrap-gpointer data)))
        (~f ~interval ~function ~data)))))
(export g_timeout_add_seconds)

;; extern guint g_child_watch_add_full(gint priority, GPid pid, GChildWatchFunc
;;      function, gpointer data, GDestroyNotify notify);
(define g_child_watch_add_full
  (let ((~f #f))
    (lambda (priority pid function data notify)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_child_watch_add_full"
            ffi:unsigned-int
            (list ffi:int ffi:int '* '* '*))))
      (let ((~priority (unwrap~fixed priority))
            (~pid (unwrap~fixed pid))
            (~function
              ((make-ftn-arg-unwrapper
                 ffi:void
                 (list ffi:int ffi:int '*))
               function))
            (~data (unwrap-gpointer data))
            (~notify
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               notify)))
        (~f ~priority ~pid ~function ~data ~notify)))))
(export g_child_watch_add_full)

;; extern guint g_child_watch_add(GPid pid, GChildWatchFunc function, gpointer 
;;     data);
(define g_child_watch_add
  (let ((~f #f))
    (lambda (pid function data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_child_watch_add"
            ffi:unsigned-int
            (list ffi:int '* '*))))
      (let ((~pid (unwrap~fixed pid))
            (~function
              ((make-ftn-arg-unwrapper
                 ffi:void
                 (list ffi:int ffi:int '*))
               function))
            (~data (unwrap-gpointer data)))
        (~f ~pid ~function ~data)))))
(export g_child_watch_add)

;; extern guint g_idle_add(GSourceFunc function, gpointer data);
(define g_idle_add
  (let ((~f #f))
    (lambda (function data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_idle_add"
            ffi:unsigned-int
            (list '* '*))))
      (let ((~function
              ((make-ftn-arg-unwrapper ffi:int (list '*))
               function))
            (~data (unwrap-gpointer data)))
        (~f ~function ~data)))))
(export g_idle_add)

;; extern guint g_idle_add_full(gint priority, GSourceFunc function, gpointer 
;;     data, GDestroyNotify notify);
(define g_idle_add_full
  (let ((~f #f))
    (lambda (priority function data notify)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_idle_add_full"
            ffi:unsigned-int
            (list ffi:int '* '* '*))))
      (let ((~priority (unwrap~fixed priority))
            (~function
              ((make-ftn-arg-unwrapper ffi:int (list '*))
               function))
            (~data (unwrap-gpointer data))
            (~notify
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               notify)))
        (~f ~priority ~function ~data ~notify)))))
(export g_idle_add_full)

;; extern gboolean g_idle_remove_by_data(gpointer data);
(define g_idle_remove_by_data
  (let ((~f #f))
    (lambda (data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_idle_remove_by_data"
            ffi:int
            (list '*))))
      (let ((~data (unwrap-gpointer data))) (~f ~data)))))
(export g_idle_remove_by_data)

;; extern void g_main_context_invoke_full(GMainContext *context, gint priority
;;     , GSourceFunc function, gpointer data, GDestroyNotify notify);
(define g_main_context_invoke_full
  (let ((~f #f))
    (lambda (context priority function data notify)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_main_context_invoke_full"
            ffi:void
            (list '* ffi:int '* '* '*))))
      (let ((~context (unwrap-GMainContext* context))
            (~priority (unwrap~fixed priority))
            (~function
              ((make-ftn-arg-unwrapper ffi:int (list '*))
               function))
            (~data (unwrap-gpointer data))
            (~notify
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               notify)))
        (~f ~context ~priority ~function ~data ~notify)))))
(export g_main_context_invoke_full)

;; extern void g_main_context_invoke(GMainContext *context, GSourceFunc 
;;     function, gpointer data);
(define g_main_context_invoke
  (let ((~f #f))
    (lambda (context function data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_main_context_invoke"
            ffi:void
            (list '* '* '*))))
      (let ((~context (unwrap-GMainContext* context))
            (~function
              ((make-ftn-arg-unwrapper ffi:int (list '*))
               function))
            (~data (unwrap-gpointer data)))
        (~f ~context ~function ~data)))))
(export g_main_context_invoke)

;; extern GSourceFuncs g_timeout_funcs;
(define g_timeout_funcs
  (let* ((addr (dynamic-pointer
                 "g_timeout_funcs"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer GSourceFuncs-desc))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_timeout_funcs)

;; extern GSourceFuncs g_child_watch_funcs;
(define g_child_watch_funcs
  (let* ((addr (dynamic-pointer
                 "g_child_watch_funcs"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer GSourceFuncs-desc))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_child_watch_funcs)

;; extern GSourceFuncs g_idle_funcs;
(define g_idle_funcs
  (let* ((addr (dynamic-pointer "g_idle_funcs" (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer GSourceFuncs-desc))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_idle_funcs)

;; extern GSourceFuncs g_unix_signal_funcs;
(define g_unix_signal_funcs
  (let* ((addr (dynamic-pointer
                 "g_unix_signal_funcs"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer GSourceFuncs-desc))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_unix_signal_funcs)

;; extern GSourceFuncs g_unix_fd_source_funcs;
(define g_unix_fd_source_funcs
  (let* ((addr (dynamic-pointer
                 "g_unix_fd_source_funcs"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer GSourceFuncs-desc))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_unix_fd_source_funcs)

;; typedef guint32 gunichar;
(define gunichar-desc unsigned-int)
(export gunichar-desc)
(define unwrap-gunichar unwrap~fixed)
(define wrap-gunichar identity)
(export gunichar-desc unwrap-gunichar wrap-gunichar)

;; typedef guint16 gunichar2;
(define gunichar2-desc unsigned-short)
(export gunichar2-desc)
(define unwrap-gunichar2 unwrap~fixed)
(define wrap-gunichar2 identity)
(export gunichar2-desc unwrap-gunichar2 wrap-gunichar2)

;; typedef enum {
;;   G_UNICODE_CONTROL,
;;   G_UNICODE_FORMAT,
;;   G_UNICODE_UNASSIGNED,
;;   G_UNICODE_PRIVATE_USE,
;;   G_UNICODE_SURROGATE,
;;   G_UNICODE_LOWERCASE_LETTER,
;;   G_UNICODE_MODIFIER_LETTER,
;;   G_UNICODE_OTHER_LETTER,
;;   G_UNICODE_TITLECASE_LETTER,
;;   G_UNICODE_UPPERCASE_LETTER,
;;   G_UNICODE_SPACING_MARK,
;;   G_UNICODE_ENCLOSING_MARK,
;;   G_UNICODE_NON_SPACING_MARK,
;;   G_UNICODE_DECIMAL_NUMBER,
;;   G_UNICODE_LETTER_NUMBER,
;;   G_UNICODE_OTHER_NUMBER,
;;   G_UNICODE_CONNECT_PUNCTUATION,
;;   G_UNICODE_DASH_PUNCTUATION,
;;   G_UNICODE_CLOSE_PUNCTUATION,
;;   G_UNICODE_FINAL_PUNCTUATION,
;;   G_UNICODE_INITIAL_PUNCTUATION,
;;   G_UNICODE_OTHER_PUNCTUATION,
;;   G_UNICODE_OPEN_PUNCTUATION,
;;   G_UNICODE_CURRENCY_SYMBOL,
;;   G_UNICODE_MODIFIER_SYMBOL,
;;   G_UNICODE_MATH_SYMBOL,
;;   G_UNICODE_OTHER_SYMBOL,
;;   G_UNICODE_LINE_SEPARATOR,
;;   G_UNICODE_PARAGRAPH_SEPARATOR,
;;   G_UNICODE_SPACE_SEPARATOR,
;; } GUnicodeType;
(define-fh-enum GUnicodeType
  '((G_UNICODE_CONTROL . 0)
    (G_UNICODE_FORMAT . 1)
    (G_UNICODE_UNASSIGNED . 2)
    (G_UNICODE_PRIVATE_USE . 3)
    (G_UNICODE_SURROGATE . 4)
    (G_UNICODE_LOWERCASE_LETTER . 5)
    (G_UNICODE_MODIFIER_LETTER . 6)
    (G_UNICODE_OTHER_LETTER . 7)
    (G_UNICODE_TITLECASE_LETTER . 8)
    (G_UNICODE_UPPERCASE_LETTER . 9)
    (G_UNICODE_SPACING_MARK . 10)
    (G_UNICODE_ENCLOSING_MARK . 11)
    (G_UNICODE_NON_SPACING_MARK . 12)
    (G_UNICODE_DECIMAL_NUMBER . 13)
    (G_UNICODE_LETTER_NUMBER . 14)
    (G_UNICODE_OTHER_NUMBER . 15)
    (G_UNICODE_CONNECT_PUNCTUATION . 16)
    (G_UNICODE_DASH_PUNCTUATION . 17)
    (G_UNICODE_CLOSE_PUNCTUATION . 18)
    (G_UNICODE_FINAL_PUNCTUATION . 19)
    (G_UNICODE_INITIAL_PUNCTUATION . 20)
    (G_UNICODE_OTHER_PUNCTUATION . 21)
    (G_UNICODE_OPEN_PUNCTUATION . 22)
    (G_UNICODE_CURRENCY_SYMBOL . 23)
    (G_UNICODE_MODIFIER_SYMBOL . 24)
    (G_UNICODE_MATH_SYMBOL . 25)
    (G_UNICODE_OTHER_SYMBOL . 26)
    (G_UNICODE_LINE_SEPARATOR . 27)
    (G_UNICODE_PARAGRAPH_SEPARATOR . 28)
    (G_UNICODE_SPACE_SEPARATOR . 29))
  )

;; typedef enum {
;;   G_UNICODE_BREAK_MANDATORY,
;;   G_UNICODE_BREAK_CARRIAGE_RETURN,
;;   G_UNICODE_BREAK_LINE_FEED,
;;   G_UNICODE_BREAK_COMBINING_MARK,
;;   G_UNICODE_BREAK_SURROGATE,
;;   G_UNICODE_BREAK_ZERO_WIDTH_SPACE,
;;   G_UNICODE_BREAK_INSEPARABLE,
;;   G_UNICODE_BREAK_NON_BREAKING_GLUE,
;;   G_UNICODE_BREAK_CONTINGENT,
;;   G_UNICODE_BREAK_SPACE,
;;   G_UNICODE_BREAK_AFTER,
;;   G_UNICODE_BREAK_BEFORE,
;;   G_UNICODE_BREAK_BEFORE_AND_AFTER,
;;   G_UNICODE_BREAK_HYPHEN,
;;   G_UNICODE_BREAK_NON_STARTER,
;;   G_UNICODE_BREAK_OPEN_PUNCTUATION,
;;   G_UNICODE_BREAK_CLOSE_PUNCTUATION,
;;   G_UNICODE_BREAK_QUOTATION,
;;   G_UNICODE_BREAK_EXCLAMATION,
;;   G_UNICODE_BREAK_IDEOGRAPHIC,
;;   G_UNICODE_BREAK_NUMERIC,
;;   G_UNICODE_BREAK_INFIX_SEPARATOR,
;;   G_UNICODE_BREAK_SYMBOL,
;;   G_UNICODE_BREAK_ALPHABETIC,
;;   G_UNICODE_BREAK_PREFIX,
;;   G_UNICODE_BREAK_POSTFIX,
;;   G_UNICODE_BREAK_COMPLEX_CONTEXT,
;;   G_UNICODE_BREAK_AMBIGUOUS,
;;   G_UNICODE_BREAK_UNKNOWN,
;;   G_UNICODE_BREAK_NEXT_LINE,
;;   G_UNICODE_BREAK_WORD_JOINER,
;;   G_UNICODE_BREAK_HANGUL_L_JAMO,
;;   G_UNICODE_BREAK_HANGUL_V_JAMO,
;;   G_UNICODE_BREAK_HANGUL_T_JAMO,
;;   G_UNICODE_BREAK_HANGUL_LV_SYLLABLE,
;;   G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,
;;   G_UNICODE_BREAK_CLOSE_PARANTHESIS,
;;   G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER,
;;   G_UNICODE_BREAK_HEBREW_LETTER,
;;   G_UNICODE_BREAK_REGIONAL_INDICATOR,
;;   G_UNICODE_BREAK_EMOJI_BASE,
;;   G_UNICODE_BREAK_EMOJI_MODIFIER,
;;   G_UNICODE_BREAK_ZERO_WIDTH_JOINER,
;; } GUnicodeBreakType;
(define-fh-enum GUnicodeBreakType
  '((G_UNICODE_BREAK_MANDATORY . 0)
    (G_UNICODE_BREAK_CARRIAGE_RETURN . 1)
    (G_UNICODE_BREAK_LINE_FEED . 2)
    (G_UNICODE_BREAK_COMBINING_MARK . 3)
    (G_UNICODE_BREAK_SURROGATE . 4)
    (G_UNICODE_BREAK_ZERO_WIDTH_SPACE . 5)
    (G_UNICODE_BREAK_INSEPARABLE . 6)
    (G_UNICODE_BREAK_NON_BREAKING_GLUE . 7)
    (G_UNICODE_BREAK_CONTINGENT . 8)
    (G_UNICODE_BREAK_SPACE . 9)
    (G_UNICODE_BREAK_AFTER . 10)
    (G_UNICODE_BREAK_BEFORE . 11)
    (G_UNICODE_BREAK_BEFORE_AND_AFTER . 12)
    (G_UNICODE_BREAK_HYPHEN . 13)
    (G_UNICODE_BREAK_NON_STARTER . 14)
    (G_UNICODE_BREAK_OPEN_PUNCTUATION . 15)
    (G_UNICODE_BREAK_CLOSE_PUNCTUATION . 16)
    (G_UNICODE_BREAK_QUOTATION . 17)
    (G_UNICODE_BREAK_EXCLAMATION . 18)
    (G_UNICODE_BREAK_IDEOGRAPHIC . 19)
    (G_UNICODE_BREAK_NUMERIC . 20)
    (G_UNICODE_BREAK_INFIX_SEPARATOR . 21)
    (G_UNICODE_BREAK_SYMBOL . 22)
    (G_UNICODE_BREAK_ALPHABETIC . 23)
    (G_UNICODE_BREAK_PREFIX . 24)
    (G_UNICODE_BREAK_POSTFIX . 25)
    (G_UNICODE_BREAK_COMPLEX_CONTEXT . 26)
    (G_UNICODE_BREAK_AMBIGUOUS . 27)
    (G_UNICODE_BREAK_UNKNOWN . 28)
    (G_UNICODE_BREAK_NEXT_LINE . 29)
    (G_UNICODE_BREAK_WORD_JOINER . 30)
    (G_UNICODE_BREAK_HANGUL_L_JAMO . 31)
    (G_UNICODE_BREAK_HANGUL_V_JAMO . 32)
    (G_UNICODE_BREAK_HANGUL_T_JAMO . 33)
    (G_UNICODE_BREAK_HANGUL_LV_SYLLABLE . 34)
    (G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE . 35)
    (G_UNICODE_BREAK_CLOSE_PARANTHESIS . 36)
    (G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER
      .
      37)
    (G_UNICODE_BREAK_HEBREW_LETTER . 38)
    (G_UNICODE_BREAK_REGIONAL_INDICATOR . 39)
    (G_UNICODE_BREAK_EMOJI_BASE . 40)
    (G_UNICODE_BREAK_EMOJI_MODIFIER . 41)
    (G_UNICODE_BREAK_ZERO_WIDTH_JOINER . 42))
  )

;; typedef enum {
;;   G_UNICODE_SCRIPT_INVALID_CODE = -1,
;;   G_UNICODE_SCRIPT_COMMON = 0,
;;   G_UNICODE_SCRIPT_INHERITED,
;;   G_UNICODE_SCRIPT_ARABIC,
;;   G_UNICODE_SCRIPT_ARMENIAN,
;;   G_UNICODE_SCRIPT_BENGALI,
;;   G_UNICODE_SCRIPT_BOPOMOFO,
;;   G_UNICODE_SCRIPT_CHEROKEE,
;;   G_UNICODE_SCRIPT_COPTIC,
;;   G_UNICODE_SCRIPT_CYRILLIC,
;;   G_UNICODE_SCRIPT_DESERET,
;;   G_UNICODE_SCRIPT_DEVANAGARI,
;;   G_UNICODE_SCRIPT_ETHIOPIC,
;;   G_UNICODE_SCRIPT_GEORGIAN,
;;   G_UNICODE_SCRIPT_GOTHIC,
;;   G_UNICODE_SCRIPT_GREEK,
;;   G_UNICODE_SCRIPT_GUJARATI,
;;   G_UNICODE_SCRIPT_GURMUKHI,
;;   G_UNICODE_SCRIPT_HAN,
;;   G_UNICODE_SCRIPT_HANGUL,
;;   G_UNICODE_SCRIPT_HEBREW,
;;   G_UNICODE_SCRIPT_HIRAGANA,
;;   G_UNICODE_SCRIPT_KANNADA,
;;   G_UNICODE_SCRIPT_KATAKANA,
;;   G_UNICODE_SCRIPT_KHMER,
;;   G_UNICODE_SCRIPT_LAO,
;;   G_UNICODE_SCRIPT_LATIN,
;;   G_UNICODE_SCRIPT_MALAYALAM,
;;   G_UNICODE_SCRIPT_MONGOLIAN,
;;   G_UNICODE_SCRIPT_MYANMAR,
;;   G_UNICODE_SCRIPT_OGHAM,
;;   G_UNICODE_SCRIPT_OLD_ITALIC,
;;   G_UNICODE_SCRIPT_ORIYA,
;;   G_UNICODE_SCRIPT_RUNIC,
;;   G_UNICODE_SCRIPT_SINHALA,
;;   G_UNICODE_SCRIPT_SYRIAC,
;;   G_UNICODE_SCRIPT_TAMIL,
;;   G_UNICODE_SCRIPT_TELUGU,
;;   G_UNICODE_SCRIPT_THAANA,
;;   G_UNICODE_SCRIPT_THAI,
;;   G_UNICODE_SCRIPT_TIBETAN,
;;   G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL,
;;   G_UNICODE_SCRIPT_YI,
;;   G_UNICODE_SCRIPT_TAGALOG,
;;   G_UNICODE_SCRIPT_HANUNOO,
;;   G_UNICODE_SCRIPT_BUHID,
;;   G_UNICODE_SCRIPT_TAGBANWA,
;;   G_UNICODE_SCRIPT_BRAILLE,
;;   G_UNICODE_SCRIPT_CYPRIOT,
;;   G_UNICODE_SCRIPT_LIMBU,
;;   G_UNICODE_SCRIPT_OSMANYA,
;;   G_UNICODE_SCRIPT_SHAVIAN,
;;   G_UNICODE_SCRIPT_LINEAR_B,
;;   G_UNICODE_SCRIPT_TAI_LE,
;;   G_UNICODE_SCRIPT_UGARITIC,
;;   G_UNICODE_SCRIPT_NEW_TAI_LUE,
;;   G_UNICODE_SCRIPT_BUGINESE,
;;   G_UNICODE_SCRIPT_GLAGOLITIC,
;;   G_UNICODE_SCRIPT_TIFINAGH,
;;   G_UNICODE_SCRIPT_SYLOTI_NAGRI,
;;   G_UNICODE_SCRIPT_OLD_PERSIAN,
;;   G_UNICODE_SCRIPT_KHAROSHTHI,
;;   G_UNICODE_SCRIPT_UNKNOWN,
;;   G_UNICODE_SCRIPT_BALINESE,
;;   G_UNICODE_SCRIPT_CUNEIFORM,
;;   G_UNICODE_SCRIPT_PHOENICIAN,
;;   G_UNICODE_SCRIPT_PHAGS_PA,
;;   G_UNICODE_SCRIPT_NKO,
;;   G_UNICODE_SCRIPT_KAYAH_LI,
;;   G_UNICODE_SCRIPT_LEPCHA,
;;   G_UNICODE_SCRIPT_REJANG,
;;   G_UNICODE_SCRIPT_SUNDANESE,
;;   G_UNICODE_SCRIPT_SAURASHTRA,
;;   G_UNICODE_SCRIPT_CHAM,
;;   G_UNICODE_SCRIPT_OL_CHIKI,
;;   G_UNICODE_SCRIPT_VAI,
;;   G_UNICODE_SCRIPT_CARIAN,
;;   G_UNICODE_SCRIPT_LYCIAN,
;;   G_UNICODE_SCRIPT_LYDIAN,
;;   G_UNICODE_SCRIPT_AVESTAN,
;;   G_UNICODE_SCRIPT_BAMUM,
;;   G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS,
;;   G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC,
;;   G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI,
;;   G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN,
;;   G_UNICODE_SCRIPT_JAVANESE,
;;   G_UNICODE_SCRIPT_KAITHI,
;;   G_UNICODE_SCRIPT_LISU,
;;   G_UNICODE_SCRIPT_MEETEI_MAYEK,
;;   G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN,
;;   G_UNICODE_SCRIPT_OLD_TURKIC,
;;   G_UNICODE_SCRIPT_SAMARITAN,
;;   G_UNICODE_SCRIPT_TAI_THAM,
;;   G_UNICODE_SCRIPT_TAI_VIET,
;;   G_UNICODE_SCRIPT_BATAK,
;;   G_UNICODE_SCRIPT_BRAHMI,
;;   G_UNICODE_SCRIPT_MANDAIC,
;;   G_UNICODE_SCRIPT_CHAKMA,
;;   G_UNICODE_SCRIPT_MEROITIC_CURSIVE,
;;   G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS,
;;   G_UNICODE_SCRIPT_MIAO,
;;   G_UNICODE_SCRIPT_SHARADA,
;;   G_UNICODE_SCRIPT_SORA_SOMPENG,
;;   G_UNICODE_SCRIPT_TAKRI,
;;   G_UNICODE_SCRIPT_BASSA_VAH,
;;   G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN,
;;   G_UNICODE_SCRIPT_DUPLOYAN,
;;   G_UNICODE_SCRIPT_ELBASAN,
;;   G_UNICODE_SCRIPT_GRANTHA,
;;   G_UNICODE_SCRIPT_KHOJKI,
;;   G_UNICODE_SCRIPT_KHUDAWADI,
;;   G_UNICODE_SCRIPT_LINEAR_A,
;;   G_UNICODE_SCRIPT_MAHAJANI,
;;   G_UNICODE_SCRIPT_MANICHAEAN,
;;   G_UNICODE_SCRIPT_MENDE_KIKAKUI,
;;   G_UNICODE_SCRIPT_MODI,
;;   G_UNICODE_SCRIPT_MRO,
;;   G_UNICODE_SCRIPT_NABATAEAN,
;;   G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN,
;;   G_UNICODE_SCRIPT_OLD_PERMIC,
;;   G_UNICODE_SCRIPT_PAHAWH_HMONG,
;;   G_UNICODE_SCRIPT_PALMYRENE,
;;   G_UNICODE_SCRIPT_PAU_CIN_HAU,
;;   G_UNICODE_SCRIPT_PSALTER_PAHLAVI,
;;   G_UNICODE_SCRIPT_SIDDHAM,
;;   G_UNICODE_SCRIPT_TIRHUTA,
;;   G_UNICODE_SCRIPT_WARANG_CITI,
;;   G_UNICODE_SCRIPT_AHOM,
;;   G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS,
;;   G_UNICODE_SCRIPT_HATRAN,
;;   G_UNICODE_SCRIPT_MULTANI,
;;   G_UNICODE_SCRIPT_OLD_HUNGARIAN,
;;   G_UNICODE_SCRIPT_SIGNWRITING,
;;   G_UNICODE_SCRIPT_ADLAM,
;;   G_UNICODE_SCRIPT_BHAIKSUKI,
;;   G_UNICODE_SCRIPT_MARCHEN,
;;   G_UNICODE_SCRIPT_NEWA,
;;   G_UNICODE_SCRIPT_OSAGE,
;;   G_UNICODE_SCRIPT_TANGUT,
;; } GUnicodeScript;
(define-fh-enum GUnicodeScript
  '((G_UNICODE_SCRIPT_INVALID_CODE . -1)
    (G_UNICODE_SCRIPT_COMMON . 0)
    (G_UNICODE_SCRIPT_INHERITED . 1)
    (G_UNICODE_SCRIPT_ARABIC . 2)
    (G_UNICODE_SCRIPT_ARMENIAN . 3)
    (G_UNICODE_SCRIPT_BENGALI . 4)
    (G_UNICODE_SCRIPT_BOPOMOFO . 5)
    (G_UNICODE_SCRIPT_CHEROKEE . 6)
    (G_UNICODE_SCRIPT_COPTIC . 7)
    (G_UNICODE_SCRIPT_CYRILLIC . 8)
    (G_UNICODE_SCRIPT_DESERET . 9)
    (G_UNICODE_SCRIPT_DEVANAGARI . 10)
    (G_UNICODE_SCRIPT_ETHIOPIC . 11)
    (G_UNICODE_SCRIPT_GEORGIAN . 12)
    (G_UNICODE_SCRIPT_GOTHIC . 13)
    (G_UNICODE_SCRIPT_GREEK . 14)
    (G_UNICODE_SCRIPT_GUJARATI . 15)
    (G_UNICODE_SCRIPT_GURMUKHI . 16)
    (G_UNICODE_SCRIPT_HAN . 17)
    (G_UNICODE_SCRIPT_HANGUL . 18)
    (G_UNICODE_SCRIPT_HEBREW . 19)
    (G_UNICODE_SCRIPT_HIRAGANA . 20)
    (G_UNICODE_SCRIPT_KANNADA . 21)
    (G_UNICODE_SCRIPT_KATAKANA . 22)
    (G_UNICODE_SCRIPT_KHMER . 23)
    (G_UNICODE_SCRIPT_LAO . 24)
    (G_UNICODE_SCRIPT_LATIN . 25)
    (G_UNICODE_SCRIPT_MALAYALAM . 26)
    (G_UNICODE_SCRIPT_MONGOLIAN . 27)
    (G_UNICODE_SCRIPT_MYANMAR . 28)
    (G_UNICODE_SCRIPT_OGHAM . 29)
    (G_UNICODE_SCRIPT_OLD_ITALIC . 30)
    (G_UNICODE_SCRIPT_ORIYA . 31)
    (G_UNICODE_SCRIPT_RUNIC . 32)
    (G_UNICODE_SCRIPT_SINHALA . 33)
    (G_UNICODE_SCRIPT_SYRIAC . 34)
    (G_UNICODE_SCRIPT_TAMIL . 35)
    (G_UNICODE_SCRIPT_TELUGU . 36)
    (G_UNICODE_SCRIPT_THAANA . 37)
    (G_UNICODE_SCRIPT_THAI . 38)
    (G_UNICODE_SCRIPT_TIBETAN . 39)
    (G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL . 40)
    (G_UNICODE_SCRIPT_YI . 41)
    (G_UNICODE_SCRIPT_TAGALOG . 42)
    (G_UNICODE_SCRIPT_HANUNOO . 43)
    (G_UNICODE_SCRIPT_BUHID . 44)
    (G_UNICODE_SCRIPT_TAGBANWA . 45)
    (G_UNICODE_SCRIPT_BRAILLE . 46)
    (G_UNICODE_SCRIPT_CYPRIOT . 47)
    (G_UNICODE_SCRIPT_LIMBU . 48)
    (G_UNICODE_SCRIPT_OSMANYA . 49)
    (G_UNICODE_SCRIPT_SHAVIAN . 50)
    (G_UNICODE_SCRIPT_LINEAR_B . 51)
    (G_UNICODE_SCRIPT_TAI_LE . 52)
    (G_UNICODE_SCRIPT_UGARITIC . 53)
    (G_UNICODE_SCRIPT_NEW_TAI_LUE . 54)
    (G_UNICODE_SCRIPT_BUGINESE . 55)
    (G_UNICODE_SCRIPT_GLAGOLITIC . 56)
    (G_UNICODE_SCRIPT_TIFINAGH . 57)
    (G_UNICODE_SCRIPT_SYLOTI_NAGRI . 58)
    (G_UNICODE_SCRIPT_OLD_PERSIAN . 59)
    (G_UNICODE_SCRIPT_KHAROSHTHI . 60)
    (G_UNICODE_SCRIPT_UNKNOWN . 61)
    (G_UNICODE_SCRIPT_BALINESE . 62)
    (G_UNICODE_SCRIPT_CUNEIFORM . 63)
    (G_UNICODE_SCRIPT_PHOENICIAN . 64)
    (G_UNICODE_SCRIPT_PHAGS_PA . 65)
    (G_UNICODE_SCRIPT_NKO . 66)
    (G_UNICODE_SCRIPT_KAYAH_LI . 67)
    (G_UNICODE_SCRIPT_LEPCHA . 68)
    (G_UNICODE_SCRIPT_REJANG . 69)
    (G_UNICODE_SCRIPT_SUNDANESE . 70)
    (G_UNICODE_SCRIPT_SAURASHTRA . 71)
    (G_UNICODE_SCRIPT_CHAM . 72)
    (G_UNICODE_SCRIPT_OL_CHIKI . 73)
    (G_UNICODE_SCRIPT_VAI . 74)
    (G_UNICODE_SCRIPT_CARIAN . 75)
    (G_UNICODE_SCRIPT_LYCIAN . 76)
    (G_UNICODE_SCRIPT_LYDIAN . 77)
    (G_UNICODE_SCRIPT_AVESTAN . 78)
    (G_UNICODE_SCRIPT_BAMUM . 79)
    (G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS . 80)
    (G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC . 81)
    (G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI . 82)
    (G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN . 83)
    (G_UNICODE_SCRIPT_JAVANESE . 84)
    (G_UNICODE_SCRIPT_KAITHI . 85)
    (G_UNICODE_SCRIPT_LISU . 86)
    (G_UNICODE_SCRIPT_MEETEI_MAYEK . 87)
    (G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN . 88)
    (G_UNICODE_SCRIPT_OLD_TURKIC . 89)
    (G_UNICODE_SCRIPT_SAMARITAN . 90)
    (G_UNICODE_SCRIPT_TAI_THAM . 91)
    (G_UNICODE_SCRIPT_TAI_VIET . 92)
    (G_UNICODE_SCRIPT_BATAK . 93)
    (G_UNICODE_SCRIPT_BRAHMI . 94)
    (G_UNICODE_SCRIPT_MANDAIC . 95)
    (G_UNICODE_SCRIPT_CHAKMA . 96)
    (G_UNICODE_SCRIPT_MEROITIC_CURSIVE . 97)
    (G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS . 98)
    (G_UNICODE_SCRIPT_MIAO . 99)
    (G_UNICODE_SCRIPT_SHARADA . 100)
    (G_UNICODE_SCRIPT_SORA_SOMPENG . 101)
    (G_UNICODE_SCRIPT_TAKRI . 102)
    (G_UNICODE_SCRIPT_BASSA_VAH . 103)
    (G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN . 104)
    (G_UNICODE_SCRIPT_DUPLOYAN . 105)
    (G_UNICODE_SCRIPT_ELBASAN . 106)
    (G_UNICODE_SCRIPT_GRANTHA . 107)
    (G_UNICODE_SCRIPT_KHOJKI . 108)
    (G_UNICODE_SCRIPT_KHUDAWADI . 109)
    (G_UNICODE_SCRIPT_LINEAR_A . 110)
    (G_UNICODE_SCRIPT_MAHAJANI . 111)
    (G_UNICODE_SCRIPT_MANICHAEAN . 112)
    (G_UNICODE_SCRIPT_MENDE_KIKAKUI . 113)
    (G_UNICODE_SCRIPT_MODI . 114)
    (G_UNICODE_SCRIPT_MRO . 115)
    (G_UNICODE_SCRIPT_NABATAEAN . 116)
    (G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN . 117)
    (G_UNICODE_SCRIPT_OLD_PERMIC . 118)
    (G_UNICODE_SCRIPT_PAHAWH_HMONG . 119)
    (G_UNICODE_SCRIPT_PALMYRENE . 120)
    (G_UNICODE_SCRIPT_PAU_CIN_HAU . 121)
    (G_UNICODE_SCRIPT_PSALTER_PAHLAVI . 122)
    (G_UNICODE_SCRIPT_SIDDHAM . 123)
    (G_UNICODE_SCRIPT_TIRHUTA . 124)
    (G_UNICODE_SCRIPT_WARANG_CITI . 125)
    (G_UNICODE_SCRIPT_AHOM . 126)
    (G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS . 127)
    (G_UNICODE_SCRIPT_HATRAN . 128)
    (G_UNICODE_SCRIPT_MULTANI . 129)
    (G_UNICODE_SCRIPT_OLD_HUNGARIAN . 130)
    (G_UNICODE_SCRIPT_SIGNWRITING . 131)
    (G_UNICODE_SCRIPT_ADLAM . 132)
    (G_UNICODE_SCRIPT_BHAIKSUKI . 133)
    (G_UNICODE_SCRIPT_MARCHEN . 134)
    (G_UNICODE_SCRIPT_NEWA . 135)
    (G_UNICODE_SCRIPT_OSAGE . 136)
    (G_UNICODE_SCRIPT_TANGUT . 137))
  )

;; extern guint32 g_unicode_script_to_iso15924(GUnicodeScript script);
(define g_unicode_script_to_iso15924
  (let ((~f #f))
    (lambda (script)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_unicode_script_to_iso15924"
            ffi:unsigned-int
            (list ffi:int))))
      (let ((~script (unwrap~fixed script)))
        (~f ~script)))))
(export g_unicode_script_to_iso15924)

;; extern GUnicodeScript g_unicode_script_from_iso15924(guint32 iso15924);
(define g_unicode_script_from_iso15924
  (let ((~f #f))
    (lambda (iso15924)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_unicode_script_from_iso15924"
            ffi:int
            (list ffi:unsigned-int))))
      (let ((~iso15924 (unwrap~fixed iso15924)))
        (~f ~iso15924)))))
(export g_unicode_script_from_iso15924)

;; extern gboolean g_unichar_isalnum(gunichar c);
(define g_unichar_isalnum
  (let ((~f #f))
    (lambda (c)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_unichar_isalnum"
            ffi:int
            (list ffi:unsigned-int))))
      (let ((~c (unwrap~fixed c))) (~f ~c)))))
(export g_unichar_isalnum)

;; extern gboolean g_unichar_isalpha(gunichar c);
(define g_unichar_isalpha
  (let ((~f #f))
    (lambda (c)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_unichar_isalpha"
            ffi:int
            (list ffi:unsigned-int))))
      (let ((~c (unwrap~fixed c))) (~f ~c)))))
(export g_unichar_isalpha)

;; extern gboolean g_unichar_iscntrl(gunichar c);
(define g_unichar_iscntrl
  (let ((~f #f))
    (lambda (c)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_unichar_iscntrl"
            ffi:int
            (list ffi:unsigned-int))))
      (let ((~c (unwrap~fixed c))) (~f ~c)))))
(export g_unichar_iscntrl)

;; extern gboolean g_unichar_isdigit(gunichar c);
(define g_unichar_isdigit
  (let ((~f #f))
    (lambda (c)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_unichar_isdigit"
            ffi:int
            (list ffi:unsigned-int))))
      (let ((~c (unwrap~fixed c))) (~f ~c)))))
(export g_unichar_isdigit)

;; extern gboolean g_unichar_isgraph(gunichar c);
(define g_unichar_isgraph
  (let ((~f #f))
    (lambda (c)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_unichar_isgraph"
            ffi:int
            (list ffi:unsigned-int))))
      (let ((~c (unwrap~fixed c))) (~f ~c)))))
(export g_unichar_isgraph)

;; extern gboolean g_unichar_islower(gunichar c);
(define g_unichar_islower
  (let ((~f #f))
    (lambda (c)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_unichar_islower"
            ffi:int
            (list ffi:unsigned-int))))
      (let ((~c (unwrap~fixed c))) (~f ~c)))))
(export g_unichar_islower)

;; extern gboolean g_unichar_isprint(gunichar c);
(define g_unichar_isprint
  (let ((~f #f))
    (lambda (c)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_unichar_isprint"
            ffi:int
            (list ffi:unsigned-int))))
      (let ((~c (unwrap~fixed c))) (~f ~c)))))
(export g_unichar_isprint)

;; extern gboolean g_unichar_ispunct(gunichar c);
(define g_unichar_ispunct
  (let ((~f #f))
    (lambda (c)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_unichar_ispunct"
            ffi:int
            (list ffi:unsigned-int))))
      (let ((~c (unwrap~fixed c))) (~f ~c)))))
(export g_unichar_ispunct)

;; extern gboolean g_unichar_isspace(gunichar c);
(define g_unichar_isspace
  (let ((~f #f))
    (lambda (c)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_unichar_isspace"
            ffi:int
            (list ffi:unsigned-int))))
      (let ((~c (unwrap~fixed c))) (~f ~c)))))
(export g_unichar_isspace)

;; extern gboolean g_unichar_isupper(gunichar c);
(define g_unichar_isupper
  (let ((~f #f))
    (lambda (c)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_unichar_isupper"
            ffi:int
            (list ffi:unsigned-int))))
      (let ((~c (unwrap~fixed c))) (~f ~c)))))
(export g_unichar_isupper)

;; extern gboolean g_unichar_isxdigit(gunichar c);
(define g_unichar_isxdigit
  (let ((~f #f))
    (lambda (c)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_unichar_isxdigit"
            ffi:int
            (list ffi:unsigned-int))))
      (let ((~c (unwrap~fixed c))) (~f ~c)))))
(export g_unichar_isxdigit)

;; extern gboolean g_unichar_istitle(gunichar c);
(define g_unichar_istitle
  (let ((~f #f))
    (lambda (c)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_unichar_istitle"
            ffi:int
            (list ffi:unsigned-int))))
      (let ((~c (unwrap~fixed c))) (~f ~c)))))
(export g_unichar_istitle)

;; extern gboolean g_unichar_isdefined(gunichar c);
(define g_unichar_isdefined
  (let ((~f #f))
    (lambda (c)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_unichar_isdefined"
            ffi:int
            (list ffi:unsigned-int))))
      (let ((~c (unwrap~fixed c))) (~f ~c)))))
(export g_unichar_isdefined)

;; extern gboolean g_unichar_iswide(gunichar c);
(define g_unichar_iswide
  (let ((~f #f))
    (lambda (c)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_unichar_iswide"
            ffi:int
            (list ffi:unsigned-int))))
      (let ((~c (unwrap~fixed c))) (~f ~c)))))
(export g_unichar_iswide)

;; extern gboolean g_unichar_iswide_cjk(gunichar c);
(define g_unichar_iswide_cjk
  (let ((~f #f))
    (lambda (c)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_unichar_iswide_cjk"
            ffi:int
            (list ffi:unsigned-int))))
      (let ((~c (unwrap~fixed c))) (~f ~c)))))
(export g_unichar_iswide_cjk)

;; extern gboolean g_unichar_iszerowidth(gunichar c);
(define g_unichar_iszerowidth
  (let ((~f #f))
    (lambda (c)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_unichar_iszerowidth"
            ffi:int
            (list ffi:unsigned-int))))
      (let ((~c (unwrap~fixed c))) (~f ~c)))))
(export g_unichar_iszerowidth)

;; extern gboolean g_unichar_ismark(gunichar c);
(define g_unichar_ismark
  (let ((~f #f))
    (lambda (c)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_unichar_ismark"
            ffi:int
            (list ffi:unsigned-int))))
      (let ((~c (unwrap~fixed c))) (~f ~c)))))
(export g_unichar_ismark)

;; extern gunichar g_unichar_toupper(gunichar c);
(define g_unichar_toupper
  (let ((~f #f))
    (lambda (c)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_unichar_toupper"
            ffi:unsigned-int
            (list ffi:unsigned-int))))
      (let ((~c (unwrap~fixed c))) (~f ~c)))))
(export g_unichar_toupper)

;; extern gunichar g_unichar_tolower(gunichar c);
(define g_unichar_tolower
  (let ((~f #f))
    (lambda (c)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_unichar_tolower"
            ffi:unsigned-int
            (list ffi:unsigned-int))))
      (let ((~c (unwrap~fixed c))) (~f ~c)))))
(export g_unichar_tolower)

;; extern gunichar g_unichar_totitle(gunichar c);
(define g_unichar_totitle
  (let ((~f #f))
    (lambda (c)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_unichar_totitle"
            ffi:unsigned-int
            (list ffi:unsigned-int))))
      (let ((~c (unwrap~fixed c))) (~f ~c)))))
(export g_unichar_totitle)

;; extern gint g_unichar_digit_value(gunichar c);
(define g_unichar_digit_value
  (let ((~f #f))
    (lambda (c)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_unichar_digit_value"
            ffi:int
            (list ffi:unsigned-int))))
      (let ((~c (unwrap~fixed c))) (~f ~c)))))
(export g_unichar_digit_value)

;; extern gint g_unichar_xdigit_value(gunichar c);
(define g_unichar_xdigit_value
  (let ((~f #f))
    (lambda (c)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_unichar_xdigit_value"
            ffi:int
            (list ffi:unsigned-int))))
      (let ((~c (unwrap~fixed c))) (~f ~c)))))
(export g_unichar_xdigit_value)

;; extern GUnicodeType g_unichar_type(gunichar c);
(define g_unichar_type
  (let ((~f #f))
    (lambda (c)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_unichar_type"
            ffi:int
            (list ffi:unsigned-int))))
      (let ((~c (unwrap~fixed c))) (~f ~c)))))
(export g_unichar_type)

;; extern GUnicodeBreakType g_unichar_break_type(gunichar c);
(define g_unichar_break_type
  (let ((~f #f))
    (lambda (c)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_unichar_break_type"
            ffi:int
            (list ffi:unsigned-int))))
      (let ((~c (unwrap~fixed c))) (~f ~c)))))
(export g_unichar_break_type)

;; extern gint g_unichar_combining_class(gunichar uc);
(define g_unichar_combining_class
  (let ((~f #f))
    (lambda (uc)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_unichar_combining_class"
            ffi:int
            (list ffi:unsigned-int))))
      (let ((~uc (unwrap~fixed uc))) (~f ~uc)))))
(export g_unichar_combining_class)

;; extern gboolean g_unichar_get_mirror_char(gunichar ch, gunichar *mirrored_ch
;;     );
(define g_unichar_get_mirror_char
  (let ((~f #f))
    (lambda (ch mirrored_ch)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_unichar_get_mirror_char"
            ffi:int
            (list ffi:unsigned-int '*))))
      (let ((~ch (unwrap~fixed ch))
            (~mirrored_ch (unwrap~pointer mirrored_ch)))
        (~f ~ch ~mirrored_ch)))))
(export g_unichar_get_mirror_char)

;; extern GUnicodeScript g_unichar_get_script(gunichar ch);
(define g_unichar_get_script
  (let ((~f #f))
    (lambda (ch)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_unichar_get_script"
            ffi:int
            (list ffi:unsigned-int))))
      (let ((~ch (unwrap~fixed ch))) (~f ~ch)))))
(export g_unichar_get_script)

;; extern gboolean g_unichar_validate(gunichar ch);
(define g_unichar_validate
  (let ((~f #f))
    (lambda (ch)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_unichar_validate"
            ffi:int
            (list ffi:unsigned-int))))
      (let ((~ch (unwrap~fixed ch))) (~f ~ch)))))
(export g_unichar_validate)

;; extern gboolean g_unichar_compose(gunichar a, gunichar b, gunichar *ch);
(define g_unichar_compose
  (let ((~f #f))
    (lambda (a b ch)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_unichar_compose"
            ffi:int
            (list ffi:unsigned-int ffi:unsigned-int '*))))
      (let ((~a (unwrap~fixed a))
            (~b (unwrap~fixed b))
            (~ch (unwrap~pointer ch)))
        (~f ~a ~b ~ch)))))
(export g_unichar_compose)

;; extern gboolean g_unichar_decompose(gunichar ch, gunichar *a, gunichar *b);
(define g_unichar_decompose
  (let ((~f #f))
    (lambda (ch a b)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_unichar_decompose"
            ffi:int
            (list ffi:unsigned-int '* '*))))
      (let ((~ch (unwrap~fixed ch))
            (~a (unwrap~pointer a))
            (~b (unwrap~pointer b)))
        (~f ~ch ~a ~b)))))
(export g_unichar_decompose)

;; extern gsize g_unichar_fully_decompose(gunichar ch, gboolean compat, 
;;     gunichar *result, gsize result_len);
(define g_unichar_fully_decompose
  (let ((~f #f))
    (lambda (ch compat result result_len)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_unichar_fully_decompose"
            ffi:unsigned-long
            (list ffi:unsigned-int
                  ffi:int
                  '*
                  ffi:unsigned-long))))
      (let ((~ch (unwrap~fixed ch))
            (~compat (unwrap~fixed compat))
            (~result (unwrap~pointer result))
            (~result_len (unwrap~fixed result_len)))
        (~f ~ch ~compat ~result ~result_len)))))
(export g_unichar_fully_decompose)

;; extern void g_unicode_canonical_ordering(gunichar *string, gsize len);
(define g_unicode_canonical_ordering
  (let ((~f #f))
    (lambda (string len)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_unicode_canonical_ordering"
            ffi:void
            (list '* ffi:unsigned-long))))
      (let ((~string (unwrap~pointer string))
            (~len (unwrap~fixed len)))
        (~f ~string ~len)))))
(export g_unicode_canonical_ordering)

;; extern gunichar *g_unicode_canonical_decomposition(gunichar ch, gsize *
;;     result_len);
(define g_unicode_canonical_decomposition
  (let ((~f #f))
    (lambda (ch result_len)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_unicode_canonical_decomposition"
            '*
            (list ffi:unsigned-int '*))))
      (let ((~ch (unwrap~fixed ch))
            (~result_len (unwrap~pointer result_len)))
        (~f ~ch ~result_len)))))
(export g_unicode_canonical_decomposition)

;; extern const gchar *constg_utf8_skip;
(define g_utf8_skip
  (let* ((addr (dynamic-pointer "g_utf8_skip" (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer (bs:pointer int)))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_utf8_skip)

;; extern gunichar g_utf8_get_char(const gchar *p);
(define g_utf8_get_char
  (let ((~f #f))
    (lambda (p)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_utf8_get_char"
            ffi:unsigned-int
            (list '*))))
      (let ((~p (unwrap~pointer p))) (~f ~p)))))
(export g_utf8_get_char)

;; extern gunichar g_utf8_get_char_validated(const gchar *p, gssize max_len);
(define g_utf8_get_char_validated
  (let ((~f #f))
    (lambda (p max_len)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_utf8_get_char_validated"
            ffi:unsigned-int
            (list '* ffi:long))))
      (let ((~p (unwrap~pointer p))
            (~max_len (unwrap~fixed max_len)))
        (~f ~p ~max_len)))))
(export g_utf8_get_char_validated)

;; extern gchar *g_utf8_offset_to_pointer(const gchar *str, glong offset);
(define g_utf8_offset_to_pointer
  (let ((~f #f))
    (lambda (str offset)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_utf8_offset_to_pointer"
            '*
            (list '* ffi:long))))
      (let ((~str (unwrap~pointer str))
            (~offset (unwrap~fixed offset)))
        (~f ~str ~offset)))))
(export g_utf8_offset_to_pointer)

;; extern glong g_utf8_pointer_to_offset(const gchar *str, const gchar *pos);
(define g_utf8_pointer_to_offset
  (let ((~f #f))
    (lambda (str pos)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_utf8_pointer_to_offset"
            ffi:long
            (list '* '*))))
      (let ((~str (unwrap~pointer str))
            (~pos (unwrap~pointer pos)))
        (~f ~str ~pos)))))
(export g_utf8_pointer_to_offset)

;; extern gchar *g_utf8_prev_char(const gchar *p);
(define g_utf8_prev_char
  (let ((~f #f))
    (lambda (p)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_utf8_prev_char" '* (list '*))))
      (let ((~p (unwrap~pointer p))) (~f ~p)))))
(export g_utf8_prev_char)

;; extern gchar *g_utf8_find_next_char(const gchar *p, const gchar *end);
(define g_utf8_find_next_char
  (let ((~f #f))
    (lambda (p end)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_utf8_find_next_char"
            '*
            (list '* '*))))
      (let ((~p (unwrap~pointer p))
            (~end (unwrap~pointer end)))
        (~f ~p ~end)))))
(export g_utf8_find_next_char)

;; extern gchar *g_utf8_find_prev_char(const gchar *str, const gchar *p);
(define g_utf8_find_prev_char
  (let ((~f #f))
    (lambda (str p)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_utf8_find_prev_char"
            '*
            (list '* '*))))
      (let ((~str (unwrap~pointer str))
            (~p (unwrap~pointer p)))
        (~f ~str ~p)))))
(export g_utf8_find_prev_char)

;; extern glong g_utf8_strlen(const gchar *p, gssize max);
(define g_utf8_strlen
  (let ((~f #f))
    (lambda (p max)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_utf8_strlen"
            ffi:long
            (list '* ffi:long))))
      (let ((~p (unwrap~pointer p))
            (~max (unwrap~fixed max)))
        (~f ~p ~max)))))
(export g_utf8_strlen)

;; extern gchar *g_utf8_substring(const gchar *str, glong start_pos, glong 
;;     end_pos);
(define g_utf8_substring
  (let ((~f #f))
    (lambda (str start_pos end_pos)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_utf8_substring"
            '*
            (list '* ffi:long ffi:long))))
      (let ((~str (unwrap~pointer str))
            (~start_pos (unwrap~fixed start_pos))
            (~end_pos (unwrap~fixed end_pos)))
        (~f ~str ~start_pos ~end_pos)))))
(export g_utf8_substring)

;; extern gchar *g_utf8_strncpy(gchar *dest, const gchar *src, gsize n);
(define g_utf8_strncpy
  (let ((~f #f))
    (lambda (dest src n)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_utf8_strncpy"
            '*
            (list '* '* ffi:unsigned-long))))
      (let ((~dest (unwrap~pointer dest))
            (~src (unwrap~pointer src))
            (~n (unwrap~fixed n)))
        (~f ~dest ~src ~n)))))
(export g_utf8_strncpy)

;; extern gchar *g_utf8_strchr(const gchar *p, gssize len, gunichar c);
(define g_utf8_strchr
  (let ((~f #f))
    (lambda (p len c)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_utf8_strchr"
            '*
            (list '* ffi:long ffi:unsigned-int))))
      (let ((~p (unwrap~pointer p))
            (~len (unwrap~fixed len))
            (~c (unwrap~fixed c)))
        (~f ~p ~len ~c)))))
(export g_utf8_strchr)

;; extern gchar *g_utf8_strrchr(const gchar *p, gssize len, gunichar c);
(define g_utf8_strrchr
  (let ((~f #f))
    (lambda (p len c)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_utf8_strrchr"
            '*
            (list '* ffi:long ffi:unsigned-int))))
      (let ((~p (unwrap~pointer p))
            (~len (unwrap~fixed len))
            (~c (unwrap~fixed c)))
        (~f ~p ~len ~c)))))
(export g_utf8_strrchr)

;; extern gchar *g_utf8_strreverse(const gchar *str, gssize len);
(define g_utf8_strreverse
  (let ((~f #f))
    (lambda (str len)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_utf8_strreverse"
            '*
            (list '* ffi:long))))
      (let ((~str (unwrap~pointer str))
            (~len (unwrap~fixed len)))
        (~f ~str ~len)))))
(export g_utf8_strreverse)

;; extern gunichar2 *g_utf8_to_utf16(const gchar *str, glong len, glong *
;;     items_read, glong *items_written, GError **error);
(define g_utf8_to_utf16
  (let ((~f #f))
    (lambda (str len items_read items_written error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_utf8_to_utf16"
            '*
            (list '* ffi:long '* '* '*))))
      (let ((~str (unwrap~pointer str))
            (~len (unwrap~fixed len))
            (~items_read (unwrap~pointer items_read))
            (~items_written (unwrap~pointer items_written))
            (~error (unwrap~pointer error)))
        (~f ~str ~len ~items_read ~items_written ~error)))))
(export g_utf8_to_utf16)

;; extern gunichar *g_utf8_to_ucs4(const gchar *str, glong len, glong *
;;     items_read, glong *items_written, GError **error);
(define g_utf8_to_ucs4
  (let ((~f #f))
    (lambda (str len items_read items_written error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_utf8_to_ucs4"
            '*
            (list '* ffi:long '* '* '*))))
      (let ((~str (unwrap~pointer str))
            (~len (unwrap~fixed len))
            (~items_read (unwrap~pointer items_read))
            (~items_written (unwrap~pointer items_written))
            (~error (unwrap~pointer error)))
        (~f ~str ~len ~items_read ~items_written ~error)))))
(export g_utf8_to_ucs4)

;; extern gunichar *g_utf8_to_ucs4_fast(const gchar *str, glong len, glong *
;;     items_written);
(define g_utf8_to_ucs4_fast
  (let ((~f #f))
    (lambda (str len items_written)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_utf8_to_ucs4_fast"
            '*
            (list '* ffi:long '*))))
      (let ((~str (unwrap~pointer str))
            (~len (unwrap~fixed len))
            (~items_written (unwrap~pointer items_written)))
        (~f ~str ~len ~items_written)))))
(export g_utf8_to_ucs4_fast)

;; extern gunichar *g_utf16_to_ucs4(const gunichar2 *str, glong len, glong *
;;     items_read, glong *items_written, GError **error);
(define g_utf16_to_ucs4
  (let ((~f #f))
    (lambda (str len items_read items_written error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_utf16_to_ucs4"
            '*
            (list '* ffi:long '* '* '*))))
      (let ((~str (unwrap~pointer str))
            (~len (unwrap~fixed len))
            (~items_read (unwrap~pointer items_read))
            (~items_written (unwrap~pointer items_written))
            (~error (unwrap~pointer error)))
        (~f ~str ~len ~items_read ~items_written ~error)))))
(export g_utf16_to_ucs4)

;; extern gchar *g_utf16_to_utf8(const gunichar2 *str, glong len, glong *
;;     items_read, glong *items_written, GError **error);
(define g_utf16_to_utf8
  (let ((~f #f))
    (lambda (str len items_read items_written error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_utf16_to_utf8"
            '*
            (list '* ffi:long '* '* '*))))
      (let ((~str (unwrap~pointer str))
            (~len (unwrap~fixed len))
            (~items_read (unwrap~pointer items_read))
            (~items_written (unwrap~pointer items_written))
            (~error (unwrap~pointer error)))
        (~f ~str ~len ~items_read ~items_written ~error)))))
(export g_utf16_to_utf8)

;; extern gunichar2 *g_ucs4_to_utf16(const gunichar *str, glong len, glong *
;;     items_read, glong *items_written, GError **error);
(define g_ucs4_to_utf16
  (let ((~f #f))
    (lambda (str len items_read items_written error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_ucs4_to_utf16"
            '*
            (list '* ffi:long '* '* '*))))
      (let ((~str (unwrap~pointer str))
            (~len (unwrap~fixed len))
            (~items_read (unwrap~pointer items_read))
            (~items_written (unwrap~pointer items_written))
            (~error (unwrap~pointer error)))
        (~f ~str ~len ~items_read ~items_written ~error)))))
(export g_ucs4_to_utf16)

;; extern gchar *g_ucs4_to_utf8(const gunichar *str, glong len, glong *
;;     items_read, glong *items_written, GError **error);
(define g_ucs4_to_utf8
  (let ((~f #f))
    (lambda (str len items_read items_written error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_ucs4_to_utf8"
            '*
            (list '* ffi:long '* '* '*))))
      (let ((~str (unwrap~pointer str))
            (~len (unwrap~fixed len))
            (~items_read (unwrap~pointer items_read))
            (~items_written (unwrap~pointer items_written))
            (~error (unwrap~pointer error)))
        (~f ~str ~len ~items_read ~items_written ~error)))))
(export g_ucs4_to_utf8)

;; extern gint g_unichar_to_utf8(gunichar c, gchar *outbuf);
(define g_unichar_to_utf8
  (let ((~f #f))
    (lambda (c outbuf)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_unichar_to_utf8"
            ffi:int
            (list ffi:unsigned-int '*))))
      (let ((~c (unwrap~fixed c))
            (~outbuf (unwrap~pointer outbuf)))
        (~f ~c ~outbuf)))))
(export g_unichar_to_utf8)

;; extern gboolean g_utf8_validate(const gchar *str, gssize max_len, const 
;;     gchar **end);
(define g_utf8_validate
  (let ((~f #f))
    (lambda (str max_len end)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_utf8_validate"
            ffi:int
            (list '* ffi:long '*))))
      (let ((~str (unwrap~pointer str))
            (~max_len (unwrap~fixed max_len))
            (~end (unwrap~pointer end)))
        (~f ~str ~max_len ~end)))))
(export g_utf8_validate)

;; extern gchar *g_utf8_strup(const gchar *str, gssize len);
(define g_utf8_strup
  (let ((~f #f))
    (lambda (str len)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_utf8_strup"
            '*
            (list '* ffi:long))))
      (let ((~str (unwrap~pointer str))
            (~len (unwrap~fixed len)))
        (~f ~str ~len)))))
(export g_utf8_strup)

;; extern gchar *g_utf8_strdown(const gchar *str, gssize len);
(define g_utf8_strdown
  (let ((~f #f))
    (lambda (str len)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_utf8_strdown"
            '*
            (list '* ffi:long))))
      (let ((~str (unwrap~pointer str))
            (~len (unwrap~fixed len)))
        (~f ~str ~len)))))
(export g_utf8_strdown)

;; extern gchar *g_utf8_casefold(const gchar *str, gssize len);
(define g_utf8_casefold
  (let ((~f #f))
    (lambda (str len)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_utf8_casefold"
            '*
            (list '* ffi:long))))
      (let ((~str (unwrap~pointer str))
            (~len (unwrap~fixed len)))
        (~f ~str ~len)))))
(export g_utf8_casefold)

;; typedef enum {
;;   G_NORMALIZE_DEFAULT,
;;   G_NORMALIZE_NFD = G_NORMALIZE_DEFAULT,
;;   G_NORMALIZE_DEFAULT_COMPOSE,
;;   G_NORMALIZE_NFC = G_NORMALIZE_DEFAULT_COMPOSE,
;;   G_NORMALIZE_ALL,
;;   G_NORMALIZE_NFKD = G_NORMALIZE_ALL,
;;   G_NORMALIZE_ALL_COMPOSE,
;;   G_NORMALIZE_NFKC = G_NORMALIZE_ALL_COMPOSE,
;; } GNormalizeMode;
(define-fh-enum GNormalizeMode
  '((G_NORMALIZE_DEFAULT . 0)
    (G_NORMALIZE_NFD . 0)
    (G_NORMALIZE_DEFAULT_COMPOSE . 1)
    (G_NORMALIZE_NFC . 1)
    (G_NORMALIZE_ALL . 2)
    (G_NORMALIZE_NFKD . 2)
    (G_NORMALIZE_ALL_COMPOSE . 3)
    (G_NORMALIZE_NFKC . 3))
  )

;; extern gchar *g_utf8_normalize(const gchar *str, gssize len, GNormalizeMode 
;;     mode);
(define g_utf8_normalize
  (let ((~f #f))
    (lambda (str len mode)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_utf8_normalize"
            '*
            (list '* ffi:long ffi:int))))
      (let ((~str (unwrap~pointer str))
            (~len (unwrap~fixed len))
            (~mode (unwrap~fixed mode)))
        (~f ~str ~len ~mode)))))
(export g_utf8_normalize)

;; extern gint g_utf8_collate(const gchar *str1, const gchar *str2);
(define g_utf8_collate
  (let ((~f #f))
    (lambda (str1 str2)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_utf8_collate"
            ffi:int
            (list '* '*))))
      (let ((~str1 (unwrap~pointer str1))
            (~str2 (unwrap~pointer str2)))
        (~f ~str1 ~str2)))))
(export g_utf8_collate)

;; extern gchar *g_utf8_collate_key(const gchar *str, gssize len);
(define g_utf8_collate_key
  (let ((~f #f))
    (lambda (str len)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_utf8_collate_key"
            '*
            (list '* ffi:long))))
      (let ((~str (unwrap~pointer str))
            (~len (unwrap~fixed len)))
        (~f ~str ~len)))))
(export g_utf8_collate_key)

;; extern gchar *g_utf8_collate_key_for_filename(const gchar *str, gssize len)
;;     ;
(define g_utf8_collate_key_for_filename
  (let ((~f #f))
    (lambda (str len)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_utf8_collate_key_for_filename"
            '*
            (list '* ffi:long))))
      (let ((~str (unwrap~pointer str))
            (~len (unwrap~fixed len)))
        (~f ~str ~len)))))
(export g_utf8_collate_key_for_filename)

;; extern gchar *g_utf8_make_valid(const gchar *str, gssize len);
(define g_utf8_make_valid
  (let ((~f #f))
    (lambda (str len)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_utf8_make_valid"
            '*
            (list '* ffi:long))))
      (let ((~str (unwrap~pointer str))
            (~len (unwrap~fixed len)))
        (~f ~str ~len)))))
(export g_utf8_make_valid)

;; typedef struct _GString GString;
(define GString-desc void)
(define GString*-desc (bs:pointer (delay GString-desc)))
(export GString*-desc)
(define-fh-pointer-type GString* GString*-desc)

;; struct _GString {
;;   gchar *str;
;;   gsize len;
;;   gsize allocated_len;
;; };
(define struct-_GString-desc
  (bs:struct
    (list `(str ,(bs:pointer int))
          `(len ,unsigned-long)
          `(allocated_len ,unsigned-long))))
(export struct-_GString-desc)
(define-fh-compound-type/p struct-_GString struct-_GString-desc)
(set! GString-desc struct-_GString-desc)
(define-fh-compound-type GString GString-desc)

;; extern GString *g_string_new(const gchar *init);
(define g_string_new
  (let ((~f #f))
    (lambda (init)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_string_new" '* (list '*))))
      (let ((~init (unwrap~pointer init)))
        (wrap-GString* (~f ~init))))))
(export g_string_new)

;; extern GString *g_string_new_len(const gchar *init, gssize len);
(define g_string_new_len
  (let ((~f #f))
    (lambda (init len)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_string_new_len"
            '*
            (list '* ffi:long))))
      (let ((~init (unwrap~pointer init))
            (~len (unwrap~fixed len)))
        (wrap-GString* (~f ~init ~len))))))
(export g_string_new_len)

;; extern GString *g_string_sized_new(gsize dfl_size);
(define g_string_sized_new
  (let ((~f #f))
    (lambda (dfl_size)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_string_sized_new"
            '*
            (list ffi:unsigned-long))))
      (let ((~dfl_size (unwrap~fixed dfl_size)))
        (wrap-GString* (~f ~dfl_size))))))
(export g_string_sized_new)

;; extern gchar *g_string_free(GString *string, gboolean free_segment);
(define g_string_free
  (let ((~f #f))
    (lambda (string free_segment)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_string_free"
            '*
            (list '* ffi:int))))
      (let ((~string (unwrap-GString* string))
            (~free_segment (unwrap~fixed free_segment)))
        (~f ~string ~free_segment)))))
(export g_string_free)

;; extern GBytes *g_string_free_to_bytes(GString *string);
(define g_string_free_to_bytes
  (let ((~f #f))
    (lambda (string)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_string_free_to_bytes"
            '*
            (list '*))))
      (let ((~string (unwrap-GString* string)))
        (wrap-GBytes* (~f ~string))))))
(export g_string_free_to_bytes)

;; extern gboolean g_string_equal(const GString *v, const GString *v2);
(define g_string_equal
  (let ((~f #f))
    (lambda (v v2)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_string_equal"
            ffi:int
            (list '* '*))))
      (let ((~v (unwrap-GString* v))
            (~v2 (unwrap-GString* v2)))
        (~f ~v ~v2)))))
(export g_string_equal)

;; extern guint g_string_hash(const GString *str);
(define g_string_hash
  (let ((~f #f))
    (lambda (str)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_string_hash"
            ffi:unsigned-int
            (list '*))))
      (let ((~str (unwrap-GString* str))) (~f ~str)))))
(export g_string_hash)

;; extern GString *g_string_assign(GString *string, const gchar *rval);
(define g_string_assign
  (let ((~f #f))
    (lambda (string rval)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_string_assign" '* (list '* '*))))
      (let ((~string (unwrap-GString* string))
            (~rval (unwrap~pointer rval)))
        (wrap-GString* (~f ~string ~rval))))))
(export g_string_assign)

;; extern GString *g_string_truncate(GString *string, gsize len);
(define g_string_truncate
  (let ((~f #f))
    (lambda (string len)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_string_truncate"
            '*
            (list '* ffi:unsigned-long))))
      (let ((~string (unwrap-GString* string))
            (~len (unwrap~fixed len)))
        (wrap-GString* (~f ~string ~len))))))
(export g_string_truncate)

;; extern GString *g_string_set_size(GString *string, gsize len);
(define g_string_set_size
  (let ((~f #f))
    (lambda (string len)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_string_set_size"
            '*
            (list '* ffi:unsigned-long))))
      (let ((~string (unwrap-GString* string))
            (~len (unwrap~fixed len)))
        (wrap-GString* (~f ~string ~len))))))
(export g_string_set_size)

;; extern GString *g_string_insert_len(GString *string, gssize pos, const gchar
;;      *val, gssize len);
(define g_string_insert_len
  (let ((~f #f))
    (lambda (string pos val len)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_string_insert_len"
            '*
            (list '* ffi:long '* ffi:long))))
      (let ((~string (unwrap-GString* string))
            (~pos (unwrap~fixed pos))
            (~val (unwrap~pointer val))
            (~len (unwrap~fixed len)))
        (wrap-GString* (~f ~string ~pos ~val ~len))))))
(export g_string_insert_len)

;; extern GString *g_string_append(GString *string, const gchar *val);
(define g_string_append
  (let ((~f #f))
    (lambda (string val)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_string_append" '* (list '* '*))))
      (let ((~string (unwrap-GString* string))
            (~val (unwrap~pointer val)))
        (wrap-GString* (~f ~string ~val))))))
(export g_string_append)

;; extern GString *g_string_append_len(GString *string, const gchar *val, 
;;     gssize len);
(define g_string_append_len
  (let ((~f #f))
    (lambda (string val len)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_string_append_len"
            '*
            (list '* '* ffi:long))))
      (let ((~string (unwrap-GString* string))
            (~val (unwrap~pointer val))
            (~len (unwrap~fixed len)))
        (wrap-GString* (~f ~string ~val ~len))))))
(export g_string_append_len)

;; extern GString *g_string_append_c(GString *string, gchar c);
(define g_string_append_c
  (let ((~f #f))
    (lambda (string c)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_string_append_c"
            '*
            (list '* ffi:int))))
      (let ((~string (unwrap-GString* string))
            (~c (unwrap~fixed c)))
        (wrap-GString* (~f ~string ~c))))))
(export g_string_append_c)

;; extern GString *g_string_append_unichar(GString *string, gunichar wc);
(define g_string_append_unichar
  (let ((~f #f))
    (lambda (string wc)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_string_append_unichar"
            '*
            (list '* ffi:unsigned-int))))
      (let ((~string (unwrap-GString* string))
            (~wc (unwrap~fixed wc)))
        (wrap-GString* (~f ~string ~wc))))))
(export g_string_append_unichar)

;; extern GString *g_string_prepend(GString *string, const gchar *val);
(define g_string_prepend
  (let ((~f #f))
    (lambda (string val)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_string_prepend" '* (list '* '*))))
      (let ((~string (unwrap-GString* string))
            (~val (unwrap~pointer val)))
        (wrap-GString* (~f ~string ~val))))))
(export g_string_prepend)

;; extern GString *g_string_prepend_c(GString *string, gchar c);
(define g_string_prepend_c
  (let ((~f #f))
    (lambda (string c)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_string_prepend_c"
            '*
            (list '* ffi:int))))
      (let ((~string (unwrap-GString* string))
            (~c (unwrap~fixed c)))
        (wrap-GString* (~f ~string ~c))))))
(export g_string_prepend_c)

;; extern GString *g_string_prepend_unichar(GString *string, gunichar wc);
(define g_string_prepend_unichar
  (let ((~f #f))
    (lambda (string wc)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_string_prepend_unichar"
            '*
            (list '* ffi:unsigned-int))))
      (let ((~string (unwrap-GString* string))
            (~wc (unwrap~fixed wc)))
        (wrap-GString* (~f ~string ~wc))))))
(export g_string_prepend_unichar)

;; extern GString *g_string_prepend_len(GString *string, const gchar *val, 
;;     gssize len);
(define g_string_prepend_len
  (let ((~f #f))
    (lambda (string val len)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_string_prepend_len"
            '*
            (list '* '* ffi:long))))
      (let ((~string (unwrap-GString* string))
            (~val (unwrap~pointer val))
            (~len (unwrap~fixed len)))
        (wrap-GString* (~f ~string ~val ~len))))))
(export g_string_prepend_len)

;; extern GString *g_string_insert(GString *string, gssize pos, const gchar *
;;     val);
(define g_string_insert
  (let ((~f #f))
    (lambda (string pos val)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_string_insert"
            '*
            (list '* ffi:long '*))))
      (let ((~string (unwrap-GString* string))
            (~pos (unwrap~fixed pos))
            (~val (unwrap~pointer val)))
        (wrap-GString* (~f ~string ~pos ~val))))))
(export g_string_insert)

;; extern GString *g_string_insert_c(GString *string, gssize pos, gchar c);
(define g_string_insert_c
  (let ((~f #f))
    (lambda (string pos c)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_string_insert_c"
            '*
            (list '* ffi:long ffi:int))))
      (let ((~string (unwrap-GString* string))
            (~pos (unwrap~fixed pos))
            (~c (unwrap~fixed c)))
        (wrap-GString* (~f ~string ~pos ~c))))))
(export g_string_insert_c)

;; extern GString *g_string_insert_unichar(GString *string, gssize pos, 
;;     gunichar wc);
(define g_string_insert_unichar
  (let ((~f #f))
    (lambda (string pos wc)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_string_insert_unichar"
            '*
            (list '* ffi:long ffi:unsigned-int))))
      (let ((~string (unwrap-GString* string))
            (~pos (unwrap~fixed pos))
            (~wc (unwrap~fixed wc)))
        (wrap-GString* (~f ~string ~pos ~wc))))))
(export g_string_insert_unichar)

;; extern GString *g_string_overwrite(GString *string, gsize pos, const gchar *
;;     val);
(define g_string_overwrite
  (let ((~f #f))
    (lambda (string pos val)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_string_overwrite"
            '*
            (list '* ffi:unsigned-long '*))))
      (let ((~string (unwrap-GString* string))
            (~pos (unwrap~fixed pos))
            (~val (unwrap~pointer val)))
        (wrap-GString* (~f ~string ~pos ~val))))))
(export g_string_overwrite)

;; extern GString *g_string_overwrite_len(GString *string, gsize pos, const 
;;     gchar *val, gssize len);
(define g_string_overwrite_len
  (let ((~f #f))
    (lambda (string pos val len)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_string_overwrite_len"
            '*
            (list '* ffi:unsigned-long '* ffi:long))))
      (let ((~string (unwrap-GString* string))
            (~pos (unwrap~fixed pos))
            (~val (unwrap~pointer val))
            (~len (unwrap~fixed len)))
        (wrap-GString* (~f ~string ~pos ~val ~len))))))
(export g_string_overwrite_len)

;; extern GString *g_string_erase(GString *string, gssize pos, gssize len);
(define g_string_erase
  (let ((~f #f))
    (lambda (string pos len)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_string_erase"
            '*
            (list '* ffi:long ffi:long))))
      (let ((~string (unwrap-GString* string))
            (~pos (unwrap~fixed pos))
            (~len (unwrap~fixed len)))
        (wrap-GString* (~f ~string ~pos ~len))))))
(export g_string_erase)

;; extern GString *g_string_ascii_down(GString *string);
(define g_string_ascii_down
  (let ((~f #f))
    (lambda (string)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_string_ascii_down" '* (list '*))))
      (let ((~string (unwrap-GString* string)))
        (wrap-GString* (~f ~string))))))
(export g_string_ascii_down)

;; extern GString *g_string_ascii_up(GString *string);
(define g_string_ascii_up
  (let ((~f #f))
    (lambda (string)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_string_ascii_up" '* (list '*))))
      (let ((~string (unwrap-GString* string)))
        (wrap-GString* (~f ~string))))))
(export g_string_ascii_up)

;; extern void g_string_vprintf(GString *string, const gchar *format, va_list 
;;     args);
(define g_string_vprintf
  (let ((~f #f))
    (lambda (string format args)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_string_vprintf"
            ffi:void
            (list '* '* '*))))
      (let ((~string (unwrap-GString* string))
            (~format (unwrap~pointer format))
            (~args (unwrap~pointer args)))
        (~f ~string ~format ~args)))))
(export g_string_vprintf)

;; extern void g_string_printf(GString *string, const gchar *format, ...);
;; ... failed.

;; extern void g_string_append_vprintf(GString *string, const gchar *format, 
;;     va_list args);
(define g_string_append_vprintf
  (let ((~f #f))
    (lambda (string format args)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_string_append_vprintf"
            ffi:void
            (list '* '* '*))))
      (let ((~string (unwrap-GString* string))
            (~format (unwrap~pointer format))
            (~args (unwrap~pointer args)))
        (~f ~string ~format ~args)))))
(export g_string_append_vprintf)

;; extern void g_string_append_printf(GString *string, const gchar *format, ...
;;     );
;; ... failed.

;; extern GString *g_string_append_uri_escaped(GString *string, const gchar *
;;     unescaped, const gchar *reserved_chars_allowed, gboolean allow_utf8);
(define g_string_append_uri_escaped
  (let ((~f #f))
    (lambda (string
             unescaped
             reserved_chars_allowed
             allow_utf8)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_string_append_uri_escaped"
            '*
            (list '* '* '* ffi:int))))
      (let ((~string (unwrap-GString* string))
            (~unescaped (unwrap~pointer unescaped))
            (~reserved_chars_allowed
              (unwrap~pointer reserved_chars_allowed))
            (~allow_utf8 (unwrap~fixed allow_utf8)))
        (wrap-GString*
          (~f ~string
              ~unescaped
              ~reserved_chars_allowed
              ~allow_utf8))))))
(export g_string_append_uri_escaped)

;; extern GString *g_string_down(GString *string);
(define g_string_down
  (let ((~f #f))
    (lambda (string)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_string_down" '* (list '*))))
      (let ((~string (unwrap-GString* string)))
        (wrap-GString* (~f ~string))))))
(export g_string_down)

;; extern GString *g_string_up(GString *string);
(define g_string_up
  (let ((~f #f))
    (lambda (string)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_string_up" '* (list '*))))
      (let ((~string (unwrap-GString* string)))
        (wrap-GString* (~f ~string))))))
(export g_string_up)

;; typedef struct _GIOChannel GIOChannel;
(define GIOChannel-desc void)
(define GIOChannel*-desc (bs:pointer (delay GIOChannel-desc)))
(export GIOChannel*-desc)
(define-fh-pointer-type GIOChannel* GIOChannel*-desc)

;; typedef struct _GIOFuncs GIOFuncs;
(define GIOFuncs-desc void)
(define GIOFuncs*-desc (bs:pointer (delay GIOFuncs-desc)))
(export GIOFuncs*-desc)
(define-fh-pointer-type GIOFuncs* GIOFuncs*-desc)

;; typedef enum {
;;   G_IO_ERROR_NONE,
;;   G_IO_ERROR_AGAIN,
;;   G_IO_ERROR_INVAL,
;;   G_IO_ERROR_UNKNOWN,
;; } GIOError;
(define-fh-enum GIOError
  '((G_IO_ERROR_NONE . 0)
    (G_IO_ERROR_AGAIN . 1)
    (G_IO_ERROR_INVAL . 2)
    (G_IO_ERROR_UNKNOWN . 3))
  )

;; typedef enum {
;;   G_IO_CHANNEL_ERROR_FBIG,
;;   G_IO_CHANNEL_ERROR_INVAL,
;;   G_IO_CHANNEL_ERROR_IO,
;;   G_IO_CHANNEL_ERROR_ISDIR,
;;   G_IO_CHANNEL_ERROR_NOSPC,
;;   G_IO_CHANNEL_ERROR_NXIO,
;;   G_IO_CHANNEL_ERROR_OVERFLOW,
;;   G_IO_CHANNEL_ERROR_PIPE,
;;   G_IO_CHANNEL_ERROR_FAILED,
;; } GIOChannelError;
(define-fh-enum GIOChannelError
  '((G_IO_CHANNEL_ERROR_FBIG . 0)
    (G_IO_CHANNEL_ERROR_INVAL . 1)
    (G_IO_CHANNEL_ERROR_IO . 2)
    (G_IO_CHANNEL_ERROR_ISDIR . 3)
    (G_IO_CHANNEL_ERROR_NOSPC . 4)
    (G_IO_CHANNEL_ERROR_NXIO . 5)
    (G_IO_CHANNEL_ERROR_OVERFLOW . 6)
    (G_IO_CHANNEL_ERROR_PIPE . 7)
    (G_IO_CHANNEL_ERROR_FAILED . 8))
  )

;; typedef enum {
;;   G_IO_STATUS_ERROR,
;;   G_IO_STATUS_NORMAL,
;;   G_IO_STATUS_EOF,
;;   G_IO_STATUS_AGAIN,
;; } GIOStatus;
(define-fh-enum GIOStatus
  '((G_IO_STATUS_ERROR . 0)
    (G_IO_STATUS_NORMAL . 1)
    (G_IO_STATUS_EOF . 2)
    (G_IO_STATUS_AGAIN . 3))
  )

;; typedef enum {
;;   G_SEEK_CUR,
;;   G_SEEK_SET,
;;   G_SEEK_END,
;; } GSeekType;
(define-fh-enum GSeekType
  '((G_SEEK_CUR . 0)
    (G_SEEK_SET . 1)
    (G_SEEK_END . 2))
  )

;; typedef enum {
;;   G_IO_FLAG_APPEND = 1<<0,
;;   G_IO_FLAG_NONBLOCK = 1<<1,
;;   G_IO_FLAG_IS_READABLE = 1<<2,
;;   G_IO_FLAG_IS_WRITABLE = 1<<3,
;;   G_IO_FLAG_IS_WRITEABLE = 1<<3,
;;   G_IO_FLAG_IS_SEEKABLE = 1<<4,
;;   G_IO_FLAG_MASK = (1<<5) - 1,
;;   G_IO_FLAG_GET_MASK = G_IO_FLAG_MASK,
;;   G_IO_FLAG_SET_MASK = G_IO_FLAG_APPEND | G_IO_FLAG_NONBLOCK,
;; } GIOFlags;
(define-fh-enum GIOFlags
  '((G_IO_FLAG_APPEND . 1)
    (G_IO_FLAG_NONBLOCK . 2)
    (G_IO_FLAG_IS_READABLE . 4)
    (G_IO_FLAG_IS_WRITABLE . 8)
    (G_IO_FLAG_IS_WRITEABLE . 8)
    (G_IO_FLAG_IS_SEEKABLE . 16)
    (G_IO_FLAG_MASK . 31)
    (G_IO_FLAG_GET_MASK . 31)
    (G_IO_FLAG_SET_MASK . 3))
  )

;; struct _GIOChannel {
;;   /*< private >*/
;;   gint ref_count;
;;   GIOFuncs *funcs;
;;   gchar *encoding;
;;   GIConv read_cd;
;;   GIConv write_cd;
;;   gchar *line_term; /* String which indicates the end of a line of text */
;;   guint line_term_len; /* So we can have null in the line term */
;;   gsize buf_size;
;;   GString *read_buf; /* Raw data from the channel */
;;   GString *encoded_read_buf; /* Channel data converted to UTF-8 */
;;   GString *write_buf; /* Data ready to be written to the file */
;;   gchar partial_write_buf[6]; 
;;       /* UTF-8 partial characters, null terminated */
;;   /* Group the flags together, immediately after partial_write_buf, to save memory */
;;       
;;   guint use_buffer : 1; /* The encoding uses the buffers */
;;   guint do_encode : 1; /* The encoding uses the GIConv coverters */
;;   guint close_on_unref : 1; /* Close the channel on final unref */
;;   guint is_readable : 1; /* Cached GIOFlag */
;;   guint is_writeable : 1; /* ditto */
;;   guint is_seekable : 1; /* ditto */
;;   gpointer reserved1;
;;   gpointer reserved2;
;; };
(define struct-_GIOChannel-desc
  (bs:struct
    (list `(ref_count ,int)
          `(funcs ,(bs:pointer (delay GIOFuncs*-desc)))
          `(encoding ,(bs:pointer int))
          `(read_cd ,(bs:pointer void))
          `(write_cd ,(bs:pointer void))
          `(line_term ,(bs:pointer int))
          `(line_term_len ,unsigned-int)
          `(buf_size ,unsigned-long)
          `(read_buf ,(bs:pointer (delay GString*-desc)))
          `(encoded_read_buf
             ,(bs:pointer (delay GString*-desc)))
          `(write_buf ,(bs:pointer (delay GString*-desc)))
          `(partial_write_buf ,(bs:vector 6 int8))
          `(use_buffer ,unsigned-int ,1)
          `(do_encode ,unsigned-int ,1)
          `(close_on_unref ,unsigned-int ,1)
          `(is_readable ,unsigned-int ,1)
          `(is_writeable ,unsigned-int ,1)
          `(is_seekable ,unsigned-int ,1)
          `(reserved1 ,gpointer-desc)
          `(reserved2 ,gpointer-desc))))
(export struct-_GIOChannel-desc)
(define-fh-compound-type/p struct-_GIOChannel struct-_GIOChannel-desc)
(set! GIOChannel-desc struct-_GIOChannel-desc)
(define-fh-compound-type GIOChannel GIOChannel-desc)

;; typedef gboolean (*GIOFunc)(GIOChannel *source, GIOCondition condition, 
;;     gpointer data);
(define-fh-function/p GIOFunc
  ffi:int (list (quote *) ffi:int (quote *)))

;; struct _GIOFuncs {
;;   GIOStatus (*io_read)(GIOChannel *channel, gchar *buf, gsize count, gsize *
;;       bytes_read, GError **err);
;;   GIOStatus (*io_write)(GIOChannel *channel, const gchar *buf, gsize count, 
;;       gsize *bytes_written, GError **err);
;;   GIOStatus (*io_seek)(GIOChannel *channel, gint64 offset, GSeekType type, 
;;       GError **err);
;;   GIOStatus (*io_close)(GIOChannel *channel, GError **err);
;;   GSource *(*io_create_watch)(GIOChannel *channel, GIOCondition condition);
;;   void (*io_free)(GIOChannel *channel);
;;   GIOStatus (*io_set_flags)(GIOChannel *channel, GIOFlags flags, GError **
;;       err);
;;   GIOFlags (*io_get_flags)(GIOChannel *channel);
;; };
(define struct-_GIOFuncs-desc
  (bs:struct
    (list `(io_read ,(bs:pointer void))
          `(io_write ,(bs:pointer void))
          `(io_seek ,(bs:pointer void))
          `(io_close ,(bs:pointer void))
          `(io_create_watch ,(bs:pointer void))
          `(io_free ,(bs:pointer void))
          `(io_set_flags ,(bs:pointer void))
          `(io_get_flags ,(bs:pointer void)))))
(export struct-_GIOFuncs-desc)
(define-fh-compound-type/p struct-_GIOFuncs struct-_GIOFuncs-desc)
(set! GIOFuncs-desc struct-_GIOFuncs-desc)
(define-fh-compound-type GIOFuncs GIOFuncs-desc)

;; extern void g_io_channel_init(GIOChannel *channel);
(define g_io_channel_init
  (let ((~f #f))
    (lambda (channel)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_io_channel_init"
            ffi:void
            (list '*))))
      (let ((~channel (unwrap-GIOChannel* channel)))
        (~f ~channel)))))
(export g_io_channel_init)

;; extern GIOChannel *g_io_channel_ref(GIOChannel *channel);
(define g_io_channel_ref
  (let ((~f #f))
    (lambda (channel)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_io_channel_ref" '* (list '*))))
      (let ((~channel (unwrap-GIOChannel* channel)))
        (wrap-GIOChannel* (~f ~channel))))))
(export g_io_channel_ref)

;; extern void g_io_channel_unref(GIOChannel *channel);
(define g_io_channel_unref
  (let ((~f #f))
    (lambda (channel)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_io_channel_unref"
            ffi:void
            (list '*))))
      (let ((~channel (unwrap-GIOChannel* channel)))
        (~f ~channel)))))
(export g_io_channel_unref)

;; extern GIOError g_io_channel_read(GIOChannel *channel, gchar *buf, gsize 
;;     count, gsize *bytes_read);
(define g_io_channel_read
  (let ((~f #f))
    (lambda (channel buf count bytes_read)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_io_channel_read"
            ffi:int
            (list '* '* ffi:unsigned-long '*))))
      (let ((~channel (unwrap-GIOChannel* channel))
            (~buf (unwrap~pointer buf))
            (~count (unwrap~fixed count))
            (~bytes_read (unwrap~pointer bytes_read)))
        (~f ~channel ~buf ~count ~bytes_read)))))
(export g_io_channel_read)

;; extern GIOError g_io_channel_write(GIOChannel *channel, const gchar *buf, 
;;     gsize count, gsize *bytes_written);
(define g_io_channel_write
  (let ((~f #f))
    (lambda (channel buf count bytes_written)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_io_channel_write"
            ffi:int
            (list '* '* ffi:unsigned-long '*))))
      (let ((~channel (unwrap-GIOChannel* channel))
            (~buf (unwrap~pointer buf))
            (~count (unwrap~fixed count))
            (~bytes_written (unwrap~pointer bytes_written)))
        (~f ~channel ~buf ~count ~bytes_written)))))
(export g_io_channel_write)

;; extern GIOError g_io_channel_seek(GIOChannel *channel, gint64 offset, 
;;     GSeekType type);
(define g_io_channel_seek
  (let ((~f #f))
    (lambda (channel offset type)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_io_channel_seek"
            ffi:int
            (list '* ffi:long ffi:int))))
      (let ((~channel (unwrap-GIOChannel* channel))
            (~offset (unwrap~fixed offset))
            (~type (unwrap~fixed type)))
        (~f ~channel ~offset ~type)))))
(export g_io_channel_seek)

;; extern void g_io_channel_close(GIOChannel *channel);
(define g_io_channel_close
  (let ((~f #f))
    (lambda (channel)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_io_channel_close"
            ffi:void
            (list '*))))
      (let ((~channel (unwrap-GIOChannel* channel)))
        (~f ~channel)))))
(export g_io_channel_close)

;; extern GIOStatus g_io_channel_shutdown(GIOChannel *channel, gboolean flush, 
;;     GError **err);
(define g_io_channel_shutdown
  (let ((~f #f))
    (lambda (channel flush err)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_io_channel_shutdown"
            ffi:int
            (list '* ffi:int '*))))
      (let ((~channel (unwrap-GIOChannel* channel))
            (~flush (unwrap~fixed flush))
            (~err (unwrap~pointer err)))
        (~f ~channel ~flush ~err)))))
(export g_io_channel_shutdown)

;; extern guint g_io_add_watch_full(GIOChannel *channel, gint priority, 
;;     GIOCondition condition, GIOFunc func, gpointer user_data, GDestroyNotify
;;      notify);
(define g_io_add_watch_full
  (let ((~f #f))
    (lambda (channel
             priority
             condition
             func
             user_data
             notify)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_io_add_watch_full"
            ffi:unsigned-int
            (list '* ffi:int ffi:int '* '* '*))))
      (let ((~channel (unwrap-GIOChannel* channel))
            (~priority (unwrap~fixed priority))
            (~condition (unwrap~fixed condition))
            (~func ((make-ftn-arg-unwrapper
                      ffi:int
                      (list '* ffi:int '*))
                    func))
            (~user_data (unwrap-gpointer user_data))
            (~notify
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               notify)))
        (~f ~channel
            ~priority
            ~condition
            ~func
            ~user_data
            ~notify)))))
(export g_io_add_watch_full)

;; extern GSource *g_io_create_watch(GIOChannel *channel, GIOCondition 
;;     condition);
(define g_io_create_watch
  (let ((~f #f))
    (lambda (channel condition)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_io_create_watch"
            '*
            (list '* ffi:int))))
      (let ((~channel (unwrap-GIOChannel* channel))
            (~condition (unwrap~fixed condition)))
        (wrap-GSource* (~f ~channel ~condition))))))
(export g_io_create_watch)

;; extern guint g_io_add_watch(GIOChannel *channel, GIOCondition condition, 
;;     GIOFunc func, gpointer user_data);
(define g_io_add_watch
  (let ((~f #f))
    (lambda (channel condition func user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_io_add_watch"
            ffi:unsigned-int
            (list '* ffi:int '* '*))))
      (let ((~channel (unwrap-GIOChannel* channel))
            (~condition (unwrap~fixed condition))
            (~func ((make-ftn-arg-unwrapper
                      ffi:int
                      (list '* ffi:int '*))
                    func))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~channel ~condition ~func ~user_data)))))
(export g_io_add_watch)

;; extern void g_io_channel_set_buffer_size(GIOChannel *channel, gsize size);
(define g_io_channel_set_buffer_size
  (let ((~f #f))
    (lambda (channel size)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_io_channel_set_buffer_size"
            ffi:void
            (list '* ffi:unsigned-long))))
      (let ((~channel (unwrap-GIOChannel* channel))
            (~size (unwrap~fixed size)))
        (~f ~channel ~size)))))
(export g_io_channel_set_buffer_size)

;; extern gsize g_io_channel_get_buffer_size(GIOChannel *channel);
(define g_io_channel_get_buffer_size
  (let ((~f #f))
    (lambda (channel)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_io_channel_get_buffer_size"
            ffi:unsigned-long
            (list '*))))
      (let ((~channel (unwrap-GIOChannel* channel)))
        (~f ~channel)))))
(export g_io_channel_get_buffer_size)

;; extern GIOCondition g_io_channel_get_buffer_condition(GIOChannel *channel);
(define g_io_channel_get_buffer_condition
  (let ((~f #f))
    (lambda (channel)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_io_channel_get_buffer_condition"
            ffi:int
            (list '*))))
      (let ((~channel (unwrap-GIOChannel* channel)))
        (~f ~channel)))))
(export g_io_channel_get_buffer_condition)

;; extern GIOStatus g_io_channel_set_flags(GIOChannel *channel, GIOFlags flags
;;     , GError **error);
(define g_io_channel_set_flags
  (let ((~f #f))
    (lambda (channel flags error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_io_channel_set_flags"
            ffi:int
            (list '* ffi:int '*))))
      (let ((~channel (unwrap-GIOChannel* channel))
            (~flags (unwrap~fixed flags))
            (~error (unwrap~pointer error)))
        (~f ~channel ~flags ~error)))))
(export g_io_channel_set_flags)

;; extern GIOFlags g_io_channel_get_flags(GIOChannel *channel);
(define g_io_channel_get_flags
  (let ((~f #f))
    (lambda (channel)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_io_channel_get_flags"
            ffi:int
            (list '*))))
      (let ((~channel (unwrap-GIOChannel* channel)))
        (~f ~channel)))))
(export g_io_channel_get_flags)

;; extern void g_io_channel_set_line_term(GIOChannel *channel, const gchar *
;;     line_term, gint length);
(define g_io_channel_set_line_term
  (let ((~f #f))
    (lambda (channel line_term length)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_io_channel_set_line_term"
            ffi:void
            (list '* '* ffi:int))))
      (let ((~channel (unwrap-GIOChannel* channel))
            (~line_term (unwrap~pointer line_term))
            (~length (unwrap~fixed length)))
        (~f ~channel ~line_term ~length)))))
(export g_io_channel_set_line_term)

;; extern const gchar *g_io_channel_get_line_term(GIOChannel *channel, gint *
;;     length);
(define g_io_channel_get_line_term
  (let ((~f #f))
    (lambda (channel length)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_io_channel_get_line_term"
            '*
            (list '* '*))))
      (let ((~channel (unwrap-GIOChannel* channel))
            (~length (unwrap~pointer length)))
        (~f ~channel ~length)))))
(export g_io_channel_get_line_term)

;; extern void g_io_channel_set_buffered(GIOChannel *channel, gboolean buffered
;;     );
(define g_io_channel_set_buffered
  (let ((~f #f))
    (lambda (channel buffered)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_io_channel_set_buffered"
            ffi:void
            (list '* ffi:int))))
      (let ((~channel (unwrap-GIOChannel* channel))
            (~buffered (unwrap~fixed buffered)))
        (~f ~channel ~buffered)))))
(export g_io_channel_set_buffered)

;; extern gboolean g_io_channel_get_buffered(GIOChannel *channel);
(define g_io_channel_get_buffered
  (let ((~f #f))
    (lambda (channel)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_io_channel_get_buffered"
            ffi:int
            (list '*))))
      (let ((~channel (unwrap-GIOChannel* channel)))
        (~f ~channel)))))
(export g_io_channel_get_buffered)

;; extern GIOStatus g_io_channel_set_encoding(GIOChannel *channel, const gchar 
;;     *encoding, GError **error);
(define g_io_channel_set_encoding
  (let ((~f #f))
    (lambda (channel encoding error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_io_channel_set_encoding"
            ffi:int
            (list '* '* '*))))
      (let ((~channel (unwrap-GIOChannel* channel))
            (~encoding (unwrap~pointer encoding))
            (~error (unwrap~pointer error)))
        (~f ~channel ~encoding ~error)))))
(export g_io_channel_set_encoding)

;; extern const gchar *g_io_channel_get_encoding(GIOChannel *channel);
(define g_io_channel_get_encoding
  (let ((~f #f))
    (lambda (channel)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_io_channel_get_encoding"
            '*
            (list '*))))
      (let ((~channel (unwrap-GIOChannel* channel)))
        (~f ~channel)))))
(export g_io_channel_get_encoding)

;; extern void g_io_channel_set_close_on_unref(GIOChannel *channel, gboolean 
;;     do_close);
(define g_io_channel_set_close_on_unref
  (let ((~f #f))
    (lambda (channel do_close)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_io_channel_set_close_on_unref"
            ffi:void
            (list '* ffi:int))))
      (let ((~channel (unwrap-GIOChannel* channel))
            (~do_close (unwrap~fixed do_close)))
        (~f ~channel ~do_close)))))
(export g_io_channel_set_close_on_unref)

;; extern gboolean g_io_channel_get_close_on_unref(GIOChannel *channel);
(define g_io_channel_get_close_on_unref
  (let ((~f #f))
    (lambda (channel)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_io_channel_get_close_on_unref"
            ffi:int
            (list '*))))
      (let ((~channel (unwrap-GIOChannel* channel)))
        (~f ~channel)))))
(export g_io_channel_get_close_on_unref)

;; extern GIOStatus g_io_channel_flush(GIOChannel *channel, GError **error);
(define g_io_channel_flush
  (let ((~f #f))
    (lambda (channel error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_io_channel_flush"
            ffi:int
            (list '* '*))))
      (let ((~channel (unwrap-GIOChannel* channel))
            (~error (unwrap~pointer error)))
        (~f ~channel ~error)))))
(export g_io_channel_flush)

;; extern GIOStatus g_io_channel_read_line(GIOChannel *channel, gchar **
;;     str_return, gsize *length, gsize *terminator_pos, GError **error);
(define g_io_channel_read_line
  (let ((~f #f))
    (lambda (channel str_return length terminator_pos error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_io_channel_read_line"
            ffi:int
            (list '* '* '* '* '*))))
      (let ((~channel (unwrap-GIOChannel* channel))
            (~str_return (unwrap~pointer str_return))
            (~length (unwrap~pointer length))
            (~terminator_pos (unwrap~pointer terminator_pos))
            (~error (unwrap~pointer error)))
        (~f ~channel
            ~str_return
            ~length
            ~terminator_pos
            ~error)))))
(export g_io_channel_read_line)

;; extern GIOStatus g_io_channel_read_line_string(GIOChannel *channel, GString 
;;     *buffer, gsize *terminator_pos, GError **error);
(define g_io_channel_read_line_string
  (let ((~f #f))
    (lambda (channel buffer terminator_pos error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_io_channel_read_line_string"
            ffi:int
            (list '* '* '* '*))))
      (let ((~channel (unwrap-GIOChannel* channel))
            (~buffer (unwrap-GString* buffer))
            (~terminator_pos (unwrap~pointer terminator_pos))
            (~error (unwrap~pointer error)))
        (~f ~channel ~buffer ~terminator_pos ~error)))))
(export g_io_channel_read_line_string)

;; extern GIOStatus g_io_channel_read_to_end(GIOChannel *channel, gchar **
;;     str_return, gsize *length, GError **error);
(define g_io_channel_read_to_end
  (let ((~f #f))
    (lambda (channel str_return length error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_io_channel_read_to_end"
            ffi:int
            (list '* '* '* '*))))
      (let ((~channel (unwrap-GIOChannel* channel))
            (~str_return (unwrap~pointer str_return))
            (~length (unwrap~pointer length))
            (~error (unwrap~pointer error)))
        (~f ~channel ~str_return ~length ~error)))))
(export g_io_channel_read_to_end)

;; extern GIOStatus g_io_channel_read_chars(GIOChannel *channel, gchar *buf, 
;;     gsize count, gsize *bytes_read, GError **error);
(define g_io_channel_read_chars
  (let ((~f #f))
    (lambda (channel buf count bytes_read error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_io_channel_read_chars"
            ffi:int
            (list '* '* ffi:unsigned-long '* '*))))
      (let ((~channel (unwrap-GIOChannel* channel))
            (~buf (unwrap~pointer buf))
            (~count (unwrap~fixed count))
            (~bytes_read (unwrap~pointer bytes_read))
            (~error (unwrap~pointer error)))
        (~f ~channel ~buf ~count ~bytes_read ~error)))))
(export g_io_channel_read_chars)

;; extern GIOStatus g_io_channel_read_unichar(GIOChannel *channel, gunichar *
;;     thechar, GError **error);
(define g_io_channel_read_unichar
  (let ((~f #f))
    (lambda (channel thechar error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_io_channel_read_unichar"
            ffi:int
            (list '* '* '*))))
      (let ((~channel (unwrap-GIOChannel* channel))
            (~thechar (unwrap~pointer thechar))
            (~error (unwrap~pointer error)))
        (~f ~channel ~thechar ~error)))))
(export g_io_channel_read_unichar)

;; extern GIOStatus g_io_channel_write_chars(GIOChannel *channel, const gchar *
;;     buf, gssize count, gsize *bytes_written, GError **error);
(define g_io_channel_write_chars
  (let ((~f #f))
    (lambda (channel buf count bytes_written error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_io_channel_write_chars"
            ffi:int
            (list '* '* ffi:long '* '*))))
      (let ((~channel (unwrap-GIOChannel* channel))
            (~buf (unwrap~pointer buf))
            (~count (unwrap~fixed count))
            (~bytes_written (unwrap~pointer bytes_written))
            (~error (unwrap~pointer error)))
        (~f ~channel ~buf ~count ~bytes_written ~error)))))
(export g_io_channel_write_chars)

;; extern GIOStatus g_io_channel_write_unichar(GIOChannel *channel, gunichar 
;;     thechar, GError **error);
(define g_io_channel_write_unichar
  (let ((~f #f))
    (lambda (channel thechar error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_io_channel_write_unichar"
            ffi:int
            (list '* ffi:unsigned-int '*))))
      (let ((~channel (unwrap-GIOChannel* channel))
            (~thechar (unwrap~fixed thechar))
            (~error (unwrap~pointer error)))
        (~f ~channel ~thechar ~error)))))
(export g_io_channel_write_unichar)

;; extern GIOStatus g_io_channel_seek_position(GIOChannel *channel, gint64 
;;     offset, GSeekType type, GError **error);
(define g_io_channel_seek_position
  (let ((~f #f))
    (lambda (channel offset type error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_io_channel_seek_position"
            ffi:int
            (list '* ffi:long ffi:int '*))))
      (let ((~channel (unwrap-GIOChannel* channel))
            (~offset (unwrap~fixed offset))
            (~type (unwrap~fixed type))
            (~error (unwrap~pointer error)))
        (~f ~channel ~offset ~type ~error)))))
(export g_io_channel_seek_position)

;; extern GIOChannel *g_io_channel_new_file(const gchar *filename, const gchar 
;;     *mode, GError **error);
(define g_io_channel_new_file
  (let ((~f #f))
    (lambda (filename mode error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_io_channel_new_file"
            '*
            (list '* '* '*))))
      (let ((~filename (unwrap~pointer filename))
            (~mode (unwrap~pointer mode))
            (~error (unwrap~pointer error)))
        (wrap-GIOChannel* (~f ~filename ~mode ~error))))))
(export g_io_channel_new_file)

;; extern GQuark g_io_channel_error_quark(void);
(define g_io_channel_error_quark
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_io_channel_error_quark"
            ffi:unsigned-int
            (list))))
      (let () (~f)))))
(export g_io_channel_error_quark)

;; extern GIOChannelError g_io_channel_error_from_errno(gint en);
(define g_io_channel_error_from_errno
  (let ((~f #f))
    (lambda (en)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_io_channel_error_from_errno"
            ffi:int
            (list ffi:int))))
      (let ((~en (unwrap~fixed en))) (~f ~en)))))
(export g_io_channel_error_from_errno)

;; extern GIOChannel *g_io_channel_unix_new(int fd);
(define g_io_channel_unix_new
  (let ((~f #f))
    (lambda (fd)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_io_channel_unix_new"
            '*
            (list ffi:int))))
      (let ((~fd (unwrap~fixed fd)))
        (wrap-GIOChannel* (~f ~fd))))))
(export g_io_channel_unix_new)

;; extern gint g_io_channel_unix_get_fd(GIOChannel *channel);
(define g_io_channel_unix_get_fd
  (let ((~f #f))
    (lambda (channel)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_io_channel_unix_get_fd"
            ffi:int
            (list '*))))
      (let ((~channel (unwrap-GIOChannel* channel)))
        (~f ~channel)))))
(export g_io_channel_unix_get_fd)

;; extern GSourceFuncs g_io_watch_funcs;
(define g_io_watch_funcs
  (let* ((addr (dynamic-pointer
                 "g_io_watch_funcs"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer GSourceFuncs-desc))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_io_watch_funcs)

;; typedef enum {
;;   G_KEY_FILE_ERROR_UNKNOWN_ENCODING,
;;   G_KEY_FILE_ERROR_PARSE,
;;   G_KEY_FILE_ERROR_NOT_FOUND,
;;   G_KEY_FILE_ERROR_KEY_NOT_FOUND,
;;   G_KEY_FILE_ERROR_GROUP_NOT_FOUND,
;;   G_KEY_FILE_ERROR_INVALID_VALUE,
;; } GKeyFileError;
(define-fh-enum GKeyFileError
  '((G_KEY_FILE_ERROR_UNKNOWN_ENCODING . 0)
    (G_KEY_FILE_ERROR_PARSE . 1)
    (G_KEY_FILE_ERROR_NOT_FOUND . 2)
    (G_KEY_FILE_ERROR_KEY_NOT_FOUND . 3)
    (G_KEY_FILE_ERROR_GROUP_NOT_FOUND . 4)
    (G_KEY_FILE_ERROR_INVALID_VALUE . 5))
  )

;; extern GQuark g_key_file_error_quark(void);
(define g_key_file_error_quark
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_error_quark"
            ffi:unsigned-int
            (list))))
      (let () (~f)))))
(export g_key_file_error_quark)

;; typedef struct _GKeyFile GKeyFile;
(define GKeyFile-desc void)
(define GKeyFile*-desc (bs:pointer GKeyFile-desc))
(export GKeyFile*-desc)
(define-fh-pointer-type GKeyFile* GKeyFile*-desc)

;; typedef enum {
;;   G_KEY_FILE_NONE = 0,
;;   G_KEY_FILE_KEEP_COMMENTS = 1<<0,
;;   G_KEY_FILE_KEEP_TRANSLATIONS = 1<<1,
;; } GKeyFileFlags;
(define-fh-enum GKeyFileFlags
  '((G_KEY_FILE_NONE . 0)
    (G_KEY_FILE_KEEP_COMMENTS . 1)
    (G_KEY_FILE_KEEP_TRANSLATIONS . 2))
  )

;; extern GKeyFile *g_key_file_new(void);
(define g_key_file_new
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_key_file_new" '* (list))))
      (let () (wrap-GKeyFile* (~f))))))
(export g_key_file_new)

;; extern GKeyFile *g_key_file_ref(GKeyFile *key_file);
(define g_key_file_ref
  (let ((~f #f))
    (lambda (key_file)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_key_file_ref" '* (list '*))))
      (let ((~key_file (unwrap-GKeyFile* key_file)))
        (wrap-GKeyFile* (~f ~key_file))))))
(export g_key_file_ref)

;; extern void g_key_file_unref(GKeyFile *key_file);
(define g_key_file_unref
  (let ((~f #f))
    (lambda (key_file)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_unref"
            ffi:void
            (list '*))))
      (let ((~key_file (unwrap-GKeyFile* key_file)))
        (~f ~key_file)))))
(export g_key_file_unref)

;; extern void g_key_file_free(GKeyFile *key_file);
(define g_key_file_free
  (let ((~f #f))
    (lambda (key_file)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_free"
            ffi:void
            (list '*))))
      (let ((~key_file (unwrap-GKeyFile* key_file)))
        (~f ~key_file)))))
(export g_key_file_free)

;; extern void g_key_file_set_list_separator(GKeyFile *key_file, gchar 
;;     separator);
(define g_key_file_set_list_separator
  (let ((~f #f))
    (lambda (key_file separator)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_set_list_separator"
            ffi:void
            (list '* ffi:int))))
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~separator (unwrap~fixed separator)))
        (~f ~key_file ~separator)))))
(export g_key_file_set_list_separator)

;; extern gboolean g_key_file_load_from_file(GKeyFile *key_file, const gchar *
;;     file, GKeyFileFlags flags, GError **error);
(define g_key_file_load_from_file
  (let ((~f #f))
    (lambda (key_file file flags error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_load_from_file"
            ffi:int
            (list '* '* ffi:int '*))))
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~file (unwrap~pointer file))
            (~flags (unwrap~fixed flags))
            (~error (unwrap~pointer error)))
        (~f ~key_file ~file ~flags ~error)))))
(export g_key_file_load_from_file)

;; extern gboolean g_key_file_load_from_data(GKeyFile *key_file, const gchar *
;;     data, gsize length, GKeyFileFlags flags, GError **error);
(define g_key_file_load_from_data
  (let ((~f #f))
    (lambda (key_file data length flags error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_load_from_data"
            ffi:int
            (list '* '* ffi:unsigned-long ffi:int '*))))
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~data (unwrap~pointer data))
            (~length (unwrap~fixed length))
            (~flags (unwrap~fixed flags))
            (~error (unwrap~pointer error)))
        (~f ~key_file ~data ~length ~flags ~error)))))
(export g_key_file_load_from_data)

;; extern gboolean g_key_file_load_from_bytes(GKeyFile *key_file, GBytes *bytes
;;     , GKeyFileFlags flags, GError **error);
(define g_key_file_load_from_bytes
  (let ((~f #f))
    (lambda (key_file bytes flags error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_load_from_bytes"
            ffi:int
            (list '* '* ffi:int '*))))
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~bytes (unwrap-GBytes* bytes))
            (~flags (unwrap~fixed flags))
            (~error (unwrap~pointer error)))
        (~f ~key_file ~bytes ~flags ~error)))))
(export g_key_file_load_from_bytes)

;; extern gboolean g_key_file_load_from_dirs(GKeyFile *key_file, const gchar *
;;     file, const gchar **search_dirs, gchar **full_path, GKeyFileFlags flags
;;     , GError **error);
(define g_key_file_load_from_dirs
  (let ((~f #f))
    (lambda (key_file file search_dirs full_path flags error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_load_from_dirs"
            ffi:int
            (list '* '* '* '* ffi:int '*))))
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~file (unwrap~pointer file))
            (~search_dirs (unwrap~pointer search_dirs))
            (~full_path (unwrap~pointer full_path))
            (~flags (unwrap~fixed flags))
            (~error (unwrap~pointer error)))
        (~f ~key_file
            ~file
            ~search_dirs
            ~full_path
            ~flags
            ~error)))))
(export g_key_file_load_from_dirs)

;; extern gboolean g_key_file_load_from_data_dirs(GKeyFile *key_file, const 
;;     gchar *file, gchar **full_path, GKeyFileFlags flags, GError **error);
(define g_key_file_load_from_data_dirs
  (let ((~f #f))
    (lambda (key_file file full_path flags error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_load_from_data_dirs"
            ffi:int
            (list '* '* '* ffi:int '*))))
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~file (unwrap~pointer file))
            (~full_path (unwrap~pointer full_path))
            (~flags (unwrap~fixed flags))
            (~error (unwrap~pointer error)))
        (~f ~key_file ~file ~full_path ~flags ~error)))))
(export g_key_file_load_from_data_dirs)

;; extern gchar *g_key_file_to_data(GKeyFile *key_file, gsize *length, GError *
;;     *error);
(define g_key_file_to_data
  (let ((~f #f))
    (lambda (key_file length error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_to_data"
            '*
            (list '* '* '*))))
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~length (unwrap~pointer length))
            (~error (unwrap~pointer error)))
        (~f ~key_file ~length ~error)))))
(export g_key_file_to_data)

;; extern gboolean g_key_file_save_to_file(GKeyFile *key_file, const gchar *
;;     filename, GError **error);
(define g_key_file_save_to_file
  (let ((~f #f))
    (lambda (key_file filename error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_save_to_file"
            ffi:int
            (list '* '* '*))))
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~filename (unwrap~pointer filename))
            (~error (unwrap~pointer error)))
        (~f ~key_file ~filename ~error)))))
(export g_key_file_save_to_file)

;; extern gchar *g_key_file_get_start_group(GKeyFile *key_file);
(define g_key_file_get_start_group
  (let ((~f #f))
    (lambda (key_file)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_get_start_group"
            '*
            (list '*))))
      (let ((~key_file (unwrap-GKeyFile* key_file)))
        (~f ~key_file)))))
(export g_key_file_get_start_group)

;; extern gchar **g_key_file_get_groups(GKeyFile *key_file, gsize *length);
(define g_key_file_get_groups
  (let* ((addr (dynamic-pointer
                 "g_key_file_get_groups"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer (bs:pointer void)))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_key_file_get_groups)

;; extern gchar **g_key_file_get_keys(GKeyFile *key_file, const gchar *
;;     group_name, gsize *length, GError **error);
(define g_key_file_get_keys
  (let* ((addr (dynamic-pointer
                 "g_key_file_get_keys"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer (bs:pointer void)))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_key_file_get_keys)

;; extern gboolean g_key_file_has_group(GKeyFile *key_file, const gchar *
;;     group_name);
(define g_key_file_has_group
  (let ((~f #f))
    (lambda (key_file group_name)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_has_group"
            ffi:int
            (list '* '*))))
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap~pointer group_name)))
        (~f ~key_file ~group_name)))))
(export g_key_file_has_group)

;; extern gboolean g_key_file_has_key(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, GError **error);
(define g_key_file_has_key
  (let ((~f #f))
    (lambda (key_file group_name key error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_has_key"
            ffi:int
            (list '* '* '* '*))))
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap~pointer group_name))
            (~key (unwrap~pointer key))
            (~error (unwrap~pointer error)))
        (~f ~key_file ~group_name ~key ~error)))))
(export g_key_file_has_key)

;; extern gchar *g_key_file_get_value(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, GError **error);
(define g_key_file_get_value
  (let ((~f #f))
    (lambda (key_file group_name key error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_get_value"
            '*
            (list '* '* '* '*))))
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap~pointer group_name))
            (~key (unwrap~pointer key))
            (~error (unwrap~pointer error)))
        (~f ~key_file ~group_name ~key ~error)))))
(export g_key_file_get_value)

;; extern void g_key_file_set_value(GKeyFile *key_file, const gchar *group_name
;;     , const gchar *key, const gchar *value);
(define g_key_file_set_value
  (let ((~f #f))
    (lambda (key_file group_name key value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_set_value"
            ffi:void
            (list '* '* '* '*))))
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap~pointer group_name))
            (~key (unwrap~pointer key))
            (~value (unwrap~pointer value)))
        (~f ~key_file ~group_name ~key ~value)))))
(export g_key_file_set_value)

;; extern gchar *g_key_file_get_string(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, GError **error);
(define g_key_file_get_string
  (let ((~f #f))
    (lambda (key_file group_name key error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_get_string"
            '*
            (list '* '* '* '*))))
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap~pointer group_name))
            (~key (unwrap~pointer key))
            (~error (unwrap~pointer error)))
        (~f ~key_file ~group_name ~key ~error)))))
(export g_key_file_get_string)

;; extern void g_key_file_set_string(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, const gchar *string);
(define g_key_file_set_string
  (let ((~f #f))
    (lambda (key_file group_name key string)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_set_string"
            ffi:void
            (list '* '* '* '*))))
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap~pointer group_name))
            (~key (unwrap~pointer key))
            (~string (unwrap~pointer string)))
        (~f ~key_file ~group_name ~key ~string)))))
(export g_key_file_set_string)

;; extern gchar *g_key_file_get_locale_string(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, const gchar *locale, GError **error);
(define g_key_file_get_locale_string
  (let ((~f #f))
    (lambda (key_file group_name key locale error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_get_locale_string"
            '*
            (list '* '* '* '* '*))))
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap~pointer group_name))
            (~key (unwrap~pointer key))
            (~locale (unwrap~pointer locale))
            (~error (unwrap~pointer error)))
        (~f ~key_file ~group_name ~key ~locale ~error)))))
(export g_key_file_get_locale_string)

;; extern void g_key_file_set_locale_string(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, const gchar *locale, const gchar *string)
;;     ;
(define g_key_file_set_locale_string
  (let ((~f #f))
    (lambda (key_file group_name key locale string)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_set_locale_string"
            ffi:void
            (list '* '* '* '* '*))))
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap~pointer group_name))
            (~key (unwrap~pointer key))
            (~locale (unwrap~pointer locale))
            (~string (unwrap~pointer string)))
        (~f ~key_file ~group_name ~key ~locale ~string)))))
(export g_key_file_set_locale_string)

;; extern gboolean g_key_file_get_boolean(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, GError **error);
(define g_key_file_get_boolean
  (let ((~f #f))
    (lambda (key_file group_name key error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_get_boolean"
            ffi:int
            (list '* '* '* '*))))
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap~pointer group_name))
            (~key (unwrap~pointer key))
            (~error (unwrap~pointer error)))
        (~f ~key_file ~group_name ~key ~error)))))
(export g_key_file_get_boolean)

;; extern void g_key_file_set_boolean(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, gboolean value);
(define g_key_file_set_boolean
  (let ((~f #f))
    (lambda (key_file group_name key value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_set_boolean"
            ffi:void
            (list '* '* '* ffi:int))))
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap~pointer group_name))
            (~key (unwrap~pointer key))
            (~value (unwrap~fixed value)))
        (~f ~key_file ~group_name ~key ~value)))))
(export g_key_file_set_boolean)

;; extern gint g_key_file_get_integer(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, GError **error);
(define g_key_file_get_integer
  (let ((~f #f))
    (lambda (key_file group_name key error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_get_integer"
            ffi:int
            (list '* '* '* '*))))
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap~pointer group_name))
            (~key (unwrap~pointer key))
            (~error (unwrap~pointer error)))
        (~f ~key_file ~group_name ~key ~error)))))
(export g_key_file_get_integer)

;; extern void g_key_file_set_integer(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, gint value);
(define g_key_file_set_integer
  (let ((~f #f))
    (lambda (key_file group_name key value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_set_integer"
            ffi:void
            (list '* '* '* ffi:int))))
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap~pointer group_name))
            (~key (unwrap~pointer key))
            (~value (unwrap~fixed value)))
        (~f ~key_file ~group_name ~key ~value)))))
(export g_key_file_set_integer)

;; extern gint64 g_key_file_get_int64(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, GError **error);
(define g_key_file_get_int64
  (let ((~f #f))
    (lambda (key_file group_name key error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_get_int64"
            ffi:long
            (list '* '* '* '*))))
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap~pointer group_name))
            (~key (unwrap~pointer key))
            (~error (unwrap~pointer error)))
        (~f ~key_file ~group_name ~key ~error)))))
(export g_key_file_get_int64)

;; extern void g_key_file_set_int64(GKeyFile *key_file, const gchar *group_name
;;     , const gchar *key, gint64 value);
(define g_key_file_set_int64
  (let ((~f #f))
    (lambda (key_file group_name key value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_set_int64"
            ffi:void
            (list '* '* '* ffi:long))))
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap~pointer group_name))
            (~key (unwrap~pointer key))
            (~value (unwrap~fixed value)))
        (~f ~key_file ~group_name ~key ~value)))))
(export g_key_file_set_int64)

;; extern guint64 g_key_file_get_uint64(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, GError **error);
(define g_key_file_get_uint64
  (let ((~f #f))
    (lambda (key_file group_name key error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_get_uint64"
            ffi:unsigned-long
            (list '* '* '* '*))))
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap~pointer group_name))
            (~key (unwrap~pointer key))
            (~error (unwrap~pointer error)))
        (~f ~key_file ~group_name ~key ~error)))))
(export g_key_file_get_uint64)

;; extern void g_key_file_set_uint64(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, guint64 value);
(define g_key_file_set_uint64
  (let ((~f #f))
    (lambda (key_file group_name key value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_set_uint64"
            ffi:void
            (list '* '* '* ffi:unsigned-long))))
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap~pointer group_name))
            (~key (unwrap~pointer key))
            (~value (unwrap~fixed value)))
        (~f ~key_file ~group_name ~key ~value)))))
(export g_key_file_set_uint64)

;; extern gdouble g_key_file_get_double(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, GError **error);
(define g_key_file_get_double
  (let ((~f #f))
    (lambda (key_file group_name key error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_get_double"
            ffi:double
            (list '* '* '* '*))))
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap~pointer group_name))
            (~key (unwrap~pointer key))
            (~error (unwrap~pointer error)))
        (wrap-gdouble
          (~f ~key_file ~group_name ~key ~error))))))
(export g_key_file_get_double)

;; extern void g_key_file_set_double(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, gdouble value);
(define g_key_file_set_double
  (let ((~f #f))
    (lambda (key_file group_name key value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_set_double"
            ffi:void
            (list '* '* '* ffi:double))))
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap~pointer group_name))
            (~key (unwrap~pointer key))
            (~value (unwrap-gdouble value)))
        (~f ~key_file ~group_name ~key ~value)))))
(export g_key_file_set_double)

;; extern gchar **g_key_file_get_string_list(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, gsize *length, GError **error);
(define g_key_file_get_string_list
  (let* ((addr (dynamic-pointer
                 "g_key_file_get_string_list"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer (bs:pointer void)))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_key_file_get_string_list)

;; extern void g_key_file_set_string_list(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, const gchar *constlist[], gsize length);
(define g_key_file_set_string_list
  (let ((~f #f))
    (lambda (key_file group_name key list length)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_set_string_list"
            ffi:void
            (list '* '* '* '* ffi:unsigned-long))))
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap~pointer group_name))
            (~key (unwrap~pointer key))
            (~list (unwrap~array list))
            (~length (unwrap~fixed length)))
        (~f ~key_file ~group_name ~key ~list ~length)))))
(export g_key_file_set_string_list)

;; extern gchar **g_key_file_get_locale_string_list(GKeyFile *key_file, const 
;;     gchar *group_name, const gchar *key, const gchar *locale, gsize *length
;;     , GError **error);
(define g_key_file_get_locale_string_list
  (let* ((addr (dynamic-pointer
                 "g_key_file_get_locale_string_list"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer (bs:pointer void)))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_key_file_get_locale_string_list)

;; extern void g_key_file_set_locale_string_list(GKeyFile *key_file, const 
;;     gchar *group_name, const gchar *key, const gchar *locale, const gchar *
;;     constlist[], gsize length);
(define g_key_file_set_locale_string_list
  (let ((~f #f))
    (lambda (key_file group_name key locale list length)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_set_locale_string_list"
            ffi:void
            (list '* '* '* '* '* ffi:unsigned-long))))
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap~pointer group_name))
            (~key (unwrap~pointer key))
            (~locale (unwrap~pointer locale))
            (~list (unwrap~array list))
            (~length (unwrap~fixed length)))
        (~f ~key_file
            ~group_name
            ~key
            ~locale
            ~list
            ~length)))))
(export g_key_file_set_locale_string_list)

;; extern gboolean *g_key_file_get_boolean_list(GKeyFile *key_file, const gchar
;;      *group_name, const gchar *key, gsize *length, GError **error);
(define g_key_file_get_boolean_list
  (let ((~f #f))
    (lambda (key_file group_name key length error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_get_boolean_list"
            '*
            (list '* '* '* '* '*))))
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap~pointer group_name))
            (~key (unwrap~pointer key))
            (~length (unwrap~pointer length))
            (~error (unwrap~pointer error)))
        (~f ~key_file ~group_name ~key ~length ~error)))))
(export g_key_file_get_boolean_list)

;; extern void g_key_file_set_boolean_list(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, gboolean list[], gsize length);
(define g_key_file_set_boolean_list
  (let ((~f #f))
    (lambda (key_file group_name key list length)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_set_boolean_list"
            ffi:void
            (list '* '* '* '* ffi:unsigned-long))))
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap~pointer group_name))
            (~key (unwrap~pointer key))
            (~list (unwrap~array list))
            (~length (unwrap~fixed length)))
        (~f ~key_file ~group_name ~key ~list ~length)))))
(export g_key_file_set_boolean_list)

;; extern gint *g_key_file_get_integer_list(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, gsize *length, GError **error);
(define g_key_file_get_integer_list
  (let ((~f #f))
    (lambda (key_file group_name key length error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_get_integer_list"
            '*
            (list '* '* '* '* '*))))
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap~pointer group_name))
            (~key (unwrap~pointer key))
            (~length (unwrap~pointer length))
            (~error (unwrap~pointer error)))
        (~f ~key_file ~group_name ~key ~length ~error)))))
(export g_key_file_get_integer_list)

;; extern void g_key_file_set_double_list(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, gdouble list[], gsize length);
(define g_key_file_set_double_list
  (let ((~f #f))
    (lambda (key_file group_name key list length)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_set_double_list"
            ffi:void
            (list '* '* '* '* ffi:unsigned-long))))
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap~pointer group_name))
            (~key (unwrap~pointer key))
            (~list (unwrap~array list))
            (~length (unwrap~fixed length)))
        (~f ~key_file ~group_name ~key ~list ~length)))))
(export g_key_file_set_double_list)

;; extern gdouble *g_key_file_get_double_list(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, gsize *length, GError **error);
(define g_key_file_get_double_list
  (let ((~f #f))
    (lambda (key_file group_name key length error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_get_double_list"
            '*
            (list '* '* '* '* '*))))
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap~pointer group_name))
            (~key (unwrap~pointer key))
            (~length (unwrap~pointer length))
            (~error (unwrap~pointer error)))
        (wrap-gdouble*
          (~f ~key_file ~group_name ~key ~length ~error))))))
(export g_key_file_get_double_list)

;; extern void g_key_file_set_integer_list(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, gint list[], gsize length);
(define g_key_file_set_integer_list
  (let ((~f #f))
    (lambda (key_file group_name key list length)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_set_integer_list"
            ffi:void
            (list '* '* '* '* ffi:unsigned-long))))
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap~pointer group_name))
            (~key (unwrap~pointer key))
            (~list (unwrap~array list))
            (~length (unwrap~fixed length)))
        (~f ~key_file ~group_name ~key ~list ~length)))))
(export g_key_file_set_integer_list)

;; extern gboolean g_key_file_set_comment(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, const gchar *comment, GError **error);
(define g_key_file_set_comment
  (let ((~f #f))
    (lambda (key_file group_name key comment error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_set_comment"
            ffi:int
            (list '* '* '* '* '*))))
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap~pointer group_name))
            (~key (unwrap~pointer key))
            (~comment (unwrap~pointer comment))
            (~error (unwrap~pointer error)))
        (~f ~key_file ~group_name ~key ~comment ~error)))))
(export g_key_file_set_comment)

;; extern gchar *g_key_file_get_comment(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, GError **error);
(define g_key_file_get_comment
  (let ((~f #f))
    (lambda (key_file group_name key error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_get_comment"
            '*
            (list '* '* '* '*))))
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap~pointer group_name))
            (~key (unwrap~pointer key))
            (~error (unwrap~pointer error)))
        (~f ~key_file ~group_name ~key ~error)))))
(export g_key_file_get_comment)

;; extern gboolean g_key_file_remove_comment(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, GError **error);
(define g_key_file_remove_comment
  (let ((~f #f))
    (lambda (key_file group_name key error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_remove_comment"
            ffi:int
            (list '* '* '* '*))))
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap~pointer group_name))
            (~key (unwrap~pointer key))
            (~error (unwrap~pointer error)))
        (~f ~key_file ~group_name ~key ~error)))))
(export g_key_file_remove_comment)

;; extern gboolean g_key_file_remove_key(GKeyFile *key_file, const gchar *
;;     group_name, const gchar *key, GError **error);
(define g_key_file_remove_key
  (let ((~f #f))
    (lambda (key_file group_name key error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_remove_key"
            ffi:int
            (list '* '* '* '*))))
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap~pointer group_name))
            (~key (unwrap~pointer key))
            (~error (unwrap~pointer error)))
        (~f ~key_file ~group_name ~key ~error)))))
(export g_key_file_remove_key)

;; extern gboolean g_key_file_remove_group(GKeyFile *key_file, const gchar *
;;     group_name, GError **error);
(define g_key_file_remove_group
  (let ((~f #f))
    (lambda (key_file group_name error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_key_file_remove_group"
            ffi:int
            (list '* '* '*))))
      (let ((~key_file (unwrap-GKeyFile* key_file))
            (~group_name (unwrap~pointer group_name))
            (~error (unwrap~pointer error)))
        (~f ~key_file ~group_name ~error)))))
(export g_key_file_remove_group)

;; typedef struct _GMappedFile GMappedFile;
(define GMappedFile-desc void)
(define GMappedFile*-desc (bs:pointer GMappedFile-desc))
(export GMappedFile*-desc)
(define-fh-pointer-type GMappedFile* GMappedFile*-desc)

;; extern GMappedFile *g_mapped_file_new(const gchar *filename, gboolean 
;;     writable, GError **error);
(define g_mapped_file_new
  (let ((~f #f))
    (lambda (filename writable error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_mapped_file_new"
            '*
            (list '* ffi:int '*))))
      (let ((~filename (unwrap~pointer filename))
            (~writable (unwrap~fixed writable))
            (~error (unwrap~pointer error)))
        (wrap-GMappedFile*
          (~f ~filename ~writable ~error))))))
(export g_mapped_file_new)

;; extern GMappedFile *g_mapped_file_new_from_fd(gint fd, gboolean writable, 
;;     GError **error);
(define g_mapped_file_new_from_fd
  (let ((~f #f))
    (lambda (fd writable error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_mapped_file_new_from_fd"
            '*
            (list ffi:int ffi:int '*))))
      (let ((~fd (unwrap~fixed fd))
            (~writable (unwrap~fixed writable))
            (~error (unwrap~pointer error)))
        (wrap-GMappedFile* (~f ~fd ~writable ~error))))))
(export g_mapped_file_new_from_fd)

;; extern gsize g_mapped_file_get_length(GMappedFile *file);
(define g_mapped_file_get_length
  (let ((~f #f))
    (lambda (file)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_mapped_file_get_length"
            ffi:unsigned-long
            (list '*))))
      (let ((~file (unwrap-GMappedFile* file)))
        (~f ~file)))))
(export g_mapped_file_get_length)

;; extern gchar *g_mapped_file_get_contents(GMappedFile *file);
(define g_mapped_file_get_contents
  (let ((~f #f))
    (lambda (file)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_mapped_file_get_contents"
            '*
            (list '*))))
      (let ((~file (unwrap-GMappedFile* file)))
        (~f ~file)))))
(export g_mapped_file_get_contents)

;; extern GBytes *g_mapped_file_get_bytes(GMappedFile *file);
(define g_mapped_file_get_bytes
  (let ((~f #f))
    (lambda (file)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_mapped_file_get_bytes"
            '*
            (list '*))))
      (let ((~file (unwrap-GMappedFile* file)))
        (wrap-GBytes* (~f ~file))))))
(export g_mapped_file_get_bytes)

;; extern GMappedFile *g_mapped_file_ref(GMappedFile *file);
(define g_mapped_file_ref
  (let ((~f #f))
    (lambda (file)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_mapped_file_ref" '* (list '*))))
      (let ((~file (unwrap-GMappedFile* file)))
        (wrap-GMappedFile* (~f ~file))))))
(export g_mapped_file_ref)

;; extern void g_mapped_file_unref(GMappedFile *file);
(define g_mapped_file_unref
  (let ((~f #f))
    (lambda (file)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_mapped_file_unref"
            ffi:void
            (list '*))))
      (let ((~file (unwrap-GMappedFile* file)))
        (~f ~file)))))
(export g_mapped_file_unref)

;; extern void g_mapped_file_free(GMappedFile *file);
(define g_mapped_file_free
  (let ((~f #f))
    (lambda (file)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_mapped_file_free"
            ffi:void
            (list '*))))
      (let ((~file (unwrap-GMappedFile* file)))
        (~f ~file)))))
(export g_mapped_file_free)

;; typedef enum {
;;   G_MARKUP_ERROR_BAD_UTF8,
;;   G_MARKUP_ERROR_EMPTY,
;;   G_MARKUP_ERROR_PARSE,
;;   G_MARKUP_ERROR_UNKNOWN_ELEMENT,
;;   G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE,
;;   G_MARKUP_ERROR_INVALID_CONTENT,
;;   G_MARKUP_ERROR_MISSING_ATTRIBUTE,
;; } GMarkupError;
(define-fh-enum GMarkupError
  '((G_MARKUP_ERROR_BAD_UTF8 . 0)
    (G_MARKUP_ERROR_EMPTY . 1)
    (G_MARKUP_ERROR_PARSE . 2)
    (G_MARKUP_ERROR_UNKNOWN_ELEMENT . 3)
    (G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE . 4)
    (G_MARKUP_ERROR_INVALID_CONTENT . 5)
    (G_MARKUP_ERROR_MISSING_ATTRIBUTE . 6))
  )

;; extern GQuark g_markup_error_quark(void);
(define g_markup_error_quark
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_markup_error_quark"
            ffi:unsigned-int
            (list))))
      (let () (~f)))))
(export g_markup_error_quark)

;; typedef enum {
;;   G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG = 1<<0,
;;   G_MARKUP_TREAT_CDATA_AS_TEXT = 1<<1,
;;   G_MARKUP_PREFIX_ERROR_POSITION = 1<<2,
;;   G_MARKUP_IGNORE_QUALIFIED = 1<<3,
;; } GMarkupParseFlags;
(define-fh-enum GMarkupParseFlags
  '((G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG . 1)
    (G_MARKUP_TREAT_CDATA_AS_TEXT . 2)
    (G_MARKUP_PREFIX_ERROR_POSITION . 4)
    (G_MARKUP_IGNORE_QUALIFIED . 8))
  )

;; typedef struct _GMarkupParseContext GMarkupParseContext;
(define GMarkupParseContext-desc void)
(define GMarkupParseContext*-desc (bs:pointer GMarkupParseContext-desc))
(export GMarkupParseContext*-desc)
(define-fh-pointer-type GMarkupParseContext* GMarkupParseContext*-desc)

;; typedef struct _GMarkupParser GMarkupParser;
(define GMarkupParser-desc void)
(define GMarkupParser*-desc (bs:pointer (delay GMarkupParser-desc)))
(export GMarkupParser*-desc)
(define-fh-pointer-type GMarkupParser* GMarkupParser*-desc)

;; struct _GMarkupParser {
;;   /* Called for open tags <foo bar="baz"> */
;;   void (*start_element)(GMarkupParseContext *context, const gchar *
;;       element_name, const gchar **attribute_names, const gchar **
;;       attribute_values, gpointer user_data, GError **error);
;;   /* Called for close tags </foo> */
;;   void (*end_element)(GMarkupParseContext *context, const gchar *
;;       element_name, gpointer user_data, GError **error);
;;   /* Called for character data */
;;   /* text is not nul-terminated */
;;   void (*text)(GMarkupParseContext *context, const gchar *text, gsize 
;;       text_len, gpointer user_data, GError **error);
;;   /* Called for strings that should be re-saved verbatim in this same
;;    * position, but are not otherwise interpretable.  At the moment
;;    * this includes comments and processing instructions.
;;    */
;;   /* text is not nul-terminated. */
;;   void (*passthrough)(GMarkupParseContext *context, const gchar *
;;       passthrough_text, gsize text_len, gpointer user_data, GError **error)
;;       ;
;;   /* Called on error, including one set by other
;;    * methods in the vtable. The GError should not be freed.
;;    */
;;   void (*error)(GMarkupParseContext *context, GError *error, gpointer 
;;       user_data);
;; };
(define struct-_GMarkupParser-desc
  (bs:struct
    (list `(start_element ,(bs:pointer void))
          `(end_element ,(bs:pointer void))
          `(text ,(bs:pointer void))
          `(passthrough ,(bs:pointer void))
          `(error ,(bs:pointer void)))))
(export struct-_GMarkupParser-desc)
(define-fh-compound-type/p struct-_GMarkupParser struct-_GMarkupParser-desc)
(set! GMarkupParser-desc struct-_GMarkupParser-desc)
(define-fh-compound-type GMarkupParser GMarkupParser-desc)

;; extern GMarkupParseContext *g_markup_parse_context_new(const GMarkupParser *
;;     parser, GMarkupParseFlags flags, gpointer user_data, GDestroyNotify 
;;     user_data_dnotify);
(define g_markup_parse_context_new
  (let ((~f #f))
    (lambda (parser flags user_data user_data_dnotify)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_markup_parse_context_new"
            '*
            (list '* ffi:int '* '*))))
      (let ((~parser (unwrap-GMarkupParser* parser))
            (~flags (unwrap~fixed flags))
            (~user_data (unwrap-gpointer user_data))
            (~user_data_dnotify
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               user_data_dnotify)))
        (wrap-GMarkupParseContext*
          (~f ~parser ~flags ~user_data ~user_data_dnotify))))))
(export g_markup_parse_context_new)

;; extern GMarkupParseContext *g_markup_parse_context_ref(GMarkupParseContext *
;;     context);
(define g_markup_parse_context_ref
  (let ((~f #f))
    (lambda (context)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_markup_parse_context_ref"
            '*
            (list '*))))
      (let ((~context (unwrap-GMarkupParseContext* context)))
        (wrap-GMarkupParseContext* (~f ~context))))))
(export g_markup_parse_context_ref)

;; extern void g_markup_parse_context_unref(GMarkupParseContext *context);
(define g_markup_parse_context_unref
  (let ((~f #f))
    (lambda (context)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_markup_parse_context_unref"
            ffi:void
            (list '*))))
      (let ((~context (unwrap-GMarkupParseContext* context)))
        (~f ~context)))))
(export g_markup_parse_context_unref)

;; extern void g_markup_parse_context_free(GMarkupParseContext *context);
(define g_markup_parse_context_free
  (let ((~f #f))
    (lambda (context)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_markup_parse_context_free"
            ffi:void
            (list '*))))
      (let ((~context (unwrap-GMarkupParseContext* context)))
        (~f ~context)))))
(export g_markup_parse_context_free)

;; extern gboolean g_markup_parse_context_parse(GMarkupParseContext *context, 
;;     const gchar *text, gssize text_len, GError **error);
(define g_markup_parse_context_parse
  (let ((~f #f))
    (lambda (context text text_len error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_markup_parse_context_parse"
            ffi:int
            (list '* '* ffi:long '*))))
      (let ((~context (unwrap-GMarkupParseContext* context))
            (~text (unwrap~pointer text))
            (~text_len (unwrap~fixed text_len))
            (~error (unwrap~pointer error)))
        (~f ~context ~text ~text_len ~error)))))
(export g_markup_parse_context_parse)

;; extern void g_markup_parse_context_push(GMarkupParseContext *context, const 
;;     GMarkupParser *parser, gpointer user_data);
(define g_markup_parse_context_push
  (let ((~f #f))
    (lambda (context parser user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_markup_parse_context_push"
            ffi:void
            (list '* '* '*))))
      (let ((~context (unwrap-GMarkupParseContext* context))
            (~parser (unwrap-GMarkupParser* parser))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~context ~parser ~user_data)))))
(export g_markup_parse_context_push)

;; extern gpointer g_markup_parse_context_pop(GMarkupParseContext *context);
(define g_markup_parse_context_pop
  (let ((~f #f))
    (lambda (context)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_markup_parse_context_pop"
            '*
            (list '*))))
      (let ((~context (unwrap-GMarkupParseContext* context)))
        (wrap-gpointer (~f ~context))))))
(export g_markup_parse_context_pop)

;; extern gboolean g_markup_parse_context_end_parse(GMarkupParseContext *
;;     context, GError **error);
(define g_markup_parse_context_end_parse
  (let ((~f #f))
    (lambda (context error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_markup_parse_context_end_parse"
            ffi:int
            (list '* '*))))
      (let ((~context (unwrap-GMarkupParseContext* context))
            (~error (unwrap~pointer error)))
        (~f ~context ~error)))))
(export g_markup_parse_context_end_parse)

;; extern const gchar *g_markup_parse_context_get_element(GMarkupParseContext *
;;     context);
(define g_markup_parse_context_get_element
  (let ((~f #f))
    (lambda (context)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_markup_parse_context_get_element"
            '*
            (list '*))))
      (let ((~context (unwrap-GMarkupParseContext* context)))
        (~f ~context)))))
(export g_markup_parse_context_get_element)

;; extern const GSList *g_markup_parse_context_get_element_stack(
;;     GMarkupParseContext *context);
(define g_markup_parse_context_get_element_stack
  (let ((~f #f))
    (lambda (context)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_markup_parse_context_get_element_stack"
            '*
            (list '*))))
      (let ((~context (unwrap-GMarkupParseContext* context)))
        (wrap-GSList* (~f ~context))))))
(export g_markup_parse_context_get_element_stack)

;; extern void g_markup_parse_context_get_position(GMarkupParseContext *context
;;     , gint *line_number, gint *char_number);
(define g_markup_parse_context_get_position
  (let ((~f #f))
    (lambda (context line_number char_number)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_markup_parse_context_get_position"
            ffi:void
            (list '* '* '*))))
      (let ((~context (unwrap-GMarkupParseContext* context))
            (~line_number (unwrap~pointer line_number))
            (~char_number (unwrap~pointer char_number)))
        (~f ~context ~line_number ~char_number)))))
(export g_markup_parse_context_get_position)

;; extern gpointer g_markup_parse_context_get_user_data(GMarkupParseContext *
;;     context);
(define g_markup_parse_context_get_user_data
  (let ((~f #f))
    (lambda (context)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_markup_parse_context_get_user_data"
            '*
            (list '*))))
      (let ((~context (unwrap-GMarkupParseContext* context)))
        (wrap-gpointer (~f ~context))))))
(export g_markup_parse_context_get_user_data)

;; extern gchar *g_markup_escape_text(const gchar *text, gssize length);
(define g_markup_escape_text
  (let ((~f #f))
    (lambda (text length)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_markup_escape_text"
            '*
            (list '* ffi:long))))
      (let ((~text (unwrap~pointer text))
            (~length (unwrap~fixed length)))
        (~f ~text ~length)))))
(export g_markup_escape_text)

;; extern gchar *g_markup_printf_escaped(const char *format, ...);
;; ... failed.

;; extern gchar *g_markup_vprintf_escaped(const char *format, va_list args);
(define g_markup_vprintf_escaped
  (let ((~f #f))
    (lambda (format args)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_markup_vprintf_escaped"
            '*
            (list '* '*))))
      (let ((~format (unwrap~pointer format))
            (~args (unwrap~pointer args)))
        (~f ~format ~args)))))
(export g_markup_vprintf_escaped)

;; typedef enum {
;;   G_MARKUP_COLLECT_INVALID,
;;   G_MARKUP_COLLECT_STRING,
;;   G_MARKUP_COLLECT_STRDUP,
;;   G_MARKUP_COLLECT_BOOLEAN,
;;   G_MARKUP_COLLECT_TRISTATE,
;;   G_MARKUP_COLLECT_OPTIONAL = 1<<16,
;; } GMarkupCollectType;
(define-fh-enum GMarkupCollectType
  '((G_MARKUP_COLLECT_INVALID . 0)
    (G_MARKUP_COLLECT_STRING . 1)
    (G_MARKUP_COLLECT_STRDUP . 2)
    (G_MARKUP_COLLECT_BOOLEAN . 3)
    (G_MARKUP_COLLECT_TRISTATE . 4)
    (G_MARKUP_COLLECT_OPTIONAL . 65536))
  )

;; extern gboolean g_markup_collect_attributes(const gchar *element_name, const
;;      gchar **attribute_names, const gchar **attribute_values, GError **error
;;     , GMarkupCollectType first_type, const gchar *first_attr, ...);
;; ... failed.

;; typedef struct _GVariantType GVariantType;
(define GVariantType-desc void)
(define GVariantType*-desc (bs:pointer GVariantType-desc))
(export GVariantType*-desc)
(define-fh-pointer-type GVariantType* GVariantType*-desc)

;; extern gboolean g_variant_type_string_is_valid(const gchar *type_string);
(define g_variant_type_string_is_valid
  (let ((~f #f))
    (lambda (type_string)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_type_string_is_valid"
            ffi:int
            (list '*))))
      (let ((~type_string (unwrap~pointer type_string)))
        (~f ~type_string)))))
(export g_variant_type_string_is_valid)

;; extern gboolean g_variant_type_string_scan(const gchar *string, const gchar 
;;     *limit, const gchar **endptr);
(define g_variant_type_string_scan
  (let ((~f #f))
    (lambda (string limit endptr)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_type_string_scan"
            ffi:int
            (list '* '* '*))))
      (let ((~string (unwrap~pointer string))
            (~limit (unwrap~pointer limit))
            (~endptr (unwrap~pointer endptr)))
        (~f ~string ~limit ~endptr)))))
(export g_variant_type_string_scan)

;; extern void g_variant_type_free(GVariantType *type);
(define g_variant_type_free
  (let ((~f #f))
    (lambda (type)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_type_free"
            ffi:void
            (list '*))))
      (let ((~type (unwrap-GVariantType* type)))
        (~f ~type)))))
(export g_variant_type_free)

;; extern GVariantType *g_variant_type_copy(const GVariantType *type);
(define g_variant_type_copy
  (let ((~f #f))
    (lambda (type)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_variant_type_copy" '* (list '*))))
      (let ((~type (unwrap-GVariantType* type)))
        (wrap-GVariantType* (~f ~type))))))
(export g_variant_type_copy)

;; extern GVariantType *g_variant_type_new(const gchar *type_string);
(define g_variant_type_new
  (let ((~f #f))
    (lambda (type_string)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_variant_type_new" '* (list '*))))
      (let ((~type_string (unwrap~pointer type_string)))
        (wrap-GVariantType* (~f ~type_string))))))
(export g_variant_type_new)

;; extern gsize g_variant_type_get_string_length(const GVariantType *type);
(define g_variant_type_get_string_length
  (let ((~f #f))
    (lambda (type)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_type_get_string_length"
            ffi:unsigned-long
            (list '*))))
      (let ((~type (unwrap-GVariantType* type)))
        (~f ~type)))))
(export g_variant_type_get_string_length)

;; extern const gchar *g_variant_type_peek_string(const GVariantType *type);
(define g_variant_type_peek_string
  (let ((~f #f))
    (lambda (type)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_type_peek_string"
            '*
            (list '*))))
      (let ((~type (unwrap-GVariantType* type)))
        (~f ~type)))))
(export g_variant_type_peek_string)

;; extern gchar *g_variant_type_dup_string(const GVariantType *type);
(define g_variant_type_dup_string
  (let ((~f #f))
    (lambda (type)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_type_dup_string"
            '*
            (list '*))))
      (let ((~type (unwrap-GVariantType* type)))
        (~f ~type)))))
(export g_variant_type_dup_string)

;; extern gboolean g_variant_type_is_definite(const GVariantType *type);
(define g_variant_type_is_definite
  (let ((~f #f))
    (lambda (type)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_type_is_definite"
            ffi:int
            (list '*))))
      (let ((~type (unwrap-GVariantType* type)))
        (~f ~type)))))
(export g_variant_type_is_definite)

;; extern gboolean g_variant_type_is_container(const GVariantType *type);
(define g_variant_type_is_container
  (let ((~f #f))
    (lambda (type)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_type_is_container"
            ffi:int
            (list '*))))
      (let ((~type (unwrap-GVariantType* type)))
        (~f ~type)))))
(export g_variant_type_is_container)

;; extern gboolean g_variant_type_is_basic(const GVariantType *type);
(define g_variant_type_is_basic
  (let ((~f #f))
    (lambda (type)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_type_is_basic"
            ffi:int
            (list '*))))
      (let ((~type (unwrap-GVariantType* type)))
        (~f ~type)))))
(export g_variant_type_is_basic)

;; extern gboolean g_variant_type_is_maybe(const GVariantType *type);
(define g_variant_type_is_maybe
  (let ((~f #f))
    (lambda (type)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_type_is_maybe"
            ffi:int
            (list '*))))
      (let ((~type (unwrap-GVariantType* type)))
        (~f ~type)))))
(export g_variant_type_is_maybe)

;; extern gboolean g_variant_type_is_array(const GVariantType *type);
(define g_variant_type_is_array
  (let ((~f #f))
    (lambda (type)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_type_is_array"
            ffi:int
            (list '*))))
      (let ((~type (unwrap-GVariantType* type)))
        (~f ~type)))))
(export g_variant_type_is_array)

;; extern gboolean g_variant_type_is_tuple(const GVariantType *type);
(define g_variant_type_is_tuple
  (let ((~f #f))
    (lambda (type)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_type_is_tuple"
            ffi:int
            (list '*))))
      (let ((~type (unwrap-GVariantType* type)))
        (~f ~type)))))
(export g_variant_type_is_tuple)

;; extern gboolean g_variant_type_is_dict_entry(const GVariantType *type);
(define g_variant_type_is_dict_entry
  (let ((~f #f))
    (lambda (type)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_type_is_dict_entry"
            ffi:int
            (list '*))))
      (let ((~type (unwrap-GVariantType* type)))
        (~f ~type)))))
(export g_variant_type_is_dict_entry)

;; extern gboolean g_variant_type_is_variant(const GVariantType *type);
(define g_variant_type_is_variant
  (let ((~f #f))
    (lambda (type)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_type_is_variant"
            ffi:int
            (list '*))))
      (let ((~type (unwrap-GVariantType* type)))
        (~f ~type)))))
(export g_variant_type_is_variant)

;; extern guint g_variant_type_hash(gconstpointer type);
(define g_variant_type_hash
  (let ((~f #f))
    (lambda (type)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_type_hash"
            ffi:unsigned-int
            (list '*))))
      (let ((~type (unwrap-gconstpointer type)))
        (~f ~type)))))
(export g_variant_type_hash)

;; extern gboolean g_variant_type_equal(gconstpointer type1, gconstpointer 
;;     type2);
(define g_variant_type_equal
  (let ((~f #f))
    (lambda (type1 type2)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_type_equal"
            ffi:int
            (list '* '*))))
      (let ((~type1 (unwrap-gconstpointer type1))
            (~type2 (unwrap-gconstpointer type2)))
        (~f ~type1 ~type2)))))
(export g_variant_type_equal)

;; extern gboolean g_variant_type_is_subtype_of(const GVariantType *type, const
;;      GVariantType *supertype);
(define g_variant_type_is_subtype_of
  (let ((~f #f))
    (lambda (type supertype)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_type_is_subtype_of"
            ffi:int
            (list '* '*))))
      (let ((~type (unwrap-GVariantType* type))
            (~supertype (unwrap-GVariantType* supertype)))
        (~f ~type ~supertype)))))
(export g_variant_type_is_subtype_of)

;; extern const GVariantType *g_variant_type_element(const GVariantType *type)
;;     ;
(define g_variant_type_element
  (let ((~f #f))
    (lambda (type)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_type_element"
            '*
            (list '*))))
      (let ((~type (unwrap-GVariantType* type)))
        (wrap-GVariantType* (~f ~type))))))
(export g_variant_type_element)

;; extern const GVariantType *g_variant_type_first(const GVariantType *type);
(define g_variant_type_first
  (let ((~f #f))
    (lambda (type)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_type_first"
            '*
            (list '*))))
      (let ((~type (unwrap-GVariantType* type)))
        (wrap-GVariantType* (~f ~type))))))
(export g_variant_type_first)

;; extern const GVariantType *g_variant_type_next(const GVariantType *type);
(define g_variant_type_next
  (let ((~f #f))
    (lambda (type)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_variant_type_next" '* (list '*))))
      (let ((~type (unwrap-GVariantType* type)))
        (wrap-GVariantType* (~f ~type))))))
(export g_variant_type_next)

;; extern gsize g_variant_type_n_items(const GVariantType *type);
(define g_variant_type_n_items
  (let ((~f #f))
    (lambda (type)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_type_n_items"
            ffi:unsigned-long
            (list '*))))
      (let ((~type (unwrap-GVariantType* type)))
        (~f ~type)))))
(export g_variant_type_n_items)

;; extern const GVariantType *g_variant_type_key(const GVariantType *type);
(define g_variant_type_key
  (let ((~f #f))
    (lambda (type)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_variant_type_key" '* (list '*))))
      (let ((~type (unwrap-GVariantType* type)))
        (wrap-GVariantType* (~f ~type))))))
(export g_variant_type_key)

;; extern const GVariantType *g_variant_type_value(const GVariantType *type);
(define g_variant_type_value
  (let ((~f #f))
    (lambda (type)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_type_value"
            '*
            (list '*))))
      (let ((~type (unwrap-GVariantType* type)))
        (wrap-GVariantType* (~f ~type))))))
(export g_variant_type_value)

;; extern GVariantType *g_variant_type_new_array(const GVariantType *element);
(define g_variant_type_new_array
  (let ((~f #f))
    (lambda (element)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_type_new_array"
            '*
            (list '*))))
      (let ((~element (unwrap-GVariantType* element)))
        (wrap-GVariantType* (~f ~element))))))
(export g_variant_type_new_array)

;; extern GVariantType *g_variant_type_new_maybe(const GVariantType *element);
(define g_variant_type_new_maybe
  (let ((~f #f))
    (lambda (element)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_type_new_maybe"
            '*
            (list '*))))
      (let ((~element (unwrap-GVariantType* element)))
        (wrap-GVariantType* (~f ~element))))))
(export g_variant_type_new_maybe)

;; extern GVariantType *g_variant_type_new_tuple(const GVariantType *const*
;;     items, gint length);
(define g_variant_type_new_tuple
  (let ((~f #f))
    (lambda (items length)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_type_new_tuple"
            '*
            (list '* ffi:int))))
      (let ((~items (unwrap~pointer items))
            (~length (unwrap~fixed length)))
        (wrap-GVariantType* (~f ~items ~length))))))
(export g_variant_type_new_tuple)

;; extern GVariantType *g_variant_type_new_dict_entry(const GVariantType *key, 
;;     const GVariantType *value);
(define g_variant_type_new_dict_entry
  (let ((~f #f))
    (lambda (key value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_type_new_dict_entry"
            '*
            (list '* '*))))
      (let ((~key (unwrap-GVariantType* key))
            (~value (unwrap-GVariantType* value)))
        (wrap-GVariantType* (~f ~key ~value))))))
(export g_variant_type_new_dict_entry)

;; extern const GVariantType *g_variant_type_checked_(const gchar *);
(define g_variant_type_checked_
  (let ((~f #f))
    (lambda (@17335)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_type_checked_"
            '*
            (list '*))))
      (let ((~@17335 (unwrap~pointer @17335)))
        (wrap-GVariantType* (~f ~@17335))))))
(export g_variant_type_checked_)

;; typedef struct _GVariant GVariant;
(define GVariant-desc void)
(define GVariant*-desc (bs:pointer GVariant-desc))
(export GVariant*-desc)
(define-fh-pointer-type GVariant* GVariant*-desc)

;; typedef enum {
;;   G_VARIANT_CLASS_BOOLEAN = 'b',
;;   G_VARIANT_CLASS_BYTE = 'y',
;;   G_VARIANT_CLASS_INT16 = 'n',
;;   G_VARIANT_CLASS_UINT16 = 'q',
;;   G_VARIANT_CLASS_INT32 = 'i',
;;   G_VARIANT_CLASS_UINT32 = 'u',
;;   G_VARIANT_CLASS_INT64 = 'x',
;;   G_VARIANT_CLASS_UINT64 = 't',
;;   G_VARIANT_CLASS_HANDLE = 'h',
;;   G_VARIANT_CLASS_DOUBLE = 'd',
;;   G_VARIANT_CLASS_STRING = 's',
;;   G_VARIANT_CLASS_OBJECT_PATH = 'o',
;;   G_VARIANT_CLASS_SIGNATURE = 'g',
;;   G_VARIANT_CLASS_VARIANT = 'v',
;;   G_VARIANT_CLASS_MAYBE = 'm',
;;   G_VARIANT_CLASS_ARRAY = 'a',
;;   G_VARIANT_CLASS_TUPLE = '(',
;;   G_VARIANT_CLASS_DICT_ENTRY = '{',
;; } GVariantClass;
(define-fh-enum GVariantClass
  '((G_VARIANT_CLASS_BOOLEAN . 98)
    (G_VARIANT_CLASS_BYTE . 121)
    (G_VARIANT_CLASS_INT16 . 110)
    (G_VARIANT_CLASS_UINT16 . 113)
    (G_VARIANT_CLASS_INT32 . 105)
    (G_VARIANT_CLASS_UINT32 . 117)
    (G_VARIANT_CLASS_INT64 . 120)
    (G_VARIANT_CLASS_UINT64 . 116)
    (G_VARIANT_CLASS_HANDLE . 104)
    (G_VARIANT_CLASS_DOUBLE . 100)
    (G_VARIANT_CLASS_STRING . 115)
    (G_VARIANT_CLASS_OBJECT_PATH . 111)
    (G_VARIANT_CLASS_SIGNATURE . 103)
    (G_VARIANT_CLASS_VARIANT . 118)
    (G_VARIANT_CLASS_MAYBE . 109)
    (G_VARIANT_CLASS_ARRAY . 97)
    (G_VARIANT_CLASS_TUPLE . 40)
    (G_VARIANT_CLASS_DICT_ENTRY . 123))
  )

;; extern void g_variant_unref(GVariant *value);
(define g_variant_unref
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_unref"
            ffi:void
            (list '*))))
      (let ((~value (unwrap-GVariant* value)))
        (~f ~value)))))
(export g_variant_unref)

;; extern GVariant *g_variant_ref(GVariant *value);
(define g_variant_ref
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_variant_ref" '* (list '*))))
      (let ((~value (unwrap-GVariant* value)))
        (wrap-GVariant* (~f ~value))))))
(export g_variant_ref)

;; extern GVariant *g_variant_ref_sink(GVariant *value);
(define g_variant_ref_sink
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_variant_ref_sink" '* (list '*))))
      (let ((~value (unwrap-GVariant* value)))
        (wrap-GVariant* (~f ~value))))))
(export g_variant_ref_sink)

;; extern gboolean g_variant_is_floating(GVariant *value);
(define g_variant_is_floating
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_is_floating"
            ffi:int
            (list '*))))
      (let ((~value (unwrap-GVariant* value)))
        (~f ~value)))))
(export g_variant_is_floating)

;; extern GVariant *g_variant_take_ref(GVariant *value);
(define g_variant_take_ref
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_variant_take_ref" '* (list '*))))
      (let ((~value (unwrap-GVariant* value)))
        (wrap-GVariant* (~f ~value))))))
(export g_variant_take_ref)

;; extern const GVariantType *g_variant_get_type(GVariant *value);
(define g_variant_get_type
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_variant_get_type" '* (list '*))))
      (let ((~value (unwrap-GVariant* value)))
        (wrap-GVariantType* (~f ~value))))))
(export g_variant_get_type)

;; extern const gchar *g_variant_get_type_string(GVariant *value);
(define g_variant_get_type_string
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_get_type_string"
            '*
            (list '*))))
      (let ((~value (unwrap-GVariant* value)))
        (~f ~value)))))
(export g_variant_get_type_string)

;; extern gboolean g_variant_is_of_type(GVariant *value, const GVariantType *
;;     type);
(define g_variant_is_of_type
  (let ((~f #f))
    (lambda (value type)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_is_of_type"
            ffi:int
            (list '* '*))))
      (let ((~value (unwrap-GVariant* value))
            (~type (unwrap-GVariantType* type)))
        (~f ~value ~type)))))
(export g_variant_is_of_type)

;; extern gboolean g_variant_is_container(GVariant *value);
(define g_variant_is_container
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_is_container"
            ffi:int
            (list '*))))
      (let ((~value (unwrap-GVariant* value)))
        (~f ~value)))))
(export g_variant_is_container)

;; extern GVariantClass g_variant_classify(GVariant *value);
(define g_variant_classify
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_classify"
            ffi:int
            (list '*))))
      (let ((~value (unwrap-GVariant* value)))
        (~f ~value)))))
(export g_variant_classify)

;; extern GVariant *g_variant_new_boolean(gboolean value);
(define g_variant_new_boolean
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_new_boolean"
            '*
            (list ffi:int))))
      (let ((~value (unwrap~fixed value)))
        (wrap-GVariant* (~f ~value))))))
(export g_variant_new_boolean)

;; extern GVariant *g_variant_new_byte(guchar value);
(define g_variant_new_byte
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_new_byte"
            '*
            (list ffi:unsigned-int))))
      (let ((~value (unwrap~fixed value)))
        (wrap-GVariant* (~f ~value))))))
(export g_variant_new_byte)

;; extern GVariant *g_variant_new_int16(gint16 value);
(define g_variant_new_int16
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_new_int16"
            '*
            (list ffi:short))))
      (let ((~value (unwrap~fixed value)))
        (wrap-GVariant* (~f ~value))))))
(export g_variant_new_int16)

;; extern GVariant *g_variant_new_uint16(guint16 value);
(define g_variant_new_uint16
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_new_uint16"
            '*
            (list ffi:unsigned-short))))
      (let ((~value (unwrap~fixed value)))
        (wrap-GVariant* (~f ~value))))))
(export g_variant_new_uint16)

;; extern GVariant *g_variant_new_int32(gint32 value);
(define g_variant_new_int32
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_new_int32"
            '*
            (list ffi:int))))
      (let ((~value (unwrap~fixed value)))
        (wrap-GVariant* (~f ~value))))))
(export g_variant_new_int32)

;; extern GVariant *g_variant_new_uint32(guint32 value);
(define g_variant_new_uint32
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_new_uint32"
            '*
            (list ffi:unsigned-int))))
      (let ((~value (unwrap~fixed value)))
        (wrap-GVariant* (~f ~value))))))
(export g_variant_new_uint32)

;; extern GVariant *g_variant_new_int64(gint64 value);
(define g_variant_new_int64
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_new_int64"
            '*
            (list ffi:long))))
      (let ((~value (unwrap~fixed value)))
        (wrap-GVariant* (~f ~value))))))
(export g_variant_new_int64)

;; extern GVariant *g_variant_new_uint64(guint64 value);
(define g_variant_new_uint64
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_new_uint64"
            '*
            (list ffi:unsigned-long))))
      (let ((~value (unwrap~fixed value)))
        (wrap-GVariant* (~f ~value))))))
(export g_variant_new_uint64)

;; extern GVariant *g_variant_new_handle(gint32 value);
(define g_variant_new_handle
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_new_handle"
            '*
            (list ffi:int))))
      (let ((~value (unwrap~fixed value)))
        (wrap-GVariant* (~f ~value))))))
(export g_variant_new_handle)

;; extern GVariant *g_variant_new_double(gdouble value);
(define g_variant_new_double
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_new_double"
            '*
            (list ffi:double))))
      (let ((~value (unwrap-gdouble value)))
        (wrap-GVariant* (~f ~value))))))
(export g_variant_new_double)

;; extern GVariant *g_variant_new_string(const gchar *string);
(define g_variant_new_string
  (let ((~f #f))
    (lambda (string)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_new_string"
            '*
            (list '*))))
      (let ((~string (unwrap~pointer string)))
        (wrap-GVariant* (~f ~string))))))
(export g_variant_new_string)

;; extern GVariant *g_variant_new_take_string(gchar *string);
(define g_variant_new_take_string
  (let ((~f #f))
    (lambda (string)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_new_take_string"
            '*
            (list '*))))
      (let ((~string (unwrap~pointer string)))
        (wrap-GVariant* (~f ~string))))))
(export g_variant_new_take_string)

;; extern GVariant *g_variant_new_printf(const gchar *format_string, ...);
;; ... failed.

;; extern GVariant *g_variant_new_object_path(const gchar *object_path);
(define g_variant_new_object_path
  (let ((~f #f))
    (lambda (object_path)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_new_object_path"
            '*
            (list '*))))
      (let ((~object_path (unwrap~pointer object_path)))
        (wrap-GVariant* (~f ~object_path))))))
(export g_variant_new_object_path)

;; extern gboolean g_variant_is_object_path(const gchar *string);
(define g_variant_is_object_path
  (let ((~f #f))
    (lambda (string)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_is_object_path"
            ffi:int
            (list '*))))
      (let ((~string (unwrap~pointer string)))
        (~f ~string)))))
(export g_variant_is_object_path)

;; extern GVariant *g_variant_new_signature(const gchar *signature);
(define g_variant_new_signature
  (let ((~f #f))
    (lambda (signature)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_new_signature"
            '*
            (list '*))))
      (let ((~signature (unwrap~pointer signature)))
        (wrap-GVariant* (~f ~signature))))))
(export g_variant_new_signature)

;; extern gboolean g_variant_is_signature(const gchar *string);
(define g_variant_is_signature
  (let ((~f #f))
    (lambda (string)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_is_signature"
            ffi:int
            (list '*))))
      (let ((~string (unwrap~pointer string)))
        (~f ~string)))))
(export g_variant_is_signature)

;; extern GVariant *g_variant_new_variant(GVariant *value);
(define g_variant_new_variant
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_new_variant"
            '*
            (list '*))))
      (let ((~value (unwrap-GVariant* value)))
        (wrap-GVariant* (~f ~value))))))
(export g_variant_new_variant)

;; extern GVariant *g_variant_new_strv(const gchar *const*strv, gssize length)
;;     ;
(define g_variant_new_strv
  (let ((~f #f))
    (lambda (strv length)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_new_strv"
            '*
            (list '* ffi:long))))
      (let ((~strv (unwrap~pointer strv))
            (~length (unwrap~fixed length)))
        (wrap-GVariant* (~f ~strv ~length))))))
(export g_variant_new_strv)

;; extern GVariant *g_variant_new_objv(const gchar *const*strv, gssize length)
;;     ;
(define g_variant_new_objv
  (let ((~f #f))
    (lambda (strv length)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_new_objv"
            '*
            (list '* ffi:long))))
      (let ((~strv (unwrap~pointer strv))
            (~length (unwrap~fixed length)))
        (wrap-GVariant* (~f ~strv ~length))))))
(export g_variant_new_objv)

;; extern GVariant *g_variant_new_bytestring(const gchar *string);
(define g_variant_new_bytestring
  (let ((~f #f))
    (lambda (string)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_new_bytestring"
            '*
            (list '*))))
      (let ((~string (unwrap~pointer string)))
        (wrap-GVariant* (~f ~string))))))
(export g_variant_new_bytestring)

;; extern GVariant *g_variant_new_bytestring_array(const gchar *const*strv, 
;;     gssize length);
(define g_variant_new_bytestring_array
  (let ((~f #f))
    (lambda (strv length)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_new_bytestring_array"
            '*
            (list '* ffi:long))))
      (let ((~strv (unwrap~pointer strv))
            (~length (unwrap~fixed length)))
        (wrap-GVariant* (~f ~strv ~length))))))
(export g_variant_new_bytestring_array)

;; extern GVariant *g_variant_new_fixed_array(const GVariantType *element_type
;;     , gconstpointer elements, gsize n_elements, gsize element_size);
(define g_variant_new_fixed_array
  (let ((~f #f))
    (lambda (element_type elements n_elements element_size)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_new_fixed_array"
            '*
            (list '* '* ffi:unsigned-long ffi:unsigned-long))))
      (let ((~element_type
              (unwrap-GVariantType* element_type))
            (~elements (unwrap-gconstpointer elements))
            (~n_elements (unwrap~fixed n_elements))
            (~element_size (unwrap~fixed element_size)))
        (wrap-GVariant*
          (~f ~element_type
              ~elements
              ~n_elements
              ~element_size))))))
(export g_variant_new_fixed_array)

;; extern gboolean g_variant_get_boolean(GVariant *value);
(define g_variant_get_boolean
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_get_boolean"
            ffi:int
            (list '*))))
      (let ((~value (unwrap-GVariant* value)))
        (~f ~value)))))
(export g_variant_get_boolean)

;; extern guchar g_variant_get_byte(GVariant *value);
(define g_variant_get_byte
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_get_byte"
            ffi:unsigned-int
            (list '*))))
      (let ((~value (unwrap-GVariant* value)))
        (~f ~value)))))
(export g_variant_get_byte)

;; extern gint16 g_variant_get_int16(GVariant *value);
(define g_variant_get_int16
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_get_int16"
            ffi:short
            (list '*))))
      (let ((~value (unwrap-GVariant* value)))
        (~f ~value)))))
(export g_variant_get_int16)

;; extern guint16 g_variant_get_uint16(GVariant *value);
(define g_variant_get_uint16
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_get_uint16"
            ffi:unsigned-short
            (list '*))))
      (let ((~value (unwrap-GVariant* value)))
        (~f ~value)))))
(export g_variant_get_uint16)

;; extern gint32 g_variant_get_int32(GVariant *value);
(define g_variant_get_int32
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_get_int32"
            ffi:int
            (list '*))))
      (let ((~value (unwrap-GVariant* value)))
        (~f ~value)))))
(export g_variant_get_int32)

;; extern guint32 g_variant_get_uint32(GVariant *value);
(define g_variant_get_uint32
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_get_uint32"
            ffi:unsigned-int
            (list '*))))
      (let ((~value (unwrap-GVariant* value)))
        (~f ~value)))))
(export g_variant_get_uint32)

;; extern gint64 g_variant_get_int64(GVariant *value);
(define g_variant_get_int64
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_get_int64"
            ffi:long
            (list '*))))
      (let ((~value (unwrap-GVariant* value)))
        (~f ~value)))))
(export g_variant_get_int64)

;; extern guint64 g_variant_get_uint64(GVariant *value);
(define g_variant_get_uint64
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_get_uint64"
            ffi:unsigned-long
            (list '*))))
      (let ((~value (unwrap-GVariant* value)))
        (~f ~value)))))
(export g_variant_get_uint64)

;; extern gint32 g_variant_get_handle(GVariant *value);
(define g_variant_get_handle
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_get_handle"
            ffi:int
            (list '*))))
      (let ((~value (unwrap-GVariant* value)))
        (~f ~value)))))
(export g_variant_get_handle)

;; extern gdouble g_variant_get_double(GVariant *value);
(define g_variant_get_double
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_get_double"
            ffi:double
            (list '*))))
      (let ((~value (unwrap-GVariant* value)))
        (wrap-gdouble (~f ~value))))))
(export g_variant_get_double)

;; extern GVariant *g_variant_get_variant(GVariant *value);
(define g_variant_get_variant
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_get_variant"
            '*
            (list '*))))
      (let ((~value (unwrap-GVariant* value)))
        (wrap-GVariant* (~f ~value))))))
(export g_variant_get_variant)

;; extern const gchar *g_variant_get_string(GVariant *value, gsize *length);
(define g_variant_get_string
  (let ((~f #f))
    (lambda (value length)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_get_string"
            '*
            (list '* '*))))
      (let ((~value (unwrap-GVariant* value))
            (~length (unwrap~pointer length)))
        (~f ~value ~length)))))
(export g_variant_get_string)

;; extern gchar *g_variant_dup_string(GVariant *value, gsize *length);
(define g_variant_dup_string
  (let ((~f #f))
    (lambda (value length)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_dup_string"
            '*
            (list '* '*))))
      (let ((~value (unwrap-GVariant* value))
            (~length (unwrap~pointer length)))
        (~f ~value ~length)))))
(export g_variant_dup_string)

;; extern const gchar **g_variant_get_strv(GVariant *value, gsize *length);
(define g_variant_get_strv
  (let* ((addr (dynamic-pointer
                 "g_variant_get_strv"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer (bs:pointer void)))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_variant_get_strv)

;; extern gchar **g_variant_dup_strv(GVariant *value, gsize *length);
(define g_variant_dup_strv
  (let* ((addr (dynamic-pointer
                 "g_variant_dup_strv"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer (bs:pointer void)))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_variant_dup_strv)

;; extern const gchar **g_variant_get_objv(GVariant *value, gsize *length);
(define g_variant_get_objv
  (let* ((addr (dynamic-pointer
                 "g_variant_get_objv"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer (bs:pointer void)))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_variant_get_objv)

;; extern gchar **g_variant_dup_objv(GVariant *value, gsize *length);
(define g_variant_dup_objv
  (let* ((addr (dynamic-pointer
                 "g_variant_dup_objv"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer (bs:pointer void)))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_variant_dup_objv)

;; extern const gchar *g_variant_get_bytestring(GVariant *value);
(define g_variant_get_bytestring
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_get_bytestring"
            '*
            (list '*))))
      (let ((~value (unwrap-GVariant* value)))
        (~f ~value)))))
(export g_variant_get_bytestring)

;; extern gchar *g_variant_dup_bytestring(GVariant *value, gsize *length);
(define g_variant_dup_bytestring
  (let ((~f #f))
    (lambda (value length)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_dup_bytestring"
            '*
            (list '* '*))))
      (let ((~value (unwrap-GVariant* value))
            (~length (unwrap~pointer length)))
        (~f ~value ~length)))))
(export g_variant_dup_bytestring)

;; extern const gchar **g_variant_get_bytestring_array(GVariant *value, gsize *
;;     length);
(define g_variant_get_bytestring_array
  (let* ((addr (dynamic-pointer
                 "g_variant_get_bytestring_array"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer (bs:pointer void)))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_variant_get_bytestring_array)

;; extern gchar **g_variant_dup_bytestring_array(GVariant *value, gsize *length
;;     );
(define g_variant_dup_bytestring_array
  (let* ((addr (dynamic-pointer
                 "g_variant_dup_bytestring_array"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer (bs:pointer void)))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_variant_dup_bytestring_array)

;; extern GVariant *g_variant_new_maybe(const GVariantType *child_type, 
;;     GVariant *child);
(define g_variant_new_maybe
  (let ((~f #f))
    (lambda (child_type child)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_new_maybe"
            '*
            (list '* '*))))
      (let ((~child_type (unwrap-GVariantType* child_type))
            (~child (unwrap-GVariant* child)))
        (wrap-GVariant* (~f ~child_type ~child))))))
(export g_variant_new_maybe)

;; extern GVariant *g_variant_new_array(const GVariantType *child_type, 
;;     GVariant *const*children, gsize n_children);
(define g_variant_new_array
  (let ((~f #f))
    (lambda (child_type children n_children)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_new_array"
            '*
            (list '* '* ffi:unsigned-long))))
      (let ((~child_type (unwrap-GVariantType* child_type))
            (~children (unwrap~pointer children))
            (~n_children (unwrap~fixed n_children)))
        (wrap-GVariant*
          (~f ~child_type ~children ~n_children))))))
(export g_variant_new_array)

;; extern GVariant *g_variant_new_tuple(GVariant *const*children, gsize 
;;     n_children);
(define g_variant_new_tuple
  (let ((~f #f))
    (lambda (children n_children)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_new_tuple"
            '*
            (list '* ffi:unsigned-long))))
      (let ((~children (unwrap~pointer children))
            (~n_children (unwrap~fixed n_children)))
        (wrap-GVariant* (~f ~children ~n_children))))))
(export g_variant_new_tuple)

;; extern GVariant *g_variant_new_dict_entry(GVariant *key, GVariant *value);
(define g_variant_new_dict_entry
  (let ((~f #f))
    (lambda (key value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_new_dict_entry"
            '*
            (list '* '*))))
      (let ((~key (unwrap-GVariant* key))
            (~value (unwrap-GVariant* value)))
        (wrap-GVariant* (~f ~key ~value))))))
(export g_variant_new_dict_entry)

;; extern GVariant *g_variant_get_maybe(GVariant *value);
(define g_variant_get_maybe
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_variant_get_maybe" '* (list '*))))
      (let ((~value (unwrap-GVariant* value)))
        (wrap-GVariant* (~f ~value))))))
(export g_variant_get_maybe)

;; extern gsize g_variant_n_children(GVariant *value);
(define g_variant_n_children
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_n_children"
            ffi:unsigned-long
            (list '*))))
      (let ((~value (unwrap-GVariant* value)))
        (~f ~value)))))
(export g_variant_n_children)

;; extern void g_variant_get_child(GVariant *value, gsize index_, const gchar *
;;     format_string, ...);
;; ... failed.

;; extern GVariant *g_variant_get_child_value(GVariant *value, gsize index_);
(define g_variant_get_child_value
  (let ((~f #f))
    (lambda (value index_)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_get_child_value"
            '*
            (list '* ffi:unsigned-long))))
      (let ((~value (unwrap-GVariant* value))
            (~index_ (unwrap~fixed index_)))
        (wrap-GVariant* (~f ~value ~index_))))))
(export g_variant_get_child_value)

;; extern gboolean g_variant_lookup(GVariant *dictionary, const gchar *key, 
;;     const gchar *format_string, ...);
;; ... failed.

;; extern GVariant *g_variant_lookup_value(GVariant *dictionary, const gchar *
;;     key, const GVariantType *expected_type);
(define g_variant_lookup_value
  (let ((~f #f))
    (lambda (dictionary key expected_type)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_lookup_value"
            '*
            (list '* '* '*))))
      (let ((~dictionary (unwrap-GVariant* dictionary))
            (~key (unwrap~pointer key))
            (~expected_type
              (unwrap-GVariantType* expected_type)))
        (wrap-GVariant*
          (~f ~dictionary ~key ~expected_type))))))
(export g_variant_lookup_value)

;; extern gconstpointer g_variant_get_fixed_array(GVariant *value, gsize *
;;     n_elements, gsize element_size);
(define g_variant_get_fixed_array
  (let ((~f #f))
    (lambda (value n_elements element_size)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_get_fixed_array"
            '*
            (list '* '* ffi:unsigned-long))))
      (let ((~value (unwrap-GVariant* value))
            (~n_elements (unwrap~pointer n_elements))
            (~element_size (unwrap~fixed element_size)))
        (wrap-gconstpointer
          (~f ~value ~n_elements ~element_size))))))
(export g_variant_get_fixed_array)

;; extern gsize g_variant_get_size(GVariant *value);
(define g_variant_get_size
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_get_size"
            ffi:unsigned-long
            (list '*))))
      (let ((~value (unwrap-GVariant* value)))
        (~f ~value)))))
(export g_variant_get_size)

;; extern gconstpointer g_variant_get_data(GVariant *value);
(define g_variant_get_data
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_variant_get_data" '* (list '*))))
      (let ((~value (unwrap-GVariant* value)))
        (wrap-gconstpointer (~f ~value))))))
(export g_variant_get_data)

;; extern GBytes *g_variant_get_data_as_bytes(GVariant *value);
(define g_variant_get_data_as_bytes
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_get_data_as_bytes"
            '*
            (list '*))))
      (let ((~value (unwrap-GVariant* value)))
        (wrap-GBytes* (~f ~value))))))
(export g_variant_get_data_as_bytes)

;; extern void g_variant_store(GVariant *value, gpointer data);
(define g_variant_store
  (let ((~f #f))
    (lambda (value data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_store"
            ffi:void
            (list '* '*))))
      (let ((~value (unwrap-GVariant* value))
            (~data (unwrap-gpointer data)))
        (~f ~value ~data)))))
(export g_variant_store)

;; extern gchar *g_variant_print(GVariant *value, gboolean type_annotate);
(define g_variant_print
  (let ((~f #f))
    (lambda (value type_annotate)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_print"
            '*
            (list '* ffi:int))))
      (let ((~value (unwrap-GVariant* value))
            (~type_annotate (unwrap~fixed type_annotate)))
        (~f ~value ~type_annotate)))))
(export g_variant_print)

;; extern GString *g_variant_print_string(GVariant *value, GString *string, 
;;     gboolean type_annotate);
(define g_variant_print_string
  (let ((~f #f))
    (lambda (value string type_annotate)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_print_string"
            '*
            (list '* '* ffi:int))))
      (let ((~value (unwrap-GVariant* value))
            (~string (unwrap-GString* string))
            (~type_annotate (unwrap~fixed type_annotate)))
        (wrap-GString*
          (~f ~value ~string ~type_annotate))))))
(export g_variant_print_string)

;; extern guint g_variant_hash(gconstpointer value);
(define g_variant_hash
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_hash"
            ffi:unsigned-int
            (list '*))))
      (let ((~value (unwrap-gconstpointer value)))
        (~f ~value)))))
(export g_variant_hash)

;; extern gboolean g_variant_equal(gconstpointer one, gconstpointer two);
(define g_variant_equal
  (let ((~f #f))
    (lambda (one two)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_equal"
            ffi:int
            (list '* '*))))
      (let ((~one (unwrap-gconstpointer one))
            (~two (unwrap-gconstpointer two)))
        (~f ~one ~two)))))
(export g_variant_equal)

;; extern GVariant *g_variant_get_normal_form(GVariant *value);
(define g_variant_get_normal_form
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_get_normal_form"
            '*
            (list '*))))
      (let ((~value (unwrap-GVariant* value)))
        (wrap-GVariant* (~f ~value))))))
(export g_variant_get_normal_form)

;; extern gboolean g_variant_is_normal_form(GVariant *value);
(define g_variant_is_normal_form
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_is_normal_form"
            ffi:int
            (list '*))))
      (let ((~value (unwrap-GVariant* value)))
        (~f ~value)))))
(export g_variant_is_normal_form)

;; extern GVariant *g_variant_byteswap(GVariant *value);
(define g_variant_byteswap
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_variant_byteswap" '* (list '*))))
      (let ((~value (unwrap-GVariant* value)))
        (wrap-GVariant* (~f ~value))))))
(export g_variant_byteswap)

;; extern GVariant *g_variant_new_from_bytes(const GVariantType *type, GBytes *
;;     bytes, gboolean trusted);
(define g_variant_new_from_bytes
  (let ((~f #f))
    (lambda (type bytes trusted)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_new_from_bytes"
            '*
            (list '* '* ffi:int))))
      (let ((~type (unwrap-GVariantType* type))
            (~bytes (unwrap-GBytes* bytes))
            (~trusted (unwrap~fixed trusted)))
        (wrap-GVariant* (~f ~type ~bytes ~trusted))))))
(export g_variant_new_from_bytes)

;; extern GVariant *g_variant_new_from_data(const GVariantType *type, 
;;     gconstpointer data, gsize size, gboolean trusted, GDestroyNotify notify
;;     , gpointer user_data);
(define g_variant_new_from_data
  (let ((~f #f))
    (lambda (type data size trusted notify user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_new_from_data"
            '*
            (list '* '* ffi:unsigned-long ffi:int '* '*))))
      (let ((~type (unwrap-GVariantType* type))
            (~data (unwrap-gconstpointer data))
            (~size (unwrap~fixed size))
            (~trusted (unwrap~fixed trusted))
            (~notify
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               notify))
            (~user_data (unwrap-gpointer user_data)))
        (wrap-GVariant*
          (~f ~type
              ~data
              ~size
              ~trusted
              ~notify
              ~user_data))))))
(export g_variant_new_from_data)

;; typedef struct _GVariantIter GVariantIter;
(define GVariantIter-desc void)
(define GVariantIter*-desc (bs:pointer (delay GVariantIter-desc)))
(export GVariantIter*-desc)
(define-fh-pointer-type GVariantIter* GVariantIter*-desc)

;; struct _GVariantIter {
;;   /*< private >*/
;;   gsize x[16];
;; };
(define struct-_GVariantIter-desc
  (bs:struct
    (list `(x ,(bs:vector 16 unsigned-long)))))
(export struct-_GVariantIter-desc)
(define-fh-compound-type/p struct-_GVariantIter struct-_GVariantIter-desc)
(set! GVariantIter-desc struct-_GVariantIter-desc)
(define-fh-compound-type GVariantIter GVariantIter-desc)

;; extern GVariantIter *g_variant_iter_new(GVariant *value);
(define g_variant_iter_new
  (let ((~f #f))
    (lambda (value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_variant_iter_new" '* (list '*))))
      (let ((~value (unwrap-GVariant* value)))
        (wrap-GVariantIter* (~f ~value))))))
(export g_variant_iter_new)

;; extern gsize g_variant_iter_init(GVariantIter *iter, GVariant *value);
(define g_variant_iter_init
  (let ((~f #f))
    (lambda (iter value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_iter_init"
            ffi:unsigned-long
            (list '* '*))))
      (let ((~iter (unwrap-GVariantIter* iter))
            (~value (unwrap-GVariant* value)))
        (~f ~iter ~value)))))
(export g_variant_iter_init)

;; extern GVariantIter *g_variant_iter_copy(GVariantIter *iter);
(define g_variant_iter_copy
  (let ((~f #f))
    (lambda (iter)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_variant_iter_copy" '* (list '*))))
      (let ((~iter (unwrap-GVariantIter* iter)))
        (wrap-GVariantIter* (~f ~iter))))))
(export g_variant_iter_copy)

;; extern gsize g_variant_iter_n_children(GVariantIter *iter);
(define g_variant_iter_n_children
  (let ((~f #f))
    (lambda (iter)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_iter_n_children"
            ffi:unsigned-long
            (list '*))))
      (let ((~iter (unwrap-GVariantIter* iter)))
        (~f ~iter)))))
(export g_variant_iter_n_children)

;; extern void g_variant_iter_free(GVariantIter *iter);
(define g_variant_iter_free
  (let ((~f #f))
    (lambda (iter)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_iter_free"
            ffi:void
            (list '*))))
      (let ((~iter (unwrap-GVariantIter* iter)))
        (~f ~iter)))))
(export g_variant_iter_free)

;; extern GVariant *g_variant_iter_next_value(GVariantIter *iter);
(define g_variant_iter_next_value
  (let ((~f #f))
    (lambda (iter)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_iter_next_value"
            '*
            (list '*))))
      (let ((~iter (unwrap-GVariantIter* iter)))
        (wrap-GVariant* (~f ~iter))))))
(export g_variant_iter_next_value)

;; extern gboolean g_variant_iter_next(GVariantIter *iter, const gchar *
;;     format_string, ...);
;; ... failed.

;; extern gboolean g_variant_iter_loop(GVariantIter *iter, const gchar *
;;     format_string, ...);
;; ... failed.

;; typedef struct _GVariantBuilder GVariantBuilder;
(define GVariantBuilder-desc void)
(define GVariantBuilder*-desc (bs:pointer (delay GVariantBuilder-desc)))
(export GVariantBuilder*-desc)
(define-fh-pointer-type GVariantBuilder* GVariantBuilder*-desc)

;; struct _GVariantBuilder {
;;   /*< private >*/
;;   union {
;;     struct {
;;       gsize partial_magic;
;;       const GVariantType *type;
;;       gsize y[14];
;;     } s;
;;     gsize x[16];
;;   } u;
;; };
(define struct-_GVariantBuilder-desc
  (bs:struct
    (list `(u ,(bs:union
                 (list `(s ,(bs:struct
                              (list `(partial_magic ,unsigned-long)
                                    `(type ,(bs:pointer
                                              (delay GVariantType*-desc)))
                                    `(y ,(bs:vector 14 unsigned-long)))))
                       `(x ,(bs:vector 16 unsigned-long))))))))
(export struct-_GVariantBuilder-desc)
(define-fh-compound-type/p struct-_GVariantBuilder struct-_GVariantBuilder-desc)
(set! GVariantBuilder-desc struct-_GVariantBuilder-desc)
(define-fh-compound-type GVariantBuilder GVariantBuilder-desc)

;; typedef enum {
;;   G_VARIANT_PARSE_ERROR_FAILED,
;;   G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED,
;;   G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE,
;;   G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED,
;;   G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END,
;;   G_VARIANT_PARSE_ERROR_INVALID_CHARACTER,
;;   G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING,
;;   G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH,
;;   G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE,
;;   G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING,
;;   G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE,
;;   G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE,
;;   G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG,
;;   G_VARIANT_PARSE_ERROR_TYPE_ERROR,
;;   G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN,
;;   G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD,
;;   G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT,
;;   G_VARIANT_PARSE_ERROR_VALUE_EXPECTED,
;; } GVariantParseError;
(define-fh-enum GVariantParseError
  '((G_VARIANT_PARSE_ERROR_FAILED . 0)
    (G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED . 1)
    (G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE . 2)
    (G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED
      .
      3)
    (G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END . 4)
    (G_VARIANT_PARSE_ERROR_INVALID_CHARACTER . 5)
    (G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING . 6)
    (G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH . 7)
    (G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE . 8)
    (G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING . 9)
    (G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE . 10)
    (G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE . 11)
    (G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG . 12)
    (G_VARIANT_PARSE_ERROR_TYPE_ERROR . 13)
    (G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN . 14)
    (G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD . 15)
    (G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT
      .
      16)
    (G_VARIANT_PARSE_ERROR_VALUE_EXPECTED . 17))
  )

;; extern GQuark g_variant_parser_get_error_quark(void);
(define g_variant_parser_get_error_quark
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_parser_get_error_quark"
            ffi:unsigned-int
            (list))))
      (let () (~f)))))
(export g_variant_parser_get_error_quark)

;; extern GQuark g_variant_parse_error_quark(void);
(define g_variant_parse_error_quark
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_parse_error_quark"
            ffi:unsigned-int
            (list))))
      (let () (~f)))))
(export g_variant_parse_error_quark)

;; extern GVariantBuilder *g_variant_builder_new(const GVariantType *type);
(define g_variant_builder_new
  (let ((~f #f))
    (lambda (type)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_builder_new"
            '*
            (list '*))))
      (let ((~type (unwrap-GVariantType* type)))
        (wrap-GVariantBuilder* (~f ~type))))))
(export g_variant_builder_new)

;; extern void g_variant_builder_unref(GVariantBuilder *builder);
(define g_variant_builder_unref
  (let ((~f #f))
    (lambda (builder)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_builder_unref"
            ffi:void
            (list '*))))
      (let ((~builder (unwrap-GVariantBuilder* builder)))
        (~f ~builder)))))
(export g_variant_builder_unref)

;; extern GVariantBuilder *g_variant_builder_ref(GVariantBuilder *builder);
(define g_variant_builder_ref
  (let ((~f #f))
    (lambda (builder)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_builder_ref"
            '*
            (list '*))))
      (let ((~builder (unwrap-GVariantBuilder* builder)))
        (wrap-GVariantBuilder* (~f ~builder))))))
(export g_variant_builder_ref)

;; extern void g_variant_builder_init(GVariantBuilder *builder, const 
;;     GVariantType *type);
(define g_variant_builder_init
  (let ((~f #f))
    (lambda (builder type)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_builder_init"
            ffi:void
            (list '* '*))))
      (let ((~builder (unwrap-GVariantBuilder* builder))
            (~type (unwrap-GVariantType* type)))
        (~f ~builder ~type)))))
(export g_variant_builder_init)

;; extern GVariant *g_variant_builder_end(GVariantBuilder *builder);
(define g_variant_builder_end
  (let ((~f #f))
    (lambda (builder)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_builder_end"
            '*
            (list '*))))
      (let ((~builder (unwrap-GVariantBuilder* builder)))
        (wrap-GVariant* (~f ~builder))))))
(export g_variant_builder_end)

;; extern void g_variant_builder_clear(GVariantBuilder *builder);
(define g_variant_builder_clear
  (let ((~f #f))
    (lambda (builder)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_builder_clear"
            ffi:void
            (list '*))))
      (let ((~builder (unwrap-GVariantBuilder* builder)))
        (~f ~builder)))))
(export g_variant_builder_clear)

;; extern void g_variant_builder_open(GVariantBuilder *builder, const 
;;     GVariantType *type);
(define g_variant_builder_open
  (let ((~f #f))
    (lambda (builder type)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_builder_open"
            ffi:void
            (list '* '*))))
      (let ((~builder (unwrap-GVariantBuilder* builder))
            (~type (unwrap-GVariantType* type)))
        (~f ~builder ~type)))))
(export g_variant_builder_open)

;; extern void g_variant_builder_close(GVariantBuilder *builder);
(define g_variant_builder_close
  (let ((~f #f))
    (lambda (builder)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_builder_close"
            ffi:void
            (list '*))))
      (let ((~builder (unwrap-GVariantBuilder* builder)))
        (~f ~builder)))))
(export g_variant_builder_close)

;; extern void g_variant_builder_add_value(GVariantBuilder *builder, GVariant *
;;     value);
(define g_variant_builder_add_value
  (let ((~f #f))
    (lambda (builder value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_builder_add_value"
            ffi:void
            (list '* '*))))
      (let ((~builder (unwrap-GVariantBuilder* builder))
            (~value (unwrap-GVariant* value)))
        (~f ~builder ~value)))))
(export g_variant_builder_add_value)

;; extern void g_variant_builder_add(GVariantBuilder *builder, const gchar *
;;     format_string, ...);
;; ... failed.

;; extern void g_variant_builder_add_parsed(GVariantBuilder *builder, const 
;;     gchar *format, ...);
;; ... failed.

;; extern GVariant *g_variant_new(const gchar *format_string, ...);
;; ... failed.

;; extern void g_variant_get(GVariant *value, const gchar *format_string, ...)
;;     ;
;; ... failed.

;; extern GVariant *g_variant_new_va(const gchar *format_string, const gchar **
;;     endptr, va_list *app);
(define g_variant_new_va
  (let ((~f #f))
    (lambda (format_string endptr app)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_new_va"
            '*
            (list '* '* '*))))
      (let ((~format_string (unwrap~pointer format_string))
            (~endptr (unwrap~pointer endptr))
            (~app (unwrap~pointer app)))
        (wrap-GVariant* (~f ~format_string ~endptr ~app))))))
(export g_variant_new_va)

;; extern void g_variant_get_va(GVariant *value, const gchar *format_string, 
;;     const gchar **endptr, va_list *app);
(define g_variant_get_va
  (let ((~f #f))
    (lambda (value format_string endptr app)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_get_va"
            ffi:void
            (list '* '* '* '*))))
      (let ((~value (unwrap-GVariant* value))
            (~format_string (unwrap~pointer format_string))
            (~endptr (unwrap~pointer endptr))
            (~app (unwrap~pointer app)))
        (~f ~value ~format_string ~endptr ~app)))))
(export g_variant_get_va)

;; extern gboolean g_variant_check_format_string(GVariant *value, const gchar *
;;     format_string, gboolean copy_only);
(define g_variant_check_format_string
  (let ((~f #f))
    (lambda (value format_string copy_only)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_check_format_string"
            ffi:int
            (list '* '* ffi:int))))
      (let ((~value (unwrap-GVariant* value))
            (~format_string (unwrap~pointer format_string))
            (~copy_only (unwrap~fixed copy_only)))
        (~f ~value ~format_string ~copy_only)))))
(export g_variant_check_format_string)

;; extern GVariant *g_variant_parse(const GVariantType *type, const gchar *text
;;     , const gchar *limit, const gchar **endptr, GError **error);
(define g_variant_parse
  (let ((~f #f))
    (lambda (type text limit endptr error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_parse"
            '*
            (list '* '* '* '* '*))))
      (let ((~type (unwrap-GVariantType* type))
            (~text (unwrap~pointer text))
            (~limit (unwrap~pointer limit))
            (~endptr (unwrap~pointer endptr))
            (~error (unwrap~pointer error)))
        (wrap-GVariant*
          (~f ~type ~text ~limit ~endptr ~error))))))
(export g_variant_parse)

;; extern GVariant *g_variant_new_parsed(const gchar *format, ...);
;; ... failed.

;; extern GVariant *g_variant_new_parsed_va(const gchar *format, va_list *app)
;;     ;
(define g_variant_new_parsed_va
  (let ((~f #f))
    (lambda (format app)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_new_parsed_va"
            '*
            (list '* '*))))
      (let ((~format (unwrap~pointer format))
            (~app (unwrap~pointer app)))
        (wrap-GVariant* (~f ~format ~app))))))
(export g_variant_new_parsed_va)

;; extern gchar *g_variant_parse_error_print_context(GError *error, const gchar
;;      *source_str);
(define g_variant_parse_error_print_context
  (let ((~f #f))
    (lambda (error source_str)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_parse_error_print_context"
            '*
            (list '* '*))))
      (let ((~error (unwrap-GError* error))
            (~source_str (unwrap~pointer source_str)))
        (~f ~error ~source_str)))))
(export g_variant_parse_error_print_context)

;; extern gint g_variant_compare(gconstpointer one, gconstpointer two);
(define g_variant_compare
  (let ((~f #f))
    (lambda (one two)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_compare"
            ffi:int
            (list '* '*))))
      (let ((~one (unwrap-gconstpointer one))
            (~two (unwrap-gconstpointer two)))
        (~f ~one ~two)))))
(export g_variant_compare)

;; typedef struct _GVariantDict GVariantDict;
(define GVariantDict-desc void)
(define GVariantDict*-desc (bs:pointer (delay GVariantDict-desc)))
(export GVariantDict*-desc)
(define-fh-pointer-type GVariantDict* GVariantDict*-desc)

;; struct _GVariantDict {
;;   /*< private >*/
;;   union {
;;     struct {
;;       GVariant *asv;
;;       gsize partial_magic;
;;       gsize y[14];
;;     } s;
;;     gsize x[16];
;;   } u;
;; };
(define struct-_GVariantDict-desc
  (bs:struct
    (list `(u ,(bs:union
                 (list `(s ,(bs:struct
                              (list `(asv ,(bs:pointer (delay GVariant*-desc)))
                                    `(partial_magic ,unsigned-long)
                                    `(y ,(bs:vector 14 unsigned-long)))))
                       `(x ,(bs:vector 16 unsigned-long))))))))
(export struct-_GVariantDict-desc)
(define-fh-compound-type/p struct-_GVariantDict struct-_GVariantDict-desc)
(set! GVariantDict-desc struct-_GVariantDict-desc)
(define-fh-compound-type GVariantDict GVariantDict-desc)

;; extern GVariantDict *g_variant_dict_new(GVariant *from_asv);
(define g_variant_dict_new
  (let ((~f #f))
    (lambda (from_asv)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_variant_dict_new" '* (list '*))))
      (let ((~from_asv (unwrap-GVariant* from_asv)))
        (wrap-GVariantDict* (~f ~from_asv))))))
(export g_variant_dict_new)

;; extern void g_variant_dict_init(GVariantDict *dict, GVariant *from_asv);
(define g_variant_dict_init
  (let ((~f #f))
    (lambda (dict from_asv)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_dict_init"
            ffi:void
            (list '* '*))))
      (let ((~dict (unwrap-GVariantDict* dict))
            (~from_asv (unwrap-GVariant* from_asv)))
        (~f ~dict ~from_asv)))))
(export g_variant_dict_init)

;; extern gboolean g_variant_dict_lookup(GVariantDict *dict, const gchar *key, 
;;     const gchar *format_string, ...);
;; ... failed.

;; extern GVariant *g_variant_dict_lookup_value(GVariantDict *dict, const gchar
;;      *key, const GVariantType *expected_type);
(define g_variant_dict_lookup_value
  (let ((~f #f))
    (lambda (dict key expected_type)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_dict_lookup_value"
            '*
            (list '* '* '*))))
      (let ((~dict (unwrap-GVariantDict* dict))
            (~key (unwrap~pointer key))
            (~expected_type
              (unwrap-GVariantType* expected_type)))
        (wrap-GVariant* (~f ~dict ~key ~expected_type))))))
(export g_variant_dict_lookup_value)

;; extern gboolean g_variant_dict_contains(GVariantDict *dict, const gchar *key
;;     );
(define g_variant_dict_contains
  (let ((~f #f))
    (lambda (dict key)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_dict_contains"
            ffi:int
            (list '* '*))))
      (let ((~dict (unwrap-GVariantDict* dict))
            (~key (unwrap~pointer key)))
        (~f ~dict ~key)))))
(export g_variant_dict_contains)

;; extern void g_variant_dict_insert(GVariantDict *dict, const gchar *key, 
;;     const gchar *format_string, ...);
;; ... failed.

;; extern void g_variant_dict_insert_value(GVariantDict *dict, const gchar *key
;;     , GVariant *value);
(define g_variant_dict_insert_value
  (let ((~f #f))
    (lambda (dict key value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_dict_insert_value"
            ffi:void
            (list '* '* '*))))
      (let ((~dict (unwrap-GVariantDict* dict))
            (~key (unwrap~pointer key))
            (~value (unwrap-GVariant* value)))
        (~f ~dict ~key ~value)))))
(export g_variant_dict_insert_value)

;; extern gboolean g_variant_dict_remove(GVariantDict *dict, const gchar *key)
;;     ;
(define g_variant_dict_remove
  (let ((~f #f))
    (lambda (dict key)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_dict_remove"
            ffi:int
            (list '* '*))))
      (let ((~dict (unwrap-GVariantDict* dict))
            (~key (unwrap~pointer key)))
        (~f ~dict ~key)))))
(export g_variant_dict_remove)

;; extern void g_variant_dict_clear(GVariantDict *dict);
(define g_variant_dict_clear
  (let ((~f #f))
    (lambda (dict)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_dict_clear"
            ffi:void
            (list '*))))
      (let ((~dict (unwrap-GVariantDict* dict)))
        (~f ~dict)))))
(export g_variant_dict_clear)

;; extern GVariant *g_variant_dict_end(GVariantDict *dict);
(define g_variant_dict_end
  (let ((~f #f))
    (lambda (dict)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_variant_dict_end" '* (list '*))))
      (let ((~dict (unwrap-GVariantDict* dict)))
        (wrap-GVariant* (~f ~dict))))))
(export g_variant_dict_end)

;; extern GVariantDict *g_variant_dict_ref(GVariantDict *dict);
(define g_variant_dict_ref
  (let ((~f #f))
    (lambda (dict)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_variant_dict_ref" '* (list '*))))
      (let ((~dict (unwrap-GVariantDict* dict)))
        (wrap-GVariantDict* (~f ~dict))))))
(export g_variant_dict_ref)

;; extern void g_variant_dict_unref(GVariantDict *dict);
(define g_variant_dict_unref
  (let ((~f #f))
    (lambda (dict)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_variant_dict_unref"
            ffi:void
            (list '*))))
      (let ((~dict (unwrap-GVariantDict* dict)))
        (~f ~dict)))))
(export g_variant_dict_unref)

;; extern gsize g_printf_string_upper_bound(const gchar *format, va_list args)
;;     ;
(define g_printf_string_upper_bound
  (let ((~f #f))
    (lambda (format args)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_printf_string_upper_bound"
            ffi:unsigned-long
            (list '* '*))))
      (let ((~format (unwrap~pointer format))
            (~args (unwrap~pointer args)))
        (~f ~format ~args)))))
(export g_printf_string_upper_bound)

;; typedef enum {
;;   G_LOG_FLAG_RECURSION = 1<<0,
;;   G_LOG_FLAG_FATAL = 1<<1,
;;   G_LOG_LEVEL_ERROR = 1<<2,
;;   G_LOG_LEVEL_CRITICAL = 1<<3,
;;   G_LOG_LEVEL_WARNING = 1<<4,
;;   G_LOG_LEVEL_MESSAGE = 1<<5,
;;   G_LOG_LEVEL_INFO = 1<<6,
;;   G_LOG_LEVEL_DEBUG = 1<<7,
;;   G_LOG_LEVEL_MASK = ~(G_LOG_FLAG_RECURSION | G_LOG_FLAG_FATAL),
;; } GLogLevelFlags;
(define-fh-enum GLogLevelFlags
  '((G_LOG_FLAG_RECURSION . 1)
    (G_LOG_FLAG_FATAL . 2)
    (G_LOG_LEVEL_ERROR . 4)
    (G_LOG_LEVEL_CRITICAL . 8)
    (G_LOG_LEVEL_WARNING . 16)
    (G_LOG_LEVEL_MESSAGE . 32)
    (G_LOG_LEVEL_INFO . 64)
    (G_LOG_LEVEL_DEBUG . 128)
    (G_LOG_LEVEL_MASK . -4))
  )

;; typedef void (*GLogFunc)(const gchar *log_domain, GLogLevelFlags log_level, 
;;     const gchar *message, gpointer user_data);
(define-fh-function/p GLogFunc
  ffi:void (list (quote *) ffi:int (quote *) (quote *)))

;; extern guint g_log_set_handler(const gchar *log_domain, GLogLevelFlags 
;;     log_levels, GLogFunc log_func, gpointer user_data);
(define g_log_set_handler
  (let ((~f #f))
    (lambda (log_domain log_levels log_func user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_log_set_handler"
            ffi:unsigned-int
            (list '* ffi:int '* '*))))
      (let ((~log_domain (unwrap~pointer log_domain))
            (~log_levels (unwrap~fixed log_levels))
            (~log_func
              ((make-ftn-arg-unwrapper
                 ffi:void
                 (list '* ffi:int '* '*))
               log_func))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~log_domain ~log_levels ~log_func ~user_data)))))
(export g_log_set_handler)

;; extern guint g_log_set_handler_full(const gchar *log_domain, GLogLevelFlags 
;;     log_levels, GLogFunc log_func, gpointer user_data, GDestroyNotify 
;;     destroy);
(define g_log_set_handler_full
  (let ((~f #f))
    (lambda (log_domain
             log_levels
             log_func
             user_data
             destroy)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_log_set_handler_full"
            ffi:unsigned-int
            (list '* ffi:int '* '* '*))))
      (let ((~log_domain (unwrap~pointer log_domain))
            (~log_levels (unwrap~fixed log_levels))
            (~log_func
              ((make-ftn-arg-unwrapper
                 ffi:void
                 (list '* ffi:int '* '*))
               log_func))
            (~user_data (unwrap-gpointer user_data))
            (~destroy
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               destroy)))
        (~f ~log_domain
            ~log_levels
            ~log_func
            ~user_data
            ~destroy)))))
(export g_log_set_handler_full)

;; extern void g_log_remove_handler(const gchar *log_domain, guint handler_id)
;;     ;
(define g_log_remove_handler
  (let ((~f #f))
    (lambda (log_domain handler_id)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_log_remove_handler"
            ffi:void
            (list '* ffi:unsigned-int))))
      (let ((~log_domain (unwrap~pointer log_domain))
            (~handler_id (unwrap~fixed handler_id)))
        (~f ~log_domain ~handler_id)))))
(export g_log_remove_handler)

;; extern void g_log_default_handler(const gchar *log_domain, GLogLevelFlags 
;;     log_level, const gchar *message, gpointer unused_data);
(define g_log_default_handler
  (let ((~f #f))
    (lambda (log_domain log_level message unused_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_log_default_handler"
            ffi:void
            (list '* ffi:int '* '*))))
      (let ((~log_domain (unwrap~pointer log_domain))
            (~log_level (unwrap~fixed log_level))
            (~message (unwrap~pointer message))
            (~unused_data (unwrap-gpointer unused_data)))
        (~f ~log_domain ~log_level ~message ~unused_data)))))
(export g_log_default_handler)

;; extern GLogFunc g_log_set_default_handler(GLogFunc log_func, gpointer 
;;     user_data);
(define g_log_set_default_handler
  (let ((~f #f))
    (lambda (log_func user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_log_set_default_handler"
            '*
            (list '* '*))))
      (let ((~log_func
              ((make-ftn-arg-unwrapper
                 ffi:void
                 (list '* ffi:int '* '*))
               log_func))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~log_func ~user_data)))))
(export g_log_set_default_handler)

;; extern void g_log(const gchar *log_domain, GLogLevelFlags log_level, const 
;;     gchar *format, ...);
;; ... failed.

;; extern void g_logv(const gchar *log_domain, GLogLevelFlags log_level, const 
;;     gchar *format, va_list args);
(define g_logv
  (let ((~f #f))
    (lambda (log_domain log_level format args)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_logv"
            ffi:void
            (list '* ffi:int '* '*))))
      (let ((~log_domain (unwrap~pointer log_domain))
            (~log_level (unwrap~fixed log_level))
            (~format (unwrap~pointer format))
            (~args (unwrap~pointer args)))
        (~f ~log_domain ~log_level ~format ~args)))))
(export g_logv)

;; extern GLogLevelFlags g_log_set_fatal_mask(const gchar *log_domain, 
;;     GLogLevelFlags fatal_mask);
(define g_log_set_fatal_mask
  (let ((~f #f))
    (lambda (log_domain fatal_mask)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_log_set_fatal_mask"
            ffi:int
            (list '* ffi:int))))
      (let ((~log_domain (unwrap~pointer log_domain))
            (~fatal_mask (unwrap~fixed fatal_mask)))
        (~f ~log_domain ~fatal_mask)))))
(export g_log_set_fatal_mask)

;; extern GLogLevelFlags g_log_set_always_fatal(GLogLevelFlags fatal_mask);
(define g_log_set_always_fatal
  (let ((~f #f))
    (lambda (fatal_mask)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_log_set_always_fatal"
            ffi:int
            (list ffi:int))))
      (let ((~fatal_mask (unwrap~fixed fatal_mask)))
        (~f ~fatal_mask)))))
(export g_log_set_always_fatal)

;; typedef enum {
;;   G_LOG_WRITER_HANDLED = 1,
;;   G_LOG_WRITER_UNHANDLED = 0,
;; } GLogWriterOutput;
(define-fh-enum GLogWriterOutput
  '((G_LOG_WRITER_HANDLED . 1)
    (G_LOG_WRITER_UNHANDLED . 0))
  )

;; typedef struct _GLogField GLogField;
(define GLogField-desc void)
(define GLogField*-desc (bs:pointer (delay GLogField-desc)))
(export GLogField*-desc)
(define-fh-pointer-type GLogField* GLogField*-desc)

;; struct _GLogField {
;;   const gchar *key;
;;   gconstpointer value;
;;   gssize length;
;; };
(define struct-_GLogField-desc
  (bs:struct
    (list `(key ,(bs:pointer int))
          `(value ,gconstpointer-desc)
          `(length ,long))))
(export struct-_GLogField-desc)
(define-fh-compound-type/p struct-_GLogField struct-_GLogField-desc)
(set! GLogField-desc struct-_GLogField-desc)
(define-fh-compound-type GLogField GLogField-desc)

;; typedef GLogWriterOutput (*GLogWriterFunc)(GLogLevelFlags log_level, const 
;;     GLogField *fields, gsize n_fields, gpointer user_data);
(define-fh-function/p GLogWriterFunc
  ffi:int (list ffi:int (quote *) ffi:unsigned-long (quote *)))

;; extern void g_log_structured(const gchar *log_domain, GLogLevelFlags 
;;     log_level, ...);
;; ... failed.

;; extern void g_log_structured_array(GLogLevelFlags log_level, const GLogField
;;      *fields, gsize n_fields);
(define g_log_structured_array
  (let ((~f #f))
    (lambda (log_level fields n_fields)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_log_structured_array"
            ffi:void
            (list ffi:int '* ffi:unsigned-long))))
      (let ((~log_level (unwrap~fixed log_level))
            (~fields (unwrap-GLogField* fields))
            (~n_fields (unwrap~fixed n_fields)))
        (~f ~log_level ~fields ~n_fields)))))
(export g_log_structured_array)

;; extern void g_log_variant(const gchar *log_domain, GLogLevelFlags log_level
;;     , GVariant *fields);
(define g_log_variant
  (let ((~f #f))
    (lambda (log_domain log_level fields)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_log_variant"
            ffi:void
            (list '* ffi:int '*))))
      (let ((~log_domain (unwrap~pointer log_domain))
            (~log_level (unwrap~fixed log_level))
            (~fields (unwrap-GVariant* fields)))
        (~f ~log_domain ~log_level ~fields)))))
(export g_log_variant)

;; extern void g_log_set_writer_func(GLogWriterFunc func, gpointer user_data, 
;;     GDestroyNotify user_data_free);
(define g_log_set_writer_func
  (let ((~f #f))
    (lambda (func user_data user_data_free)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_log_set_writer_func"
            ffi:void
            (list '* '* '*))))
      (let ((~func ((make-ftn-arg-unwrapper
                      ffi:int
                      (list ffi:int '* ffi:unsigned-long '*))
                    func))
            (~user_data (unwrap-gpointer user_data))
            (~user_data_free
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               user_data_free)))
        (~f ~func ~user_data ~user_data_free)))))
(export g_log_set_writer_func)

;; extern gboolean g_log_writer_supports_color(gint output_fd);
(define g_log_writer_supports_color
  (let ((~f #f))
    (lambda (output_fd)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_log_writer_supports_color"
            ffi:int
            (list ffi:int))))
      (let ((~output_fd (unwrap~fixed output_fd)))
        (~f ~output_fd)))))
(export g_log_writer_supports_color)

;; extern gboolean g_log_writer_is_journald(gint output_fd);
(define g_log_writer_is_journald
  (let ((~f #f))
    (lambda (output_fd)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_log_writer_is_journald"
            ffi:int
            (list ffi:int))))
      (let ((~output_fd (unwrap~fixed output_fd)))
        (~f ~output_fd)))))
(export g_log_writer_is_journald)

;; extern gchar *g_log_writer_format_fields(GLogLevelFlags log_level, const 
;;     GLogField *fields, gsize n_fields, gboolean use_color);
(define g_log_writer_format_fields
  (let ((~f #f))
    (lambda (log_level fields n_fields use_color)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_log_writer_format_fields"
            '*
            (list ffi:int '* ffi:unsigned-long ffi:int))))
      (let ((~log_level (unwrap~fixed log_level))
            (~fields (unwrap-GLogField* fields))
            (~n_fields (unwrap~fixed n_fields))
            (~use_color (unwrap~fixed use_color)))
        (~f ~log_level ~fields ~n_fields ~use_color)))))
(export g_log_writer_format_fields)

;; extern GLogWriterOutput g_log_writer_journald(GLogLevelFlags log_level, 
;;     const GLogField *fields, gsize n_fields, gpointer user_data);
(define g_log_writer_journald
  (let ((~f #f))
    (lambda (log_level fields n_fields user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_log_writer_journald"
            ffi:int
            (list ffi:int '* ffi:unsigned-long '*))))
      (let ((~log_level (unwrap~fixed log_level))
            (~fields (unwrap-GLogField* fields))
            (~n_fields (unwrap~fixed n_fields))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~log_level ~fields ~n_fields ~user_data)))))
(export g_log_writer_journald)

;; extern GLogWriterOutput g_log_writer_standard_streams(GLogLevelFlags 
;;     log_level, const GLogField *fields, gsize n_fields, gpointer user_data)
;;     ;
(define g_log_writer_standard_streams
  (let ((~f #f))
    (lambda (log_level fields n_fields user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_log_writer_standard_streams"
            ffi:int
            (list ffi:int '* ffi:unsigned-long '*))))
      (let ((~log_level (unwrap~fixed log_level))
            (~fields (unwrap-GLogField* fields))
            (~n_fields (unwrap~fixed n_fields))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~log_level ~fields ~n_fields ~user_data)))))
(export g_log_writer_standard_streams)

;; extern GLogWriterOutput g_log_writer_default(GLogLevelFlags log_level, const
;;      GLogField *fields, gsize n_fields, gpointer user_data);
(define g_log_writer_default
  (let ((~f #f))
    (lambda (log_level fields n_fields user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_log_writer_default"
            ffi:int
            (list ffi:int '* ffi:unsigned-long '*))))
      (let ((~log_level (unwrap~fixed log_level))
            (~fields (unwrap-GLogField* fields))
            (~n_fields (unwrap~fixed n_fields))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~log_level ~fields ~n_fields ~user_data)))))
(export g_log_writer_default)

;; void _g_log_fallback_handler(const gchar *log_domain, GLogLevelFlags 
;;     log_level, const gchar *message, gpointer unused_data);
(define _g_log_fallback_handler
  (let ((~f #f))
    (lambda (log_domain log_level message unused_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "_g_log_fallback_handler"
            ffi:void
            (list '* ffi:int '* '*))))
      (let ((~log_domain (unwrap~pointer log_domain))
            (~log_level (unwrap~fixed log_level))
            (~message (unwrap~pointer message))
            (~unused_data (unwrap-gpointer unused_data)))
        (~f ~log_domain ~log_level ~message ~unused_data)))))
(export _g_log_fallback_handler)

;; extern void g_return_if_fail_warning(const char *log_domain, const char *
;;     pretty_function, const char *expression);
(define g_return_if_fail_warning
  (let ((~f #f))
    (lambda (log_domain pretty_function expression)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_return_if_fail_warning"
            ffi:void
            (list '* '* '*))))
      (let ((~log_domain (unwrap~pointer log_domain))
            (~pretty_function
              (unwrap~pointer pretty_function))
            (~expression (unwrap~pointer expression)))
        (~f ~log_domain ~pretty_function ~expression)))))
(export g_return_if_fail_warning)

;; extern void g_warn_message(const char *domain, const char *file, int line, 
;;     const char *func, const char *warnexpr);
(define g_warn_message
  (let ((~f #f))
    (lambda (domain file line func warnexpr)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_warn_message"
            ffi:void
            (list '* '* ffi:int '* '*))))
      (let ((~domain (unwrap~pointer domain))
            (~file (unwrap~pointer file))
            (~line (unwrap~fixed line))
            (~func (unwrap~pointer func))
            (~warnexpr (unwrap~pointer warnexpr)))
        (~f ~domain ~file ~line ~func ~warnexpr)))))
(export g_warn_message)

;; extern void g_assert_warning(const char *log_domain, const char *file, const
;;      int line, const char *pretty_function, const char *expression);
(define g_assert_warning
  (let ((~f #f))
    (lambda (log_domain file line pretty_function expression)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_assert_warning"
            ffi:void
            (list '* '* ffi:int '* '*))))
      (let ((~log_domain (unwrap~pointer log_domain))
            (~file (unwrap~pointer file))
            (~line (unwrap~fixed line))
            (~pretty_function
              (unwrap~pointer pretty_function))
            (~expression (unwrap~pointer expression)))
        (~f ~log_domain
            ~file
            ~line
            ~pretty_function
            ~expression)))))
(export g_assert_warning)

;; typedef void (*GPrintFunc)(const gchar *string);
(define-fh-function/p GPrintFunc
  ffi:void (list (quote *)))

;; extern void g_print(const gchar *format, ...);
;; ... failed.

;; extern GPrintFunc g_set_print_handler(GPrintFunc func);
(define g_set_print_handler
  (let ((~f #f))
    (lambda (func)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_set_print_handler" '* (list '*))))
      (let ((~func ((make-ftn-arg-unwrapper ffi:void (list '*))
                    func)))
        (~f ~func)))))
(export g_set_print_handler)

;; extern void g_printerr(const gchar *format, ...);
;; ... failed.

;; extern GPrintFunc g_set_printerr_handler(GPrintFunc func);
(define g_set_printerr_handler
  (let ((~f #f))
    (lambda (func)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_set_printerr_handler"
            '*
            (list '*))))
      (let ((~func ((make-ftn-arg-unwrapper ffi:void (list '*))
                    func)))
        (~f ~func)))))
(export g_set_printerr_handler)

;; typedef struct _GOptionContext GOptionContext;
(define GOptionContext-desc void)
(define GOptionContext*-desc (bs:pointer GOptionContext-desc))
(export GOptionContext*-desc)
(define-fh-pointer-type GOptionContext* GOptionContext*-desc)

;; typedef struct _GOptionGroup GOptionGroup;
(define GOptionGroup-desc void)
(define GOptionGroup*-desc (bs:pointer GOptionGroup-desc))
(export GOptionGroup*-desc)
(define-fh-pointer-type GOptionGroup* GOptionGroup*-desc)

;; typedef struct _GOptionEntry GOptionEntry;
(define GOptionEntry-desc void)
(define GOptionEntry*-desc (bs:pointer (delay GOptionEntry-desc)))
(export GOptionEntry*-desc)
(define-fh-pointer-type GOptionEntry* GOptionEntry*-desc)

;; typedef enum {
;;   G_OPTION_FLAG_NONE = 0,
;;   G_OPTION_FLAG_HIDDEN = 1<<0,
;;   G_OPTION_FLAG_IN_MAIN = 1<<1,
;;   G_OPTION_FLAG_REVERSE = 1<<2,
;;   G_OPTION_FLAG_NO_ARG = 1<<3,
;;   G_OPTION_FLAG_FILENAME = 1<<4,
;;   G_OPTION_FLAG_OPTIONAL_ARG = 1<<5,
;;   G_OPTION_FLAG_NOALIAS = 1<<6,
;; } GOptionFlags;
(define-fh-enum GOptionFlags
  '((G_OPTION_FLAG_NONE . 0)
    (G_OPTION_FLAG_HIDDEN . 1)
    (G_OPTION_FLAG_IN_MAIN . 2)
    (G_OPTION_FLAG_REVERSE . 4)
    (G_OPTION_FLAG_NO_ARG . 8)
    (G_OPTION_FLAG_FILENAME . 16)
    (G_OPTION_FLAG_OPTIONAL_ARG . 32)
    (G_OPTION_FLAG_NOALIAS . 64))
  )

;; typedef enum {
;;   G_OPTION_ARG_NONE,
;;   G_OPTION_ARG_STRING,
;;   G_OPTION_ARG_INT,
;;   G_OPTION_ARG_CALLBACK,
;;   G_OPTION_ARG_FILENAME,
;;   G_OPTION_ARG_STRING_ARRAY,
;;   G_OPTION_ARG_FILENAME_ARRAY,
;;   G_OPTION_ARG_DOUBLE,
;;   G_OPTION_ARG_INT64,
;; } GOptionArg;
(define-fh-enum GOptionArg
  '((G_OPTION_ARG_NONE . 0)
    (G_OPTION_ARG_STRING . 1)
    (G_OPTION_ARG_INT . 2)
    (G_OPTION_ARG_CALLBACK . 3)
    (G_OPTION_ARG_FILENAME . 4)
    (G_OPTION_ARG_STRING_ARRAY . 5)
    (G_OPTION_ARG_FILENAME_ARRAY . 6)
    (G_OPTION_ARG_DOUBLE . 7)
    (G_OPTION_ARG_INT64 . 8))
  )

;; typedef gboolean (*GOptionArgFunc)(const gchar *option_name, const gchar *
;;     value, gpointer data, GError **error);
(define-fh-function/p GOptionArgFunc
  ffi:int (list (quote *) (quote *) (quote *) (quote *)))

;; typedef gboolean (*GOptionParseFunc)(GOptionContext *context, GOptionGroup *
;;     group, gpointer data, GError **error);
(define-fh-function/p GOptionParseFunc
  ffi:int (list (quote *) (quote *) (quote *) (quote *)))

;; typedef void (*GOptionErrorFunc)(GOptionContext *context, GOptionGroup *
;;     group, gpointer data, GError **error);
(define-fh-function/p GOptionErrorFunc
  ffi:void (list (quote *) (quote *) (quote *) (quote *)))

;; typedef enum {
;;   G_OPTION_ERROR_UNKNOWN_OPTION,
;;   G_OPTION_ERROR_BAD_VALUE,
;;   G_OPTION_ERROR_FAILED,
;; } GOptionError;
(define-fh-enum GOptionError
  '((G_OPTION_ERROR_UNKNOWN_OPTION . 0)
    (G_OPTION_ERROR_BAD_VALUE . 1)
    (G_OPTION_ERROR_FAILED . 2))
  )

;; extern GQuark g_option_error_quark(void);
(define g_option_error_quark
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_option_error_quark"
            ffi:unsigned-int
            (list))))
      (let () (~f)))))
(export g_option_error_quark)

;; struct _GOptionEntry {
;;   const gchar *long_name;
;;   gchar short_name;
;;   gint flags;
;;   GOptionArg arg;
;;   gpointer arg_data;
;;   const gchar *description;
;;   const gchar *arg_description;
;; };
(define struct-_GOptionEntry-desc
  (bs:struct
    (list `(long_name ,(bs:pointer int))
          `(short_name ,int)
          `(flags ,int)
          `(arg ,int)
          `(arg_data ,gpointer-desc)
          `(description ,(bs:pointer int))
          `(arg_description ,(bs:pointer int)))))
(export struct-_GOptionEntry-desc)
(define-fh-compound-type/p struct-_GOptionEntry struct-_GOptionEntry-desc)
(set! GOptionEntry-desc struct-_GOptionEntry-desc)
(define-fh-compound-type GOptionEntry GOptionEntry-desc)

;; extern GOptionContext *g_option_context_new(const gchar *parameter_string);
(define g_option_context_new
  (let ((~f #f))
    (lambda (parameter_string)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_option_context_new"
            '*
            (list '*))))
      (let ((~parameter_string
              (unwrap~pointer parameter_string)))
        (wrap-GOptionContext* (~f ~parameter_string))))))
(export g_option_context_new)

;; extern void g_option_context_set_summary(GOptionContext *context, const 
;;     gchar *summary);
(define g_option_context_set_summary
  (let ((~f #f))
    (lambda (context summary)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_option_context_set_summary"
            ffi:void
            (list '* '*))))
      (let ((~context (unwrap-GOptionContext* context))
            (~summary (unwrap~pointer summary)))
        (~f ~context ~summary)))))
(export g_option_context_set_summary)

;; extern const gchar *g_option_context_get_summary(GOptionContext *context);
(define g_option_context_get_summary
  (let ((~f #f))
    (lambda (context)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_option_context_get_summary"
            '*
            (list '*))))
      (let ((~context (unwrap-GOptionContext* context)))
        (~f ~context)))))
(export g_option_context_get_summary)

;; extern void g_option_context_set_description(GOptionContext *context, const 
;;     gchar *description);
(define g_option_context_set_description
  (let ((~f #f))
    (lambda (context description)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_option_context_set_description"
            ffi:void
            (list '* '*))))
      (let ((~context (unwrap-GOptionContext* context))
            (~description (unwrap~pointer description)))
        (~f ~context ~description)))))
(export g_option_context_set_description)

;; extern const gchar *g_option_context_get_description(GOptionContext *context
;;     );
(define g_option_context_get_description
  (let ((~f #f))
    (lambda (context)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_option_context_get_description"
            '*
            (list '*))))
      (let ((~context (unwrap-GOptionContext* context)))
        (~f ~context)))))
(export g_option_context_get_description)

;; extern void g_option_context_free(GOptionContext *context);
(define g_option_context_free
  (let ((~f #f))
    (lambda (context)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_option_context_free"
            ffi:void
            (list '*))))
      (let ((~context (unwrap-GOptionContext* context)))
        (~f ~context)))))
(export g_option_context_free)

;; extern void g_option_context_set_help_enabled(GOptionContext *context, 
;;     gboolean help_enabled);
(define g_option_context_set_help_enabled
  (let ((~f #f))
    (lambda (context help_enabled)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_option_context_set_help_enabled"
            ffi:void
            (list '* ffi:int))))
      (let ((~context (unwrap-GOptionContext* context))
            (~help_enabled (unwrap~fixed help_enabled)))
        (~f ~context ~help_enabled)))))
(export g_option_context_set_help_enabled)

;; extern gboolean g_option_context_get_help_enabled(GOptionContext *context);
(define g_option_context_get_help_enabled
  (let ((~f #f))
    (lambda (context)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_option_context_get_help_enabled"
            ffi:int
            (list '*))))
      (let ((~context (unwrap-GOptionContext* context)))
        (~f ~context)))))
(export g_option_context_get_help_enabled)

;; extern void g_option_context_set_ignore_unknown_options(GOptionContext *
;;     context, gboolean ignore_unknown);
(define g_option_context_set_ignore_unknown_options
  (let ((~f #f))
    (lambda (context ignore_unknown)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_option_context_set_ignore_unknown_options"
            ffi:void
            (list '* ffi:int))))
      (let ((~context (unwrap-GOptionContext* context))
            (~ignore_unknown (unwrap~fixed ignore_unknown)))
        (~f ~context ~ignore_unknown)))))
(export g_option_context_set_ignore_unknown_options)

;; extern gboolean g_option_context_get_ignore_unknown_options(GOptionContext *
;;     context);
(define g_option_context_get_ignore_unknown_options
  (let ((~f #f))
    (lambda (context)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_option_context_get_ignore_unknown_options"
            ffi:int
            (list '*))))
      (let ((~context (unwrap-GOptionContext* context)))
        (~f ~context)))))
(export g_option_context_get_ignore_unknown_options)

;; extern void g_option_context_set_strict_posix(GOptionContext *context, 
;;     gboolean strict_posix);
(define g_option_context_set_strict_posix
  (let ((~f #f))
    (lambda (context strict_posix)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_option_context_set_strict_posix"
            ffi:void
            (list '* ffi:int))))
      (let ((~context (unwrap-GOptionContext* context))
            (~strict_posix (unwrap~fixed strict_posix)))
        (~f ~context ~strict_posix)))))
(export g_option_context_set_strict_posix)

;; extern gboolean g_option_context_get_strict_posix(GOptionContext *context);
(define g_option_context_get_strict_posix
  (let ((~f #f))
    (lambda (context)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_option_context_get_strict_posix"
            ffi:int
            (list '*))))
      (let ((~context (unwrap-GOptionContext* context)))
        (~f ~context)))))
(export g_option_context_get_strict_posix)

;; extern void g_option_context_add_main_entries(GOptionContext *context, const
;;      GOptionEntry *entries, const gchar *translation_domain);
(define g_option_context_add_main_entries
  (let ((~f #f))
    (lambda (context entries translation_domain)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_option_context_add_main_entries"
            ffi:void
            (list '* '* '*))))
      (let ((~context (unwrap-GOptionContext* context))
            (~entries (unwrap-GOptionEntry* entries))
            (~translation_domain
              (unwrap~pointer translation_domain)))
        (~f ~context ~entries ~translation_domain)))))
(export g_option_context_add_main_entries)

;; extern gboolean g_option_context_parse(GOptionContext *context, gint *argc, 
;;     gchar ***argv, GError **error);
(define g_option_context_parse
  (let ((~f #f))
    (lambda (context argc argv error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_option_context_parse"
            ffi:int
            (list '* '* '* '*))))
      (let ((~context (unwrap-GOptionContext* context))
            (~argc (unwrap~pointer argc))
            (~argv (unwrap~pointer argv))
            (~error (unwrap~pointer error)))
        (~f ~context ~argc ~argv ~error)))))
(export g_option_context_parse)

;; extern gboolean g_option_context_parse_strv(GOptionContext *context, gchar *
;;     **arguments, GError **error);
(define g_option_context_parse_strv
  (let ((~f #f))
    (lambda (context arguments error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_option_context_parse_strv"
            ffi:int
            (list '* '* '*))))
      (let ((~context (unwrap-GOptionContext* context))
            (~arguments (unwrap~pointer arguments))
            (~error (unwrap~pointer error)))
        (~f ~context ~arguments ~error)))))
(export g_option_context_parse_strv)

;; extern void g_option_context_set_translate_func(GOptionContext *context, 
;;     GTranslateFunc func, gpointer data, GDestroyNotify destroy_notify);
(define g_option_context_set_translate_func
  (let ((~f #f))
    (lambda (context func data destroy_notify)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_option_context_set_translate_func"
            ffi:void
            (list '* '* '* '*))))
      (let ((~context (unwrap-GOptionContext* context))
            (~func ((make-ftn-arg-unwrapper '* (list '* '*)) func))
            (~data (unwrap-gpointer data))
            (~destroy_notify
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               destroy_notify)))
        (~f ~context ~func ~data ~destroy_notify)))))
(export g_option_context_set_translate_func)

;; extern void g_option_context_set_translation_domain(GOptionContext *context
;;     , const gchar *domain);
(define g_option_context_set_translation_domain
  (let ((~f #f))
    (lambda (context domain)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_option_context_set_translation_domain"
            ffi:void
            (list '* '*))))
      (let ((~context (unwrap-GOptionContext* context))
            (~domain (unwrap~pointer domain)))
        (~f ~context ~domain)))))
(export g_option_context_set_translation_domain)

;; extern void g_option_context_add_group(GOptionContext *context, GOptionGroup
;;      *group);
(define g_option_context_add_group
  (let ((~f #f))
    (lambda (context group)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_option_context_add_group"
            ffi:void
            (list '* '*))))
      (let ((~context (unwrap-GOptionContext* context))
            (~group (unwrap-GOptionGroup* group)))
        (~f ~context ~group)))))
(export g_option_context_add_group)

;; extern void g_option_context_set_main_group(GOptionContext *context, 
;;     GOptionGroup *group);
(define g_option_context_set_main_group
  (let ((~f #f))
    (lambda (context group)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_option_context_set_main_group"
            ffi:void
            (list '* '*))))
      (let ((~context (unwrap-GOptionContext* context))
            (~group (unwrap-GOptionGroup* group)))
        (~f ~context ~group)))))
(export g_option_context_set_main_group)

;; extern GOptionGroup *g_option_context_get_main_group(GOptionContext *context
;;     );
(define g_option_context_get_main_group
  (let ((~f #f))
    (lambda (context)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_option_context_get_main_group"
            '*
            (list '*))))
      (let ((~context (unwrap-GOptionContext* context)))
        (wrap-GOptionGroup* (~f ~context))))))
(export g_option_context_get_main_group)

;; extern gchar *g_option_context_get_help(GOptionContext *context, gboolean 
;;     main_help, GOptionGroup *group);
(define g_option_context_get_help
  (let ((~f #f))
    (lambda (context main_help group)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_option_context_get_help"
            '*
            (list '* ffi:int '*))))
      (let ((~context (unwrap-GOptionContext* context))
            (~main_help (unwrap~fixed main_help))
            (~group (unwrap-GOptionGroup* group)))
        (~f ~context ~main_help ~group)))))
(export g_option_context_get_help)

;; extern GOptionGroup *g_option_group_new(const gchar *name, const gchar *
;;     description, const gchar *help_description, gpointer user_data, 
;;     GDestroyNotify destroy);
(define g_option_group_new
  (let ((~f #f))
    (lambda (name
             description
             help_description
             user_data
             destroy)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_option_group_new"
            '*
            (list '* '* '* '* '*))))
      (let ((~name (unwrap~pointer name))
            (~description (unwrap~pointer description))
            (~help_description
              (unwrap~pointer help_description))
            (~user_data (unwrap-gpointer user_data))
            (~destroy
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               destroy)))
        (wrap-GOptionGroup*
          (~f ~name
              ~description
              ~help_description
              ~user_data
              ~destroy))))))
(export g_option_group_new)

;; extern void g_option_group_set_parse_hooks(GOptionGroup *group, 
;;     GOptionParseFunc pre_parse_func, GOptionParseFunc post_parse_func);
(define g_option_group_set_parse_hooks
  (let ((~f #f))
    (lambda (group pre_parse_func post_parse_func)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_option_group_set_parse_hooks"
            ffi:void
            (list '* '* '*))))
      (let ((~group (unwrap-GOptionGroup* group))
            (~pre_parse_func
              ((make-ftn-arg-unwrapper
                 ffi:int
                 (list '* '* '* '*))
               pre_parse_func))
            (~post_parse_func
              ((make-ftn-arg-unwrapper
                 ffi:int
                 (list '* '* '* '*))
               post_parse_func)))
        (~f ~group ~pre_parse_func ~post_parse_func)))))
(export g_option_group_set_parse_hooks)

;; extern void g_option_group_set_error_hook(GOptionGroup *group, 
;;     GOptionErrorFunc error_func);
(define g_option_group_set_error_hook
  (let ((~f #f))
    (lambda (group error_func)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_option_group_set_error_hook"
            ffi:void
            (list '* '*))))
      (let ((~group (unwrap-GOptionGroup* group))
            (~error_func
              ((make-ftn-arg-unwrapper
                 ffi:void
                 (list '* '* '* '*))
               error_func)))
        (~f ~group ~error_func)))))
(export g_option_group_set_error_hook)

;; extern void g_option_group_free(GOptionGroup *group);
(define g_option_group_free
  (let ((~f #f))
    (lambda (group)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_option_group_free"
            ffi:void
            (list '*))))
      (let ((~group (unwrap-GOptionGroup* group)))
        (~f ~group)))))
(export g_option_group_free)

;; extern GOptionGroup *g_option_group_ref(GOptionGroup *group);
(define g_option_group_ref
  (let ((~f #f))
    (lambda (group)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_option_group_ref" '* (list '*))))
      (let ((~group (unwrap-GOptionGroup* group)))
        (wrap-GOptionGroup* (~f ~group))))))
(export g_option_group_ref)

;; extern void g_option_group_unref(GOptionGroup *group);
(define g_option_group_unref
  (let ((~f #f))
    (lambda (group)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_option_group_unref"
            ffi:void
            (list '*))))
      (let ((~group (unwrap-GOptionGroup* group)))
        (~f ~group)))))
(export g_option_group_unref)

;; extern void g_option_group_add_entries(GOptionGroup *group, const 
;;     GOptionEntry *entries);
(define g_option_group_add_entries
  (let ((~f #f))
    (lambda (group entries)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_option_group_add_entries"
            ffi:void
            (list '* '*))))
      (let ((~group (unwrap-GOptionGroup* group))
            (~entries (unwrap-GOptionEntry* entries)))
        (~f ~group ~entries)))))
(export g_option_group_add_entries)

;; extern void g_option_group_set_translate_func(GOptionGroup *group, 
;;     GTranslateFunc func, gpointer data, GDestroyNotify destroy_notify);
(define g_option_group_set_translate_func
  (let ((~f #f))
    (lambda (group func data destroy_notify)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_option_group_set_translate_func"
            ffi:void
            (list '* '* '* '*))))
      (let ((~group (unwrap-GOptionGroup* group))
            (~func ((make-ftn-arg-unwrapper '* (list '* '*)) func))
            (~data (unwrap-gpointer data))
            (~destroy_notify
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               destroy_notify)))
        (~f ~group ~func ~data ~destroy_notify)))))
(export g_option_group_set_translate_func)

;; extern void g_option_group_set_translation_domain(GOptionGroup *group, const
;;      gchar *domain);
(define g_option_group_set_translation_domain
  (let ((~f #f))
    (lambda (group domain)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_option_group_set_translation_domain"
            ffi:void
            (list '* '*))))
      (let ((~group (unwrap-GOptionGroup* group))
            (~domain (unwrap~pointer domain)))
        (~f ~group ~domain)))))
(export g_option_group_set_translation_domain)

;; typedef struct _GPatternSpec GPatternSpec;
(define GPatternSpec-desc void)
(define GPatternSpec*-desc (bs:pointer GPatternSpec-desc))
(export GPatternSpec*-desc)
(define-fh-pointer-type GPatternSpec* GPatternSpec*-desc)

;; extern GPatternSpec *g_pattern_spec_new(const gchar *pattern);
(define g_pattern_spec_new
  (let ((~f #f))
    (lambda (pattern)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_pattern_spec_new" '* (list '*))))
      (let ((~pattern (unwrap~pointer pattern)))
        (wrap-GPatternSpec* (~f ~pattern))))))
(export g_pattern_spec_new)

;; extern void g_pattern_spec_free(GPatternSpec *pspec);
(define g_pattern_spec_free
  (let ((~f #f))
    (lambda (pspec)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_pattern_spec_free"
            ffi:void
            (list '*))))
      (let ((~pspec (unwrap-GPatternSpec* pspec)))
        (~f ~pspec)))))
(export g_pattern_spec_free)

;; extern gboolean g_pattern_spec_equal(GPatternSpec *pspec1, GPatternSpec *
;;     pspec2);
(define g_pattern_spec_equal
  (let ((~f #f))
    (lambda (pspec1 pspec2)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_pattern_spec_equal"
            ffi:int
            (list '* '*))))
      (let ((~pspec1 (unwrap-GPatternSpec* pspec1))
            (~pspec2 (unwrap-GPatternSpec* pspec2)))
        (~f ~pspec1 ~pspec2)))))
(export g_pattern_spec_equal)

;; extern gboolean g_pattern_match(GPatternSpec *pspec, guint string_length, 
;;     const gchar *string, const gchar *string_reversed);
(define g_pattern_match
  (let ((~f #f))
    (lambda (pspec string_length string string_reversed)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_pattern_match"
            ffi:int
            (list '* ffi:unsigned-int '* '*))))
      (let ((~pspec (unwrap-GPatternSpec* pspec))
            (~string_length (unwrap~fixed string_length))
            (~string (unwrap~pointer string))
            (~string_reversed
              (unwrap~pointer string_reversed)))
        (~f ~pspec
            ~string_length
            ~string
            ~string_reversed)))))
(export g_pattern_match)

;; extern gboolean g_pattern_match_string(GPatternSpec *pspec, const gchar *
;;     string);
(define g_pattern_match_string
  (let ((~f #f))
    (lambda (pspec string)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_pattern_match_string"
            ffi:int
            (list '* '*))))
      (let ((~pspec (unwrap-GPatternSpec* pspec))
            (~string (unwrap~pointer string)))
        (~f ~pspec ~string)))))
(export g_pattern_match_string)

;; extern gboolean g_pattern_match_simple(const gchar *pattern, const gchar *
;;     string);
(define g_pattern_match_simple
  (let ((~f #f))
    (lambda (pattern string)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_pattern_match_simple"
            ffi:int
            (list '* '*))))
      (let ((~pattern (unwrap~pointer pattern))
            (~string (unwrap~pointer string)))
        (~f ~pattern ~string)))))
(export g_pattern_match_simple)

;; extern guint g_spaced_primes_closest(guint num);
(define g_spaced_primes_closest
  (let ((~f #f))
    (lambda (num)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_spaced_primes_closest"
            ffi:unsigned-int
            (list ffi:unsigned-int))))
      (let ((~num (unwrap~fixed num))) (~f ~num)))))
(export g_spaced_primes_closest)

;; extern void g_qsort_with_data(gconstpointer pbase, gint total_elems, gsize 
;;     size, GCompareDataFunc compare_func, gpointer user_data);
(define g_qsort_with_data
  (let ((~f #f))
    (lambda (pbase total_elems size compare_func user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_qsort_with_data"
            ffi:void
            (list '* ffi:int ffi:unsigned-long '* '*))))
      (let ((~pbase (unwrap-gconstpointer pbase))
            (~total_elems (unwrap~fixed total_elems))
            (~size (unwrap~fixed size))
            (~compare_func
              ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
               compare_func))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~pbase
            ~total_elems
            ~size
            ~compare_func
            ~user_data)))))
(export g_qsort_with_data)

;; typedef struct _GQueue GQueue;
(define GQueue-desc void)
(define GQueue*-desc (bs:pointer (delay GQueue-desc)))
(export GQueue*-desc)
(define-fh-pointer-type GQueue* GQueue*-desc)

;; struct _GQueue {
;;   GList *head;
;;   GList *tail;
;;   guint length;
;; };
(define struct-_GQueue-desc
  (bs:struct
    (list `(head ,(bs:pointer (delay GList*-desc)))
          `(tail ,(bs:pointer (delay GList*-desc)))
          `(length ,unsigned-int))))
(export struct-_GQueue-desc)
(define-fh-compound-type/p struct-_GQueue struct-_GQueue-desc)
(set! GQueue-desc struct-_GQueue-desc)
(define-fh-compound-type GQueue GQueue-desc)

;; extern GQueue *g_queue_new(void);
(define g_queue_new
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f (fh-link-proc "g_queue_new" '* (list))))
      (let () (wrap-GQueue* (~f))))))
(export g_queue_new)

;; extern void g_queue_free(GQueue *queue);
(define g_queue_free
  (let ((~f #f))
    (lambda (queue)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_queue_free" ffi:void (list '*))))
      (let ((~queue (unwrap-GQueue* queue)))
        (~f ~queue)))))
(export g_queue_free)

;; extern void g_queue_free_full(GQueue *queue, GDestroyNotify free_func);
(define g_queue_free_full
  (let ((~f #f))
    (lambda (queue free_func)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_queue_free_full"
            ffi:void
            (list '* '*))))
      (let ((~queue (unwrap-GQueue* queue))
            (~free_func
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               free_func)))
        (~f ~queue ~free_func)))))
(export g_queue_free_full)

;; extern void g_queue_init(GQueue *queue);
(define g_queue_init
  (let ((~f #f))
    (lambda (queue)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_queue_init" ffi:void (list '*))))
      (let ((~queue (unwrap-GQueue* queue)))
        (~f ~queue)))))
(export g_queue_init)

;; extern void g_queue_clear(GQueue *queue);
(define g_queue_clear
  (let ((~f #f))
    (lambda (queue)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_queue_clear" ffi:void (list '*))))
      (let ((~queue (unwrap-GQueue* queue)))
        (~f ~queue)))))
(export g_queue_clear)

;; extern gboolean g_queue_is_empty(GQueue *queue);
(define g_queue_is_empty
  (let ((~f #f))
    (lambda (queue)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_queue_is_empty"
            ffi:int
            (list '*))))
      (let ((~queue (unwrap-GQueue* queue)))
        (~f ~queue)))))
(export g_queue_is_empty)

;; extern guint g_queue_get_length(GQueue *queue);
(define g_queue_get_length
  (let ((~f #f))
    (lambda (queue)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_queue_get_length"
            ffi:unsigned-int
            (list '*))))
      (let ((~queue (unwrap-GQueue* queue)))
        (~f ~queue)))))
(export g_queue_get_length)

;; extern void g_queue_reverse(GQueue *queue);
(define g_queue_reverse
  (let ((~f #f))
    (lambda (queue)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_queue_reverse"
            ffi:void
            (list '*))))
      (let ((~queue (unwrap-GQueue* queue)))
        (~f ~queue)))))
(export g_queue_reverse)

;; extern GQueue *g_queue_copy(GQueue *queue);
(define g_queue_copy
  (let ((~f #f))
    (lambda (queue)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_queue_copy" '* (list '*))))
      (let ((~queue (unwrap-GQueue* queue)))
        (wrap-GQueue* (~f ~queue))))))
(export g_queue_copy)

;; extern void g_queue_foreach(GQueue *queue, GFunc func, gpointer user_data);
(define g_queue_foreach
  (let ((~f #f))
    (lambda (queue func user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_queue_foreach"
            ffi:void
            (list '* '* '*))))
      (let ((~queue (unwrap-GQueue* queue))
            (~func ((make-ftn-arg-unwrapper ffi:void (list '* '*))
                    func))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~queue ~func ~user_data)))))
(export g_queue_foreach)

;; extern GList *g_queue_find(GQueue *queue, gconstpointer data);
(define g_queue_find
  (let ((~f #f))
    (lambda (queue data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_queue_find" '* (list '* '*))))
      (let ((~queue (unwrap-GQueue* queue))
            (~data (unwrap-gconstpointer data)))
        (wrap-GList* (~f ~queue ~data))))))
(export g_queue_find)

;; extern GList *g_queue_find_custom(GQueue *queue, gconstpointer data, 
;;     GCompareFunc func);
(define g_queue_find_custom
  (let ((~f #f))
    (lambda (queue data func)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_queue_find_custom"
            '*
            (list '* '* '*))))
      (let ((~queue (unwrap-GQueue* queue))
            (~data (unwrap-gconstpointer data))
            (~func ((make-ftn-arg-unwrapper ffi:int (list '* '*))
                    func)))
        (wrap-GList* (~f ~queue ~data ~func))))))
(export g_queue_find_custom)

;; extern void g_queue_sort(GQueue *queue, GCompareDataFunc compare_func, 
;;     gpointer user_data);
(define g_queue_sort
  (let ((~f #f))
    (lambda (queue compare_func user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_queue_sort"
            ffi:void
            (list '* '* '*))))
      (let ((~queue (unwrap-GQueue* queue))
            (~compare_func
              ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
               compare_func))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~queue ~compare_func ~user_data)))))
(export g_queue_sort)

;; extern void g_queue_push_head(GQueue *queue, gpointer data);
(define g_queue_push_head
  (let ((~f #f))
    (lambda (queue data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_queue_push_head"
            ffi:void
            (list '* '*))))
      (let ((~queue (unwrap-GQueue* queue))
            (~data (unwrap-gpointer data)))
        (~f ~queue ~data)))))
(export g_queue_push_head)

;; extern void g_queue_push_tail(GQueue *queue, gpointer data);
(define g_queue_push_tail
  (let ((~f #f))
    (lambda (queue data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_queue_push_tail"
            ffi:void
            (list '* '*))))
      (let ((~queue (unwrap-GQueue* queue))
            (~data (unwrap-gpointer data)))
        (~f ~queue ~data)))))
(export g_queue_push_tail)

;; extern void g_queue_push_nth(GQueue *queue, gpointer data, gint n);
(define g_queue_push_nth
  (let ((~f #f))
    (lambda (queue data n)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_queue_push_nth"
            ffi:void
            (list '* '* ffi:int))))
      (let ((~queue (unwrap-GQueue* queue))
            (~data (unwrap-gpointer data))
            (~n (unwrap~fixed n)))
        (~f ~queue ~data ~n)))))
(export g_queue_push_nth)

;; extern gpointer g_queue_pop_head(GQueue *queue);
(define g_queue_pop_head
  (let ((~f #f))
    (lambda (queue)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_queue_pop_head" '* (list '*))))
      (let ((~queue (unwrap-GQueue* queue)))
        (wrap-gpointer (~f ~queue))))))
(export g_queue_pop_head)

;; extern gpointer g_queue_pop_tail(GQueue *queue);
(define g_queue_pop_tail
  (let ((~f #f))
    (lambda (queue)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_queue_pop_tail" '* (list '*))))
      (let ((~queue (unwrap-GQueue* queue)))
        (wrap-gpointer (~f ~queue))))))
(export g_queue_pop_tail)

;; extern gpointer g_queue_pop_nth(GQueue *queue, guint n);
(define g_queue_pop_nth
  (let ((~f #f))
    (lambda (queue n)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_queue_pop_nth"
            '*
            (list '* ffi:unsigned-int))))
      (let ((~queue (unwrap-GQueue* queue))
            (~n (unwrap~fixed n)))
        (wrap-gpointer (~f ~queue ~n))))))
(export g_queue_pop_nth)

;; extern gpointer g_queue_peek_head(GQueue *queue);
(define g_queue_peek_head
  (let ((~f #f))
    (lambda (queue)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_queue_peek_head" '* (list '*))))
      (let ((~queue (unwrap-GQueue* queue)))
        (wrap-gpointer (~f ~queue))))))
(export g_queue_peek_head)

;; extern gpointer g_queue_peek_tail(GQueue *queue);
(define g_queue_peek_tail
  (let ((~f #f))
    (lambda (queue)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_queue_peek_tail" '* (list '*))))
      (let ((~queue (unwrap-GQueue* queue)))
        (wrap-gpointer (~f ~queue))))))
(export g_queue_peek_tail)

;; extern gpointer g_queue_peek_nth(GQueue *queue, guint n);
(define g_queue_peek_nth
  (let ((~f #f))
    (lambda (queue n)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_queue_peek_nth"
            '*
            (list '* ffi:unsigned-int))))
      (let ((~queue (unwrap-GQueue* queue))
            (~n (unwrap~fixed n)))
        (wrap-gpointer (~f ~queue ~n))))))
(export g_queue_peek_nth)

;; extern gint g_queue_index(GQueue *queue, gconstpointer data);
(define g_queue_index
  (let ((~f #f))
    (lambda (queue data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_queue_index"
            ffi:int
            (list '* '*))))
      (let ((~queue (unwrap-GQueue* queue))
            (~data (unwrap-gconstpointer data)))
        (~f ~queue ~data)))))
(export g_queue_index)

;; extern gboolean g_queue_remove(GQueue *queue, gconstpointer data);
(define g_queue_remove
  (let ((~f #f))
    (lambda (queue data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_queue_remove"
            ffi:int
            (list '* '*))))
      (let ((~queue (unwrap-GQueue* queue))
            (~data (unwrap-gconstpointer data)))
        (~f ~queue ~data)))))
(export g_queue_remove)

;; extern guint g_queue_remove_all(GQueue *queue, gconstpointer data);
(define g_queue_remove_all
  (let ((~f #f))
    (lambda (queue data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_queue_remove_all"
            ffi:unsigned-int
            (list '* '*))))
      (let ((~queue (unwrap-GQueue* queue))
            (~data (unwrap-gconstpointer data)))
        (~f ~queue ~data)))))
(export g_queue_remove_all)

;; extern void g_queue_insert_before(GQueue *queue, GList *sibling, gpointer 
;;     data);
(define g_queue_insert_before
  (let ((~f #f))
    (lambda (queue sibling data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_queue_insert_before"
            ffi:void
            (list '* '* '*))))
      (let ((~queue (unwrap-GQueue* queue))
            (~sibling (unwrap-GList* sibling))
            (~data (unwrap-gpointer data)))
        (~f ~queue ~sibling ~data)))))
(export g_queue_insert_before)

;; extern void g_queue_insert_after(GQueue *queue, GList *sibling, gpointer 
;;     data);
(define g_queue_insert_after
  (let ((~f #f))
    (lambda (queue sibling data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_queue_insert_after"
            ffi:void
            (list '* '* '*))))
      (let ((~queue (unwrap-GQueue* queue))
            (~sibling (unwrap-GList* sibling))
            (~data (unwrap-gpointer data)))
        (~f ~queue ~sibling ~data)))))
(export g_queue_insert_after)

;; extern void g_queue_insert_sorted(GQueue *queue, gpointer data, 
;;     GCompareDataFunc func, gpointer user_data);
(define g_queue_insert_sorted
  (let ((~f #f))
    (lambda (queue data func user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_queue_insert_sorted"
            ffi:void
            (list '* '* '* '*))))
      (let ((~queue (unwrap-GQueue* queue))
            (~data (unwrap-gpointer data))
            (~func ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
                    func))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~queue ~data ~func ~user_data)))))
(export g_queue_insert_sorted)

;; extern void g_queue_push_head_link(GQueue *queue, GList *link_);
(define g_queue_push_head_link
  (let ((~f #f))
    (lambda (queue link_)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_queue_push_head_link"
            ffi:void
            (list '* '*))))
      (let ((~queue (unwrap-GQueue* queue))
            (~link_ (unwrap-GList* link_)))
        (~f ~queue ~link_)))))
(export g_queue_push_head_link)

;; extern void g_queue_push_tail_link(GQueue *queue, GList *link_);
(define g_queue_push_tail_link
  (let ((~f #f))
    (lambda (queue link_)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_queue_push_tail_link"
            ffi:void
            (list '* '*))))
      (let ((~queue (unwrap-GQueue* queue))
            (~link_ (unwrap-GList* link_)))
        (~f ~queue ~link_)))))
(export g_queue_push_tail_link)

;; extern void g_queue_push_nth_link(GQueue *queue, gint n, GList *link_);
(define g_queue_push_nth_link
  (let ((~f #f))
    (lambda (queue n link_)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_queue_push_nth_link"
            ffi:void
            (list '* ffi:int '*))))
      (let ((~queue (unwrap-GQueue* queue))
            (~n (unwrap~fixed n))
            (~link_ (unwrap-GList* link_)))
        (~f ~queue ~n ~link_)))))
(export g_queue_push_nth_link)

;; extern GList *g_queue_pop_head_link(GQueue *queue);
(define g_queue_pop_head_link
  (let ((~f #f))
    (lambda (queue)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_queue_pop_head_link"
            '*
            (list '*))))
      (let ((~queue (unwrap-GQueue* queue)))
        (wrap-GList* (~f ~queue))))))
(export g_queue_pop_head_link)

;; extern GList *g_queue_pop_tail_link(GQueue *queue);
(define g_queue_pop_tail_link
  (let ((~f #f))
    (lambda (queue)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_queue_pop_tail_link"
            '*
            (list '*))))
      (let ((~queue (unwrap-GQueue* queue)))
        (wrap-GList* (~f ~queue))))))
(export g_queue_pop_tail_link)

;; extern GList *g_queue_pop_nth_link(GQueue *queue, guint n);
(define g_queue_pop_nth_link
  (let ((~f #f))
    (lambda (queue n)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_queue_pop_nth_link"
            '*
            (list '* ffi:unsigned-int))))
      (let ((~queue (unwrap-GQueue* queue))
            (~n (unwrap~fixed n)))
        (wrap-GList* (~f ~queue ~n))))))
(export g_queue_pop_nth_link)

;; extern GList *g_queue_peek_head_link(GQueue *queue);
(define g_queue_peek_head_link
  (let ((~f #f))
    (lambda (queue)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_queue_peek_head_link"
            '*
            (list '*))))
      (let ((~queue (unwrap-GQueue* queue)))
        (wrap-GList* (~f ~queue))))))
(export g_queue_peek_head_link)

;; extern GList *g_queue_peek_tail_link(GQueue *queue);
(define g_queue_peek_tail_link
  (let ((~f #f))
    (lambda (queue)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_queue_peek_tail_link"
            '*
            (list '*))))
      (let ((~queue (unwrap-GQueue* queue)))
        (wrap-GList* (~f ~queue))))))
(export g_queue_peek_tail_link)

;; extern GList *g_queue_peek_nth_link(GQueue *queue, guint n);
(define g_queue_peek_nth_link
  (let ((~f #f))
    (lambda (queue n)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_queue_peek_nth_link"
            '*
            (list '* ffi:unsigned-int))))
      (let ((~queue (unwrap-GQueue* queue))
            (~n (unwrap~fixed n)))
        (wrap-GList* (~f ~queue ~n))))))
(export g_queue_peek_nth_link)

;; extern gint g_queue_link_index(GQueue *queue, GList *link_);
(define g_queue_link_index
  (let ((~f #f))
    (lambda (queue link_)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_queue_link_index"
            ffi:int
            (list '* '*))))
      (let ((~queue (unwrap-GQueue* queue))
            (~link_ (unwrap-GList* link_)))
        (~f ~queue ~link_)))))
(export g_queue_link_index)

;; extern void g_queue_unlink(GQueue *queue, GList *link_);
(define g_queue_unlink
  (let ((~f #f))
    (lambda (queue link_)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_queue_unlink"
            ffi:void
            (list '* '*))))
      (let ((~queue (unwrap-GQueue* queue))
            (~link_ (unwrap-GList* link_)))
        (~f ~queue ~link_)))))
(export g_queue_unlink)

;; extern void g_queue_delete_link(GQueue *queue, GList *link_);
(define g_queue_delete_link
  (let ((~f #f))
    (lambda (queue link_)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_queue_delete_link"
            ffi:void
            (list '* '*))))
      (let ((~queue (unwrap-GQueue* queue))
            (~link_ (unwrap-GList* link_)))
        (~f ~queue ~link_)))))
(export g_queue_delete_link)

;; typedef struct _GRand GRand;
(define GRand-desc void)
(define GRand*-desc (bs:pointer GRand-desc))
(export GRand*-desc)
(define-fh-pointer-type GRand* GRand*-desc)

;; extern GRand *g_rand_new_with_seed(guint32 seed);
(define g_rand_new_with_seed
  (let ((~f #f))
    (lambda (seed)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_rand_new_with_seed"
            '*
            (list ffi:unsigned-int))))
      (let ((~seed (unwrap~fixed seed)))
        (wrap-GRand* (~f ~seed))))))
(export g_rand_new_with_seed)

;; extern GRand *g_rand_new_with_seed_array(const guint32 *seed, guint 
;;     seed_length);
(define g_rand_new_with_seed_array
  (let ((~f #f))
    (lambda (seed seed_length)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_rand_new_with_seed_array"
            '*
            (list '* ffi:unsigned-int))))
      (let ((~seed (unwrap~pointer seed))
            (~seed_length (unwrap~fixed seed_length)))
        (wrap-GRand* (~f ~seed ~seed_length))))))
(export g_rand_new_with_seed_array)

;; extern GRand *g_rand_new(void);
(define g_rand_new
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f (fh-link-proc "g_rand_new" '* (list))))
      (let () (wrap-GRand* (~f))))))
(export g_rand_new)

;; extern void g_rand_free(GRand *rand_);
(define g_rand_free
  (let ((~f #f))
    (lambda (rand_)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_rand_free" ffi:void (list '*))))
      (let ((~rand_ (unwrap-GRand* rand_)))
        (~f ~rand_)))))
(export g_rand_free)

;; extern GRand *g_rand_copy(GRand *rand_);
(define g_rand_copy
  (let ((~f #f))
    (lambda (rand_)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_rand_copy" '* (list '*))))
      (let ((~rand_ (unwrap-GRand* rand_)))
        (wrap-GRand* (~f ~rand_))))))
(export g_rand_copy)

;; extern void g_rand_set_seed(GRand *rand_, guint32 seed);
(define g_rand_set_seed
  (let ((~f #f))
    (lambda (rand_ seed)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_rand_set_seed"
            ffi:void
            (list '* ffi:unsigned-int))))
      (let ((~rand_ (unwrap-GRand* rand_))
            (~seed (unwrap~fixed seed)))
        (~f ~rand_ ~seed)))))
(export g_rand_set_seed)

;; extern void g_rand_set_seed_array(GRand *rand_, const guint32 *seed, guint 
;;     seed_length);
(define g_rand_set_seed_array
  (let ((~f #f))
    (lambda (rand_ seed seed_length)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_rand_set_seed_array"
            ffi:void
            (list '* '* ffi:unsigned-int))))
      (let ((~rand_ (unwrap-GRand* rand_))
            (~seed (unwrap~pointer seed))
            (~seed_length (unwrap~fixed seed_length)))
        (~f ~rand_ ~seed ~seed_length)))))
(export g_rand_set_seed_array)

;; extern guint32 g_rand_int(GRand *rand_);
(define g_rand_int
  (let ((~f #f))
    (lambda (rand_)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_rand_int"
            ffi:unsigned-int
            (list '*))))
      (let ((~rand_ (unwrap-GRand* rand_)))
        (~f ~rand_)))))
(export g_rand_int)

;; extern gint32 g_rand_int_range(GRand *rand_, gint32 begin, gint32 end);
(define g_rand_int_range
  (let ((~f #f))
    (lambda (rand_ begin end)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_rand_int_range"
            ffi:int
            (list '* ffi:int ffi:int))))
      (let ((~rand_ (unwrap-GRand* rand_))
            (~begin (unwrap~fixed begin))
            (~end (unwrap~fixed end)))
        (~f ~rand_ ~begin ~end)))))
(export g_rand_int_range)

;; extern gdouble g_rand_double(GRand *rand_);
(define g_rand_double
  (let ((~f #f))
    (lambda (rand_)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_rand_double"
            ffi:double
            (list '*))))
      (let ((~rand_ (unwrap-GRand* rand_)))
        (wrap-gdouble (~f ~rand_))))))
(export g_rand_double)

;; extern gdouble g_rand_double_range(GRand *rand_, gdouble begin, gdouble end)
;;     ;
(define g_rand_double_range
  (let ((~f #f))
    (lambda (rand_ begin end)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_rand_double_range"
            ffi:double
            (list '* ffi:double ffi:double))))
      (let ((~rand_ (unwrap-GRand* rand_))
            (~begin (unwrap-gdouble begin))
            (~end (unwrap-gdouble end)))
        (wrap-gdouble (~f ~rand_ ~begin ~end))))))
(export g_rand_double_range)

;; extern void g_random_set_seed(guint32 seed);
(define g_random_set_seed
  (let ((~f #f))
    (lambda (seed)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_random_set_seed"
            ffi:void
            (list ffi:unsigned-int))))
      (let ((~seed (unwrap~fixed seed))) (~f ~seed)))))
(export g_random_set_seed)

;; extern guint32 g_random_int(void);
(define g_random_int
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_random_int"
            ffi:unsigned-int
            (list))))
      (let () (~f)))))
(export g_random_int)

;; extern gint32 g_random_int_range(gint32 begin, gint32 end);
(define g_random_int_range
  (let ((~f #f))
    (lambda (begin end)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_random_int_range"
            ffi:int
            (list ffi:int ffi:int))))
      (let ((~begin (unwrap~fixed begin))
            (~end (unwrap~fixed end)))
        (~f ~begin ~end)))))
(export g_random_int_range)

;; extern gdouble g_random_double(void);
(define g_random_double
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_random_double"
            ffi:double
            (list))))
      (let () (wrap-gdouble (~f))))))
(export g_random_double)

;; extern gdouble g_random_double_range(gdouble begin, gdouble end);
(define g_random_double_range
  (let ((~f #f))
    (lambda (begin end)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_random_double_range"
            ffi:double
            (list ffi:double ffi:double))))
      (let ((~begin (unwrap-gdouble begin))
            (~end (unwrap-gdouble end)))
        (wrap-gdouble (~f ~begin ~end))))))
(export g_random_double_range)

;; typedef enum {
;;   G_REGEX_ERROR_COMPILE,
;;   G_REGEX_ERROR_OPTIMIZE,
;;   G_REGEX_ERROR_REPLACE,
;;   G_REGEX_ERROR_MATCH,
;;   G_REGEX_ERROR_INTERNAL,
;;   G_REGEX_ERROR_STRAY_BACKSLASH = 101,
;;   G_REGEX_ERROR_MISSING_CONTROL_CHAR = 102,
;;   G_REGEX_ERROR_UNRECOGNIZED_ESCAPE = 103,
;;   G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER = 104,
;;   G_REGEX_ERROR_QUANTIFIER_TOO_BIG = 105,
;;   G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS = 106,
;;   G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS = 107,
;;   G_REGEX_ERROR_RANGE_OUT_OF_ORDER = 108,
;;   G_REGEX_ERROR_NOTHING_TO_REPEAT = 109,
;;   G_REGEX_ERROR_UNRECOGNIZED_CHARACTER = 112,
;;   G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS = 113,
;;   G_REGEX_ERROR_UNMATCHED_PARENTHESIS = 114,
;;   G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE = 115,
;;   G_REGEX_ERROR_UNTERMINATED_COMMENT = 118,
;;   G_REGEX_ERROR_EXPRESSION_TOO_LARGE = 120,
;;   G_REGEX_ERROR_MEMORY_ERROR = 121,
;;   G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND = 125,
;;   G_REGEX_ERROR_MALFORMED_CONDITION = 126,
;;   G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES = 127,
;;   G_REGEX_ERROR_ASSERTION_EXPECTED = 128,
;;   G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME = 130,
;;   G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED = 131,
;;   G_REGEX_ERROR_HEX_CODE_TOO_LARGE = 134,
;;   G_REGEX_ERROR_INVALID_CONDITION = 135,
;;   G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND = 136,
;;   G_REGEX_ERROR_INFINITE_LOOP = 140,
;;   G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR = 142,
;;   G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME = 143,
;;   G_REGEX_ERROR_MALFORMED_PROPERTY = 146,
;;   G_REGEX_ERROR_UNKNOWN_PROPERTY = 147,
;;   G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG = 148,
;;   G_REGEX_ERROR_TOO_MANY_SUBPATTERNS = 149,
;;   G_REGEX_ERROR_INVALID_OCTAL_VALUE = 151,
;;   G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE = 154,
;;   G_REGEX_ERROR_DEFINE_REPETION = 155,
;;   G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS = 156,
;;   G_REGEX_ERROR_MISSING_BACK_REFERENCE = 157,
;;   G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE = 158,
;;   G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN = 159,
;;   G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB = 160,
;;   G_REGEX_ERROR_NUMBER_TOO_BIG = 161,
;;   G_REGEX_ERROR_MISSING_SUBPATTERN_NAME = 162,
;;   G_REGEX_ERROR_MISSING_DIGIT = 163,
;;   G_REGEX_ERROR_INVALID_DATA_CHARACTER = 164,
;;   G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME = 165,
;;   G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED = 166,
;;   G_REGEX_ERROR_INVALID_CONTROL_CHAR = 168,
;;   G_REGEX_ERROR_MISSING_NAME = 169,
;;   G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS = 171,
;;   G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES = 172,
;;   G_REGEX_ERROR_NAME_TOO_LONG = 175,
;;   G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE = 176,
;; } GRegexError;
(define-fh-enum GRegexError
  '((G_REGEX_ERROR_COMPILE . 0)
    (G_REGEX_ERROR_OPTIMIZE . 1)
    (G_REGEX_ERROR_REPLACE . 2)
    (G_REGEX_ERROR_MATCH . 3)
    (G_REGEX_ERROR_INTERNAL . 4)
    (G_REGEX_ERROR_STRAY_BACKSLASH . 101)
    (G_REGEX_ERROR_MISSING_CONTROL_CHAR . 102)
    (G_REGEX_ERROR_UNRECOGNIZED_ESCAPE . 103)
    (G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER . 104)
    (G_REGEX_ERROR_QUANTIFIER_TOO_BIG . 105)
    (G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS
      .
      106)
    (G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS
      .
      107)
    (G_REGEX_ERROR_RANGE_OUT_OF_ORDER . 108)
    (G_REGEX_ERROR_NOTHING_TO_REPEAT . 109)
    (G_REGEX_ERROR_UNRECOGNIZED_CHARACTER . 112)
    (G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS
      .
      113)
    (G_REGEX_ERROR_UNMATCHED_PARENTHESIS . 114)
    (G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE
      .
      115)
    (G_REGEX_ERROR_UNTERMINATED_COMMENT . 118)
    (G_REGEX_ERROR_EXPRESSION_TOO_LARGE . 120)
    (G_REGEX_ERROR_MEMORY_ERROR . 121)
    (G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND . 125)
    (G_REGEX_ERROR_MALFORMED_CONDITION . 126)
    (G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES
      .
      127)
    (G_REGEX_ERROR_ASSERTION_EXPECTED . 128)
    (G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME . 130)
    (G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED
      .
      131)
    (G_REGEX_ERROR_HEX_CODE_TOO_LARGE . 134)
    (G_REGEX_ERROR_INVALID_CONDITION . 135)
    (G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND
      .
      136)
    (G_REGEX_ERROR_INFINITE_LOOP . 140)
    (G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR
      .
      142)
    (G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME . 143)
    (G_REGEX_ERROR_MALFORMED_PROPERTY . 146)
    (G_REGEX_ERROR_UNKNOWN_PROPERTY . 147)
    (G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG . 148)
    (G_REGEX_ERROR_TOO_MANY_SUBPATTERNS . 149)
    (G_REGEX_ERROR_INVALID_OCTAL_VALUE . 151)
    (G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE . 154)
    (G_REGEX_ERROR_DEFINE_REPETION . 155)
    (G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS
      .
      156)
    (G_REGEX_ERROR_MISSING_BACK_REFERENCE . 157)
    (G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE . 158)
    (G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN
      .
      159)
    (G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB
      .
      160)
    (G_REGEX_ERROR_NUMBER_TOO_BIG . 161)
    (G_REGEX_ERROR_MISSING_SUBPATTERN_NAME . 162)
    (G_REGEX_ERROR_MISSING_DIGIT . 163)
    (G_REGEX_ERROR_INVALID_DATA_CHARACTER . 164)
    (G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME . 165)
    (G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED
      .
      166)
    (G_REGEX_ERROR_INVALID_CONTROL_CHAR . 168)
    (G_REGEX_ERROR_MISSING_NAME . 169)
    (G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS . 171)
    (G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES . 172)
    (G_REGEX_ERROR_NAME_TOO_LONG . 175)
    (G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE . 176))
  )

;; extern GQuark g_regex_error_quark(void);
(define g_regex_error_quark
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_regex_error_quark"
            ffi:unsigned-int
            (list))))
      (let () (~f)))))
(export g_regex_error_quark)

;; typedef enum {
;;   G_REGEX_CASELESS = 1<<0,
;;   G_REGEX_MULTILINE = 1<<1,
;;   G_REGEX_DOTALL = 1<<2,
;;   G_REGEX_EXTENDED = 1<<3,
;;   G_REGEX_ANCHORED = 1<<4,
;;   G_REGEX_DOLLAR_ENDONLY = 1<<5,
;;   G_REGEX_UNGREEDY = 1<<9,
;;   G_REGEX_RAW = 1<<11,
;;   G_REGEX_NO_AUTO_CAPTURE = 1<<12,
;;   G_REGEX_OPTIMIZE = 1<<13,
;;   G_REGEX_FIRSTLINE = 1<<18,
;;   G_REGEX_DUPNAMES = 1<<19,
;;   G_REGEX_NEWLINE_CR = 1<<20,
;;   G_REGEX_NEWLINE_LF = 1<<21,
;;   G_REGEX_NEWLINE_CRLF = G_REGEX_NEWLINE_CR | G_REGEX_NEWLINE_LF,
;;   G_REGEX_NEWLINE_ANYCRLF = G_REGEX_NEWLINE_CR | 1<<22,
;;   G_REGEX_BSR_ANYCRLF = 1<<23,
;;   G_REGEX_JAVASCRIPT_COMPAT = 1<<25,
;; } GRegexCompileFlags;
(define-fh-enum GRegexCompileFlags
  '((G_REGEX_CASELESS . 1)
    (G_REGEX_MULTILINE . 2)
    (G_REGEX_DOTALL . 4)
    (G_REGEX_EXTENDED . 8)
    (G_REGEX_ANCHORED . 16)
    (G_REGEX_DOLLAR_ENDONLY . 32)
    (G_REGEX_UNGREEDY . 512)
    (G_REGEX_RAW . 2048)
    (G_REGEX_NO_AUTO_CAPTURE . 4096)
    (G_REGEX_OPTIMIZE . 8192)
    (G_REGEX_FIRSTLINE . 262144)
    (G_REGEX_DUPNAMES . 524288)
    (G_REGEX_NEWLINE_CR . 1048576)
    (G_REGEX_NEWLINE_LF . 2097152)
    (G_REGEX_NEWLINE_CRLF . 3145728)
    (G_REGEX_NEWLINE_ANYCRLF . 5242880)
    (G_REGEX_BSR_ANYCRLF . 8388608)
    (G_REGEX_JAVASCRIPT_COMPAT . 33554432))
  )

;; typedef enum {
;;   G_REGEX_MATCH_ANCHORED = 1<<4,
;;   G_REGEX_MATCH_NOTBOL = 1<<7,
;;   G_REGEX_MATCH_NOTEOL = 1<<8,
;;   G_REGEX_MATCH_NOTEMPTY = 1<<10,
;;   G_REGEX_MATCH_PARTIAL = 1<<15,
;;   G_REGEX_MATCH_NEWLINE_CR = 1<<20,
;;   G_REGEX_MATCH_NEWLINE_LF = 1<<21,
;;   G_REGEX_MATCH_NEWLINE_CRLF = G_REGEX_MATCH_NEWLINE_CR | 
;;       G_REGEX_MATCH_NEWLINE_LF,
;;   G_REGEX_MATCH_NEWLINE_ANY = 1<<22,
;;   G_REGEX_MATCH_NEWLINE_ANYCRLF = G_REGEX_MATCH_NEWLINE_CR | 
;;       G_REGEX_MATCH_NEWLINE_ANY,
;;   G_REGEX_MATCH_BSR_ANYCRLF = 1<<23,
;;   G_REGEX_MATCH_BSR_ANY = 1<<24,
;;   G_REGEX_MATCH_PARTIAL_SOFT = G_REGEX_MATCH_PARTIAL,
;;   G_REGEX_MATCH_PARTIAL_HARD = 1<<27,
;;   G_REGEX_MATCH_NOTEMPTY_ATSTART = 1<<28,
;; } GRegexMatchFlags;
(define-fh-enum GRegexMatchFlags
  '((G_REGEX_MATCH_ANCHORED . 16)
    (G_REGEX_MATCH_NOTBOL . 128)
    (G_REGEX_MATCH_NOTEOL . 256)
    (G_REGEX_MATCH_NOTEMPTY . 1024)
    (G_REGEX_MATCH_PARTIAL . 32768)
    (G_REGEX_MATCH_NEWLINE_CR . 1048576)
    (G_REGEX_MATCH_NEWLINE_LF . 2097152)
    (G_REGEX_MATCH_NEWLINE_CRLF . 3145728)
    (G_REGEX_MATCH_NEWLINE_ANY . 4194304)
    (G_REGEX_MATCH_NEWLINE_ANYCRLF . 5242880)
    (G_REGEX_MATCH_BSR_ANYCRLF . 8388608)
    (G_REGEX_MATCH_BSR_ANY . 16777216)
    (G_REGEX_MATCH_PARTIAL_SOFT . 32768)
    (G_REGEX_MATCH_PARTIAL_HARD . 134217728)
    (G_REGEX_MATCH_NOTEMPTY_ATSTART . 268435456))
  )

;; typedef struct _GRegex GRegex;
(define GRegex-desc void)
(define GRegex*-desc (bs:pointer GRegex-desc))
(export GRegex*-desc)
(define-fh-pointer-type GRegex* GRegex*-desc)

;; typedef struct _GMatchInfo GMatchInfo;
(define GMatchInfo-desc void)
(define GMatchInfo*-desc (bs:pointer GMatchInfo-desc))
(export GMatchInfo*-desc)
(define-fh-pointer-type GMatchInfo* GMatchInfo*-desc)

;; typedef gboolean (*GRegexEvalCallback)(const GMatchInfo *match_info, GString
;;      *result, gpointer user_data);
(define-fh-function/p GRegexEvalCallback
  ffi:int (list (quote *) (quote *) (quote *)))

;; extern GRegex *g_regex_new(const gchar *pattern, GRegexCompileFlags 
;;     compile_options, GRegexMatchFlags match_options, GError **error);
(define g_regex_new
  (let ((~f #f))
    (lambda (pattern compile_options match_options error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_regex_new"
            '*
            (list '* ffi:int ffi:int '*))))
      (let ((~pattern (unwrap~pointer pattern))
            (~compile_options (unwrap~fixed compile_options))
            (~match_options (unwrap~fixed match_options))
            (~error (unwrap~pointer error)))
        (wrap-GRegex*
          (~f ~pattern
              ~compile_options
              ~match_options
              ~error))))))
(export g_regex_new)

;; extern GRegex *g_regex_ref(GRegex *regex);
(define g_regex_ref
  (let ((~f #f))
    (lambda (regex)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_regex_ref" '* (list '*))))
      (let ((~regex (unwrap-GRegex* regex)))
        (wrap-GRegex* (~f ~regex))))))
(export g_regex_ref)

;; extern void g_regex_unref(GRegex *regex);
(define g_regex_unref
  (let ((~f #f))
    (lambda (regex)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_regex_unref" ffi:void (list '*))))
      (let ((~regex (unwrap-GRegex* regex)))
        (~f ~regex)))))
(export g_regex_unref)

;; extern const gchar *g_regex_get_pattern(const GRegex *regex);
(define g_regex_get_pattern
  (let ((~f #f))
    (lambda (regex)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_regex_get_pattern" '* (list '*))))
      (let ((~regex (unwrap-GRegex* regex)))
        (~f ~regex)))))
(export g_regex_get_pattern)

;; extern gint g_regex_get_max_backref(const GRegex *regex);
(define g_regex_get_max_backref
  (let ((~f #f))
    (lambda (regex)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_regex_get_max_backref"
            ffi:int
            (list '*))))
      (let ((~regex (unwrap-GRegex* regex)))
        (~f ~regex)))))
(export g_regex_get_max_backref)

;; extern gint g_regex_get_capture_count(const GRegex *regex);
(define g_regex_get_capture_count
  (let ((~f #f))
    (lambda (regex)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_regex_get_capture_count"
            ffi:int
            (list '*))))
      (let ((~regex (unwrap-GRegex* regex)))
        (~f ~regex)))))
(export g_regex_get_capture_count)

;; extern gboolean g_regex_get_has_cr_or_lf(const GRegex *regex);
(define g_regex_get_has_cr_or_lf
  (let ((~f #f))
    (lambda (regex)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_regex_get_has_cr_or_lf"
            ffi:int
            (list '*))))
      (let ((~regex (unwrap-GRegex* regex)))
        (~f ~regex)))))
(export g_regex_get_has_cr_or_lf)

;; extern gint g_regex_get_max_lookbehind(const GRegex *regex);
(define g_regex_get_max_lookbehind
  (let ((~f #f))
    (lambda (regex)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_regex_get_max_lookbehind"
            ffi:int
            (list '*))))
      (let ((~regex (unwrap-GRegex* regex)))
        (~f ~regex)))))
(export g_regex_get_max_lookbehind)

;; extern gint g_regex_get_string_number(const GRegex *regex, const gchar *name
;;     );
(define g_regex_get_string_number
  (let ((~f #f))
    (lambda (regex name)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_regex_get_string_number"
            ffi:int
            (list '* '*))))
      (let ((~regex (unwrap-GRegex* regex))
            (~name (unwrap~pointer name)))
        (~f ~regex ~name)))))
(export g_regex_get_string_number)

;; extern gchar *g_regex_escape_string(const gchar *string, gint length);
(define g_regex_escape_string
  (let ((~f #f))
    (lambda (string length)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_regex_escape_string"
            '*
            (list '* ffi:int))))
      (let ((~string (unwrap~pointer string))
            (~length (unwrap~fixed length)))
        (~f ~string ~length)))))
(export g_regex_escape_string)

;; extern gchar *g_regex_escape_nul(const gchar *string, gint length);
(define g_regex_escape_nul
  (let ((~f #f))
    (lambda (string length)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_regex_escape_nul"
            '*
            (list '* ffi:int))))
      (let ((~string (unwrap~pointer string))
            (~length (unwrap~fixed length)))
        (~f ~string ~length)))))
(export g_regex_escape_nul)

;; extern GRegexCompileFlags g_regex_get_compile_flags(const GRegex *regex);
(define g_regex_get_compile_flags
  (let ((~f #f))
    (lambda (regex)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_regex_get_compile_flags"
            ffi:int
            (list '*))))
      (let ((~regex (unwrap-GRegex* regex)))
        (~f ~regex)))))
(export g_regex_get_compile_flags)

;; extern GRegexMatchFlags g_regex_get_match_flags(const GRegex *regex);
(define g_regex_get_match_flags
  (let ((~f #f))
    (lambda (regex)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_regex_get_match_flags"
            ffi:int
            (list '*))))
      (let ((~regex (unwrap-GRegex* regex)))
        (~f ~regex)))))
(export g_regex_get_match_flags)

;; extern gboolean g_regex_match_simple(const gchar *pattern, const gchar *
;;     string, GRegexCompileFlags compile_options, GRegexMatchFlags 
;;     match_options);
(define g_regex_match_simple
  (let ((~f #f))
    (lambda (pattern string compile_options match_options)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_regex_match_simple"
            ffi:int
            (list '* '* ffi:int ffi:int))))
      (let ((~pattern (unwrap~pointer pattern))
            (~string (unwrap~pointer string))
            (~compile_options (unwrap~fixed compile_options))
            (~match_options (unwrap~fixed match_options)))
        (~f ~pattern
            ~string
            ~compile_options
            ~match_options)))))
(export g_regex_match_simple)

;; extern gboolean g_regex_match(const GRegex *regex, const gchar *string, 
;;     GRegexMatchFlags match_options, GMatchInfo **match_info);
(define g_regex_match
  (let ((~f #f))
    (lambda (regex string match_options match_info)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_regex_match"
            ffi:int
            (list '* '* ffi:int '*))))
      (let ((~regex (unwrap-GRegex* regex))
            (~string (unwrap~pointer string))
            (~match_options (unwrap~fixed match_options))
            (~match_info (unwrap~pointer match_info)))
        (~f ~regex ~string ~match_options ~match_info)))))
(export g_regex_match)

;; extern gboolean g_regex_match_full(const GRegex *regex, const gchar *string
;;     , gssize string_len, gint start_position, GRegexMatchFlags match_options
;;     , GMatchInfo **match_info, GError **error);
(define g_regex_match_full
  (let ((~f #f))
    (lambda (regex
             string
             string_len
             start_position
             match_options
             match_info
             error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_regex_match_full"
            ffi:int
            (list '* '* ffi:long ffi:int ffi:int '* '*))))
      (let ((~regex (unwrap-GRegex* regex))
            (~string (unwrap~pointer string))
            (~string_len (unwrap~fixed string_len))
            (~start_position (unwrap~fixed start_position))
            (~match_options (unwrap~fixed match_options))
            (~match_info (unwrap~pointer match_info))
            (~error (unwrap~pointer error)))
        (~f ~regex
            ~string
            ~string_len
            ~start_position
            ~match_options
            ~match_info
            ~error)))))
(export g_regex_match_full)

;; extern gboolean g_regex_match_all(const GRegex *regex, const gchar *string, 
;;     GRegexMatchFlags match_options, GMatchInfo **match_info);
(define g_regex_match_all
  (let ((~f #f))
    (lambda (regex string match_options match_info)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_regex_match_all"
            ffi:int
            (list '* '* ffi:int '*))))
      (let ((~regex (unwrap-GRegex* regex))
            (~string (unwrap~pointer string))
            (~match_options (unwrap~fixed match_options))
            (~match_info (unwrap~pointer match_info)))
        (~f ~regex ~string ~match_options ~match_info)))))
(export g_regex_match_all)

;; extern gboolean g_regex_match_all_full(const GRegex *regex, const gchar *
;;     string, gssize string_len, gint start_position, GRegexMatchFlags 
;;     match_options, GMatchInfo **match_info, GError **error);
(define g_regex_match_all_full
  (let ((~f #f))
    (lambda (regex
             string
             string_len
             start_position
             match_options
             match_info
             error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_regex_match_all_full"
            ffi:int
            (list '* '* ffi:long ffi:int ffi:int '* '*))))
      (let ((~regex (unwrap-GRegex* regex))
            (~string (unwrap~pointer string))
            (~string_len (unwrap~fixed string_len))
            (~start_position (unwrap~fixed start_position))
            (~match_options (unwrap~fixed match_options))
            (~match_info (unwrap~pointer match_info))
            (~error (unwrap~pointer error)))
        (~f ~regex
            ~string
            ~string_len
            ~start_position
            ~match_options
            ~match_info
            ~error)))))
(export g_regex_match_all_full)

;; extern gchar **g_regex_split_simple(const gchar *pattern, const gchar *
;;     string, GRegexCompileFlags compile_options, GRegexMatchFlags 
;;     match_options);
(define g_regex_split_simple
  (let* ((addr (dynamic-pointer
                 "g_regex_split_simple"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer (bs:pointer void)))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_regex_split_simple)

;; extern gchar **g_regex_split(const GRegex *regex, const gchar *string, 
;;     GRegexMatchFlags match_options);
(define g_regex_split
  (let* ((addr (dynamic-pointer "g_regex_split" (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer (bs:pointer void)))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_regex_split)

;; extern gchar **g_regex_split_full(const GRegex *regex, const gchar *string, 
;;     gssize string_len, gint start_position, GRegexMatchFlags match_options, 
;;     gint max_tokens, GError **error);
(define g_regex_split_full
  (let* ((addr (dynamic-pointer
                 "g_regex_split_full"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer (bs:pointer void)))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_regex_split_full)

;; extern gchar *g_regex_replace(const GRegex *regex, const gchar *string, 
;;     gssize string_len, gint start_position, const gchar *replacement, 
;;     GRegexMatchFlags match_options, GError **error);
(define g_regex_replace
  (let ((~f #f))
    (lambda (regex
             string
             string_len
             start_position
             replacement
             match_options
             error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_regex_replace"
            '*
            (list '* '* ffi:long ffi:int '* ffi:int '*))))
      (let ((~regex (unwrap-GRegex* regex))
            (~string (unwrap~pointer string))
            (~string_len (unwrap~fixed string_len))
            (~start_position (unwrap~fixed start_position))
            (~replacement (unwrap~pointer replacement))
            (~match_options (unwrap~fixed match_options))
            (~error (unwrap~pointer error)))
        (~f ~regex
            ~string
            ~string_len
            ~start_position
            ~replacement
            ~match_options
            ~error)))))
(export g_regex_replace)

;; extern gchar *g_regex_replace_literal(const GRegex *regex, const gchar *
;;     string, gssize string_len, gint start_position, const gchar *replacement
;;     , GRegexMatchFlags match_options, GError **error);
(define g_regex_replace_literal
  (let ((~f #f))
    (lambda (regex
             string
             string_len
             start_position
             replacement
             match_options
             error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_regex_replace_literal"
            '*
            (list '* '* ffi:long ffi:int '* ffi:int '*))))
      (let ((~regex (unwrap-GRegex* regex))
            (~string (unwrap~pointer string))
            (~string_len (unwrap~fixed string_len))
            (~start_position (unwrap~fixed start_position))
            (~replacement (unwrap~pointer replacement))
            (~match_options (unwrap~fixed match_options))
            (~error (unwrap~pointer error)))
        (~f ~regex
            ~string
            ~string_len
            ~start_position
            ~replacement
            ~match_options
            ~error)))))
(export g_regex_replace_literal)

;; extern gchar *g_regex_replace_eval(const GRegex *regex, const gchar *string
;;     , gssize string_len, gint start_position, GRegexMatchFlags match_options
;;     , GRegexEvalCallback eval, gpointer user_data, GError **error);
(define g_regex_replace_eval
  (let ((~f #f))
    (lambda (regex
             string
             string_len
             start_position
             match_options
             eval
             user_data
             error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_regex_replace_eval"
            '*
            (list '* '* ffi:long ffi:int ffi:int '* '* '*))))
      (let ((~regex (unwrap-GRegex* regex))
            (~string (unwrap~pointer string))
            (~string_len (unwrap~fixed string_len))
            (~start_position (unwrap~fixed start_position))
            (~match_options (unwrap~fixed match_options))
            (~eval ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
                    eval))
            (~user_data (unwrap-gpointer user_data))
            (~error (unwrap~pointer error)))
        (~f ~regex
            ~string
            ~string_len
            ~start_position
            ~match_options
            ~eval
            ~user_data
            ~error)))))
(export g_regex_replace_eval)

;; extern gboolean g_regex_check_replacement(const gchar *replacement, gboolean
;;      *has_references, GError **error);
(define g_regex_check_replacement
  (let ((~f #f))
    (lambda (replacement has_references error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_regex_check_replacement"
            ffi:int
            (list '* '* '*))))
      (let ((~replacement (unwrap~pointer replacement))
            (~has_references (unwrap~pointer has_references))
            (~error (unwrap~pointer error)))
        (~f ~replacement ~has_references ~error)))))
(export g_regex_check_replacement)

;; extern GRegex *g_match_info_get_regex(const GMatchInfo *match_info);
(define g_match_info_get_regex
  (let ((~f #f))
    (lambda (match_info)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_match_info_get_regex"
            '*
            (list '*))))
      (let ((~match_info (unwrap-GMatchInfo* match_info)))
        (wrap-GRegex* (~f ~match_info))))))
(export g_match_info_get_regex)

;; extern const gchar *g_match_info_get_string(const GMatchInfo *match_info);
(define g_match_info_get_string
  (let ((~f #f))
    (lambda (match_info)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_match_info_get_string"
            '*
            (list '*))))
      (let ((~match_info (unwrap-GMatchInfo* match_info)))
        (~f ~match_info)))))
(export g_match_info_get_string)

;; extern GMatchInfo *g_match_info_ref(GMatchInfo *match_info);
(define g_match_info_ref
  (let ((~f #f))
    (lambda (match_info)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_match_info_ref" '* (list '*))))
      (let ((~match_info (unwrap-GMatchInfo* match_info)))
        (wrap-GMatchInfo* (~f ~match_info))))))
(export g_match_info_ref)

;; extern void g_match_info_unref(GMatchInfo *match_info);
(define g_match_info_unref
  (let ((~f #f))
    (lambda (match_info)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_match_info_unref"
            ffi:void
            (list '*))))
      (let ((~match_info (unwrap-GMatchInfo* match_info)))
        (~f ~match_info)))))
(export g_match_info_unref)

;; extern void g_match_info_free(GMatchInfo *match_info);
(define g_match_info_free
  (let ((~f #f))
    (lambda (match_info)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_match_info_free"
            ffi:void
            (list '*))))
      (let ((~match_info (unwrap-GMatchInfo* match_info)))
        (~f ~match_info)))))
(export g_match_info_free)

;; extern gboolean g_match_info_next(GMatchInfo *match_info, GError **error);
(define g_match_info_next
  (let ((~f #f))
    (lambda (match_info error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_match_info_next"
            ffi:int
            (list '* '*))))
      (let ((~match_info (unwrap-GMatchInfo* match_info))
            (~error (unwrap~pointer error)))
        (~f ~match_info ~error)))))
(export g_match_info_next)

;; extern gboolean g_match_info_matches(const GMatchInfo *match_info);
(define g_match_info_matches
  (let ((~f #f))
    (lambda (match_info)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_match_info_matches"
            ffi:int
            (list '*))))
      (let ((~match_info (unwrap-GMatchInfo* match_info)))
        (~f ~match_info)))))
(export g_match_info_matches)

;; extern gint g_match_info_get_match_count(const GMatchInfo *match_info);
(define g_match_info_get_match_count
  (let ((~f #f))
    (lambda (match_info)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_match_info_get_match_count"
            ffi:int
            (list '*))))
      (let ((~match_info (unwrap-GMatchInfo* match_info)))
        (~f ~match_info)))))
(export g_match_info_get_match_count)

;; extern gboolean g_match_info_is_partial_match(const GMatchInfo *match_info)
;;     ;
(define g_match_info_is_partial_match
  (let ((~f #f))
    (lambda (match_info)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_match_info_is_partial_match"
            ffi:int
            (list '*))))
      (let ((~match_info (unwrap-GMatchInfo* match_info)))
        (~f ~match_info)))))
(export g_match_info_is_partial_match)

;; extern gchar *g_match_info_expand_references(const GMatchInfo *match_info, 
;;     const gchar *string_to_expand, GError **error);
(define g_match_info_expand_references
  (let ((~f #f))
    (lambda (match_info string_to_expand error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_match_info_expand_references"
            '*
            (list '* '* '*))))
      (let ((~match_info (unwrap-GMatchInfo* match_info))
            (~string_to_expand
              (unwrap~pointer string_to_expand))
            (~error (unwrap~pointer error)))
        (~f ~match_info ~string_to_expand ~error)))))
(export g_match_info_expand_references)

;; extern gchar *g_match_info_fetch(const GMatchInfo *match_info, gint 
;;     match_num);
(define g_match_info_fetch
  (let ((~f #f))
    (lambda (match_info match_num)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_match_info_fetch"
            '*
            (list '* ffi:int))))
      (let ((~match_info (unwrap-GMatchInfo* match_info))
            (~match_num (unwrap~fixed match_num)))
        (~f ~match_info ~match_num)))))
(export g_match_info_fetch)

;; extern gboolean g_match_info_fetch_pos(const GMatchInfo *match_info, gint 
;;     match_num, gint *start_pos, gint *end_pos);
(define g_match_info_fetch_pos
  (let ((~f #f))
    (lambda (match_info match_num start_pos end_pos)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_match_info_fetch_pos"
            ffi:int
            (list '* ffi:int '* '*))))
      (let ((~match_info (unwrap-GMatchInfo* match_info))
            (~match_num (unwrap~fixed match_num))
            (~start_pos (unwrap~pointer start_pos))
            (~end_pos (unwrap~pointer end_pos)))
        (~f ~match_info ~match_num ~start_pos ~end_pos)))))
(export g_match_info_fetch_pos)

;; extern gchar *g_match_info_fetch_named(const GMatchInfo *match_info, const 
;;     gchar *name);
(define g_match_info_fetch_named
  (let ((~f #f))
    (lambda (match_info name)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_match_info_fetch_named"
            '*
            (list '* '*))))
      (let ((~match_info (unwrap-GMatchInfo* match_info))
            (~name (unwrap~pointer name)))
        (~f ~match_info ~name)))))
(export g_match_info_fetch_named)

;; extern gboolean g_match_info_fetch_named_pos(const GMatchInfo *match_info, 
;;     const gchar *name, gint *start_pos, gint *end_pos);
(define g_match_info_fetch_named_pos
  (let ((~f #f))
    (lambda (match_info name start_pos end_pos)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_match_info_fetch_named_pos"
            ffi:int
            (list '* '* '* '*))))
      (let ((~match_info (unwrap-GMatchInfo* match_info))
            (~name (unwrap~pointer name))
            (~start_pos (unwrap~pointer start_pos))
            (~end_pos (unwrap~pointer end_pos)))
        (~f ~match_info ~name ~start_pos ~end_pos)))))
(export g_match_info_fetch_named_pos)

;; extern gchar **g_match_info_fetch_all(const GMatchInfo *match_info);
(define g_match_info_fetch_all
  (let* ((addr (dynamic-pointer
                 "g_match_info_fetch_all"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer (bs:pointer void)))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_match_info_fetch_all)

;; typedef struct _GScanner GScanner;
(define GScanner-desc void)
(define GScanner*-desc (bs:pointer (delay GScanner-desc)))
(export GScanner*-desc)
(define-fh-pointer-type GScanner* GScanner*-desc)

;; typedef struct _GScannerConfig GScannerConfig;
(define GScannerConfig-desc void)
(define GScannerConfig*-desc (bs:pointer (delay GScannerConfig-desc)))
(export GScannerConfig*-desc)
(define-fh-pointer-type GScannerConfig* GScannerConfig*-desc)

;; typedef union _GTokenValue GTokenValue;
;; union _GTokenValue {
;;   gpointer v_symbol;
;;   gchar *v_identifier;
;;   gulong v_binary;
;;   gulong v_octal;
;;   gulong v_int;
;;   guint64 v_int64;
;;   gdouble v_float;
;;   gulong v_hex;
;;   gchar *v_string;
;;   gchar *v_comment;
;;   guchar v_char;
;;   guint v_error;
;; };
(define GTokenValue-desc
  (bs:union
    (list `(v_symbol ,gpointer-desc)
          `(v_identifier ,(bs:pointer int))
          `(v_binary ,unsigned-long)
          `(v_octal ,unsigned-long)
          `(v_int ,unsigned-long)
          `(v_int64 ,unsigned-long)
          `(v_float ,gdouble-desc)
          `(v_hex ,unsigned-long)
          `(v_string ,(bs:pointer int))
          `(v_comment ,(bs:pointer int))
          `(v_char ,unsigned-int)
          `(v_error ,unsigned-int))))
(export GTokenValue-desc)
(define-fh-compound-type/p GTokenValue GTokenValue-desc)
(define union-_GTokenValue GTokenValue)

;; typedef void (*GScannerMsgFunc)(GScanner *scanner, gchar *message, gboolean 
;;     error);
(define-fh-function/p GScannerMsgFunc
  ffi:void (list (quote *) (quote *) ffi:int))

;; typedef enum {
;;   G_ERR_UNKNOWN,
;;   G_ERR_UNEXP_EOF,
;;   G_ERR_UNEXP_EOF_IN_STRING,
;;   G_ERR_UNEXP_EOF_IN_COMMENT,
;;   G_ERR_NON_DIGIT_IN_CONST,
;;   G_ERR_DIGIT_RADIX,
;;   G_ERR_FLOAT_RADIX,
;;   G_ERR_FLOAT_MALFORMED,
;; } GErrorType;
(define-fh-enum GErrorType
  '((G_ERR_UNKNOWN . 0)
    (G_ERR_UNEXP_EOF . 1)
    (G_ERR_UNEXP_EOF_IN_STRING . 2)
    (G_ERR_UNEXP_EOF_IN_COMMENT . 3)
    (G_ERR_NON_DIGIT_IN_CONST . 4)
    (G_ERR_DIGIT_RADIX . 5)
    (G_ERR_FLOAT_RADIX . 6)
    (G_ERR_FLOAT_MALFORMED . 7))
  )

;; typedef enum {
;;   G_TOKEN_EOF = 0,
;;   G_TOKEN_LEFT_PAREN = '(',
;;   G_TOKEN_RIGHT_PAREN = ')',
;;   G_TOKEN_LEFT_CURLY = '{',
;;   G_TOKEN_RIGHT_CURLY = '}',
;;   G_TOKEN_LEFT_BRACE = '[',
;;   G_TOKEN_RIGHT_BRACE = ']',
;;   G_TOKEN_EQUAL_SIGN = '=',
;;   G_TOKEN_COMMA = ',',
;;   G_TOKEN_NONE = 256,
;;   G_TOKEN_ERROR,
;;   G_TOKEN_CHAR,
;;   G_TOKEN_BINARY,
;;   G_TOKEN_OCTAL,
;;   G_TOKEN_INT,
;;   G_TOKEN_HEX,
;;   G_TOKEN_FLOAT,
;;   G_TOKEN_STRING,
;;   G_TOKEN_SYMBOL,
;;   G_TOKEN_IDENTIFIER,
;;   G_TOKEN_IDENTIFIER_NULL,
;;   G_TOKEN_COMMENT_SINGLE,
;;   G_TOKEN_COMMENT_MULTI,
;;   G_TOKEN_LAST,
;; } GTokenType;
(define-fh-enum GTokenType
  '((G_TOKEN_EOF . 0)
    (G_TOKEN_LEFT_PAREN . 40)
    (G_TOKEN_RIGHT_PAREN . 41)
    (G_TOKEN_LEFT_CURLY . 123)
    (G_TOKEN_RIGHT_CURLY . 125)
    (G_TOKEN_LEFT_BRACE . 91)
    (G_TOKEN_RIGHT_BRACE . 93)
    (G_TOKEN_EQUAL_SIGN . 61)
    (G_TOKEN_COMMA . 44)
    (G_TOKEN_NONE . 256)
    (G_TOKEN_ERROR . 257)
    (G_TOKEN_CHAR . 258)
    (G_TOKEN_BINARY . 259)
    (G_TOKEN_OCTAL . 260)
    (G_TOKEN_INT . 261)
    (G_TOKEN_HEX . 262)
    (G_TOKEN_FLOAT . 263)
    (G_TOKEN_STRING . 264)
    (G_TOKEN_SYMBOL . 265)
    (G_TOKEN_IDENTIFIER . 266)
    (G_TOKEN_IDENTIFIER_NULL . 267)
    (G_TOKEN_COMMENT_SINGLE . 268)
    (G_TOKEN_COMMENT_MULTI . 269)
    (G_TOKEN_LAST . 270))
  )

;; struct _GScannerConfig {
;;   /* Character sets
;;    */
;;   gchar *cset_skip_characters; /* default: " \t\n" */
;;   gchar *cset_identifier_first;
;;   gchar *cset_identifier_nth;
;;   gchar *cpair_comment_single; /* default: "#\n" */
;;   /* Should symbol lookup work case sensitive?
;;    */
;;   guint case_sensitive : 1;
;;   /* Boolean values to be adjusted "on the fly"
;;    * to configure scanning behaviour.
;;    */
;;   guint skip_comment_multi : 1; /* C like comment */
;;   guint skip_comment_single : 1; /* single line comment */
;;   guint scan_comment_multi : 1; /* scan multi line comments? */
;;   guint scan_identifier : 1;
;;   guint scan_identifier_1char : 1;
;;   guint scan_identifier_NULL : 1;
;;   guint scan_symbols : 1;
;;   guint scan_binary : 1;
;;   guint scan_octal : 1;
;;   guint scan_float : 1;
;;   guint scan_hex : 1; /* '0x0ff0' */
;;   guint scan_hex_dollar : 1; /* '$0ff0' */
;;   guint scan_string_sq : 1; /* string: 'anything' */
;;   guint scan_string_dq : 1; /* string: "\\-escapes!\n" */
;;   guint numbers_2_int : 1; /* bin, octal, hex => int */
;;   guint int_2_float : 1; /* int => G_TOKEN_FLOAT? */
;;   guint identifier_2_string : 1;
;;   guint char_2_token : 1; /* return G_TOKEN_CHAR? */
;;   guint symbol_2_token : 1;
;;   guint scope_0_fallback : 1; /* try scope 0 on lookups? */
;;   guint store_int64 : 1; /* use value.v_int64 rather than v_int */
;;   /*< private >*/
;;   guint padding_dummy;
;; };
(define struct-_GScannerConfig-desc
  (bs:struct
    (list `(cset_skip_characters ,(bs:pointer int))
          `(cset_identifier_first ,(bs:pointer int))
          `(cset_identifier_nth ,(bs:pointer int))
          `(cpair_comment_single ,(bs:pointer int))
          `(case_sensitive ,unsigned-int ,1)
          `(skip_comment_multi ,unsigned-int ,1)
          `(skip_comment_single ,unsigned-int ,1)
          `(scan_comment_multi ,unsigned-int ,1)
          `(scan_identifier ,unsigned-int ,1)
          `(scan_identifier_1char ,unsigned-int ,1)
          `(scan_identifier_NULL ,unsigned-int ,1)
          `(scan_symbols ,unsigned-int ,1)
          `(scan_binary ,unsigned-int ,1)
          `(scan_octal ,unsigned-int ,1)
          `(scan_float ,unsigned-int ,1)
          `(scan_hex ,unsigned-int ,1)
          `(scan_hex_dollar ,unsigned-int ,1)
          `(scan_string_sq ,unsigned-int ,1)
          `(scan_string_dq ,unsigned-int ,1)
          `(numbers_2_int ,unsigned-int ,1)
          `(int_2_float ,unsigned-int ,1)
          `(identifier_2_string ,unsigned-int ,1)
          `(char_2_token ,unsigned-int ,1)
          `(symbol_2_token ,unsigned-int ,1)
          `(scope_0_fallback ,unsigned-int ,1)
          `(store_int64 ,unsigned-int ,1)
          `(padding_dummy ,unsigned-int))))
(export struct-_GScannerConfig-desc)
(define-fh-compound-type/p struct-_GScannerConfig struct-_GScannerConfig-desc)
(set! GScannerConfig-desc struct-_GScannerConfig-desc)
(define-fh-compound-type GScannerConfig GScannerConfig-desc)

;; struct _GScanner {
;;   /* unused fields */
;;   gpointer user_data;
;;   guint max_parse_errors;
;;   /* g_scanner_error() increments this field */
;;   guint parse_errors;
;;   /* name of input stream, featured by the default message handler */
;;   const gchar *input_name;
;;   /* quarked data */
;;   GData *qdata;
;;   /* link into the scanner configuration */
;;   GScannerConfig *config;
;;   /* fields filled in after g_scanner_get_next_token() */
;;   GTokenType token;
;;   GTokenValue value;
;;   guint line;
;;   guint position;
;;   /* fields filled in after g_scanner_peek_next_token() */
;;   GTokenType next_token;
;;   GTokenValue next_value;
;;   guint next_line;
;;   guint next_position;
;;   /*< private >*/
;;   /* to be considered private */
;;   GHashTable *symbol_table;
;;   gint input_fd;
;;   const gchar *text;
;;   const gchar *text_end;
;;   gchar *buffer;
;;   guint scope_id;
;;   /*< public >*/
;;   /* handler function for _warn and _error */
;;   GScannerMsgFunc msg_handler;
;; };
(define struct-_GScanner-desc
  (bs:struct
    (list `(user_data ,gpointer-desc)
          `(max_parse_errors ,unsigned-int)
          `(parse_errors ,unsigned-int)
          `(input_name ,(bs:pointer int))
          `(qdata ,(bs:pointer (delay GData*-desc)))
          `(config
             ,(bs:pointer (delay GScannerConfig*-desc)))
          `(token ,int)
          `(value ,GTokenValue-desc)
          `(line ,unsigned-int)
          `(position ,unsigned-int)
          `(next_token ,int)
          `(next_value ,GTokenValue-desc)
          `(next_line ,unsigned-int)
          `(next_position ,unsigned-int)
          `(symbol_table
             ,(bs:pointer (delay GHashTable*-desc)))
          `(input_fd ,int)
          `(text ,(bs:pointer int))
          `(text_end ,(bs:pointer int))
          `(buffer ,(bs:pointer int))
          `(scope_id ,unsigned-int)
          `(msg_handler ,(bs:pointer void)))))
(export struct-_GScanner-desc)
(define-fh-compound-type/p struct-_GScanner struct-_GScanner-desc)
(set! GScanner-desc struct-_GScanner-desc)
(define-fh-compound-type GScanner GScanner-desc)

;; extern GScanner *g_scanner_new(const GScannerConfig *config_templ);
(define g_scanner_new
  (let ((~f #f))
    (lambda (config_templ)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_scanner_new" '* (list '*))))
      (let ((~config_templ
              (unwrap-GScannerConfig* config_templ)))
        (wrap-GScanner* (~f ~config_templ))))))
(export g_scanner_new)

;; extern void g_scanner_destroy(GScanner *scanner);
(define g_scanner_destroy
  (let ((~f #f))
    (lambda (scanner)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_scanner_destroy"
            ffi:void
            (list '*))))
      (let ((~scanner (unwrap-GScanner* scanner)))
        (~f ~scanner)))))
(export g_scanner_destroy)

;; extern void g_scanner_input_file(GScanner *scanner, gint input_fd);
(define g_scanner_input_file
  (let ((~f #f))
    (lambda (scanner input_fd)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_scanner_input_file"
            ffi:void
            (list '* ffi:int))))
      (let ((~scanner (unwrap-GScanner* scanner))
            (~input_fd (unwrap~fixed input_fd)))
        (~f ~scanner ~input_fd)))))
(export g_scanner_input_file)

;; extern void g_scanner_sync_file_offset(GScanner *scanner);
(define g_scanner_sync_file_offset
  (let ((~f #f))
    (lambda (scanner)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_scanner_sync_file_offset"
            ffi:void
            (list '*))))
      (let ((~scanner (unwrap-GScanner* scanner)))
        (~f ~scanner)))))
(export g_scanner_sync_file_offset)

;; extern void g_scanner_input_text(GScanner *scanner, const gchar *text, guint
;;      text_len);
(define g_scanner_input_text
  (let ((~f #f))
    (lambda (scanner text text_len)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_scanner_input_text"
            ffi:void
            (list '* '* ffi:unsigned-int))))
      (let ((~scanner (unwrap-GScanner* scanner))
            (~text (unwrap~pointer text))
            (~text_len (unwrap~fixed text_len)))
        (~f ~scanner ~text ~text_len)))))
(export g_scanner_input_text)

;; extern GTokenType g_scanner_get_next_token(GScanner *scanner);
(define g_scanner_get_next_token
  (let ((~f #f))
    (lambda (scanner)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_scanner_get_next_token"
            ffi:int
            (list '*))))
      (let ((~scanner (unwrap-GScanner* scanner)))
        (~f ~scanner)))))
(export g_scanner_get_next_token)

;; extern GTokenType g_scanner_peek_next_token(GScanner *scanner);
(define g_scanner_peek_next_token
  (let ((~f #f))
    (lambda (scanner)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_scanner_peek_next_token"
            ffi:int
            (list '*))))
      (let ((~scanner (unwrap-GScanner* scanner)))
        (~f ~scanner)))))
(export g_scanner_peek_next_token)

;; extern GTokenType g_scanner_cur_token(GScanner *scanner);
(define g_scanner_cur_token
  (let ((~f #f))
    (lambda (scanner)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_scanner_cur_token"
            ffi:int
            (list '*))))
      (let ((~scanner (unwrap-GScanner* scanner)))
        (~f ~scanner)))))
(export g_scanner_cur_token)

;; extern GTokenValue g_scanner_cur_value(GScanner *scanner);
(define g_scanner_cur_value
  (let ((~f #f))
    (lambda (scanner)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_scanner_cur_value" '* (list '*))))
      (let ((~scanner (unwrap-GScanner* scanner)))
        (wrap-GTokenValue (~f ~scanner))))))
(export g_scanner_cur_value)

;; extern guint g_scanner_cur_line(GScanner *scanner);
(define g_scanner_cur_line
  (let ((~f #f))
    (lambda (scanner)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_scanner_cur_line"
            ffi:unsigned-int
            (list '*))))
      (let ((~scanner (unwrap-GScanner* scanner)))
        (~f ~scanner)))))
(export g_scanner_cur_line)

;; extern guint g_scanner_cur_position(GScanner *scanner);
(define g_scanner_cur_position
  (let ((~f #f))
    (lambda (scanner)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_scanner_cur_position"
            ffi:unsigned-int
            (list '*))))
      (let ((~scanner (unwrap-GScanner* scanner)))
        (~f ~scanner)))))
(export g_scanner_cur_position)

;; extern gboolean g_scanner_eof(GScanner *scanner);
(define g_scanner_eof
  (let ((~f #f))
    (lambda (scanner)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_scanner_eof" ffi:int (list '*))))
      (let ((~scanner (unwrap-GScanner* scanner)))
        (~f ~scanner)))))
(export g_scanner_eof)

;; extern guint g_scanner_set_scope(GScanner *scanner, guint scope_id);
(define g_scanner_set_scope
  (let ((~f #f))
    (lambda (scanner scope_id)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_scanner_set_scope"
            ffi:unsigned-int
            (list '* ffi:unsigned-int))))
      (let ((~scanner (unwrap-GScanner* scanner))
            (~scope_id (unwrap~fixed scope_id)))
        (~f ~scanner ~scope_id)))))
(export g_scanner_set_scope)

;; extern void g_scanner_scope_add_symbol(GScanner *scanner, guint scope_id, 
;;     const gchar *symbol, gpointer value);
(define g_scanner_scope_add_symbol
  (let ((~f #f))
    (lambda (scanner scope_id symbol value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_scanner_scope_add_symbol"
            ffi:void
            (list '* ffi:unsigned-int '* '*))))
      (let ((~scanner (unwrap-GScanner* scanner))
            (~scope_id (unwrap~fixed scope_id))
            (~symbol (unwrap~pointer symbol))
            (~value (unwrap-gpointer value)))
        (~f ~scanner ~scope_id ~symbol ~value)))))
(export g_scanner_scope_add_symbol)

;; extern void g_scanner_scope_remove_symbol(GScanner *scanner, guint scope_id
;;     , const gchar *symbol);
(define g_scanner_scope_remove_symbol
  (let ((~f #f))
    (lambda (scanner scope_id symbol)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_scanner_scope_remove_symbol"
            ffi:void
            (list '* ffi:unsigned-int '*))))
      (let ((~scanner (unwrap-GScanner* scanner))
            (~scope_id (unwrap~fixed scope_id))
            (~symbol (unwrap~pointer symbol)))
        (~f ~scanner ~scope_id ~symbol)))))
(export g_scanner_scope_remove_symbol)

;; extern gpointer g_scanner_scope_lookup_symbol(GScanner *scanner, guint 
;;     scope_id, const gchar *symbol);
(define g_scanner_scope_lookup_symbol
  (let ((~f #f))
    (lambda (scanner scope_id symbol)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_scanner_scope_lookup_symbol"
            '*
            (list '* ffi:unsigned-int '*))))
      (let ((~scanner (unwrap-GScanner* scanner))
            (~scope_id (unwrap~fixed scope_id))
            (~symbol (unwrap~pointer symbol)))
        (wrap-gpointer (~f ~scanner ~scope_id ~symbol))))))
(export g_scanner_scope_lookup_symbol)

;; extern void g_scanner_scope_foreach_symbol(GScanner *scanner, guint scope_id
;;     , GHFunc func, gpointer user_data);
(define g_scanner_scope_foreach_symbol
  (let ((~f #f))
    (lambda (scanner scope_id func user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_scanner_scope_foreach_symbol"
            ffi:void
            (list '* ffi:unsigned-int '* '*))))
      (let ((~scanner (unwrap-GScanner* scanner))
            (~scope_id (unwrap~fixed scope_id))
            (~func ((make-ftn-arg-unwrapper ffi:void (list '* '* '*))
                    func))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~scanner ~scope_id ~func ~user_data)))))
(export g_scanner_scope_foreach_symbol)

;; extern gpointer g_scanner_lookup_symbol(GScanner *scanner, const gchar *
;;     symbol);
(define g_scanner_lookup_symbol
  (let ((~f #f))
    (lambda (scanner symbol)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_scanner_lookup_symbol"
            '*
            (list '* '*))))
      (let ((~scanner (unwrap-GScanner* scanner))
            (~symbol (unwrap~pointer symbol)))
        (wrap-gpointer (~f ~scanner ~symbol))))))
(export g_scanner_lookup_symbol)

;; extern void g_scanner_unexp_token(GScanner *scanner, GTokenType 
;;     expected_token, const gchar *identifier_spec, const gchar *symbol_spec, 
;;     const gchar *symbol_name, const gchar *message, gint is_error);
(define g_scanner_unexp_token
  (let ((~f #f))
    (lambda (scanner
             expected_token
             identifier_spec
             symbol_spec
             symbol_name
             message
             is_error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_scanner_unexp_token"
            ffi:void
            (list '* ffi:int '* '* '* '* ffi:int))))
      (let ((~scanner (unwrap-GScanner* scanner))
            (~expected_token (unwrap~fixed expected_token))
            (~identifier_spec
              (unwrap~pointer identifier_spec))
            (~symbol_spec (unwrap~pointer symbol_spec))
            (~symbol_name (unwrap~pointer symbol_name))
            (~message (unwrap~pointer message))
            (~is_error (unwrap~fixed is_error)))
        (~f ~scanner
            ~expected_token
            ~identifier_spec
            ~symbol_spec
            ~symbol_name
            ~message
            ~is_error)))))
(export g_scanner_unexp_token)

;; extern void g_scanner_error(GScanner *scanner, const gchar *format, ...);
;; ... failed.

;; extern void g_scanner_warn(GScanner *scanner, const gchar *format, ...);
;; ... failed.

;; typedef struct _GSequence GSequence;
(define GSequence-desc void)
(define GSequence*-desc (bs:pointer GSequence-desc))
(export GSequence*-desc)
(define-fh-pointer-type GSequence* GSequence*-desc)

;; typedef struct _GSequenceNode GSequenceIter;
(define GSequenceIter-desc void)
(define GSequenceIter*-desc (bs:pointer GSequenceIter-desc))
(export GSequenceIter*-desc)
(define-fh-pointer-type GSequenceIter* GSequenceIter*-desc)

;; typedef gint (*GSequenceIterCompareFunc)(GSequenceIter *a, GSequenceIter *b
;;     , gpointer data);
(define-fh-function/p GSequenceIterCompareFunc
  ffi:int (list (quote *) (quote *) (quote *)))

;; extern GSequence *g_sequence_new(GDestroyNotify data_destroy);
(define g_sequence_new
  (let ((~f #f))
    (lambda (data_destroy)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_sequence_new" '* (list '*))))
      (let ((~data_destroy
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               data_destroy)))
        (wrap-GSequence* (~f ~data_destroy))))))
(export g_sequence_new)

;; extern void g_sequence_free(GSequence *seq);
(define g_sequence_free
  (let ((~f #f))
    (lambda (seq)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_sequence_free"
            ffi:void
            (list '*))))
      (let ((~seq (unwrap-GSequence* seq))) (~f ~seq)))))
(export g_sequence_free)

;; extern gint g_sequence_get_length(GSequence *seq);
(define g_sequence_get_length
  (let ((~f #f))
    (lambda (seq)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_sequence_get_length"
            ffi:int
            (list '*))))
      (let ((~seq (unwrap-GSequence* seq))) (~f ~seq)))))
(export g_sequence_get_length)

;; extern void g_sequence_foreach(GSequence *seq, GFunc func, gpointer 
;;     user_data);
(define g_sequence_foreach
  (let ((~f #f))
    (lambda (seq func user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_sequence_foreach"
            ffi:void
            (list '* '* '*))))
      (let ((~seq (unwrap-GSequence* seq))
            (~func ((make-ftn-arg-unwrapper ffi:void (list '* '*))
                    func))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~seq ~func ~user_data)))))
(export g_sequence_foreach)

;; extern void g_sequence_foreach_range(GSequenceIter *begin, GSequenceIter *
;;     end, GFunc func, gpointer user_data);
(define g_sequence_foreach_range
  (let ((~f #f))
    (lambda (begin end func user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_sequence_foreach_range"
            ffi:void
            (list '* '* '* '*))))
      (let ((~begin (unwrap-GSequenceIter* begin))
            (~end (unwrap-GSequenceIter* end))
            (~func ((make-ftn-arg-unwrapper ffi:void (list '* '*))
                    func))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~begin ~end ~func ~user_data)))))
(export g_sequence_foreach_range)

;; extern void g_sequence_sort(GSequence *seq, GCompareDataFunc cmp_func, 
;;     gpointer cmp_data);
(define g_sequence_sort
  (let ((~f #f))
    (lambda (seq cmp_func cmp_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_sequence_sort"
            ffi:void
            (list '* '* '*))))
      (let ((~seq (unwrap-GSequence* seq))
            (~cmp_func
              ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
               cmp_func))
            (~cmp_data (unwrap-gpointer cmp_data)))
        (~f ~seq ~cmp_func ~cmp_data)))))
(export g_sequence_sort)

;; extern void g_sequence_sort_iter(GSequence *seq, GSequenceIterCompareFunc 
;;     cmp_func, gpointer cmp_data);
(define g_sequence_sort_iter
  (let ((~f #f))
    (lambda (seq cmp_func cmp_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_sequence_sort_iter"
            ffi:void
            (list '* '* '*))))
      (let ((~seq (unwrap-GSequence* seq))
            (~cmp_func
              ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
               cmp_func))
            (~cmp_data (unwrap-gpointer cmp_data)))
        (~f ~seq ~cmp_func ~cmp_data)))))
(export g_sequence_sort_iter)

;; extern gboolean g_sequence_is_empty(GSequence *seq);
(define g_sequence_is_empty
  (let ((~f #f))
    (lambda (seq)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_sequence_is_empty"
            ffi:int
            (list '*))))
      (let ((~seq (unwrap-GSequence* seq))) (~f ~seq)))))
(export g_sequence_is_empty)

;; extern GSequenceIter *g_sequence_get_begin_iter(GSequence *seq);
(define g_sequence_get_begin_iter
  (let ((~f #f))
    (lambda (seq)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_sequence_get_begin_iter"
            '*
            (list '*))))
      (let ((~seq (unwrap-GSequence* seq)))
        (wrap-GSequenceIter* (~f ~seq))))))
(export g_sequence_get_begin_iter)

;; extern GSequenceIter *g_sequence_get_end_iter(GSequence *seq);
(define g_sequence_get_end_iter
  (let ((~f #f))
    (lambda (seq)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_sequence_get_end_iter"
            '*
            (list '*))))
      (let ((~seq (unwrap-GSequence* seq)))
        (wrap-GSequenceIter* (~f ~seq))))))
(export g_sequence_get_end_iter)

;; extern GSequenceIter *g_sequence_get_iter_at_pos(GSequence *seq, gint pos);
(define g_sequence_get_iter_at_pos
  (let ((~f #f))
    (lambda (seq pos)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_sequence_get_iter_at_pos"
            '*
            (list '* ffi:int))))
      (let ((~seq (unwrap-GSequence* seq))
            (~pos (unwrap~fixed pos)))
        (wrap-GSequenceIter* (~f ~seq ~pos))))))
(export g_sequence_get_iter_at_pos)

;; extern GSequenceIter *g_sequence_append(GSequence *seq, gpointer data);
(define g_sequence_append
  (let ((~f #f))
    (lambda (seq data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_sequence_append"
            '*
            (list '* '*))))
      (let ((~seq (unwrap-GSequence* seq))
            (~data (unwrap-gpointer data)))
        (wrap-GSequenceIter* (~f ~seq ~data))))))
(export g_sequence_append)

;; extern GSequenceIter *g_sequence_prepend(GSequence *seq, gpointer data);
(define g_sequence_prepend
  (let ((~f #f))
    (lambda (seq data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_sequence_prepend"
            '*
            (list '* '*))))
      (let ((~seq (unwrap-GSequence* seq))
            (~data (unwrap-gpointer data)))
        (wrap-GSequenceIter* (~f ~seq ~data))))))
(export g_sequence_prepend)

;; extern GSequenceIter *g_sequence_insert_before(GSequenceIter *iter, gpointer
;;      data);
(define g_sequence_insert_before
  (let ((~f #f))
    (lambda (iter data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_sequence_insert_before"
            '*
            (list '* '*))))
      (let ((~iter (unwrap-GSequenceIter* iter))
            (~data (unwrap-gpointer data)))
        (wrap-GSequenceIter* (~f ~iter ~data))))))
(export g_sequence_insert_before)

;; extern void g_sequence_move(GSequenceIter *src, GSequenceIter *dest);
(define g_sequence_move
  (let ((~f #f))
    (lambda (src dest)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_sequence_move"
            ffi:void
            (list '* '*))))
      (let ((~src (unwrap-GSequenceIter* src))
            (~dest (unwrap-GSequenceIter* dest)))
        (~f ~src ~dest)))))
(export g_sequence_move)

;; extern void g_sequence_swap(GSequenceIter *a, GSequenceIter *b);
(define g_sequence_swap
  (let ((~f #f))
    (lambda (a b)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_sequence_swap"
            ffi:void
            (list '* '*))))
      (let ((~a (unwrap-GSequenceIter* a))
            (~b (unwrap-GSequenceIter* b)))
        (~f ~a ~b)))))
(export g_sequence_swap)

;; extern GSequenceIter *g_sequence_insert_sorted(GSequence *seq, gpointer data
;;     , GCompareDataFunc cmp_func, gpointer cmp_data);
(define g_sequence_insert_sorted
  (let ((~f #f))
    (lambda (seq data cmp_func cmp_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_sequence_insert_sorted"
            '*
            (list '* '* '* '*))))
      (let ((~seq (unwrap-GSequence* seq))
            (~data (unwrap-gpointer data))
            (~cmp_func
              ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
               cmp_func))
            (~cmp_data (unwrap-gpointer cmp_data)))
        (wrap-GSequenceIter*
          (~f ~seq ~data ~cmp_func ~cmp_data))))))
(export g_sequence_insert_sorted)

;; extern GSequenceIter *g_sequence_insert_sorted_iter(GSequence *seq, gpointer
;;      data, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data);
(define g_sequence_insert_sorted_iter
  (let ((~f #f))
    (lambda (seq data iter_cmp cmp_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_sequence_insert_sorted_iter"
            '*
            (list '* '* '* '*))))
      (let ((~seq (unwrap-GSequence* seq))
            (~data (unwrap-gpointer data))
            (~iter_cmp
              ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
               iter_cmp))
            (~cmp_data (unwrap-gpointer cmp_data)))
        (wrap-GSequenceIter*
          (~f ~seq ~data ~iter_cmp ~cmp_data))))))
(export g_sequence_insert_sorted_iter)

;; extern void g_sequence_sort_changed(GSequenceIter *iter, GCompareDataFunc 
;;     cmp_func, gpointer cmp_data);
(define g_sequence_sort_changed
  (let ((~f #f))
    (lambda (iter cmp_func cmp_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_sequence_sort_changed"
            ffi:void
            (list '* '* '*))))
      (let ((~iter (unwrap-GSequenceIter* iter))
            (~cmp_func
              ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
               cmp_func))
            (~cmp_data (unwrap-gpointer cmp_data)))
        (~f ~iter ~cmp_func ~cmp_data)))))
(export g_sequence_sort_changed)

;; extern void g_sequence_sort_changed_iter(GSequenceIter *iter, 
;;     GSequenceIterCompareFunc iter_cmp, gpointer cmp_data);
(define g_sequence_sort_changed_iter
  (let ((~f #f))
    (lambda (iter iter_cmp cmp_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_sequence_sort_changed_iter"
            ffi:void
            (list '* '* '*))))
      (let ((~iter (unwrap-GSequenceIter* iter))
            (~iter_cmp
              ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
               iter_cmp))
            (~cmp_data (unwrap-gpointer cmp_data)))
        (~f ~iter ~iter_cmp ~cmp_data)))))
(export g_sequence_sort_changed_iter)

;; extern void g_sequence_remove(GSequenceIter *iter);
(define g_sequence_remove
  (let ((~f #f))
    (lambda (iter)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_sequence_remove"
            ffi:void
            (list '*))))
      (let ((~iter (unwrap-GSequenceIter* iter)))
        (~f ~iter)))))
(export g_sequence_remove)

;; extern void g_sequence_remove_range(GSequenceIter *begin, GSequenceIter *end
;;     );
(define g_sequence_remove_range
  (let ((~f #f))
    (lambda (begin end)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_sequence_remove_range"
            ffi:void
            (list '* '*))))
      (let ((~begin (unwrap-GSequenceIter* begin))
            (~end (unwrap-GSequenceIter* end)))
        (~f ~begin ~end)))))
(export g_sequence_remove_range)

;; extern void g_sequence_move_range(GSequenceIter *dest, GSequenceIter *begin
;;     , GSequenceIter *end);
(define g_sequence_move_range
  (let ((~f #f))
    (lambda (dest begin end)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_sequence_move_range"
            ffi:void
            (list '* '* '*))))
      (let ((~dest (unwrap-GSequenceIter* dest))
            (~begin (unwrap-GSequenceIter* begin))
            (~end (unwrap-GSequenceIter* end)))
        (~f ~dest ~begin ~end)))))
(export g_sequence_move_range)

;; extern GSequenceIter *g_sequence_search(GSequence *seq, gpointer data, 
;;     GCompareDataFunc cmp_func, gpointer cmp_data);
(define g_sequence_search
  (let ((~f #f))
    (lambda (seq data cmp_func cmp_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_sequence_search"
            '*
            (list '* '* '* '*))))
      (let ((~seq (unwrap-GSequence* seq))
            (~data (unwrap-gpointer data))
            (~cmp_func
              ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
               cmp_func))
            (~cmp_data (unwrap-gpointer cmp_data)))
        (wrap-GSequenceIter*
          (~f ~seq ~data ~cmp_func ~cmp_data))))))
(export g_sequence_search)

;; extern GSequenceIter *g_sequence_search_iter(GSequence *seq, gpointer data, 
;;     GSequenceIterCompareFunc iter_cmp, gpointer cmp_data);
(define g_sequence_search_iter
  (let ((~f #f))
    (lambda (seq data iter_cmp cmp_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_sequence_search_iter"
            '*
            (list '* '* '* '*))))
      (let ((~seq (unwrap-GSequence* seq))
            (~data (unwrap-gpointer data))
            (~iter_cmp
              ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
               iter_cmp))
            (~cmp_data (unwrap-gpointer cmp_data)))
        (wrap-GSequenceIter*
          (~f ~seq ~data ~iter_cmp ~cmp_data))))))
(export g_sequence_search_iter)

;; extern GSequenceIter *g_sequence_lookup(GSequence *seq, gpointer data, 
;;     GCompareDataFunc cmp_func, gpointer cmp_data);
(define g_sequence_lookup
  (let ((~f #f))
    (lambda (seq data cmp_func cmp_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_sequence_lookup"
            '*
            (list '* '* '* '*))))
      (let ((~seq (unwrap-GSequence* seq))
            (~data (unwrap-gpointer data))
            (~cmp_func
              ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
               cmp_func))
            (~cmp_data (unwrap-gpointer cmp_data)))
        (wrap-GSequenceIter*
          (~f ~seq ~data ~cmp_func ~cmp_data))))))
(export g_sequence_lookup)

;; extern GSequenceIter *g_sequence_lookup_iter(GSequence *seq, gpointer data, 
;;     GSequenceIterCompareFunc iter_cmp, gpointer cmp_data);
(define g_sequence_lookup_iter
  (let ((~f #f))
    (lambda (seq data iter_cmp cmp_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_sequence_lookup_iter"
            '*
            (list '* '* '* '*))))
      (let ((~seq (unwrap-GSequence* seq))
            (~data (unwrap-gpointer data))
            (~iter_cmp
              ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
               iter_cmp))
            (~cmp_data (unwrap-gpointer cmp_data)))
        (wrap-GSequenceIter*
          (~f ~seq ~data ~iter_cmp ~cmp_data))))))
(export g_sequence_lookup_iter)

;; extern gpointer g_sequence_get(GSequenceIter *iter);
(define g_sequence_get
  (let ((~f #f))
    (lambda (iter)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_sequence_get" '* (list '*))))
      (let ((~iter (unwrap-GSequenceIter* iter)))
        (wrap-gpointer (~f ~iter))))))
(export g_sequence_get)

;; extern void g_sequence_set(GSequenceIter *iter, gpointer data);
(define g_sequence_set
  (let ((~f #f))
    (lambda (iter data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_sequence_set"
            ffi:void
            (list '* '*))))
      (let ((~iter (unwrap-GSequenceIter* iter))
            (~data (unwrap-gpointer data)))
        (~f ~iter ~data)))))
(export g_sequence_set)

;; extern gboolean g_sequence_iter_is_begin(GSequenceIter *iter);
(define g_sequence_iter_is_begin
  (let ((~f #f))
    (lambda (iter)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_sequence_iter_is_begin"
            ffi:int
            (list '*))))
      (let ((~iter (unwrap-GSequenceIter* iter)))
        (~f ~iter)))))
(export g_sequence_iter_is_begin)

;; extern gboolean g_sequence_iter_is_end(GSequenceIter *iter);
(define g_sequence_iter_is_end
  (let ((~f #f))
    (lambda (iter)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_sequence_iter_is_end"
            ffi:int
            (list '*))))
      (let ((~iter (unwrap-GSequenceIter* iter)))
        (~f ~iter)))))
(export g_sequence_iter_is_end)

;; extern GSequenceIter *g_sequence_iter_next(GSequenceIter *iter);
(define g_sequence_iter_next
  (let ((~f #f))
    (lambda (iter)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_sequence_iter_next"
            '*
            (list '*))))
      (let ((~iter (unwrap-GSequenceIter* iter)))
        (wrap-GSequenceIter* (~f ~iter))))))
(export g_sequence_iter_next)

;; extern GSequenceIter *g_sequence_iter_prev(GSequenceIter *iter);
(define g_sequence_iter_prev
  (let ((~f #f))
    (lambda (iter)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_sequence_iter_prev"
            '*
            (list '*))))
      (let ((~iter (unwrap-GSequenceIter* iter)))
        (wrap-GSequenceIter* (~f ~iter))))))
(export g_sequence_iter_prev)

;; extern gint g_sequence_iter_get_position(GSequenceIter *iter);
(define g_sequence_iter_get_position
  (let ((~f #f))
    (lambda (iter)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_sequence_iter_get_position"
            ffi:int
            (list '*))))
      (let ((~iter (unwrap-GSequenceIter* iter)))
        (~f ~iter)))))
(export g_sequence_iter_get_position)

;; extern GSequenceIter *g_sequence_iter_move(GSequenceIter *iter, gint delta)
;;     ;
(define g_sequence_iter_move
  (let ((~f #f))
    (lambda (iter delta)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_sequence_iter_move"
            '*
            (list '* ffi:int))))
      (let ((~iter (unwrap-GSequenceIter* iter))
            (~delta (unwrap~fixed delta)))
        (wrap-GSequenceIter* (~f ~iter ~delta))))))
(export g_sequence_iter_move)

;; extern GSequence *g_sequence_iter_get_sequence(GSequenceIter *iter);
(define g_sequence_iter_get_sequence
  (let ((~f #f))
    (lambda (iter)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_sequence_iter_get_sequence"
            '*
            (list '*))))
      (let ((~iter (unwrap-GSequenceIter* iter)))
        (wrap-GSequence* (~f ~iter))))))
(export g_sequence_iter_get_sequence)

;; extern gint g_sequence_iter_compare(GSequenceIter *a, GSequenceIter *b);
(define g_sequence_iter_compare
  (let ((~f #f))
    (lambda (a b)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_sequence_iter_compare"
            ffi:int
            (list '* '*))))
      (let ((~a (unwrap-GSequenceIter* a))
            (~b (unwrap-GSequenceIter* b)))
        (~f ~a ~b)))))
(export g_sequence_iter_compare)

;; extern GSequenceIter *g_sequence_range_get_midpoint(GSequenceIter *begin, 
;;     GSequenceIter *end);
(define g_sequence_range_get_midpoint
  (let ((~f #f))
    (lambda (begin end)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_sequence_range_get_midpoint"
            '*
            (list '* '*))))
      (let ((~begin (unwrap-GSequenceIter* begin))
            (~end (unwrap-GSequenceIter* end)))
        (wrap-GSequenceIter* (~f ~begin ~end))))))
(export g_sequence_range_get_midpoint)

;; typedef enum {
;;   G_SHELL_ERROR_BAD_QUOTING,
;;   G_SHELL_ERROR_EMPTY_STRING,
;;   G_SHELL_ERROR_FAILED,
;; } GShellError;
(define-fh-enum GShellError
  '((G_SHELL_ERROR_BAD_QUOTING . 0)
    (G_SHELL_ERROR_EMPTY_STRING . 1)
    (G_SHELL_ERROR_FAILED . 2))
  )

;; extern GQuark g_shell_error_quark(void);
(define g_shell_error_quark
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_shell_error_quark"
            ffi:unsigned-int
            (list))))
      (let () (~f)))))
(export g_shell_error_quark)

;; extern gchar *g_shell_quote(const gchar *unquoted_string);
(define g_shell_quote
  (let ((~f #f))
    (lambda (unquoted_string)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_shell_quote" '* (list '*))))
      (let ((~unquoted_string
              (unwrap~pointer unquoted_string)))
        (~f ~unquoted_string)))))
(export g_shell_quote)

;; extern gchar *g_shell_unquote(const gchar *quoted_string, GError **error);
(define g_shell_unquote
  (let ((~f #f))
    (lambda (quoted_string error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_shell_unquote" '* (list '* '*))))
      (let ((~quoted_string (unwrap~pointer quoted_string))
            (~error (unwrap~pointer error)))
        (~f ~quoted_string ~error)))))
(export g_shell_unquote)

;; extern gboolean g_shell_parse_argv(const gchar *command_line, gint *argcp, 
;;     gchar ***argvp, GError **error);
(define g_shell_parse_argv
  (let ((~f #f))
    (lambda (command_line argcp argvp error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_shell_parse_argv"
            ffi:int
            (list '* '* '* '*))))
      (let ((~command_line (unwrap~pointer command_line))
            (~argcp (unwrap~pointer argcp))
            (~argvp (unwrap~pointer argvp))
            (~error (unwrap~pointer error)))
        (~f ~command_line ~argcp ~argvp ~error)))))
(export g_shell_parse_argv)

;; extern gpointer g_slice_alloc(gsize block_size);
(define g_slice_alloc
  (let ((~f #f))
    (lambda (block_size)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_slice_alloc"
            '*
            (list ffi:unsigned-long))))
      (let ((~block_size (unwrap~fixed block_size)))
        (wrap-gpointer (~f ~block_size))))))
(export g_slice_alloc)

;; extern gpointer g_slice_alloc0(gsize block_size);
(define g_slice_alloc0
  (let ((~f #f))
    (lambda (block_size)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_slice_alloc0"
            '*
            (list ffi:unsigned-long))))
      (let ((~block_size (unwrap~fixed block_size)))
        (wrap-gpointer (~f ~block_size))))))
(export g_slice_alloc0)

;; extern gpointer g_slice_copy(gsize block_size, gconstpointer mem_block);
(define g_slice_copy
  (let ((~f #f))
    (lambda (block_size mem_block)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_slice_copy"
            '*
            (list ffi:unsigned-long '*))))
      (let ((~block_size (unwrap~fixed block_size))
            (~mem_block (unwrap-gconstpointer mem_block)))
        (wrap-gpointer (~f ~block_size ~mem_block))))))
(export g_slice_copy)

;; extern void g_slice_free1(gsize block_size, gpointer mem_block);
(define g_slice_free1
  (let ((~f #f))
    (lambda (block_size mem_block)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_slice_free1"
            ffi:void
            (list ffi:unsigned-long '*))))
      (let ((~block_size (unwrap~fixed block_size))
            (~mem_block (unwrap-gpointer mem_block)))
        (~f ~block_size ~mem_block)))))
(export g_slice_free1)

;; extern void g_slice_free_chain_with_offset(gsize block_size, gpointer 
;;     mem_chain, gsize next_offset);
(define g_slice_free_chain_with_offset
  (let ((~f #f))
    (lambda (block_size mem_chain next_offset)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_slice_free_chain_with_offset"
            ffi:void
            (list ffi:unsigned-long '* ffi:unsigned-long))))
      (let ((~block_size (unwrap~fixed block_size))
            (~mem_chain (unwrap-gpointer mem_chain))
            (~next_offset (unwrap~fixed next_offset)))
        (~f ~block_size ~mem_chain ~next_offset)))))
(export g_slice_free_chain_with_offset)

;; typedef enum {
;;   G_SLICE_CONFIG_ALWAYS_MALLOC = 1,
;;   G_SLICE_CONFIG_BYPASS_MAGAZINES,
;;   G_SLICE_CONFIG_WORKING_SET_MSECS,
;;   G_SLICE_CONFIG_COLOR_INCREMENT,
;;   G_SLICE_CONFIG_CHUNK_SIZES,
;;   G_SLICE_CONFIG_CONTENTION_COUNTER,
;; } GSliceConfig;
(define-fh-enum GSliceConfig
  '((G_SLICE_CONFIG_ALWAYS_MALLOC . 1)
    (G_SLICE_CONFIG_BYPASS_MAGAZINES . 2)
    (G_SLICE_CONFIG_WORKING_SET_MSECS . 3)
    (G_SLICE_CONFIG_COLOR_INCREMENT . 4)
    (G_SLICE_CONFIG_CHUNK_SIZES . 5)
    (G_SLICE_CONFIG_CONTENTION_COUNTER . 6))
  )

;; extern void g_slice_set_config(GSliceConfig ckey, gint64 value);
(define g_slice_set_config
  (let ((~f #f))
    (lambda (ckey value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_slice_set_config"
            ffi:void
            (list ffi:int ffi:long))))
      (let ((~ckey (unwrap~fixed ckey))
            (~value (unwrap~fixed value)))
        (~f ~ckey ~value)))))
(export g_slice_set_config)

;; extern gint64 g_slice_get_config(GSliceConfig ckey);
(define g_slice_get_config
  (let ((~f #f))
    (lambda (ckey)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_slice_get_config"
            ffi:long
            (list ffi:int))))
      (let ((~ckey (unwrap~fixed ckey))) (~f ~ckey)))))
(export g_slice_get_config)

;; extern gint64 *g_slice_get_config_state(GSliceConfig ckey, gint64 address, 
;;     guint *n_values);
(define g_slice_get_config_state
  (let ((~f #f))
    (lambda (ckey address n_values)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_slice_get_config_state"
            '*
            (list ffi:int ffi:long '*))))
      (let ((~ckey (unwrap~fixed ckey))
            (~address (unwrap~fixed address))
            (~n_values (unwrap~pointer n_values)))
        (~f ~ckey ~address ~n_values)))))
(export g_slice_get_config_state)

;; typedef enum {
;;   G_SPAWN_ERROR_FORK,
;;   G_SPAWN_ERROR_READ,
;;   G_SPAWN_ERROR_CHDIR,
;;   G_SPAWN_ERROR_ACCES,
;;   G_SPAWN_ERROR_PERM,
;;   G_SPAWN_ERROR_TOO_BIG,
;;   G_SPAWN_ERROR_2BIG = G_SPAWN_ERROR_TOO_BIG,
;;   G_SPAWN_ERROR_NOEXEC,
;;   G_SPAWN_ERROR_NAMETOOLONG,
;;   G_SPAWN_ERROR_NOENT,
;;   G_SPAWN_ERROR_NOMEM,
;;   G_SPAWN_ERROR_NOTDIR,
;;   G_SPAWN_ERROR_LOOP,
;;   G_SPAWN_ERROR_TXTBUSY,
;;   G_SPAWN_ERROR_IO,
;;   G_SPAWN_ERROR_NFILE,
;;   G_SPAWN_ERROR_MFILE,
;;   G_SPAWN_ERROR_INVAL,
;;   G_SPAWN_ERROR_ISDIR,
;;   G_SPAWN_ERROR_LIBBAD,
;;   G_SPAWN_ERROR_FAILED,
;; } GSpawnError;
(define-fh-enum GSpawnError
  '((G_SPAWN_ERROR_FORK . 0)
    (G_SPAWN_ERROR_READ . 1)
    (G_SPAWN_ERROR_CHDIR . 2)
    (G_SPAWN_ERROR_ACCES . 3)
    (G_SPAWN_ERROR_PERM . 4)
    (G_SPAWN_ERROR_TOO_BIG . 5)
    (G_SPAWN_ERROR_2BIG . 5)
    (G_SPAWN_ERROR_NOEXEC . 6)
    (G_SPAWN_ERROR_NAMETOOLONG . 7)
    (G_SPAWN_ERROR_NOENT . 8)
    (G_SPAWN_ERROR_NOMEM . 9)
    (G_SPAWN_ERROR_NOTDIR . 10)
    (G_SPAWN_ERROR_LOOP . 11)
    (G_SPAWN_ERROR_TXTBUSY . 12)
    (G_SPAWN_ERROR_IO . 13)
    (G_SPAWN_ERROR_NFILE . 14)
    (G_SPAWN_ERROR_MFILE . 15)
    (G_SPAWN_ERROR_INVAL . 16)
    (G_SPAWN_ERROR_ISDIR . 17)
    (G_SPAWN_ERROR_LIBBAD . 18)
    (G_SPAWN_ERROR_FAILED . 19))
  )

;; typedef void (*GSpawnChildSetupFunc)(gpointer user_data);
(define-fh-function/p GSpawnChildSetupFunc
  ffi:void (list (quote *)))

;; typedef enum {
;;   G_SPAWN_DEFAULT = 0,
;;   G_SPAWN_LEAVE_DESCRIPTORS_OPEN = 1<<0,
;;   G_SPAWN_DO_NOT_REAP_CHILD = 1<<1,
;;   G_SPAWN_SEARCH_PATH = 1<<2,
;;   G_SPAWN_STDOUT_TO_DEV_NULL = 1<<3,
;;   G_SPAWN_STDERR_TO_DEV_NULL = 1<<4,
;;   G_SPAWN_CHILD_INHERITS_STDIN = 1<<5,
;;   G_SPAWN_FILE_AND_ARGV_ZERO = 1<<6,
;;   G_SPAWN_SEARCH_PATH_FROM_ENVP = 1<<7,
;;   G_SPAWN_CLOEXEC_PIPES = 1<<8,
;; } GSpawnFlags;
(define-fh-enum GSpawnFlags
  '((G_SPAWN_DEFAULT . 0)
    (G_SPAWN_LEAVE_DESCRIPTORS_OPEN . 1)
    (G_SPAWN_DO_NOT_REAP_CHILD . 2)
    (G_SPAWN_SEARCH_PATH . 4)
    (G_SPAWN_STDOUT_TO_DEV_NULL . 8)
    (G_SPAWN_STDERR_TO_DEV_NULL . 16)
    (G_SPAWN_CHILD_INHERITS_STDIN . 32)
    (G_SPAWN_FILE_AND_ARGV_ZERO . 64)
    (G_SPAWN_SEARCH_PATH_FROM_ENVP . 128)
    (G_SPAWN_CLOEXEC_PIPES . 256))
  )

;; extern GQuark g_spawn_error_quark(void);
(define g_spawn_error_quark
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_spawn_error_quark"
            ffi:unsigned-int
            (list))))
      (let () (~f)))))
(export g_spawn_error_quark)

;; extern GQuark g_spawn_exit_error_quark(void);
(define g_spawn_exit_error_quark
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_spawn_exit_error_quark"
            ffi:unsigned-int
            (list))))
      (let () (~f)))))
(export g_spawn_exit_error_quark)

;; extern gboolean g_spawn_async(const gchar *working_directory, gchar **argv, 
;;     gchar **envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, 
;;     gpointer user_data, GPid *child_pid, GError **error);
(define g_spawn_async
  (let ((~f #f))
    (lambda (working_directory
             argv
             envp
             flags
             child_setup
             user_data
             child_pid
             error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_spawn_async"
            ffi:int
            (list '* '* '* ffi:int '* '* '* '*))))
      (let ((~working_directory
              (unwrap~pointer working_directory))
            (~argv (unwrap~pointer argv))
            (~envp (unwrap~pointer envp))
            (~flags (unwrap~fixed flags))
            (~child_setup
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               child_setup))
            (~user_data (unwrap-gpointer user_data))
            (~child_pid (unwrap~pointer child_pid))
            (~error (unwrap~pointer error)))
        (~f ~working_directory
            ~argv
            ~envp
            ~flags
            ~child_setup
            ~user_data
            ~child_pid
            ~error)))))
(export g_spawn_async)

;; extern gboolean g_spawn_async_with_pipes(const gchar *working_directory, 
;;     gchar **argv, gchar **envp, GSpawnFlags flags, GSpawnChildSetupFunc 
;;     child_setup, gpointer user_data, GPid *child_pid, gint *standard_input, 
;;     gint *standard_output, gint *standard_error, GError **error);
(define g_spawn_async_with_pipes
  (let ((~f #f))
    (lambda (working_directory
             argv
             envp
             flags
             child_setup
             user_data
             child_pid
             standard_input
             standard_output
             standard_error
             error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_spawn_async_with_pipes"
            ffi:int
            (list '* '* '* ffi:int '* '* '* '* '* '* '*))))
      (let ((~working_directory
              (unwrap~pointer working_directory))
            (~argv (unwrap~pointer argv))
            (~envp (unwrap~pointer envp))
            (~flags (unwrap~fixed flags))
            (~child_setup
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               child_setup))
            (~user_data (unwrap-gpointer user_data))
            (~child_pid (unwrap~pointer child_pid))
            (~standard_input (unwrap~pointer standard_input))
            (~standard_output
              (unwrap~pointer standard_output))
            (~standard_error (unwrap~pointer standard_error))
            (~error (unwrap~pointer error)))
        (~f ~working_directory
            ~argv
            ~envp
            ~flags
            ~child_setup
            ~user_data
            ~child_pid
            ~standard_input
            ~standard_output
            ~standard_error
            ~error)))))
(export g_spawn_async_with_pipes)

;; extern gboolean g_spawn_sync(const gchar *working_directory, gchar **argv, 
;;     gchar **envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, 
;;     gpointer user_data, gchar **standard_output, gchar **standard_error, 
;;     gint *exit_status, GError **error);
(define g_spawn_sync
  (let ((~f #f))
    (lambda (working_directory
             argv
             envp
             flags
             child_setup
             user_data
             standard_output
             standard_error
             exit_status
             error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_spawn_sync"
            ffi:int
            (list '* '* '* ffi:int '* '* '* '* '* '*))))
      (let ((~working_directory
              (unwrap~pointer working_directory))
            (~argv (unwrap~pointer argv))
            (~envp (unwrap~pointer envp))
            (~flags (unwrap~fixed flags))
            (~child_setup
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               child_setup))
            (~user_data (unwrap-gpointer user_data))
            (~standard_output
              (unwrap~pointer standard_output))
            (~standard_error (unwrap~pointer standard_error))
            (~exit_status (unwrap~pointer exit_status))
            (~error (unwrap~pointer error)))
        (~f ~working_directory
            ~argv
            ~envp
            ~flags
            ~child_setup
            ~user_data
            ~standard_output
            ~standard_error
            ~exit_status
            ~error)))))
(export g_spawn_sync)

;; extern gboolean g_spawn_command_line_sync(const gchar *command_line, gchar *
;;     *standard_output, gchar **standard_error, gint *exit_status, GError **
;;     error);
(define g_spawn_command_line_sync
  (let ((~f #f))
    (lambda (command_line
             standard_output
             standard_error
             exit_status
             error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_spawn_command_line_sync"
            ffi:int
            (list '* '* '* '* '*))))
      (let ((~command_line (unwrap~pointer command_line))
            (~standard_output
              (unwrap~pointer standard_output))
            (~standard_error (unwrap~pointer standard_error))
            (~exit_status (unwrap~pointer exit_status))
            (~error (unwrap~pointer error)))
        (~f ~command_line
            ~standard_output
            ~standard_error
            ~exit_status
            ~error)))))
(export g_spawn_command_line_sync)

;; extern gboolean g_spawn_command_line_async(const gchar *command_line, GError
;;      **error);
(define g_spawn_command_line_async
  (let ((~f #f))
    (lambda (command_line error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_spawn_command_line_async"
            ffi:int
            (list '* '*))))
      (let ((~command_line (unwrap~pointer command_line))
            (~error (unwrap~pointer error)))
        (~f ~command_line ~error)))))
(export g_spawn_command_line_async)

;; extern gboolean g_spawn_check_exit_status(gint exit_status, GError **error)
;;     ;
(define g_spawn_check_exit_status
  (let ((~f #f))
    (lambda (exit_status error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_spawn_check_exit_status"
            ffi:int
            (list ffi:int '*))))
      (let ((~exit_status (unwrap~fixed exit_status))
            (~error (unwrap~pointer error)))
        (~f ~exit_status ~error)))))
(export g_spawn_check_exit_status)

;; extern void g_spawn_close_pid(GPid pid);
(define g_spawn_close_pid
  (let ((~f #f))
    (lambda (pid)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_spawn_close_pid"
            ffi:void
            (list ffi:int))))
      (let ((~pid (unwrap~fixed pid))) (~f ~pid)))))
(export g_spawn_close_pid)

;; typedef enum {
;;   G_ASCII_ALNUM = 1<<0,
;;   G_ASCII_ALPHA = 1<<1,
;;   G_ASCII_CNTRL = 1<<2,
;;   G_ASCII_DIGIT = 1<<3,
;;   G_ASCII_GRAPH = 1<<4,
;;   G_ASCII_LOWER = 1<<5,
;;   G_ASCII_PRINT = 1<<6,
;;   G_ASCII_PUNCT = 1<<7,
;;   G_ASCII_SPACE = 1<<8,
;;   G_ASCII_UPPER = 1<<9,
;;   G_ASCII_XDIGIT = 1<<10,
;; } GAsciiType;
(define-fh-enum GAsciiType
  '((G_ASCII_ALNUM . 1)
    (G_ASCII_ALPHA . 2)
    (G_ASCII_CNTRL . 4)
    (G_ASCII_DIGIT . 8)
    (G_ASCII_GRAPH . 16)
    (G_ASCII_LOWER . 32)
    (G_ASCII_PRINT . 64)
    (G_ASCII_PUNCT . 128)
    (G_ASCII_SPACE . 256)
    (G_ASCII_UPPER . 512)
    (G_ASCII_XDIGIT . 1024))
  )

;; extern const guint16 *constg_ascii_table;
(define g_ascii_table
  (let* ((addr (dynamic-pointer "g_ascii_table" (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer (bs:pointer unsigned-short)))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_ascii_table)

;; extern gchar g_ascii_tolower(gchar c);
(define g_ascii_tolower
  (let ((~f #f))
    (lambda (c)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_ascii_tolower"
            ffi:int
            (list ffi:int))))
      (let ((~c (unwrap~fixed c))) (~f ~c)))))
(export g_ascii_tolower)

;; extern gchar g_ascii_toupper(gchar c);
(define g_ascii_toupper
  (let ((~f #f))
    (lambda (c)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_ascii_toupper"
            ffi:int
            (list ffi:int))))
      (let ((~c (unwrap~fixed c))) (~f ~c)))))
(export g_ascii_toupper)

;; extern gint g_ascii_digit_value(gchar c);
(define g_ascii_digit_value
  (let ((~f #f))
    (lambda (c)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_ascii_digit_value"
            ffi:int
            (list ffi:int))))
      (let ((~c (unwrap~fixed c))) (~f ~c)))))
(export g_ascii_digit_value)

;; extern gint g_ascii_xdigit_value(gchar c);
(define g_ascii_xdigit_value
  (let ((~f #f))
    (lambda (c)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_ascii_xdigit_value"
            ffi:int
            (list ffi:int))))
      (let ((~c (unwrap~fixed c))) (~f ~c)))))
(export g_ascii_xdigit_value)

;; extern gchar *g_strdelimit(gchar *string, const gchar *delimiters, gchar 
;;     new_delimiter);
(define g_strdelimit
  (let ((~f #f))
    (lambda (string delimiters new_delimiter)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_strdelimit"
            '*
            (list '* '* ffi:int))))
      (let ((~string (unwrap~pointer string))
            (~delimiters (unwrap~pointer delimiters))
            (~new_delimiter (unwrap~fixed new_delimiter)))
        (~f ~string ~delimiters ~new_delimiter)))))
(export g_strdelimit)

;; extern gchar *g_strcanon(gchar *string, const gchar *valid_chars, gchar 
;;     substitutor);
(define g_strcanon
  (let ((~f #f))
    (lambda (string valid_chars substitutor)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_strcanon"
            '*
            (list '* '* ffi:int))))
      (let ((~string (unwrap~pointer string))
            (~valid_chars (unwrap~pointer valid_chars))
            (~substitutor (unwrap~fixed substitutor)))
        (~f ~string ~valid_chars ~substitutor)))))
(export g_strcanon)

;; extern const gchar *g_strerror(gint errnum);
(define g_strerror
  (let ((~f #f))
    (lambda (errnum)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_strerror" '* (list ffi:int))))
      (let ((~errnum (unwrap~fixed errnum)))
        (~f ~errnum)))))
(export g_strerror)

;; extern const gchar *g_strsignal(gint signum);
(define g_strsignal
  (let ((~f #f))
    (lambda (signum)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_strsignal" '* (list ffi:int))))
      (let ((~signum (unwrap~fixed signum)))
        (~f ~signum)))))
(export g_strsignal)

;; extern gchar *g_strreverse(gchar *string);
(define g_strreverse
  (let ((~f #f))
    (lambda (string)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_strreverse" '* (list '*))))
      (let ((~string (unwrap~pointer string)))
        (~f ~string)))))
(export g_strreverse)

;; extern gsize g_strlcpy(gchar *dest, const gchar *src, gsize dest_size);
(define g_strlcpy
  (let ((~f #f))
    (lambda (dest src dest_size)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_strlcpy"
            ffi:unsigned-long
            (list '* '* ffi:unsigned-long))))
      (let ((~dest (unwrap~pointer dest))
            (~src (unwrap~pointer src))
            (~dest_size (unwrap~fixed dest_size)))
        (~f ~dest ~src ~dest_size)))))
(export g_strlcpy)

;; extern gsize g_strlcat(gchar *dest, const gchar *src, gsize dest_size);
(define g_strlcat
  (let ((~f #f))
    (lambda (dest src dest_size)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_strlcat"
            ffi:unsigned-long
            (list '* '* ffi:unsigned-long))))
      (let ((~dest (unwrap~pointer dest))
            (~src (unwrap~pointer src))
            (~dest_size (unwrap~fixed dest_size)))
        (~f ~dest ~src ~dest_size)))))
(export g_strlcat)

;; extern gchar *g_strstr_len(const gchar *haystack, gssize haystack_len, const
;;      gchar *needle);
(define g_strstr_len
  (let ((~f #f))
    (lambda (haystack haystack_len needle)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_strstr_len"
            '*
            (list '* ffi:long '*))))
      (let ((~haystack (unwrap~pointer haystack))
            (~haystack_len (unwrap~fixed haystack_len))
            (~needle (unwrap~pointer needle)))
        (~f ~haystack ~haystack_len ~needle)))))
(export g_strstr_len)

;; extern gchar *g_strrstr(const gchar *haystack, const gchar *needle);
(define g_strrstr
  (let ((~f #f))
    (lambda (haystack needle)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_strrstr" '* (list '* '*))))
      (let ((~haystack (unwrap~pointer haystack))
            (~needle (unwrap~pointer needle)))
        (~f ~haystack ~needle)))))
(export g_strrstr)

;; extern gchar *g_strrstr_len(const gchar *haystack, gssize haystack_len, 
;;     const gchar *needle);
(define g_strrstr_len
  (let ((~f #f))
    (lambda (haystack haystack_len needle)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_strrstr_len"
            '*
            (list '* ffi:long '*))))
      (let ((~haystack (unwrap~pointer haystack))
            (~haystack_len (unwrap~fixed haystack_len))
            (~needle (unwrap~pointer needle)))
        (~f ~haystack ~haystack_len ~needle)))))
(export g_strrstr_len)

;; extern gboolean g_str_has_suffix(const gchar *str, const gchar *suffix);
(define g_str_has_suffix
  (let ((~f #f))
    (lambda (str suffix)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_str_has_suffix"
            ffi:int
            (list '* '*))))
      (let ((~str (unwrap~pointer str))
            (~suffix (unwrap~pointer suffix)))
        (~f ~str ~suffix)))))
(export g_str_has_suffix)

;; extern gboolean g_str_has_prefix(const gchar *str, const gchar *prefix);
(define g_str_has_prefix
  (let ((~f #f))
    (lambda (str prefix)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_str_has_prefix"
            ffi:int
            (list '* '*))))
      (let ((~str (unwrap~pointer str))
            (~prefix (unwrap~pointer prefix)))
        (~f ~str ~prefix)))))
(export g_str_has_prefix)

;; extern gdouble g_strtod(const gchar *nptr, gchar **endptr);
(define g_strtod
  (let ((~f #f))
    (lambda (nptr endptr)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_strtod" ffi:double (list '* '*))))
      (let ((~nptr (unwrap~pointer nptr))
            (~endptr (unwrap~pointer endptr)))
        (wrap-gdouble (~f ~nptr ~endptr))))))
(export g_strtod)

;; extern gdouble g_ascii_strtod(const gchar *nptr, gchar **endptr);
(define g_ascii_strtod
  (let ((~f #f))
    (lambda (nptr endptr)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_ascii_strtod"
            ffi:double
            (list '* '*))))
      (let ((~nptr (unwrap~pointer nptr))
            (~endptr (unwrap~pointer endptr)))
        (wrap-gdouble (~f ~nptr ~endptr))))))
(export g_ascii_strtod)

;; extern guint64 g_ascii_strtoull(const gchar *nptr, gchar **endptr, guint 
;;     base);
(define g_ascii_strtoull
  (let ((~f #f))
    (lambda (nptr endptr base)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_ascii_strtoull"
            ffi:unsigned-long
            (list '* '* ffi:unsigned-int))))
      (let ((~nptr (unwrap~pointer nptr))
            (~endptr (unwrap~pointer endptr))
            (~base (unwrap~fixed base)))
        (~f ~nptr ~endptr ~base)))))
(export g_ascii_strtoull)

;; extern gint64 g_ascii_strtoll(const gchar *nptr, gchar **endptr, guint base)
;;     ;
(define g_ascii_strtoll
  (let ((~f #f))
    (lambda (nptr endptr base)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_ascii_strtoll"
            ffi:long
            (list '* '* ffi:unsigned-int))))
      (let ((~nptr (unwrap~pointer nptr))
            (~endptr (unwrap~pointer endptr))
            (~base (unwrap~fixed base)))
        (~f ~nptr ~endptr ~base)))))
(export g_ascii_strtoll)

;; extern gchar *g_ascii_dtostr(gchar *buffer, gint buf_len, gdouble d);
(define g_ascii_dtostr
  (let ((~f #f))
    (lambda (buffer buf_len d)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_ascii_dtostr"
            '*
            (list '* ffi:int ffi:double))))
      (let ((~buffer (unwrap~pointer buffer))
            (~buf_len (unwrap~fixed buf_len))
            (~d (unwrap-gdouble d)))
        (~f ~buffer ~buf_len ~d)))))
(export g_ascii_dtostr)

;; extern gchar *g_ascii_formatd(gchar *buffer, gint buf_len, const gchar *
;;     format, gdouble d);
(define g_ascii_formatd
  (let ((~f #f))
    (lambda (buffer buf_len format d)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_ascii_formatd"
            '*
            (list '* ffi:int '* ffi:double))))
      (let ((~buffer (unwrap~pointer buffer))
            (~buf_len (unwrap~fixed buf_len))
            (~format (unwrap~pointer format))
            (~d (unwrap-gdouble d)))
        (~f ~buffer ~buf_len ~format ~d)))))
(export g_ascii_formatd)

;; extern gchar *g_strchug(gchar *string);
(define g_strchug
  (let ((~f #f))
    (lambda (string)
      (if (not ~f)
        (set! ~f (fh-link-proc "g_strchug" '* (list '*))))
      (let ((~string (unwrap~pointer string)))
        (~f ~string)))))
(export g_strchug)

;; extern gchar *g_strchomp(gchar *string);
(define g_strchomp
  (let ((~f #f))
    (lambda (string)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_strchomp" '* (list '*))))
      (let ((~string (unwrap~pointer string)))
        (~f ~string)))))
(export g_strchomp)

;; extern gint g_ascii_strcasecmp(const gchar *s1, const gchar *s2);
(define g_ascii_strcasecmp
  (let ((~f #f))
    (lambda (s1 s2)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_ascii_strcasecmp"
            ffi:int
            (list '* '*))))
      (let ((~s1 (unwrap~pointer s1))
            (~s2 (unwrap~pointer s2)))
        (~f ~s1 ~s2)))))
(export g_ascii_strcasecmp)

;; extern gint g_ascii_strncasecmp(const gchar *s1, const gchar *s2, gsize n);
(define g_ascii_strncasecmp
  (let ((~f #f))
    (lambda (s1 s2 n)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_ascii_strncasecmp"
            ffi:int
            (list '* '* ffi:unsigned-long))))
      (let ((~s1 (unwrap~pointer s1))
            (~s2 (unwrap~pointer s2))
            (~n (unwrap~fixed n)))
        (~f ~s1 ~s2 ~n)))))
(export g_ascii_strncasecmp)

;; extern gchar *g_ascii_strdown(const gchar *str, gssize len);
(define g_ascii_strdown
  (let ((~f #f))
    (lambda (str len)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_ascii_strdown"
            '*
            (list '* ffi:long))))
      (let ((~str (unwrap~pointer str))
            (~len (unwrap~fixed len)))
        (~f ~str ~len)))))
(export g_ascii_strdown)

;; extern gchar *g_ascii_strup(const gchar *str, gssize len);
(define g_ascii_strup
  (let ((~f #f))
    (lambda (str len)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_ascii_strup"
            '*
            (list '* ffi:long))))
      (let ((~str (unwrap~pointer str))
            (~len (unwrap~fixed len)))
        (~f ~str ~len)))))
(export g_ascii_strup)

;; extern gboolean g_str_is_ascii(const gchar *str);
(define g_str_is_ascii
  (let ((~f #f))
    (lambda (str)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_str_is_ascii" ffi:int (list '*))))
      (let ((~str (unwrap~pointer str))) (~f ~str)))))
(export g_str_is_ascii)

;; extern gint g_strcasecmp(const gchar *s1, const gchar *s2);
(define g_strcasecmp
  (let ((~f #f))
    (lambda (s1 s2)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_strcasecmp"
            ffi:int
            (list '* '*))))
      (let ((~s1 (unwrap~pointer s1))
            (~s2 (unwrap~pointer s2)))
        (~f ~s1 ~s2)))))
(export g_strcasecmp)

;; extern gint g_strncasecmp(const gchar *s1, const gchar *s2, guint n);
(define g_strncasecmp
  (let ((~f #f))
    (lambda (s1 s2 n)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_strncasecmp"
            ffi:int
            (list '* '* ffi:unsigned-int))))
      (let ((~s1 (unwrap~pointer s1))
            (~s2 (unwrap~pointer s2))
            (~n (unwrap~fixed n)))
        (~f ~s1 ~s2 ~n)))))
(export g_strncasecmp)

;; extern gchar *g_strdown(gchar *string);
(define g_strdown
  (let ((~f #f))
    (lambda (string)
      (if (not ~f)
        (set! ~f (fh-link-proc "g_strdown" '* (list '*))))
      (let ((~string (unwrap~pointer string)))
        (~f ~string)))))
(export g_strdown)

;; extern gchar *g_strup(gchar *string);
(define g_strup
  (let ((~f #f))
    (lambda (string)
      (if (not ~f)
        (set! ~f (fh-link-proc "g_strup" '* (list '*))))
      (let ((~string (unwrap~pointer string)))
        (~f ~string)))))
(export g_strup)

;; extern gchar *g_strdup(const gchar *str);
(define g_strdup
  (let ((~f #f))
    (lambda (str)
      (if (not ~f)
        (set! ~f (fh-link-proc "g_strdup" '* (list '*))))
      (let ((~str (unwrap~pointer str))) (~f ~str)))))
(export g_strdup)

;; extern gchar *g_strdup_printf(const gchar *format, ...);
;; ... failed.

;; extern gchar *g_strdup_vprintf(const gchar *format, va_list args);
(define g_strdup_vprintf
  (let ((~f #f))
    (lambda (format args)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_strdup_vprintf" '* (list '* '*))))
      (let ((~format (unwrap~pointer format))
            (~args (unwrap~pointer args)))
        (~f ~format ~args)))))
(export g_strdup_vprintf)

;; extern gchar *g_strndup(const gchar *str, gsize n);
(define g_strndup
  (let ((~f #f))
    (lambda (str n)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_strndup"
            '*
            (list '* ffi:unsigned-long))))
      (let ((~str (unwrap~pointer str))
            (~n (unwrap~fixed n)))
        (~f ~str ~n)))))
(export g_strndup)

;; extern gchar *g_strnfill(gsize length, gchar fill_char);
(define g_strnfill
  (let ((~f #f))
    (lambda (length fill_char)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_strnfill"
            '*
            (list ffi:unsigned-long ffi:int))))
      (let ((~length (unwrap~fixed length))
            (~fill_char (unwrap~fixed fill_char)))
        (~f ~length ~fill_char)))))
(export g_strnfill)

;; extern gchar *g_strconcat(const gchar *string1, ...);
;; ... failed.

;; extern gchar *g_strjoin(const gchar *separator, ...);
;; ... failed.

;; extern gchar *g_strcompress(const gchar *source);
(define g_strcompress
  (let ((~f #f))
    (lambda (source)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_strcompress" '* (list '*))))
      (let ((~source (unwrap~pointer source)))
        (~f ~source)))))
(export g_strcompress)

;; extern gchar *g_strescape(const gchar *source, const gchar *exceptions);
(define g_strescape
  (let ((~f #f))
    (lambda (source exceptions)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_strescape" '* (list '* '*))))
      (let ((~source (unwrap~pointer source))
            (~exceptions (unwrap~pointer exceptions)))
        (~f ~source ~exceptions)))))
(export g_strescape)

;; extern gpointer g_memdup(gconstpointer mem, guint byte_size);
(define g_memdup
  (let ((~f #f))
    (lambda (mem byte_size)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_memdup"
            '*
            (list '* ffi:unsigned-int))))
      (let ((~mem (unwrap-gconstpointer mem))
            (~byte_size (unwrap~fixed byte_size)))
        (wrap-gpointer (~f ~mem ~byte_size))))))
(export g_memdup)

;; typedef gchar **GStrv;
(define GStrv-desc (bs:pointer (bs:pointer gchar-desc)))
(define-fh-pointer-type GStrv GStrv-desc)

;; extern gchar **g_strsplit(const gchar *string, const gchar *delimiter, gint 
;;     max_tokens);
(define g_strsplit
  (let* ((addr (dynamic-pointer "g_strsplit" (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer (bs:pointer void)))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_strsplit)

;; extern gchar **g_strsplit_set(const gchar *string, const gchar *delimiters, 
;;     gint max_tokens);
(define g_strsplit_set
  (let* ((addr (dynamic-pointer "g_strsplit_set" (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer (bs:pointer void)))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_strsplit_set)

;; extern gchar *g_strjoinv(const gchar *separator, gchar **str_array);
(define g_strjoinv
  (let ((~f #f))
    (lambda (separator str_array)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_strjoinv" '* (list '* '*))))
      (let ((~separator (unwrap~pointer separator))
            (~str_array (unwrap~pointer str_array)))
        (~f ~separator ~str_array)))))
(export g_strjoinv)

;; extern void g_strfreev(gchar **str_array);
(define g_strfreev
  (let ((~f #f))
    (lambda (str_array)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_strfreev" ffi:void (list '*))))
      (let ((~str_array (unwrap~pointer str_array)))
        (~f ~str_array)))))
(export g_strfreev)

;; extern gchar **g_strdupv(gchar **str_array);
(define g_strdupv
  (let* ((addr (dynamic-pointer "g_strdupv" (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer (bs:pointer void)))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_strdupv)

;; extern guint g_strv_length(gchar **str_array);
(define g_strv_length
  (let ((~f #f))
    (lambda (str_array)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_strv_length"
            ffi:unsigned-int
            (list '*))))
      (let ((~str_array (unwrap~pointer str_array)))
        (~f ~str_array)))))
(export g_strv_length)

;; extern gchar *g_stpcpy(gchar *dest, const char *src);
(define g_stpcpy
  (let ((~f #f))
    (lambda (dest src)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_stpcpy" '* (list '* '*))))
      (let ((~dest (unwrap~pointer dest))
            (~src (unwrap~pointer src)))
        (~f ~dest ~src)))))
(export g_stpcpy)

;; extern gchar *g_str_to_ascii(const gchar *str, const gchar *from_locale);
(define g_str_to_ascii
  (let ((~f #f))
    (lambda (str from_locale)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_str_to_ascii" '* (list '* '*))))
      (let ((~str (unwrap~pointer str))
            (~from_locale (unwrap~pointer from_locale)))
        (~f ~str ~from_locale)))))
(export g_str_to_ascii)

;; extern gchar **g_str_tokenize_and_fold(const gchar *string, const gchar *
;;     translit_locale, gchar ***ascii_alternates);
(define g_str_tokenize_and_fold
  (let* ((addr (dynamic-pointer
                 "g_str_tokenize_and_fold"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer (bs:pointer void)))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_str_tokenize_and_fold)

;; extern gboolean g_str_match_string(const gchar *search_term, const gchar *
;;     potential_hit, gboolean accept_alternates);
(define g_str_match_string
  (let ((~f #f))
    (lambda (search_term potential_hit accept_alternates)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_str_match_string"
            ffi:int
            (list '* '* ffi:int))))
      (let ((~search_term (unwrap~pointer search_term))
            (~potential_hit (unwrap~pointer potential_hit))
            (~accept_alternates
              (unwrap~fixed accept_alternates)))
        (~f ~search_term
            ~potential_hit
            ~accept_alternates)))))
(export g_str_match_string)

;; extern gboolean g_strv_contains(const gchar *const*strv, const gchar *str);
(define g_strv_contains
  (let ((~f #f))
    (lambda (strv str)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_strv_contains"
            ffi:int
            (list '* '*))))
      (let ((~strv (unwrap~pointer strv))
            (~str (unwrap~pointer str)))
        (~f ~strv ~str)))))
(export g_strv_contains)

;; typedef struct _GStringChunk GStringChunk;
(define GStringChunk-desc void)
(define GStringChunk*-desc (bs:pointer GStringChunk-desc))
(export GStringChunk*-desc)
(define-fh-pointer-type GStringChunk* GStringChunk*-desc)

;; extern GStringChunk *g_string_chunk_new(gsize size);
(define g_string_chunk_new
  (let ((~f #f))
    (lambda (size)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_string_chunk_new"
            '*
            (list ffi:unsigned-long))))
      (let ((~size (unwrap~fixed size)))
        (wrap-GStringChunk* (~f ~size))))))
(export g_string_chunk_new)

;; extern void g_string_chunk_free(GStringChunk *chunk);
(define g_string_chunk_free
  (let ((~f #f))
    (lambda (chunk)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_string_chunk_free"
            ffi:void
            (list '*))))
      (let ((~chunk (unwrap-GStringChunk* chunk)))
        (~f ~chunk)))))
(export g_string_chunk_free)

;; extern void g_string_chunk_clear(GStringChunk *chunk);
(define g_string_chunk_clear
  (let ((~f #f))
    (lambda (chunk)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_string_chunk_clear"
            ffi:void
            (list '*))))
      (let ((~chunk (unwrap-GStringChunk* chunk)))
        (~f ~chunk)))))
(export g_string_chunk_clear)

;; extern gchar *g_string_chunk_insert(GStringChunk *chunk, const gchar *string
;;     );
(define g_string_chunk_insert
  (let ((~f #f))
    (lambda (chunk string)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_string_chunk_insert"
            '*
            (list '* '*))))
      (let ((~chunk (unwrap-GStringChunk* chunk))
            (~string (unwrap~pointer string)))
        (~f ~chunk ~string)))))
(export g_string_chunk_insert)

;; extern gchar *g_string_chunk_insert_len(GStringChunk *chunk, const gchar *
;;     string, gssize len);
(define g_string_chunk_insert_len
  (let ((~f #f))
    (lambda (chunk string len)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_string_chunk_insert_len"
            '*
            (list '* '* ffi:long))))
      (let ((~chunk (unwrap-GStringChunk* chunk))
            (~string (unwrap~pointer string))
            (~len (unwrap~fixed len)))
        (~f ~chunk ~string ~len)))))
(export g_string_chunk_insert_len)

;; extern gchar *g_string_chunk_insert_const(GStringChunk *chunk, const gchar *
;;     string);
(define g_string_chunk_insert_const
  (let ((~f #f))
    (lambda (chunk string)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_string_chunk_insert_const"
            '*
            (list '* '*))))
      (let ((~chunk (unwrap-GStringChunk* chunk))
            (~string (unwrap~pointer string)))
        (~f ~chunk ~string)))))
(export g_string_chunk_insert_const)

;; typedef struct GTestCase GTestCase;
(define GTestCase-desc void)
(define GTestCase*-desc (bs:pointer GTestCase-desc))
(export GTestCase*-desc)
(define-fh-pointer-type GTestCase* GTestCase*-desc)

;; typedef struct GTestSuite GTestSuite;
(define GTestSuite-desc void)
(define GTestSuite*-desc (bs:pointer GTestSuite-desc))
(export GTestSuite*-desc)
(define-fh-pointer-type GTestSuite* GTestSuite*-desc)

;; typedef void (*GTestFunc)(void);
(define-fh-function/p GTestFunc
  ffi:void (list ffi:void))

;; typedef void (*GTestDataFunc)(gconstpointer user_data);
(define-fh-function/p GTestDataFunc
  ffi:void (list (quote *)))

;; typedef void (*GTestFixtureFunc)(gpointer fixture, gconstpointer user_data)
;;     ;
(define-fh-function/p GTestFixtureFunc
  ffi:void (list (quote *) (quote *)))

;; extern int g_strcmp0(const char *str1, const char *str2);
(define g_strcmp0
  (let ((~f #f))
    (lambda (str1 str2)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_strcmp0" ffi:int (list '* '*))))
      (let ((~str1 (unwrap~pointer str1))
            (~str2 (unwrap~pointer str2)))
        (~f ~str1 ~str2)))))
(export g_strcmp0)

;; extern void g_test_minimized_result(double minimized_quantity, const char *
;;     format, ...);
;; ... failed.

;; extern void g_test_maximized_result(double maximized_quantity, const char *
;;     format, ...);
;; ... failed.

;; extern void g_test_init(int *argc, char ***argv, ...);
;; ... failed.

;; extern gboolean g_test_subprocess(void);
(define g_test_subprocess
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_test_subprocess" ffi:int (list))))
      (let () (~f)))))
(export g_test_subprocess)

;; extern int g_test_run(void);
(define g_test_run
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_test_run" ffi:int (list))))
      (let () (~f)))))
(export g_test_run)

;; extern void g_test_add_func(const char *testpath, GTestFunc test_func);
(define g_test_add_func
  (let ((~f #f))
    (lambda (testpath test_func)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_test_add_func"
            ffi:void
            (list '* '*))))
      (let ((~testpath (unwrap~pointer testpath))
            (~test_func
              ((make-ftn-arg-unwrapper ffi:void (list ffi:void))
               test_func)))
        (~f ~testpath ~test_func)))))
(export g_test_add_func)

;; extern void g_test_add_data_func(const char *testpath, gconstpointer 
;;     test_data, GTestDataFunc test_func);
(define g_test_add_data_func
  (let ((~f #f))
    (lambda (testpath test_data test_func)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_test_add_data_func"
            ffi:void
            (list '* '* '*))))
      (let ((~testpath (unwrap~pointer testpath))
            (~test_data (unwrap-gconstpointer test_data))
            (~test_func
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               test_func)))
        (~f ~testpath ~test_data ~test_func)))))
(export g_test_add_data_func)

;; extern void g_test_add_data_func_full(const char *testpath, gpointer 
;;     test_data, GTestDataFunc test_func, GDestroyNotify data_free_func);
(define g_test_add_data_func_full
  (let ((~f #f))
    (lambda (testpath test_data test_func data_free_func)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_test_add_data_func_full"
            ffi:void
            (list '* '* '* '*))))
      (let ((~testpath (unwrap~pointer testpath))
            (~test_data (unwrap-gpointer test_data))
            (~test_func
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               test_func))
            (~data_free_func
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               data_free_func)))
        (~f ~testpath
            ~test_data
            ~test_func
            ~data_free_func)))))
(export g_test_add_data_func_full)

;; extern void g_test_fail(void);
(define g_test_fail
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_test_fail" ffi:void (list))))
      (let () (~f)))))
(export g_test_fail)

;; extern void g_test_incomplete(const gchar *msg);
(define g_test_incomplete
  (let ((~f #f))
    (lambda (msg)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_test_incomplete"
            ffi:void
            (list '*))))
      (let ((~msg (unwrap~pointer msg))) (~f ~msg)))))
(export g_test_incomplete)

;; extern void g_test_skip(const gchar *msg);
(define g_test_skip
  (let ((~f #f))
    (lambda (msg)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_test_skip" ffi:void (list '*))))
      (let ((~msg (unwrap~pointer msg))) (~f ~msg)))))
(export g_test_skip)

;; extern gboolean g_test_failed(void);
(define g_test_failed
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_test_failed" ffi:int (list))))
      (let () (~f)))))
(export g_test_failed)

;; extern void g_test_set_nonfatal_assertions(void);
(define g_test_set_nonfatal_assertions
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_test_set_nonfatal_assertions"
            ffi:void
            (list))))
      (let () (~f)))))
(export g_test_set_nonfatal_assertions)

;; extern void g_test_message(const char *format, ...);
;; ... failed.

;; extern void g_test_bug_base(const char *uri_pattern);
(define g_test_bug_base
  (let ((~f #f))
    (lambda (uri_pattern)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_test_bug_base"
            ffi:void
            (list '*))))
      (let ((~uri_pattern (unwrap~pointer uri_pattern)))
        (~f ~uri_pattern)))))
(export g_test_bug_base)

;; extern void g_test_bug(const char *bug_uri_snippet);
(define g_test_bug
  (let ((~f #f))
    (lambda (bug_uri_snippet)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_test_bug" ffi:void (list '*))))
      (let ((~bug_uri_snippet
              (unwrap~pointer bug_uri_snippet)))
        (~f ~bug_uri_snippet)))))
(export g_test_bug)

;; extern void g_test_timer_start(void);
(define g_test_timer_start
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_test_timer_start"
            ffi:void
            (list))))
      (let () (~f)))))
(export g_test_timer_start)

;; extern double g_test_timer_elapsed(void); /* elapsed seconds */
(define g_test_timer_elapsed
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_test_timer_elapsed"
            ffi:double
            (list))))
      (let () (~f)))))
(export g_test_timer_elapsed)

;; extern double g_test_timer_last(void); /* repeat last elapsed() result */
(define g_test_timer_last
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_test_timer_last"
            ffi:double
            (list))))
      (let () (~f)))))
(export g_test_timer_last)

;; extern void g_test_queue_free(gpointer gfree_pointer);
(define g_test_queue_free
  (let ((~f #f))
    (lambda (gfree_pointer)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_test_queue_free"
            ffi:void
            (list '*))))
      (let ((~gfree_pointer (unwrap-gpointer gfree_pointer)))
        (~f ~gfree_pointer)))))
(export g_test_queue_free)

;; extern void g_test_queue_destroy(GDestroyNotify destroy_func, gpointer 
;;     destroy_data);
(define g_test_queue_destroy
  (let ((~f #f))
    (lambda (destroy_func destroy_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_test_queue_destroy"
            ffi:void
            (list '* '*))))
      (let ((~destroy_func
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               destroy_func))
            (~destroy_data (unwrap-gpointer destroy_data)))
        (~f ~destroy_func ~destroy_data)))))
(export g_test_queue_destroy)

;; typedef enum {
;;   G_TEST_TRAP_SILENCE_STDOUT = 1<<7,
;;   G_TEST_TRAP_SILENCE_STDERR = 1<<8,
;;   G_TEST_TRAP_INHERIT_STDIN = 1<<9,
;; } GTestTrapFlags;
(define-fh-enum GTestTrapFlags
  '((G_TEST_TRAP_SILENCE_STDOUT . 128)
    (G_TEST_TRAP_SILENCE_STDERR . 256)
    (G_TEST_TRAP_INHERIT_STDIN . 512))
  )

;; extern gboolean g_test_trap_fork(guint64 usec_timeout, GTestTrapFlags 
;;     test_trap_flags);
(define g_test_trap_fork
  (let ((~f #f))
    (lambda (usec_timeout test_trap_flags)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_test_trap_fork"
            ffi:int
            (list ffi:unsigned-long ffi:int))))
      (let ((~usec_timeout (unwrap~fixed usec_timeout))
            (~test_trap_flags (unwrap~fixed test_trap_flags)))
        (~f ~usec_timeout ~test_trap_flags)))))
(export g_test_trap_fork)

;; typedef enum {
;;   G_TEST_SUBPROCESS_INHERIT_STDIN = 1<<0,
;;   G_TEST_SUBPROCESS_INHERIT_STDOUT = 1<<1,
;;   G_TEST_SUBPROCESS_INHERIT_STDERR = 1<<2,
;; } GTestSubprocessFlags;
(define-fh-enum GTestSubprocessFlags
  '((G_TEST_SUBPROCESS_INHERIT_STDIN . 1)
    (G_TEST_SUBPROCESS_INHERIT_STDOUT . 2)
    (G_TEST_SUBPROCESS_INHERIT_STDERR . 4))
  )

;; extern void g_test_trap_subprocess(const char *test_path, guint64 
;;     usec_timeout, GTestSubprocessFlags test_flags);
(define g_test_trap_subprocess
  (let ((~f #f))
    (lambda (test_path usec_timeout test_flags)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_test_trap_subprocess"
            ffi:void
            (list '* ffi:unsigned-long ffi:int))))
      (let ((~test_path (unwrap~pointer test_path))
            (~usec_timeout (unwrap~fixed usec_timeout))
            (~test_flags (unwrap~fixed test_flags)))
        (~f ~test_path ~usec_timeout ~test_flags)))))
(export g_test_trap_subprocess)

;; extern gboolean g_test_trap_has_passed(void);
(define g_test_trap_has_passed
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_test_trap_has_passed"
            ffi:int
            (list))))
      (let () (~f)))))
(export g_test_trap_has_passed)

;; extern gboolean g_test_trap_reached_timeout(void);
(define g_test_trap_reached_timeout
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_test_trap_reached_timeout"
            ffi:int
            (list))))
      (let () (~f)))))
(export g_test_trap_reached_timeout)

;; extern gint32 g_test_rand_int(void);
(define g_test_rand_int
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_test_rand_int" ffi:int (list))))
      (let () (~f)))))
(export g_test_rand_int)

;; extern gint32 g_test_rand_int_range(gint32 begin, gint32 end);
(define g_test_rand_int_range
  (let ((~f #f))
    (lambda (begin end)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_test_rand_int_range"
            ffi:int
            (list ffi:int ffi:int))))
      (let ((~begin (unwrap~fixed begin))
            (~end (unwrap~fixed end)))
        (~f ~begin ~end)))))
(export g_test_rand_int_range)

;; extern double g_test_rand_double(void);
(define g_test_rand_double
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_test_rand_double"
            ffi:double
            (list))))
      (let () (~f)))))
(export g_test_rand_double)

;; extern double g_test_rand_double_range(double range_start, double range_end)
;;     ;
(define g_test_rand_double_range
  (let ((~f #f))
    (lambda (range_start range_end)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_test_rand_double_range"
            ffi:double
            (list ffi:double ffi:double))))
      (let ((~range_start (unwrap~float range_start))
            (~range_end (unwrap~float range_end)))
        (~f ~range_start ~range_end)))))
(export g_test_rand_double_range)

;; extern GTestCase *g_test_create_case(const char *test_name, gsize data_size
;;     , gconstpointer test_data, GTestFixtureFunc data_setup, GTestFixtureFunc
;;      data_test, GTestFixtureFunc data_teardown);
(define g_test_create_case
  (let ((~f #f))
    (lambda (test_name
             data_size
             test_data
             data_setup
             data_test
             data_teardown)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_test_create_case"
            '*
            (list '* ffi:unsigned-long '* '* '* '*))))
      (let ((~test_name (unwrap~pointer test_name))
            (~data_size (unwrap~fixed data_size))
            (~test_data (unwrap-gconstpointer test_data))
            (~data_setup
              ((make-ftn-arg-unwrapper ffi:void (list '* '*))
               data_setup))
            (~data_test
              ((make-ftn-arg-unwrapper ffi:void (list '* '*))
               data_test))
            (~data_teardown
              ((make-ftn-arg-unwrapper ffi:void (list '* '*))
               data_teardown)))
        (wrap-GTestCase*
          (~f ~test_name
              ~data_size
              ~test_data
              ~data_setup
              ~data_test
              ~data_teardown))))))
(export g_test_create_case)

;; extern GTestSuite *g_test_create_suite(const char *suite_name);
(define g_test_create_suite
  (let ((~f #f))
    (lambda (suite_name)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_test_create_suite" '* (list '*))))
      (let ((~suite_name (unwrap~pointer suite_name)))
        (wrap-GTestSuite* (~f ~suite_name))))))
(export g_test_create_suite)

;; extern GTestSuite *g_test_get_root(void);
(define g_test_get_root
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_test_get_root" '* (list))))
      (let () (wrap-GTestSuite* (~f))))))
(export g_test_get_root)

;; extern void g_test_suite_add(GTestSuite *suite, GTestCase *test_case);
(define g_test_suite_add
  (let ((~f #f))
    (lambda (suite test_case)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_test_suite_add"
            ffi:void
            (list '* '*))))
      (let ((~suite (unwrap-GTestSuite* suite))
            (~test_case (unwrap-GTestCase* test_case)))
        (~f ~suite ~test_case)))))
(export g_test_suite_add)

;; extern void g_test_suite_add_suite(GTestSuite *suite, GTestSuite *
;;     nestedsuite);
(define g_test_suite_add_suite
  (let ((~f #f))
    (lambda (suite nestedsuite)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_test_suite_add_suite"
            ffi:void
            (list '* '*))))
      (let ((~suite (unwrap-GTestSuite* suite))
            (~nestedsuite (unwrap-GTestSuite* nestedsuite)))
        (~f ~suite ~nestedsuite)))))
(export g_test_suite_add_suite)

;; extern int g_test_run_suite(GTestSuite *suite);
(define g_test_run_suite
  (let ((~f #f))
    (lambda (suite)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_test_run_suite"
            ffi:int
            (list '*))))
      (let ((~suite (unwrap-GTestSuite* suite)))
        (~f ~suite)))))
(export g_test_run_suite)

;; extern void g_test_trap_assertions(const char *domain, const char *file, int
;;      line, const char *func, guint64 assertion_flags, const char *pattern);
(define g_test_trap_assertions
  (let ((~f #f))
    (lambda (domain file line func assertion_flags pattern)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_test_trap_assertions"
            ffi:void
            (list '* '* ffi:int '* ffi:unsigned-long '*))))
      (let ((~domain (unwrap~pointer domain))
            (~file (unwrap~pointer file))
            (~line (unwrap~fixed line))
            (~func (unwrap~pointer func))
            (~assertion_flags (unwrap~fixed assertion_flags))
            (~pattern (unwrap~pointer pattern)))
        (~f ~domain
            ~file
            ~line
            ~func
            ~assertion_flags
            ~pattern)))))
(export g_test_trap_assertions)

;; extern void g_assertion_message(const char *domain, const char *file, int 
;;     line, const char *func, const char *message);
(define g_assertion_message
  (let ((~f #f))
    (lambda (domain file line func message)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_assertion_message"
            ffi:void
            (list '* '* ffi:int '* '*))))
      (let ((~domain (unwrap~pointer domain))
            (~file (unwrap~pointer file))
            (~line (unwrap~fixed line))
            (~func (unwrap~pointer func))
            (~message (unwrap~pointer message)))
        (~f ~domain ~file ~line ~func ~message)))))
(export g_assertion_message)

;; extern void g_assertion_message_expr(const char *domain, const char *file, 
;;     int line, const char *func, const char *expr);
(define g_assertion_message_expr
  (let ((~f #f))
    (lambda (domain file line func expr)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_assertion_message_expr"
            ffi:void
            (list '* '* ffi:int '* '*))))
      (let ((~domain (unwrap~pointer domain))
            (~file (unwrap~pointer file))
            (~line (unwrap~fixed line))
            (~func (unwrap~pointer func))
            (~expr (unwrap~pointer expr)))
        (~f ~domain ~file ~line ~func ~expr)))))
(export g_assertion_message_expr)

;; extern void g_assertion_message_cmpstr(const char *domain, const char *file
;;     , int line, const char *func, const char *expr, const char *arg1, const 
;;     char *cmp, const char *arg2);
(define g_assertion_message_cmpstr
  (let ((~f #f))
    (lambda (domain file line func expr arg1 cmp arg2)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_assertion_message_cmpstr"
            ffi:void
            (list '* '* ffi:int '* '* '* '* '*))))
      (let ((~domain (unwrap~pointer domain))
            (~file (unwrap~pointer file))
            (~line (unwrap~fixed line))
            (~func (unwrap~pointer func))
            (~expr (unwrap~pointer expr))
            (~arg1 (unwrap~pointer arg1))
            (~cmp (unwrap~pointer cmp))
            (~arg2 (unwrap~pointer arg2)))
        (~f ~domain
            ~file
            ~line
            ~func
            ~expr
            ~arg1
            ~cmp
            ~arg2)))))
(export g_assertion_message_cmpstr)

;; extern void g_assertion_message_cmpnum(const char *domain, const char *file
;;     , int line, const char *func, const char *expr, long double arg1, const 
;;     char *cmp, long double arg2, char numtype);
;; ... failed.

;; extern void g_assertion_message_error(const char *domain, const char *file, 
;;     int line, const char *func, const char *expr, const GError *error, 
;;     GQuark error_domain, int error_code);
(define g_assertion_message_error
  (let ((~f #f))
    (lambda (domain
             file
             line
             func
             expr
             error
             error_domain
             error_code)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_assertion_message_error"
            ffi:void
            (list '*
                  '*
                  ffi:int
                  '*
                  '*
                  '*
                  ffi:unsigned-int
                  ffi:int))))
      (let ((~domain (unwrap~pointer domain))
            (~file (unwrap~pointer file))
            (~line (unwrap~fixed line))
            (~func (unwrap~pointer func))
            (~expr (unwrap~pointer expr))
            (~error (unwrap-GError* error))
            (~error_domain (unwrap~fixed error_domain))
            (~error_code (unwrap~fixed error_code)))
        (~f ~domain
            ~file
            ~line
            ~func
            ~expr
            ~error
            ~error_domain
            ~error_code)))))
(export g_assertion_message_error)

;; extern void g_test_add_vtable(const char *testpath, gsize data_size, 
;;     gconstpointer test_data, GTestFixtureFunc data_setup, GTestFixtureFunc 
;;     data_test, GTestFixtureFunc data_teardown);
(define g_test_add_vtable
  (let ((~f #f))
    (lambda (testpath
             data_size
             test_data
             data_setup
             data_test
             data_teardown)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_test_add_vtable"
            ffi:void
            (list '* ffi:unsigned-long '* '* '* '*))))
      (let ((~testpath (unwrap~pointer testpath))
            (~data_size (unwrap~fixed data_size))
            (~test_data (unwrap-gconstpointer test_data))
            (~data_setup
              ((make-ftn-arg-unwrapper ffi:void (list '* '*))
               data_setup))
            (~data_test
              ((make-ftn-arg-unwrapper ffi:void (list '* '*))
               data_test))
            (~data_teardown
              ((make-ftn-arg-unwrapper ffi:void (list '* '*))
               data_teardown)))
        (~f ~testpath
            ~data_size
            ~test_data
            ~data_setup
            ~data_test
            ~data_teardown)))))
(export g_test_add_vtable)

;; typedef struct {
;;   gboolean test_initialized;
;;   gboolean test_quick; /* disable thorough tests */
;;   gboolean test_perf; /* run performance tests */
;;   gboolean test_verbose; /* extra info */
;;   gboolean test_quiet; /* reduce output */
;;   gboolean test_undefined; /* run tests that are meant to assert */
;; } GTestConfig;
(define GTestConfig-desc
  (bs:struct
    (list `(test_initialized ,int)
          `(test_quick ,int)
          `(test_perf ,int)
          `(test_verbose ,int)
          `(test_quiet ,int)
          `(test_undefined ,int))))
(export GTestConfig-desc)
(define-fh-compound-type/p GTestConfig GTestConfig-desc)

;; extern const GTestConfig *constg_test_config_vars;
(define g_test_config_vars
  (let* ((addr (dynamic-pointer
                 "g_test_config_vars"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer
                  (bs:pointer (delay GTestConfig*-desc))))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_test_config_vars)

;; typedef enum {
;;   G_TEST_LOG_NONE,
;;   G_TEST_LOG_ERROR,
;;   G_TEST_LOG_START_BINARY,
;;   G_TEST_LOG_LIST_CASE,
;;   G_TEST_LOG_SKIP_CASE,
;;   G_TEST_LOG_START_CASE,
;;   G_TEST_LOG_STOP_CASE,
;;   G_TEST_LOG_MIN_RESULT,
;;   G_TEST_LOG_MAX_RESULT,
;;   G_TEST_LOG_MESSAGE,
;;   G_TEST_LOG_START_SUITE,
;;   G_TEST_LOG_STOP_SUITE,
;; } GTestLogType;
(define-fh-enum GTestLogType
  '((G_TEST_LOG_NONE . 0)
    (G_TEST_LOG_ERROR . 1)
    (G_TEST_LOG_START_BINARY . 2)
    (G_TEST_LOG_LIST_CASE . 3)
    (G_TEST_LOG_SKIP_CASE . 4)
    (G_TEST_LOG_START_CASE . 5)
    (G_TEST_LOG_STOP_CASE . 6)
    (G_TEST_LOG_MIN_RESULT . 7)
    (G_TEST_LOG_MAX_RESULT . 8)
    (G_TEST_LOG_MESSAGE . 9)
    (G_TEST_LOG_START_SUITE . 10)
    (G_TEST_LOG_STOP_SUITE . 11))
  )

;; typedef struct {
;;   GTestLogType log_type;
;;   guint n_strings;
;;   gchar **strings; /* NULL terminated */
;;   guint n_nums;
;;   long double *nums;
;; } GTestLogMsg;
(define GTestLogMsg-desc
  (bs:struct
    (list `(log_type ,int)
          `(n_strings ,unsigned-int)
          `(strings ,(bs:pointer (bs:pointer int)))
          `(n_nums ,unsigned-int)
          `(nums ,(bs:pointer #f)))))
(export GTestLogMsg-desc)
(define-fh-compound-type/p GTestLogMsg GTestLogMsg-desc)

;; typedef struct {
;;   /*< private >*/
;;   GString *data;
;;   GSList *msgs;
;; } GTestLogBuffer;
(define GTestLogBuffer-desc
  (bs:struct
    (list `(data ,(bs:pointer (delay GString*-desc)))
          `(msgs ,(bs:pointer (delay GSList*-desc))))))
(export GTestLogBuffer-desc)
(define-fh-compound-type/p GTestLogBuffer GTestLogBuffer-desc)

;; extern const char *g_test_log_type_name(GTestLogType log_type);
(define g_test_log_type_name
  (let ((~f #f))
    (lambda (log_type)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_test_log_type_name"
            '*
            (list ffi:int))))
      (let ((~log_type (unwrap~fixed log_type)))
        (~f ~log_type)))))
(export g_test_log_type_name)

;; extern GTestLogBuffer *g_test_log_buffer_new(void);
(define g_test_log_buffer_new
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_test_log_buffer_new" '* (list))))
      (let () (wrap-GTestLogBuffer* (~f))))))
(export g_test_log_buffer_new)

;; extern void g_test_log_buffer_free(GTestLogBuffer *tbuffer);
(define g_test_log_buffer_free
  (let ((~f #f))
    (lambda (tbuffer)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_test_log_buffer_free"
            ffi:void
            (list '*))))
      (let ((~tbuffer (unwrap-GTestLogBuffer* tbuffer)))
        (~f ~tbuffer)))))
(export g_test_log_buffer_free)

;; extern void g_test_log_buffer_push(GTestLogBuffer *tbuffer, guint n_bytes, 
;;     const guint8 *bytes);
(define g_test_log_buffer_push
  (let ((~f #f))
    (lambda (tbuffer n_bytes bytes)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_test_log_buffer_push"
            ffi:void
            (list '* ffi:unsigned-int '*))))
      (let ((~tbuffer (unwrap-GTestLogBuffer* tbuffer))
            (~n_bytes (unwrap~fixed n_bytes))
            (~bytes (unwrap~pointer bytes)))
        (~f ~tbuffer ~n_bytes ~bytes)))))
(export g_test_log_buffer_push)

;; extern GTestLogMsg *g_test_log_buffer_pop(GTestLogBuffer *tbuffer);
(define g_test_log_buffer_pop
  (let ((~f #f))
    (lambda (tbuffer)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_test_log_buffer_pop"
            '*
            (list '*))))
      (let ((~tbuffer (unwrap-GTestLogBuffer* tbuffer)))
        (wrap-GTestLogMsg* (~f ~tbuffer))))))
(export g_test_log_buffer_pop)

;; extern void g_test_log_msg_free(GTestLogMsg *tmsg);
(define g_test_log_msg_free
  (let ((~f #f))
    (lambda (tmsg)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_test_log_msg_free"
            ffi:void
            (list '*))))
      (let ((~tmsg (unwrap-GTestLogMsg* tmsg)))
        (~f ~tmsg)))))
(export g_test_log_msg_free)

;; typedef gboolean (*GTestLogFatalFunc)(const gchar *log_domain, 
;;     GLogLevelFlags log_level, const gchar *message, gpointer user_data);
(define-fh-function/p GTestLogFatalFunc
  ffi:int (list (quote *) ffi:int (quote *) (quote *)))

;; extern void g_test_log_set_fatal_handler(GTestLogFatalFunc log_func, 
;;     gpointer user_data);
(define g_test_log_set_fatal_handler
  (let ((~f #f))
    (lambda (log_func user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_test_log_set_fatal_handler"
            ffi:void
            (list '* '*))))
      (let ((~log_func
              ((make-ftn-arg-unwrapper
                 ffi:int
                 (list '* ffi:int '* '*))
               log_func))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~log_func ~user_data)))))
(export g_test_log_set_fatal_handler)

;; extern void g_test_expect_message(const gchar *log_domain, GLogLevelFlags 
;;     log_level, const gchar *pattern);
(define g_test_expect_message
  (let ((~f #f))
    (lambda (log_domain log_level pattern)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_test_expect_message"
            ffi:void
            (list '* ffi:int '*))))
      (let ((~log_domain (unwrap~pointer log_domain))
            (~log_level (unwrap~fixed log_level))
            (~pattern (unwrap~pointer pattern)))
        (~f ~log_domain ~log_level ~pattern)))))
(export g_test_expect_message)

;; extern void g_test_assert_expected_messages_internal(const char *domain, 
;;     const char *file, int line, const char *func);
(define g_test_assert_expected_messages_internal
  (let ((~f #f))
    (lambda (domain file line func)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_test_assert_expected_messages_internal"
            ffi:void
            (list '* '* ffi:int '*))))
      (let ((~domain (unwrap~pointer domain))
            (~file (unwrap~pointer file))
            (~line (unwrap~fixed line))
            (~func (unwrap~pointer func)))
        (~f ~domain ~file ~line ~func)))))
(export g_test_assert_expected_messages_internal)

;; typedef enum {
;;   G_TEST_DIST,
;;   G_TEST_BUILT,
;; } GTestFileType;
(define-fh-enum GTestFileType
  '((G_TEST_DIST . 0) (G_TEST_BUILT . 1))
  )

;; extern gchar *g_test_build_filename(GTestFileType file_type, const gchar *
;;     first_path, ...);
;; ... failed.

;; extern const gchar *g_test_get_dir(GTestFileType file_type);
(define g_test_get_dir
  (let ((~f #f))
    (lambda (file_type)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_test_get_dir" '* (list ffi:int))))
      (let ((~file_type (unwrap~fixed file_type)))
        (~f ~file_type)))))
(export g_test_get_dir)

;; extern const gchar *g_test_get_filename(GTestFileType file_type, const gchar
;;      *first_path, ...);
;; ... failed.

;; typedef struct _GThreadPool GThreadPool;
(define GThreadPool-desc void)
(define GThreadPool*-desc (bs:pointer (delay GThreadPool-desc)))
(export GThreadPool*-desc)
(define-fh-pointer-type GThreadPool* GThreadPool*-desc)

;; struct _GThreadPool {
;;   GFunc func;
;;   gpointer user_data;
;;   gboolean exclusive;
;; };
(define struct-_GThreadPool-desc
  (bs:struct
    (list `(func ,(bs:pointer void))
          `(user_data ,gpointer-desc)
          `(exclusive ,int))))
(export struct-_GThreadPool-desc)
(define-fh-compound-type/p struct-_GThreadPool struct-_GThreadPool-desc)
(set! GThreadPool-desc struct-_GThreadPool-desc)
(define-fh-compound-type GThreadPool GThreadPool-desc)

;; extern GThreadPool *g_thread_pool_new(GFunc func, gpointer user_data, gint 
;;     max_threads, gboolean exclusive, GError **error);
(define g_thread_pool_new
  (let ((~f #f))
    (lambda (func user_data max_threads exclusive error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_thread_pool_new"
            '*
            (list '* '* ffi:int ffi:int '*))))
      (let ((~func ((make-ftn-arg-unwrapper ffi:void (list '* '*))
                    func))
            (~user_data (unwrap-gpointer user_data))
            (~max_threads (unwrap~fixed max_threads))
            (~exclusive (unwrap~fixed exclusive))
            (~error (unwrap~pointer error)))
        (wrap-GThreadPool*
          (~f ~func
              ~user_data
              ~max_threads
              ~exclusive
              ~error))))))
(export g_thread_pool_new)

;; extern void g_thread_pool_free(GThreadPool *pool, gboolean immediate, 
;;     gboolean wait_);
(define g_thread_pool_free
  (let ((~f #f))
    (lambda (pool immediate wait_)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_thread_pool_free"
            ffi:void
            (list '* ffi:int ffi:int))))
      (let ((~pool (unwrap-GThreadPool* pool))
            (~immediate (unwrap~fixed immediate))
            (~wait_ (unwrap~fixed wait_)))
        (~f ~pool ~immediate ~wait_)))))
(export g_thread_pool_free)

;; extern gboolean g_thread_pool_push(GThreadPool *pool, gpointer data, GError 
;;     **error);
(define g_thread_pool_push
  (let ((~f #f))
    (lambda (pool data error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_thread_pool_push"
            ffi:int
            (list '* '* '*))))
      (let ((~pool (unwrap-GThreadPool* pool))
            (~data (unwrap-gpointer data))
            (~error (unwrap~pointer error)))
        (~f ~pool ~data ~error)))))
(export g_thread_pool_push)

;; extern guint g_thread_pool_unprocessed(GThreadPool *pool);
(define g_thread_pool_unprocessed
  (let ((~f #f))
    (lambda (pool)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_thread_pool_unprocessed"
            ffi:unsigned-int
            (list '*))))
      (let ((~pool (unwrap-GThreadPool* pool)))
        (~f ~pool)))))
(export g_thread_pool_unprocessed)

;; extern void g_thread_pool_set_sort_function(GThreadPool *pool, 
;;     GCompareDataFunc func, gpointer user_data);
(define g_thread_pool_set_sort_function
  (let ((~f #f))
    (lambda (pool func user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_thread_pool_set_sort_function"
            ffi:void
            (list '* '* '*))))
      (let ((~pool (unwrap-GThreadPool* pool))
            (~func ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
                    func))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~pool ~func ~user_data)))))
(export g_thread_pool_set_sort_function)

;; extern gboolean g_thread_pool_move_to_front(GThreadPool *pool, gpointer data
;;     );
(define g_thread_pool_move_to_front
  (let ((~f #f))
    (lambda (pool data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_thread_pool_move_to_front"
            ffi:int
            (list '* '*))))
      (let ((~pool (unwrap-GThreadPool* pool))
            (~data (unwrap-gpointer data)))
        (~f ~pool ~data)))))
(export g_thread_pool_move_to_front)

;; extern gboolean g_thread_pool_set_max_threads(GThreadPool *pool, gint 
;;     max_threads, GError **error);
(define g_thread_pool_set_max_threads
  (let ((~f #f))
    (lambda (pool max_threads error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_thread_pool_set_max_threads"
            ffi:int
            (list '* ffi:int '*))))
      (let ((~pool (unwrap-GThreadPool* pool))
            (~max_threads (unwrap~fixed max_threads))
            (~error (unwrap~pointer error)))
        (~f ~pool ~max_threads ~error)))))
(export g_thread_pool_set_max_threads)

;; extern gint g_thread_pool_get_max_threads(GThreadPool *pool);
(define g_thread_pool_get_max_threads
  (let ((~f #f))
    (lambda (pool)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_thread_pool_get_max_threads"
            ffi:int
            (list '*))))
      (let ((~pool (unwrap-GThreadPool* pool)))
        (~f ~pool)))))
(export g_thread_pool_get_max_threads)

;; extern guint g_thread_pool_get_num_threads(GThreadPool *pool);
(define g_thread_pool_get_num_threads
  (let ((~f #f))
    (lambda (pool)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_thread_pool_get_num_threads"
            ffi:unsigned-int
            (list '*))))
      (let ((~pool (unwrap-GThreadPool* pool)))
        (~f ~pool)))))
(export g_thread_pool_get_num_threads)

;; extern void g_thread_pool_set_max_unused_threads(gint max_threads);
(define g_thread_pool_set_max_unused_threads
  (let ((~f #f))
    (lambda (max_threads)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_thread_pool_set_max_unused_threads"
            ffi:void
            (list ffi:int))))
      (let ((~max_threads (unwrap~fixed max_threads)))
        (~f ~max_threads)))))
(export g_thread_pool_set_max_unused_threads)

;; extern gint g_thread_pool_get_max_unused_threads(void);
(define g_thread_pool_get_max_unused_threads
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_thread_pool_get_max_unused_threads"
            ffi:int
            (list))))
      (let () (~f)))))
(export g_thread_pool_get_max_unused_threads)

;; extern guint g_thread_pool_get_num_unused_threads(void);
(define g_thread_pool_get_num_unused_threads
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_thread_pool_get_num_unused_threads"
            ffi:unsigned-int
            (list))))
      (let () (~f)))))
(export g_thread_pool_get_num_unused_threads)

;; extern void g_thread_pool_stop_unused_threads(void);
(define g_thread_pool_stop_unused_threads
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_thread_pool_stop_unused_threads"
            ffi:void
            (list))))
      (let () (~f)))))
(export g_thread_pool_stop_unused_threads)

;; extern void g_thread_pool_set_max_idle_time(guint interval);
(define g_thread_pool_set_max_idle_time
  (let ((~f #f))
    (lambda (interval)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_thread_pool_set_max_idle_time"
            ffi:void
            (list ffi:unsigned-int))))
      (let ((~interval (unwrap~fixed interval)))
        (~f ~interval)))))
(export g_thread_pool_set_max_idle_time)

;; extern guint g_thread_pool_get_max_idle_time(void);
(define g_thread_pool_get_max_idle_time
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_thread_pool_get_max_idle_time"
            ffi:unsigned-int
            (list))))
      (let () (~f)))))
(export g_thread_pool_get_max_idle_time)

;; typedef struct _GTimer GTimer;
(define GTimer-desc void)
(define GTimer*-desc (bs:pointer GTimer-desc))
(export GTimer*-desc)
(define-fh-pointer-type GTimer* GTimer*-desc)

;; extern GTimer *g_timer_new(void);
(define g_timer_new
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f (fh-link-proc "g_timer_new" '* (list))))
      (let () (wrap-GTimer* (~f))))))
(export g_timer_new)

;; extern void g_timer_destroy(GTimer *timer);
(define g_timer_destroy
  (let ((~f #f))
    (lambda (timer)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_timer_destroy"
            ffi:void
            (list '*))))
      (let ((~timer (unwrap-GTimer* timer)))
        (~f ~timer)))))
(export g_timer_destroy)

;; extern void g_timer_start(GTimer *timer);
(define g_timer_start
  (let ((~f #f))
    (lambda (timer)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_timer_start" ffi:void (list '*))))
      (let ((~timer (unwrap-GTimer* timer)))
        (~f ~timer)))))
(export g_timer_start)

;; extern void g_timer_stop(GTimer *timer);
(define g_timer_stop
  (let ((~f #f))
    (lambda (timer)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_timer_stop" ffi:void (list '*))))
      (let ((~timer (unwrap-GTimer* timer)))
        (~f ~timer)))))
(export g_timer_stop)

;; extern void g_timer_reset(GTimer *timer);
(define g_timer_reset
  (let ((~f #f))
    (lambda (timer)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_timer_reset" ffi:void (list '*))))
      (let ((~timer (unwrap-GTimer* timer)))
        (~f ~timer)))))
(export g_timer_reset)

;; extern void g_timer_continue(GTimer *timer);
(define g_timer_continue
  (let ((~f #f))
    (lambda (timer)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_timer_continue"
            ffi:void
            (list '*))))
      (let ((~timer (unwrap-GTimer* timer)))
        (~f ~timer)))))
(export g_timer_continue)

;; extern gdouble g_timer_elapsed(GTimer *timer, gulong *microseconds);
(define g_timer_elapsed
  (let ((~f #f))
    (lambda (timer microseconds)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_timer_elapsed"
            ffi:double
            (list '* '*))))
      (let ((~timer (unwrap-GTimer* timer))
            (~microseconds (unwrap~pointer microseconds)))
        (wrap-gdouble (~f ~timer ~microseconds))))))
(export g_timer_elapsed)

;; extern void g_usleep(gulong microseconds);
(define g_usleep
  (let ((~f #f))
    (lambda (microseconds)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_usleep"
            ffi:void
            (list ffi:unsigned-long))))
      (let ((~microseconds (unwrap~fixed microseconds)))
        (~f ~microseconds)))))
(export g_usleep)

;; extern void g_time_val_add(GTimeVal *time_, glong microseconds);
(define g_time_val_add
  (let ((~f #f))
    (lambda (time_ microseconds)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_time_val_add"
            ffi:void
            (list '* ffi:long))))
      (let ((~time_ (unwrap-GTimeVal* time_))
            (~microseconds (unwrap~fixed microseconds)))
        (~f ~time_ ~microseconds)))))
(export g_time_val_add)

;; extern gboolean g_time_val_from_iso8601(const gchar *iso_date, GTimeVal *
;;     time_);
(define g_time_val_from_iso8601
  (let ((~f #f))
    (lambda (iso_date time_)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_time_val_from_iso8601"
            ffi:int
            (list '* '*))))
      (let ((~iso_date (unwrap~pointer iso_date))
            (~time_ (unwrap-GTimeVal* time_)))
        (~f ~iso_date ~time_)))))
(export g_time_val_from_iso8601)

;; extern gchar *g_time_val_to_iso8601(GTimeVal *time_);
(define g_time_val_to_iso8601
  (let ((~f #f))
    (lambda (time_)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_time_val_to_iso8601"
            '*
            (list '*))))
      (let ((~time_ (unwrap-GTimeVal* time_)))
        (~f ~time_)))))
(export g_time_val_to_iso8601)

;; typedef struct _GTrashStack GTrashStack;
(define GTrashStack-desc void)
(define GTrashStack*-desc (bs:pointer (delay GTrashStack-desc)))
(export GTrashStack*-desc)
(define-fh-pointer-type GTrashStack* GTrashStack*-desc)

;; struct _GTrashStack {
;;   GTrashStack *next;
;; };
(define struct-_GTrashStack-desc
  (bs:struct
    (list `(next ,(bs:pointer (delay GTrashStack*-desc))))))
(export struct-_GTrashStack-desc)
(define-fh-compound-type/p struct-_GTrashStack struct-_GTrashStack-desc)
(set! GTrashStack-desc struct-_GTrashStack-desc)
(define-fh-compound-type GTrashStack GTrashStack-desc)

;; extern void g_trash_stack_push(GTrashStack **stack_p, gpointer data_p);
(define g_trash_stack_push
  (let ((~f #f))
    (lambda (stack_p data_p)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_trash_stack_push"
            ffi:void
            (list '* '*))))
      (let ((~stack_p (unwrap~pointer stack_p))
            (~data_p (unwrap-gpointer data_p)))
        (~f ~stack_p ~data_p)))))
(export g_trash_stack_push)

;; extern gpointer g_trash_stack_pop(GTrashStack **stack_p);
(define g_trash_stack_pop
  (let ((~f #f))
    (lambda (stack_p)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_trash_stack_pop" '* (list '*))))
      (let ((~stack_p (unwrap~pointer stack_p)))
        (wrap-gpointer (~f ~stack_p))))))
(export g_trash_stack_pop)

;; extern gpointer g_trash_stack_peek(GTrashStack **stack_p);
(define g_trash_stack_peek
  (let ((~f #f))
    (lambda (stack_p)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_trash_stack_peek" '* (list '*))))
      (let ((~stack_p (unwrap~pointer stack_p)))
        (wrap-gpointer (~f ~stack_p))))))
(export g_trash_stack_peek)

;; extern guint g_trash_stack_height(GTrashStack **stack_p);
(define g_trash_stack_height
  (let ((~f #f))
    (lambda (stack_p)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_trash_stack_height"
            ffi:unsigned-int
            (list '*))))
      (let ((~stack_p (unwrap~pointer stack_p)))
        (~f ~stack_p)))))
(export g_trash_stack_height)

;; typedef struct _GTree GTree;
(define GTree-desc void)
(define GTree*-desc (bs:pointer GTree-desc))
(export GTree*-desc)
(define-fh-pointer-type GTree* GTree*-desc)

;; typedef gboolean (*GTraverseFunc)(gpointer key, gpointer value, gpointer 
;;     data);
(define-fh-function/p GTraverseFunc
  ffi:int (list (quote *) (quote *) (quote *)))

;; extern GTree *g_tree_new(GCompareFunc key_compare_func);
(define g_tree_new
  (let ((~f #f))
    (lambda (key_compare_func)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_tree_new" '* (list '*))))
      (let ((~key_compare_func
              ((make-ftn-arg-unwrapper ffi:int (list '* '*))
               key_compare_func)))
        (wrap-GTree* (~f ~key_compare_func))))))
(export g_tree_new)

;; extern GTree *g_tree_new_with_data(GCompareDataFunc key_compare_func, 
;;     gpointer key_compare_data);
(define g_tree_new_with_data
  (let ((~f #f))
    (lambda (key_compare_func key_compare_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_tree_new_with_data"
            '*
            (list '* '*))))
      (let ((~key_compare_func
              ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
               key_compare_func))
            (~key_compare_data
              (unwrap-gpointer key_compare_data)))
        (wrap-GTree*
          (~f ~key_compare_func ~key_compare_data))))))
(export g_tree_new_with_data)

;; extern GTree *g_tree_new_full(GCompareDataFunc key_compare_func, gpointer 
;;     key_compare_data, GDestroyNotify key_destroy_func, GDestroyNotify 
;;     value_destroy_func);
(define g_tree_new_full
  (let ((~f #f))
    (lambda (key_compare_func
             key_compare_data
             key_destroy_func
             value_destroy_func)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_tree_new_full"
            '*
            (list '* '* '* '*))))
      (let ((~key_compare_func
              ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
               key_compare_func))
            (~key_compare_data
              (unwrap-gpointer key_compare_data))
            (~key_destroy_func
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               key_destroy_func))
            (~value_destroy_func
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               value_destroy_func)))
        (wrap-GTree*
          (~f ~key_compare_func
              ~key_compare_data
              ~key_destroy_func
              ~value_destroy_func))))))
(export g_tree_new_full)

;; extern GTree *g_tree_ref(GTree *tree);
(define g_tree_ref
  (let ((~f #f))
    (lambda (tree)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_tree_ref" '* (list '*))))
      (let ((~tree (unwrap-GTree* tree)))
        (wrap-GTree* (~f ~tree))))))
(export g_tree_ref)

;; extern void g_tree_unref(GTree *tree);
(define g_tree_unref
  (let ((~f #f))
    (lambda (tree)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_tree_unref" ffi:void (list '*))))
      (let ((~tree (unwrap-GTree* tree))) (~f ~tree)))))
(export g_tree_unref)

;; extern void g_tree_destroy(GTree *tree);
(define g_tree_destroy
  (let ((~f #f))
    (lambda (tree)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_tree_destroy"
            ffi:void
            (list '*))))
      (let ((~tree (unwrap-GTree* tree))) (~f ~tree)))))
(export g_tree_destroy)

;; extern void g_tree_insert(GTree *tree, gpointer key, gpointer value);
(define g_tree_insert
  (let ((~f #f))
    (lambda (tree key value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_tree_insert"
            ffi:void
            (list '* '* '*))))
      (let ((~tree (unwrap-GTree* tree))
            (~key (unwrap-gpointer key))
            (~value (unwrap-gpointer value)))
        (~f ~tree ~key ~value)))))
(export g_tree_insert)

;; extern void g_tree_replace(GTree *tree, gpointer key, gpointer value);
(define g_tree_replace
  (let ((~f #f))
    (lambda (tree key value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_tree_replace"
            ffi:void
            (list '* '* '*))))
      (let ((~tree (unwrap-GTree* tree))
            (~key (unwrap-gpointer key))
            (~value (unwrap-gpointer value)))
        (~f ~tree ~key ~value)))))
(export g_tree_replace)

;; extern gboolean g_tree_remove(GTree *tree, gconstpointer key);
(define g_tree_remove
  (let ((~f #f))
    (lambda (tree key)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_tree_remove"
            ffi:int
            (list '* '*))))
      (let ((~tree (unwrap-GTree* tree))
            (~key (unwrap-gconstpointer key)))
        (~f ~tree ~key)))))
(export g_tree_remove)

;; extern gboolean g_tree_steal(GTree *tree, gconstpointer key);
(define g_tree_steal
  (let ((~f #f))
    (lambda (tree key)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_tree_steal"
            ffi:int
            (list '* '*))))
      (let ((~tree (unwrap-GTree* tree))
            (~key (unwrap-gconstpointer key)))
        (~f ~tree ~key)))))
(export g_tree_steal)

;; extern gpointer g_tree_lookup(GTree *tree, gconstpointer key);
(define g_tree_lookup
  (let ((~f #f))
    (lambda (tree key)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_tree_lookup" '* (list '* '*))))
      (let ((~tree (unwrap-GTree* tree))
            (~key (unwrap-gconstpointer key)))
        (wrap-gpointer (~f ~tree ~key))))))
(export g_tree_lookup)

;; extern gboolean g_tree_lookup_extended(GTree *tree, gconstpointer lookup_key
;;     , gpointer *orig_key, gpointer *value);
(define g_tree_lookup_extended
  (let ((~f #f))
    (lambda (tree lookup_key orig_key value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_tree_lookup_extended"
            ffi:int
            (list '* '* '* '*))))
      (let ((~tree (unwrap-GTree* tree))
            (~lookup_key (unwrap-gconstpointer lookup_key))
            (~orig_key (unwrap-gpointer* orig_key))
            (~value (unwrap-gpointer* value)))
        (~f ~tree ~lookup_key ~orig_key ~value)))))
(export g_tree_lookup_extended)

;; extern void g_tree_foreach(GTree *tree, GTraverseFunc func, gpointer 
;;     user_data);
(define g_tree_foreach
  (let ((~f #f))
    (lambda (tree func user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_tree_foreach"
            ffi:void
            (list '* '* '*))))
      (let ((~tree (unwrap-GTree* tree))
            (~func ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
                    func))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~tree ~func ~user_data)))))
(export g_tree_foreach)

;; extern void g_tree_traverse(GTree *tree, GTraverseFunc traverse_func, 
;;     GTraverseType traverse_type, gpointer user_data);
(define g_tree_traverse
  (let ((~f #f))
    (lambda (tree traverse_func traverse_type user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_tree_traverse"
            ffi:void
            (list '* '* ffi:int '*))))
      (let ((~tree (unwrap-GTree* tree))
            (~traverse_func
              ((make-ftn-arg-unwrapper ffi:int (list '* '* '*))
               traverse_func))
            (~traverse_type (unwrap~fixed traverse_type))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~tree
            ~traverse_func
            ~traverse_type
            ~user_data)))))
(export g_tree_traverse)

;; extern gpointer g_tree_search(GTree *tree, GCompareFunc search_func, 
;;     gconstpointer user_data);
(define g_tree_search
  (let ((~f #f))
    (lambda (tree search_func user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_tree_search" '* (list '* '* '*))))
      (let ((~tree (unwrap-GTree* tree))
            (~search_func
              ((make-ftn-arg-unwrapper ffi:int (list '* '*))
               search_func))
            (~user_data (unwrap-gconstpointer user_data)))
        (wrap-gpointer
          (~f ~tree ~search_func ~user_data))))))
(export g_tree_search)

;; extern gint g_tree_height(GTree *tree);
(define g_tree_height
  (let ((~f #f))
    (lambda (tree)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_tree_height" ffi:int (list '*))))
      (let ((~tree (unwrap-GTree* tree))) (~f ~tree)))))
(export g_tree_height)

;; extern gint g_tree_nnodes(GTree *tree);
(define g_tree_nnodes
  (let ((~f #f))
    (lambda (tree)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_tree_nnodes" ffi:int (list '*))))
      (let ((~tree (unwrap-GTree* tree))) (~f ~tree)))))
(export g_tree_nnodes)

;; extern char *g_uri_unescape_string(const char *escaped_string, const char *
;;     illegal_characters);
(define g_uri_unescape_string
  (let ((~f #f))
    (lambda (escaped_string illegal_characters)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_uri_unescape_string"
            '*
            (list '* '*))))
      (let ((~escaped_string (unwrap~pointer escaped_string))
            (~illegal_characters
              (unwrap~pointer illegal_characters)))
        (~f ~escaped_string ~illegal_characters)))))
(export g_uri_unescape_string)

;; extern char *g_uri_unescape_segment(const char *escaped_string, const char *
;;     escaped_string_end, const char *illegal_characters);
(define g_uri_unescape_segment
  (let ((~f #f))
    (lambda (escaped_string
             escaped_string_end
             illegal_characters)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_uri_unescape_segment"
            '*
            (list '* '* '*))))
      (let ((~escaped_string (unwrap~pointer escaped_string))
            (~escaped_string_end
              (unwrap~pointer escaped_string_end))
            (~illegal_characters
              (unwrap~pointer illegal_characters)))
        (~f ~escaped_string
            ~escaped_string_end
            ~illegal_characters)))))
(export g_uri_unescape_segment)

;; extern char *g_uri_parse_scheme(const char *uri);
(define g_uri_parse_scheme
  (let ((~f #f))
    (lambda (uri)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_uri_parse_scheme" '* (list '*))))
      (let ((~uri (unwrap~pointer uri))) (~f ~uri)))))
(export g_uri_parse_scheme)

;; extern char *g_uri_escape_string(const char *unescaped, const char *
;;     reserved_chars_allowed, gboolean allow_utf8);
(define g_uri_escape_string
  (let ((~f #f))
    (lambda (unescaped reserved_chars_allowed allow_utf8)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_uri_escape_string"
            '*
            (list '* '* ffi:int))))
      (let ((~unescaped (unwrap~pointer unescaped))
            (~reserved_chars_allowed
              (unwrap~pointer reserved_chars_allowed))
            (~allow_utf8 (unwrap~fixed allow_utf8)))
        (~f ~unescaped
            ~reserved_chars_allowed
            ~allow_utf8)))))
(export g_uri_escape_string)

;; extern gboolean g_uuid_string_is_valid(const gchar *str);
(define g_uuid_string_is_valid
  (let ((~f #f))
    (lambda (str)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_uuid_string_is_valid"
            ffi:int
            (list '*))))
      (let ((~str (unwrap~pointer str))) (~f ~str)))))
(export g_uuid_string_is_valid)

;; extern gchar *g_uuid_string_random(void);
(define g_uuid_string_random
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_uuid_string_random" '* (list))))
      (let () (~f)))))
(export g_uuid_string_random)

;; extern const guint glib_major_version;
(define glib_major_version
  (let* ((addr (dynamic-pointer
                 "glib_major_version"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer unsigned-int))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export glib_major_version)

;; extern const guint glib_minor_version;
(define glib_minor_version
  (let* ((addr (dynamic-pointer
                 "glib_minor_version"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer unsigned-int))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export glib_minor_version)

;; extern const guint glib_micro_version;
(define glib_micro_version
  (let* ((addr (dynamic-pointer
                 "glib_micro_version"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer unsigned-int))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export glib_micro_version)

;; extern const guint glib_interface_age;
(define glib_interface_age
  (let* ((addr (dynamic-pointer
                 "glib_interface_age"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer unsigned-int))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export glib_interface_age)

;; extern const guint glib_binary_age;
(define glib_binary_age
  (let* ((addr (dynamic-pointer
                 "glib_binary_age"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer unsigned-int))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export glib_binary_age)

;; extern const gchar *glib_check_version(guint required_major, guint 
;;     required_minor, guint required_micro);
(define glib_check_version
  (let ((~f #f))
    (lambda (required_major required_minor required_micro)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "glib_check_version"
            '*
            (list ffi:unsigned-int
                  ffi:unsigned-int
                  ffi:unsigned-int))))
      (let ((~required_major (unwrap~fixed required_major))
            (~required_minor (unwrap~fixed required_minor))
            (~required_micro (unwrap~fixed required_micro)))
        (~f ~required_major
            ~required_minor
            ~required_micro)))))
(export glib_check_version)

;; typedef struct _GAllocator GAllocator;
(define GAllocator-desc void)
(define GAllocator*-desc (bs:pointer GAllocator-desc))
(export GAllocator*-desc)
(define-fh-pointer-type GAllocator* GAllocator*-desc)

;; typedef struct _GMemChunk GMemChunk;
(define GMemChunk-desc void)
(define GMemChunk*-desc (bs:pointer GMemChunk-desc))
(export GMemChunk*-desc)
(define-fh-pointer-type GMemChunk* GMemChunk*-desc)

;; extern GMemChunk *g_mem_chunk_new(const gchar *name, gint atom_size, gsize 
;;     area_size, gint type);
(define g_mem_chunk_new
  (let ((~f #f))
    (lambda (name atom_size area_size type)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_mem_chunk_new"
            '*
            (list '* ffi:int ffi:unsigned-long ffi:int))))
      (let ((~name (unwrap~pointer name))
            (~atom_size (unwrap~fixed atom_size))
            (~area_size (unwrap~fixed area_size))
            (~type (unwrap~fixed type)))
        (wrap-GMemChunk*
          (~f ~name ~atom_size ~area_size ~type))))))
(export g_mem_chunk_new)

;; extern void g_mem_chunk_destroy(GMemChunk *mem_chunk);
(define g_mem_chunk_destroy
  (let ((~f #f))
    (lambda (mem_chunk)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_mem_chunk_destroy"
            ffi:void
            (list '*))))
      (let ((~mem_chunk (unwrap-GMemChunk* mem_chunk)))
        (~f ~mem_chunk)))))
(export g_mem_chunk_destroy)

;; extern gpointer g_mem_chunk_alloc(GMemChunk *mem_chunk);
(define g_mem_chunk_alloc
  (let ((~f #f))
    (lambda (mem_chunk)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_mem_chunk_alloc" '* (list '*))))
      (let ((~mem_chunk (unwrap-GMemChunk* mem_chunk)))
        (wrap-gpointer (~f ~mem_chunk))))))
(export g_mem_chunk_alloc)

;; extern gpointer g_mem_chunk_alloc0(GMemChunk *mem_chunk);
(define g_mem_chunk_alloc0
  (let ((~f #f))
    (lambda (mem_chunk)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_mem_chunk_alloc0" '* (list '*))))
      (let ((~mem_chunk (unwrap-GMemChunk* mem_chunk)))
        (wrap-gpointer (~f ~mem_chunk))))))
(export g_mem_chunk_alloc0)

;; extern void g_mem_chunk_free(GMemChunk *mem_chunk, gpointer mem);
(define g_mem_chunk_free
  (let ((~f #f))
    (lambda (mem_chunk mem)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_mem_chunk_free"
            ffi:void
            (list '* '*))))
      (let ((~mem_chunk (unwrap-GMemChunk* mem_chunk))
            (~mem (unwrap-gpointer mem)))
        (~f ~mem_chunk ~mem)))))
(export g_mem_chunk_free)

;; extern void g_mem_chunk_clean(GMemChunk *mem_chunk);
(define g_mem_chunk_clean
  (let ((~f #f))
    (lambda (mem_chunk)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_mem_chunk_clean"
            ffi:void
            (list '*))))
      (let ((~mem_chunk (unwrap-GMemChunk* mem_chunk)))
        (~f ~mem_chunk)))))
(export g_mem_chunk_clean)

;; extern void g_mem_chunk_reset(GMemChunk *mem_chunk);
(define g_mem_chunk_reset
  (let ((~f #f))
    (lambda (mem_chunk)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_mem_chunk_reset"
            ffi:void
            (list '*))))
      (let ((~mem_chunk (unwrap-GMemChunk* mem_chunk)))
        (~f ~mem_chunk)))))
(export g_mem_chunk_reset)

;; extern void g_mem_chunk_print(GMemChunk *mem_chunk);
(define g_mem_chunk_print
  (let ((~f #f))
    (lambda (mem_chunk)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_mem_chunk_print"
            ffi:void
            (list '*))))
      (let ((~mem_chunk (unwrap-GMemChunk* mem_chunk)))
        (~f ~mem_chunk)))))
(export g_mem_chunk_print)

;; extern void g_mem_chunk_info(void);
(define g_mem_chunk_info
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_mem_chunk_info" ffi:void (list))))
      (let () (~f)))))
(export g_mem_chunk_info)

;; extern void g_blow_chunks(void);
(define g_blow_chunks
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_blow_chunks" ffi:void (list))))
      (let () (~f)))))
(export g_blow_chunks)

;; extern GAllocator *g_allocator_new(const gchar *name, guint n_preallocs);
(define g_allocator_new
  (let ((~f #f))
    (lambda (name n_preallocs)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_allocator_new"
            '*
            (list '* ffi:unsigned-int))))
      (let ((~name (unwrap~pointer name))
            (~n_preallocs (unwrap~fixed n_preallocs)))
        (wrap-GAllocator* (~f ~name ~n_preallocs))))))
(export g_allocator_new)

;; extern void g_allocator_free(GAllocator *allocator);
(define g_allocator_free
  (let ((~f #f))
    (lambda (allocator)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_allocator_free"
            ffi:void
            (list '*))))
      (let ((~allocator (unwrap-GAllocator* allocator)))
        (~f ~allocator)))))
(export g_allocator_free)

;; extern void g_list_push_allocator(GAllocator *allocator);
(define g_list_push_allocator
  (let ((~f #f))
    (lambda (allocator)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_list_push_allocator"
            ffi:void
            (list '*))))
      (let ((~allocator (unwrap-GAllocator* allocator)))
        (~f ~allocator)))))
(export g_list_push_allocator)

;; extern void g_list_pop_allocator(void);
(define g_list_pop_allocator
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_list_pop_allocator"
            ffi:void
            (list))))
      (let () (~f)))))
(export g_list_pop_allocator)

;; extern void g_slist_push_allocator(GAllocator *allocator);
(define g_slist_push_allocator
  (let ((~f #f))
    (lambda (allocator)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_slist_push_allocator"
            ffi:void
            (list '*))))
      (let ((~allocator (unwrap-GAllocator* allocator)))
        (~f ~allocator)))))
(export g_slist_push_allocator)

;; extern void g_slist_pop_allocator(void);
(define g_slist_pop_allocator
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_slist_pop_allocator"
            ffi:void
            (list))))
      (let () (~f)))))
(export g_slist_pop_allocator)

;; extern void g_node_push_allocator(GAllocator *allocator);
(define g_node_push_allocator
  (let ((~f #f))
    (lambda (allocator)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_node_push_allocator"
            ffi:void
            (list '*))))
      (let ((~allocator (unwrap-GAllocator* allocator)))
        (~f ~allocator)))))
(export g_node_push_allocator)

;; extern void g_node_pop_allocator(void);
(define g_node_pop_allocator
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_node_pop_allocator"
            ffi:void
            (list))))
      (let () (~f)))))
(export g_node_pop_allocator)

;; typedef struct _GCache GCache;
(define GCache-desc void)
(define GCache*-desc (bs:pointer GCache-desc))
(export GCache*-desc)
(define-fh-pointer-type GCache* GCache*-desc)

;; typedef gpointer (*GCacheNewFunc)(gpointer key);
(define-fh-function/p GCacheNewFunc
  (quote *) (list (quote *)))

;; typedef gpointer (*GCacheDupFunc)(gpointer value);
(define-fh-function/p GCacheDupFunc
  (quote *) (list (quote *)))

;; typedef void (*GCacheDestroyFunc)(gpointer value);
(define-fh-function/p GCacheDestroyFunc
  ffi:void (list (quote *)))

;; extern GCache *g_cache_new(GCacheNewFunc value_new_func, GCacheDestroyFunc 
;;     value_destroy_func, GCacheDupFunc key_dup_func, GCacheDestroyFunc 
;;     key_destroy_func, GHashFunc hash_key_func, GHashFunc hash_value_func, 
;;     GEqualFunc key_equal_func);
(define g_cache_new
  (let ((~f #f))
    (lambda (value_new_func
             value_destroy_func
             key_dup_func
             key_destroy_func
             hash_key_func
             hash_value_func
             key_equal_func)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_cache_new"
            '*
            (list '* '* '* '* '* '* '*))))
      (let ((~value_new_func
              ((make-ftn-arg-unwrapper '* (list '*))
               value_new_func))
            (~value_destroy_func
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               value_destroy_func))
            (~key_dup_func
              ((make-ftn-arg-unwrapper '* (list '*))
               key_dup_func))
            (~key_destroy_func
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               key_destroy_func))
            (~hash_key_func
              ((make-ftn-arg-unwrapper
                 ffi:unsigned-int
                 (list '*))
               hash_key_func))
            (~hash_value_func
              ((make-ftn-arg-unwrapper
                 ffi:unsigned-int
                 (list '*))
               hash_value_func))
            (~key_equal_func
              ((make-ftn-arg-unwrapper ffi:int (list '* '*))
               key_equal_func)))
        (wrap-GCache*
          (~f ~value_new_func
              ~value_destroy_func
              ~key_dup_func
              ~key_destroy_func
              ~hash_key_func
              ~hash_value_func
              ~key_equal_func))))))
(export g_cache_new)

;; extern void g_cache_destroy(GCache *cache);
(define g_cache_destroy
  (let ((~f #f))
    (lambda (cache)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_cache_destroy"
            ffi:void
            (list '*))))
      (let ((~cache (unwrap-GCache* cache)))
        (~f ~cache)))))
(export g_cache_destroy)

;; extern gpointer g_cache_insert(GCache *cache, gpointer key);
(define g_cache_insert
  (let ((~f #f))
    (lambda (cache key)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_cache_insert" '* (list '* '*))))
      (let ((~cache (unwrap-GCache* cache))
            (~key (unwrap-gpointer key)))
        (wrap-gpointer (~f ~cache ~key))))))
(export g_cache_insert)

;; extern void g_cache_remove(GCache *cache, gconstpointer value);
(define g_cache_remove
  (let ((~f #f))
    (lambda (cache value)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_cache_remove"
            ffi:void
            (list '* '*))))
      (let ((~cache (unwrap-GCache* cache))
            (~value (unwrap-gconstpointer value)))
        (~f ~cache ~value)))))
(export g_cache_remove)

;; extern void g_cache_key_foreach(GCache *cache, GHFunc func, gpointer 
;;     user_data);
(define g_cache_key_foreach
  (let ((~f #f))
    (lambda (cache func user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_cache_key_foreach"
            ffi:void
            (list '* '* '*))))
      (let ((~cache (unwrap-GCache* cache))
            (~func ((make-ftn-arg-unwrapper ffi:void (list '* '* '*))
                    func))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~cache ~func ~user_data)))))
(export g_cache_key_foreach)

;; extern void g_cache_value_foreach(GCache *cache, GHFunc func, gpointer 
;;     user_data);
(define g_cache_value_foreach
  (let ((~f #f))
    (lambda (cache func user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_cache_value_foreach"
            ffi:void
            (list '* '* '*))))
      (let ((~cache (unwrap-GCache* cache))
            (~func ((make-ftn-arg-unwrapper ffi:void (list '* '* '*))
                    func))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~cache ~func ~user_data)))))
(export g_cache_value_foreach)

;; typedef struct _GCompletion GCompletion;
(define GCompletion-desc void)
(define GCompletion*-desc (bs:pointer (delay GCompletion-desc)))
(export GCompletion*-desc)
(define-fh-pointer-type GCompletion* GCompletion*-desc)

;; typedef gchar *(*GCompletionFunc)(gpointer);
(define-fh-function/p
  GCompletionFunc
  '*
  (list ffi:void))

;; typedef gint (*GCompletionStrncmpFunc)(const gchar *s1, const gchar *s2, 
;;     gsize n);
(define-fh-function/p GCompletionStrncmpFunc
  ffi:int (list (quote *) (quote *) ffi:unsigned-long))

;; struct _GCompletion {
;;   GList *items;
;;   GCompletionFunc func;
;;   gchar *prefix;
;;   GList *cache;
;;   GCompletionStrncmpFunc strncmp_func;
;; };
(define struct-_GCompletion-desc
  (bs:struct
    (list `(items ,(bs:pointer (delay GList*-desc)))
          `(func ,(bs:pointer void))
          `(prefix ,(bs:pointer int))
          `(cache ,(bs:pointer (delay GList*-desc)))
          `(strncmp_func ,(bs:pointer void)))))
(export struct-_GCompletion-desc)
(define-fh-compound-type/p struct-_GCompletion struct-_GCompletion-desc)
(set! GCompletion-desc struct-_GCompletion-desc)
(define-fh-compound-type GCompletion GCompletion-desc)

;; extern GCompletion *g_completion_new(GCompletionFunc func);
(define g_completion_new
  (let ((~f #f))
    (lambda (func)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_completion_new" '* (list '*))))
      (let ((~func ((make-ftn-arg-unwrapper '* (list ffi:void))
                    func)))
        (wrap-GCompletion* (~f ~func))))))
(export g_completion_new)

;; extern void g_completion_add_items(GCompletion *cmp, GList *items);
(define g_completion_add_items
  (let ((~f #f))
    (lambda (cmp items)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_completion_add_items"
            ffi:void
            (list '* '*))))
      (let ((~cmp (unwrap-GCompletion* cmp))
            (~items (unwrap-GList* items)))
        (~f ~cmp ~items)))))
(export g_completion_add_items)

;; extern void g_completion_remove_items(GCompletion *cmp, GList *items);
(define g_completion_remove_items
  (let ((~f #f))
    (lambda (cmp items)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_completion_remove_items"
            ffi:void
            (list '* '*))))
      (let ((~cmp (unwrap-GCompletion* cmp))
            (~items (unwrap-GList* items)))
        (~f ~cmp ~items)))))
(export g_completion_remove_items)

;; extern void g_completion_clear_items(GCompletion *cmp);
(define g_completion_clear_items
  (let ((~f #f))
    (lambda (cmp)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_completion_clear_items"
            ffi:void
            (list '*))))
      (let ((~cmp (unwrap-GCompletion* cmp)))
        (~f ~cmp)))))
(export g_completion_clear_items)

;; extern GList *g_completion_complete(GCompletion *cmp, const gchar *prefix, 
;;     gchar **new_prefix);
(define g_completion_complete
  (let ((~f #f))
    (lambda (cmp prefix new_prefix)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_completion_complete"
            '*
            (list '* '* '*))))
      (let ((~cmp (unwrap-GCompletion* cmp))
            (~prefix (unwrap~pointer prefix))
            (~new_prefix (unwrap~pointer new_prefix)))
        (wrap-GList* (~f ~cmp ~prefix ~new_prefix))))))
(export g_completion_complete)

;; extern GList *g_completion_complete_utf8(GCompletion *cmp, const gchar *
;;     prefix, gchar **new_prefix);
(define g_completion_complete_utf8
  (let ((~f #f))
    (lambda (cmp prefix new_prefix)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_completion_complete_utf8"
            '*
            (list '* '* '*))))
      (let ((~cmp (unwrap-GCompletion* cmp))
            (~prefix (unwrap~pointer prefix))
            (~new_prefix (unwrap~pointer new_prefix)))
        (wrap-GList* (~f ~cmp ~prefix ~new_prefix))))))
(export g_completion_complete_utf8)

;; extern void g_completion_set_compare(GCompletion *cmp, 
;;     GCompletionStrncmpFunc strncmp_func);
(define g_completion_set_compare
  (let ((~f #f))
    (lambda (cmp strncmp_func)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_completion_set_compare"
            ffi:void
            (list '* '*))))
      (let ((~cmp (unwrap-GCompletion* cmp))
            (~strncmp_func
              ((make-ftn-arg-unwrapper
                 ffi:int
                 (list '* '* ffi:unsigned-long))
               strncmp_func)))
        (~f ~cmp ~strncmp_func)))))
(export g_completion_set_compare)

;; extern void g_completion_free(GCompletion *cmp);
(define g_completion_free
  (let ((~f #f))
    (lambda (cmp)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_completion_free"
            ffi:void
            (list '*))))
      (let ((~cmp (unwrap-GCompletion* cmp)))
        (~f ~cmp)))))
(export g_completion_free)

;; typedef struct _GRelation GRelation;
(define GRelation-desc void)
(define GRelation*-desc (bs:pointer GRelation-desc))
(export GRelation*-desc)
(define-fh-pointer-type GRelation* GRelation*-desc)

;; typedef struct _GTuples GTuples;
(define GTuples-desc void)
(define GTuples*-desc (bs:pointer (delay GTuples-desc)))
(export GTuples*-desc)
(define-fh-pointer-type GTuples* GTuples*-desc)

;; struct _GTuples {
;;   guint len;
;; };
(define struct-_GTuples-desc
  (bs:struct (list `(len ,unsigned-int))))
(export struct-_GTuples-desc)
(define-fh-compound-type/p struct-_GTuples struct-_GTuples-desc)
(set! GTuples-desc struct-_GTuples-desc)
(define-fh-compound-type GTuples GTuples-desc)

;; extern GRelation *g_relation_new(gint fields);
(define g_relation_new
  (let ((~f #f))
    (lambda (fields)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_relation_new" '* (list ffi:int))))
      (let ((~fields (unwrap~fixed fields)))
        (wrap-GRelation* (~f ~fields))))))
(export g_relation_new)

;; extern void g_relation_destroy(GRelation *relation);
(define g_relation_destroy
  (let ((~f #f))
    (lambda (relation)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_relation_destroy"
            ffi:void
            (list '*))))
      (let ((~relation (unwrap-GRelation* relation)))
        (~f ~relation)))))
(export g_relation_destroy)

;; extern void g_relation_index(GRelation *relation, gint field, GHashFunc 
;;     hash_func, GEqualFunc key_equal_func);
(define g_relation_index
  (let ((~f #f))
    (lambda (relation field hash_func key_equal_func)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_relation_index"
            ffi:void
            (list '* ffi:int '* '*))))
      (let ((~relation (unwrap-GRelation* relation))
            (~field (unwrap~fixed field))
            (~hash_func
              ((make-ftn-arg-unwrapper
                 ffi:unsigned-int
                 (list '*))
               hash_func))
            (~key_equal_func
              ((make-ftn-arg-unwrapper ffi:int (list '* '*))
               key_equal_func)))
        (~f ~relation ~field ~hash_func ~key_equal_func)))))
(export g_relation_index)

;; extern void g_relation_insert(GRelation *relation, ...);
;; ... failed.

;; extern gint g_relation_delete(GRelation *relation, gconstpointer key, gint 
;;     field);
(define g_relation_delete
  (let ((~f #f))
    (lambda (relation key field)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_relation_delete"
            ffi:int
            (list '* '* ffi:int))))
      (let ((~relation (unwrap-GRelation* relation))
            (~key (unwrap-gconstpointer key))
            (~field (unwrap~fixed field)))
        (~f ~relation ~key ~field)))))
(export g_relation_delete)

;; extern GTuples *g_relation_select(GRelation *relation, gconstpointer key, 
;;     gint field);
(define g_relation_select
  (let ((~f #f))
    (lambda (relation key field)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_relation_select"
            '*
            (list '* '* ffi:int))))
      (let ((~relation (unwrap-GRelation* relation))
            (~key (unwrap-gconstpointer key))
            (~field (unwrap~fixed field)))
        (wrap-GTuples* (~f ~relation ~key ~field))))))
(export g_relation_select)

;; extern gint g_relation_count(GRelation *relation, gconstpointer key, gint 
;;     field);
(define g_relation_count
  (let ((~f #f))
    (lambda (relation key field)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_relation_count"
            ffi:int
            (list '* '* ffi:int))))
      (let ((~relation (unwrap-GRelation* relation))
            (~key (unwrap-gconstpointer key))
            (~field (unwrap~fixed field)))
        (~f ~relation ~key ~field)))))
(export g_relation_count)

;; extern gboolean g_relation_exists(GRelation *relation, ...);
;; ... failed.

;; extern void g_relation_print(GRelation *relation);
(define g_relation_print
  (let ((~f #f))
    (lambda (relation)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_relation_print"
            ffi:void
            (list '*))))
      (let ((~relation (unwrap-GRelation* relation)))
        (~f ~relation)))))
(export g_relation_print)

;; extern void g_tuples_destroy(GTuples *tuples);
(define g_tuples_destroy
  (let ((~f #f))
    (lambda (tuples)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_tuples_destroy"
            ffi:void
            (list '*))))
      (let ((~tuples (unwrap-GTuples* tuples)))
        (~f ~tuples)))))
(export g_tuples_destroy)

;; extern gpointer g_tuples_index(GTuples *tuples, gint index_, gint field);
(define g_tuples_index
  (let ((~f #f))
    (lambda (tuples index_ field)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_tuples_index"
            '*
            (list '* ffi:int ffi:int))))
      (let ((~tuples (unwrap-GTuples* tuples))
            (~index_ (unwrap~fixed index_))
            (~field (unwrap~fixed field)))
        (wrap-gpointer (~f ~tuples ~index_ ~field))))))
(export g_tuples_index)

;; typedef enum {
;;   G_THREAD_PRIORITY_LOW,
;;   G_THREAD_PRIORITY_NORMAL,
;;   G_THREAD_PRIORITY_HIGH,
;;   G_THREAD_PRIORITY_URGENT,
;; } GThreadPriority;
(define-fh-enum GThreadPriority
  '((G_THREAD_PRIORITY_LOW . 0)
    (G_THREAD_PRIORITY_NORMAL . 1)
    (G_THREAD_PRIORITY_HIGH . 2)
    (G_THREAD_PRIORITY_URGENT . 3))
  )

;; struct _GThread {
;;   /*< private >*/
;;   GThreadFunc func;
;;   gpointer data;
;;   gboolean joinable;
;;   GThreadPriority priority;
;; };
(define struct-_GThread-desc
  (bs:struct
    (list `(func ,(bs:pointer void))
          `(data ,gpointer-desc)
          `(joinable ,int)
          `(priority ,int))))
(export struct-_GThread-desc)
(define-fh-compound-type/p struct-_GThread struct-_GThread-desc)
(set! GThread-desc struct-_GThread-desc)
(define-fh-compound-type GThread GThread-desc)

;; typedef struct _GThreadFunctions GThreadFunctions;
(define GThreadFunctions-desc void)
(define GThreadFunctions*-desc (bs:pointer (delay GThreadFunctions-desc)))
(export GThreadFunctions*-desc)
(define-fh-pointer-type GThreadFunctions* GThreadFunctions*-desc)

;; struct _GThreadFunctions {
;;   GMutex *(*mutex_new)(void);
;;   void (*mutex_lock)(GMutex *mutex);
;;   gboolean (*mutex_trylock)(GMutex *mutex);
;;   void (*mutex_unlock)(GMutex *mutex);
;;   void (*mutex_free)(GMutex *mutex);
;;   GCond *(*cond_new)(void);
;;   void (*cond_signal)(GCond *cond);
;;   void (*cond_broadcast)(GCond *cond);
;;   void (*cond_wait)(GCond *cond, GMutex *mutex);
;;   gboolean (*cond_timed_wait)(GCond *cond, GMutex *mutex, GTimeVal *end_time
;;       );
;;   void (*cond_free)(GCond *cond);
;;   GPrivate *(*private_new)(GDestroyNotify destructor);
;;   gpointer (*private_get)(GPrivate *private_key);
;;   void (*private_set)(GPrivate *private_key, gpointer data);
;;   void (*thread_create)(GThreadFunc func, gpointer data, gulong stack_size, 
;;       gboolean joinable, gboolean bound, GThreadPriority priority, gpointer 
;;       thread, GError **error);
;;   void (*thread_yield)(void);
;;   void (*thread_join)(gpointer thread);
;;   void (*thread_exit)(void);
;;   void (*thread_set_priority)(gpointer thread, GThreadPriority priority);
;;   void (*thread_self)(gpointer thread);
;;   gboolean (*thread_equal)(gpointer thread1, gpointer thread2);
;; };
(define struct-_GThreadFunctions-desc
  (bs:struct
    (list `(mutex_new ,(bs:pointer void))
          `(mutex_lock ,(bs:pointer void))
          `(mutex_trylock ,(bs:pointer void))
          `(mutex_unlock ,(bs:pointer void))
          `(mutex_free ,(bs:pointer void))
          `(cond_new ,(bs:pointer void))
          `(cond_signal ,(bs:pointer void))
          `(cond_broadcast ,(bs:pointer void))
          `(cond_wait ,(bs:pointer void))
          `(cond_timed_wait ,(bs:pointer void))
          `(cond_free ,(bs:pointer void))
          `(private_new ,(bs:pointer void))
          `(private_get ,(bs:pointer void))
          `(private_set ,(bs:pointer void))
          `(thread_create ,(bs:pointer void))
          `(thread_yield ,(bs:pointer void))
          `(thread_join ,(bs:pointer void))
          `(thread_exit ,(bs:pointer void))
          `(thread_set_priority ,(bs:pointer void))
          `(thread_self ,(bs:pointer void))
          `(thread_equal ,(bs:pointer void)))))
(export struct-_GThreadFunctions-desc)
(define-fh-compound-type/p struct-_GThreadFunctions struct-_GThreadFunctions-desc)
(set! GThreadFunctions-desc struct-_GThreadFunctions-desc)
(define-fh-compound-type GThreadFunctions GThreadFunctions-desc)

;; extern GThreadFunctions g_thread_functions_for_glib_use;
(define g_thread_functions_for_glib_use
  (let* ((addr (dynamic-pointer
                 "g_thread_functions_for_glib_use"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer GThreadFunctions-desc))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_thread_functions_for_glib_use)

;; extern gboolean g_thread_use_default_impl;
(define g_thread_use_default_impl
  (let* ((addr (dynamic-pointer
                 "g_thread_use_default_impl"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer int))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_thread_use_default_impl)

;; extern guint64 (*g_thread_gettime)(void);
(define g_thread_gettime
  (let* ((addr (dynamic-pointer
                 "g_thread_gettime"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer (bs:pointer void)))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_thread_gettime)

;; extern GThread *g_thread_create(GThreadFunc func, gpointer data, gboolean 
;;     joinable, GError **error);
(define g_thread_create
  (let ((~f #f))
    (lambda (func data joinable error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_thread_create"
            '*
            (list '* '* ffi:int '*))))
      (let ((~func ((make-ftn-arg-unwrapper '* (list '*)) func))
            (~data (unwrap-gpointer data))
            (~joinable (unwrap~fixed joinable))
            (~error (unwrap~pointer error)))
        (wrap-GThread* (~f ~func ~data ~joinable ~error))))))
(export g_thread_create)

;; extern GThread *g_thread_create_full(GThreadFunc func, gpointer data, gulong
;;      stack_size, gboolean joinable, gboolean bound, GThreadPriority priority
;;     , GError **error);
(define g_thread_create_full
  (let ((~f #f))
    (lambda (func
             data
             stack_size
             joinable
             bound
             priority
             error)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_thread_create_full"
            '*
            (list '*
                  '*
                  ffi:unsigned-long
                  ffi:int
                  ffi:int
                  ffi:int
                  '*))))
      (let ((~func ((make-ftn-arg-unwrapper '* (list '*)) func))
            (~data (unwrap-gpointer data))
            (~stack_size (unwrap~fixed stack_size))
            (~joinable (unwrap~fixed joinable))
            (~bound (unwrap~fixed bound))
            (~priority (unwrap~fixed priority))
            (~error (unwrap~pointer error)))
        (wrap-GThread*
          (~f ~func
              ~data
              ~stack_size
              ~joinable
              ~bound
              ~priority
              ~error))))))
(export g_thread_create_full)

;; extern void g_thread_set_priority(GThread *thread, GThreadPriority priority)
;;     ;
(define g_thread_set_priority
  (let ((~f #f))
    (lambda (thread priority)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_thread_set_priority"
            ffi:void
            (list '* ffi:int))))
      (let ((~thread (unwrap-GThread* thread))
            (~priority (unwrap~fixed priority)))
        (~f ~thread ~priority)))))
(export g_thread_set_priority)

;; extern void g_thread_foreach(GFunc thread_func, gpointer user_data);
(define g_thread_foreach
  (let ((~f #f))
    (lambda (thread_func user_data)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_thread_foreach"
            ffi:void
            (list '* '*))))
      (let ((~thread_func
              ((make-ftn-arg-unwrapper ffi:void (list '* '*))
               thread_func))
            (~user_data (unwrap-gpointer user_data)))
        (~f ~thread_func ~user_data)))))
(export g_thread_foreach)

;; typedef struct {
;;   GMutex *mutex;
;;   /* only for ABI compatibility reasons */
;;   pthread_mutex_t unused;
;; } GStaticMutex;
(define GStaticMutex-desc
  (bs:struct
    (list `(mutex ,(bs:pointer (delay GMutex*-desc)))
          `(unused
             ,(bs:struct
                (list `(__sig ,long)
                      `(__opaque ,(bs:vector 56 int8))))))))
(export GStaticMutex-desc)
(define-fh-compound-type/p GStaticMutex GStaticMutex-desc)

;; extern void g_static_mutex_init(GStaticMutex *mutex);
(define g_static_mutex_init
  (let ((~f #f))
    (lambda (mutex)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_static_mutex_init"
            ffi:void
            (list '*))))
      (let ((~mutex (unwrap-GStaticMutex* mutex)))
        (~f ~mutex)))))
(export g_static_mutex_init)

;; extern void g_static_mutex_free(GStaticMutex *mutex);
(define g_static_mutex_free
  (let ((~f #f))
    (lambda (mutex)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_static_mutex_free"
            ffi:void
            (list '*))))
      (let ((~mutex (unwrap-GStaticMutex* mutex)))
        (~f ~mutex)))))
(export g_static_mutex_free)

;; extern GMutex *g_static_mutex_get_mutex_impl(GStaticMutex *mutex);
(define g_static_mutex_get_mutex_impl
  (let ((~f #f))
    (lambda (mutex)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_static_mutex_get_mutex_impl"
            '*
            (list '*))))
      (let ((~mutex (unwrap-GStaticMutex* mutex)))
        (wrap-GMutex* (~f ~mutex))))))
(export g_static_mutex_get_mutex_impl)

;; typedef struct _GStaticRecMutex GStaticRecMutex;
(define GStaticRecMutex-desc void)
(define GStaticRecMutex*-desc (bs:pointer (delay GStaticRecMutex-desc)))
(export GStaticRecMutex*-desc)
(define-fh-pointer-type GStaticRecMutex* GStaticRecMutex*-desc)

;; struct _GStaticRecMutex {
;;   /*< private >*/
;;   GStaticMutex mutex;
;;   guint depth;
;;   /* ABI compat only */
;;   union {
;;     pthread_t owner;
;;     gdouble dummy;
;;   } unused;
;; };
(define struct-_GStaticRecMutex-desc
  (bs:struct
    (list `(mutex ,GStaticMutex-desc)
          `(depth ,unsigned-int)
          `(unused
             ,(bs:union
                (list `(owner ,(bs:pointer void))
                      `(dummy ,gdouble-desc)))))))
(export struct-_GStaticRecMutex-desc)
(define-fh-compound-type/p struct-_GStaticRecMutex struct-_GStaticRecMutex-desc)
(set! GStaticRecMutex-desc struct-_GStaticRecMutex-desc)
(define-fh-compound-type GStaticRecMutex GStaticRecMutex-desc)

;; extern void g_static_rec_mutex_init(GStaticRecMutex *mutex);
(define g_static_rec_mutex_init
  (let ((~f #f))
    (lambda (mutex)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_static_rec_mutex_init"
            ffi:void
            (list '*))))
      (let ((~mutex (unwrap-GStaticRecMutex* mutex)))
        (~f ~mutex)))))
(export g_static_rec_mutex_init)

;; extern void g_static_rec_mutex_lock(GStaticRecMutex *mutex);
(define g_static_rec_mutex_lock
  (let ((~f #f))
    (lambda (mutex)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_static_rec_mutex_lock"
            ffi:void
            (list '*))))
      (let ((~mutex (unwrap-GStaticRecMutex* mutex)))
        (~f ~mutex)))))
(export g_static_rec_mutex_lock)

;; extern gboolean g_static_rec_mutex_trylock(GStaticRecMutex *mutex);
(define g_static_rec_mutex_trylock
  (let ((~f #f))
    (lambda (mutex)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_static_rec_mutex_trylock"
            ffi:int
            (list '*))))
      (let ((~mutex (unwrap-GStaticRecMutex* mutex)))
        (~f ~mutex)))))
(export g_static_rec_mutex_trylock)

;; extern void g_static_rec_mutex_unlock(GStaticRecMutex *mutex);
(define g_static_rec_mutex_unlock
  (let ((~f #f))
    (lambda (mutex)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_static_rec_mutex_unlock"
            ffi:void
            (list '*))))
      (let ((~mutex (unwrap-GStaticRecMutex* mutex)))
        (~f ~mutex)))))
(export g_static_rec_mutex_unlock)

;; extern void g_static_rec_mutex_lock_full(GStaticRecMutex *mutex, guint depth
;;     );
(define g_static_rec_mutex_lock_full
  (let ((~f #f))
    (lambda (mutex depth)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_static_rec_mutex_lock_full"
            ffi:void
            (list '* ffi:unsigned-int))))
      (let ((~mutex (unwrap-GStaticRecMutex* mutex))
            (~depth (unwrap~fixed depth)))
        (~f ~mutex ~depth)))))
(export g_static_rec_mutex_lock_full)

;; extern guint g_static_rec_mutex_unlock_full(GStaticRecMutex *mutex);
(define g_static_rec_mutex_unlock_full
  (let ((~f #f))
    (lambda (mutex)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_static_rec_mutex_unlock_full"
            ffi:unsigned-int
            (list '*))))
      (let ((~mutex (unwrap-GStaticRecMutex* mutex)))
        (~f ~mutex)))))
(export g_static_rec_mutex_unlock_full)

;; extern void g_static_rec_mutex_free(GStaticRecMutex *mutex);
(define g_static_rec_mutex_free
  (let ((~f #f))
    (lambda (mutex)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_static_rec_mutex_free"
            ffi:void
            (list '*))))
      (let ((~mutex (unwrap-GStaticRecMutex* mutex)))
        (~f ~mutex)))))
(export g_static_rec_mutex_free)

;; typedef struct _GStaticRWLock GStaticRWLock;
(define GStaticRWLock-desc void)
(define GStaticRWLock*-desc (bs:pointer (delay GStaticRWLock-desc)))
(export GStaticRWLock*-desc)
(define-fh-pointer-type GStaticRWLock* GStaticRWLock*-desc)

;; struct _GStaticRWLock {
;;   /*< private >*/
;;   GStaticMutex mutex;
;;   GCond *read_cond;
;;   GCond *write_cond;
;;   guint read_counter;
;;   gboolean have_writer;
;;   guint want_to_read;
;;   guint want_to_write;
;; };
(define struct-_GStaticRWLock-desc
  (bs:struct
    (list `(mutex ,GStaticMutex-desc)
          `(read_cond ,(bs:pointer (delay GCond*-desc)))
          `(write_cond ,(bs:pointer (delay GCond*-desc)))
          `(read_counter ,unsigned-int)
          `(have_writer ,int)
          `(want_to_read ,unsigned-int)
          `(want_to_write ,unsigned-int))))
(export struct-_GStaticRWLock-desc)
(define-fh-compound-type/p struct-_GStaticRWLock struct-_GStaticRWLock-desc)
(set! GStaticRWLock-desc struct-_GStaticRWLock-desc)
(define-fh-compound-type GStaticRWLock GStaticRWLock-desc)

;; extern void g_static_rw_lock_init(GStaticRWLock *lock);
(define g_static_rw_lock_init
  (let ((~f #f))
    (lambda (lock)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_static_rw_lock_init"
            ffi:void
            (list '*))))
      (let ((~lock (unwrap-GStaticRWLock* lock)))
        (~f ~lock)))))
(export g_static_rw_lock_init)

;; extern void g_static_rw_lock_reader_lock(GStaticRWLock *lock);
(define g_static_rw_lock_reader_lock
  (let ((~f #f))
    (lambda (lock)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_static_rw_lock_reader_lock"
            ffi:void
            (list '*))))
      (let ((~lock (unwrap-GStaticRWLock* lock)))
        (~f ~lock)))))
(export g_static_rw_lock_reader_lock)

;; extern gboolean g_static_rw_lock_reader_trylock(GStaticRWLock *lock);
(define g_static_rw_lock_reader_trylock
  (let ((~f #f))
    (lambda (lock)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_static_rw_lock_reader_trylock"
            ffi:int
            (list '*))))
      (let ((~lock (unwrap-GStaticRWLock* lock)))
        (~f ~lock)))))
(export g_static_rw_lock_reader_trylock)

;; extern void g_static_rw_lock_reader_unlock(GStaticRWLock *lock);
(define g_static_rw_lock_reader_unlock
  (let ((~f #f))
    (lambda (lock)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_static_rw_lock_reader_unlock"
            ffi:void
            (list '*))))
      (let ((~lock (unwrap-GStaticRWLock* lock)))
        (~f ~lock)))))
(export g_static_rw_lock_reader_unlock)

;; extern void g_static_rw_lock_writer_lock(GStaticRWLock *lock);
(define g_static_rw_lock_writer_lock
  (let ((~f #f))
    (lambda (lock)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_static_rw_lock_writer_lock"
            ffi:void
            (list '*))))
      (let ((~lock (unwrap-GStaticRWLock* lock)))
        (~f ~lock)))))
(export g_static_rw_lock_writer_lock)

;; extern gboolean g_static_rw_lock_writer_trylock(GStaticRWLock *lock);
(define g_static_rw_lock_writer_trylock
  (let ((~f #f))
    (lambda (lock)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_static_rw_lock_writer_trylock"
            ffi:int
            (list '*))))
      (let ((~lock (unwrap-GStaticRWLock* lock)))
        (~f ~lock)))))
(export g_static_rw_lock_writer_trylock)

;; extern void g_static_rw_lock_writer_unlock(GStaticRWLock *lock);
(define g_static_rw_lock_writer_unlock
  (let ((~f #f))
    (lambda (lock)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_static_rw_lock_writer_unlock"
            ffi:void
            (list '*))))
      (let ((~lock (unwrap-GStaticRWLock* lock)))
        (~f ~lock)))))
(export g_static_rw_lock_writer_unlock)

;; extern void g_static_rw_lock_free(GStaticRWLock *lock);
(define g_static_rw_lock_free
  (let ((~f #f))
    (lambda (lock)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_static_rw_lock_free"
            ffi:void
            (list '*))))
      (let ((~lock (unwrap-GStaticRWLock* lock)))
        (~f ~lock)))))
(export g_static_rw_lock_free)

;; extern GPrivate *g_private_new(GDestroyNotify notify);
(define g_private_new
  (let ((~f #f))
    (lambda (notify)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_private_new" '* (list '*))))
      (let ((~notify
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               notify)))
        (wrap-GPrivate* (~f ~notify))))))
(export g_private_new)

;; typedef struct _GStaticPrivate GStaticPrivate;
(define GStaticPrivate-desc void)
(define GStaticPrivate*-desc (bs:pointer (delay GStaticPrivate-desc)))
(export GStaticPrivate*-desc)
(define-fh-pointer-type GStaticPrivate* GStaticPrivate*-desc)

;; struct _GStaticPrivate {
;;   /*< private >*/
;;   guint index;
;; };
(define struct-_GStaticPrivate-desc
  (bs:struct (list `(index ,unsigned-int))))
(export struct-_GStaticPrivate-desc)
(define-fh-compound-type/p struct-_GStaticPrivate struct-_GStaticPrivate-desc)
(set! GStaticPrivate-desc struct-_GStaticPrivate-desc)
(define-fh-compound-type GStaticPrivate GStaticPrivate-desc)

;; extern void g_static_private_init(GStaticPrivate *private_key);
(define g_static_private_init
  (let ((~f #f))
    (lambda (private_key)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_static_private_init"
            ffi:void
            (list '*))))
      (let ((~private_key
              (unwrap-GStaticPrivate* private_key)))
        (~f ~private_key)))))
(export g_static_private_init)

;; extern gpointer g_static_private_get(GStaticPrivate *private_key);
(define g_static_private_get
  (let ((~f #f))
    (lambda (private_key)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_static_private_get"
            '*
            (list '*))))
      (let ((~private_key
              (unwrap-GStaticPrivate* private_key)))
        (wrap-gpointer (~f ~private_key))))))
(export g_static_private_get)

;; extern void g_static_private_set(GStaticPrivate *private_key, gpointer data
;;     , GDestroyNotify notify);
(define g_static_private_set
  (let ((~f #f))
    (lambda (private_key data notify)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_static_private_set"
            ffi:void
            (list '* '* '*))))
      (let ((~private_key
              (unwrap-GStaticPrivate* private_key))
            (~data (unwrap-gpointer data))
            (~notify
              ((make-ftn-arg-unwrapper ffi:void (list '*))
               notify)))
        (~f ~private_key ~data ~notify)))))
(export g_static_private_set)

;; extern void g_static_private_free(GStaticPrivate *private_key);
(define g_static_private_free
  (let ((~f #f))
    (lambda (private_key)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_static_private_free"
            ffi:void
            (list '*))))
      (let ((~private_key
              (unwrap-GStaticPrivate* private_key)))
        (~f ~private_key)))))
(export g_static_private_free)

;; extern gboolean g_once_init_enter_impl(volatile gsize *location);
(define g_once_init_enter_impl
  (let ((~f #f))
    (lambda (location)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_once_init_enter_impl"
            ffi:int
            (list '*))))
      (let ((~location (unwrap~pointer location)))
        (~f ~location)))))
(export g_once_init_enter_impl)

;; extern void g_thread_init(gpointer vtable);
(define g_thread_init
  (let ((~f #f))
    (lambda (vtable)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_thread_init" ffi:void (list '*))))
      (let ((~vtable (unwrap-gpointer vtable)))
        (~f ~vtable)))))
(export g_thread_init)

;; extern void g_thread_init_with_errorcheck_mutexes(gpointer vtable);
(define g_thread_init_with_errorcheck_mutexes
  (let ((~f #f))
    (lambda (vtable)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_thread_init_with_errorcheck_mutexes"
            ffi:void
            (list '*))))
      (let ((~vtable (unwrap-gpointer vtable)))
        (~f ~vtable)))))
(export g_thread_init_with_errorcheck_mutexes)

;; extern gboolean g_thread_get_initialized(void);
(define g_thread_get_initialized
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_thread_get_initialized"
            ffi:int
            (list))))
      (let () (~f)))))
(export g_thread_get_initialized)

;; extern gboolean g_threads_got_initialized;
(define g_threads_got_initialized
  (let* ((addr (dynamic-pointer
                 "g_threads_got_initialized"
                 (dynamic-link)))
         (bs* (make-bytestructure
                (ffi:pointer->bytevector addr (ffi:sizeof '*))
                0
                (bs:pointer int))))
    (case-lambda (() (bytestructure-ref bs* '*)))))
(export g_threads_got_initialized)

;; extern GMutex *g_mutex_new(void);
(define g_mutex_new
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f (fh-link-proc "g_mutex_new" '* (list))))
      (let () (wrap-GMutex* (~f))))))
(export g_mutex_new)

;; extern void g_mutex_free(GMutex *mutex);
(define g_mutex_free
  (let ((~f #f))
    (lambda (mutex)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_mutex_free" ffi:void (list '*))))
      (let ((~mutex (unwrap-GMutex* mutex)))
        (~f ~mutex)))))
(export g_mutex_free)

;; extern GCond *g_cond_new(void);
(define g_cond_new
  (let ((~f #f))
    (lambda ()
      (if (not ~f)
        (set! ~f (fh-link-proc "g_cond_new" '* (list))))
      (let () (wrap-GCond* (~f))))))
(export g_cond_new)

;; extern void g_cond_free(GCond *cond);
(define g_cond_free
  (let ((~f #f))
    (lambda (cond)
      (if (not ~f)
        (set! ~f
          (fh-link-proc "g_cond_free" ffi:void (list '*))))
      (let ((~cond (unwrap-GCond* cond))) (~f ~cond)))))
(export g_cond_free)

;; extern gboolean g_cond_timed_wait(GCond *cond, GMutex *mutex, GTimeVal *
;;     timeval);
(define g_cond_timed_wait
  (let ((~f #f))
    (lambda (cond mutex timeval)
      (if (not ~f)
        (set! ~f
          (fh-link-proc
            "g_cond_timed_wait"
            ffi:int
            (list '* '* '*))))
      (let ((~cond (unwrap-GCond* cond))
            (~mutex (unwrap-GMutex* mutex))
            (~timeval (unwrap-GTimeVal* timeval)))
        (~f ~cond ~mutex ~timeval)))))
(export g_cond_timed_wait)

;; typedef GAsyncQueue *GAsyncQueue_autoptr;
(define GAsyncQueue_autoptr-desc (bs:pointer GAsyncQueue-desc))
(define-fh-pointer-type GAsyncQueue_autoptr GAsyncQueue_autoptr-desc)

;; typedef GBookmarkFile *GBookmarkFile_autoptr;
(define GBookmarkFile_autoptr-desc (bs:pointer GBookmarkFile-desc))
(define-fh-pointer-type GBookmarkFile_autoptr GBookmarkFile_autoptr-desc)

;; typedef GBytes *GBytes_autoptr;
(define GBytes_autoptr-desc (bs:pointer GBytes-desc))
(define-fh-pointer-type GBytes_autoptr GBytes_autoptr-desc)

;; typedef GChecksum *GChecksum_autoptr;
(define GChecksum_autoptr-desc (bs:pointer GChecksum-desc))
(define-fh-pointer-type GChecksum_autoptr GChecksum_autoptr-desc)

;; typedef GDateTime *GDateTime_autoptr;
(define GDateTime_autoptr-desc (bs:pointer GDateTime-desc))
(define-fh-pointer-type GDateTime_autoptr GDateTime_autoptr-desc)

;; typedef GDir *GDir_autoptr;
(define GDir_autoptr-desc (bs:pointer GDir-desc))
(define-fh-pointer-type GDir_autoptr GDir_autoptr-desc)

;; typedef GError *GError_autoptr;
(define GError_autoptr-desc (bs:pointer GError-desc))
(define-fh-pointer-type GError_autoptr GError_autoptr-desc)

;; typedef GHashTable *GHashTable_autoptr;
(define GHashTable_autoptr-desc (bs:pointer GHashTable-desc))
(define-fh-pointer-type GHashTable_autoptr GHashTable_autoptr-desc)

;; typedef GHmac *GHmac_autoptr;
(define GHmac_autoptr-desc (bs:pointer GHmac-desc))
(define-fh-pointer-type GHmac_autoptr GHmac_autoptr-desc)

;; typedef GIOChannel *GIOChannel_autoptr;
(define GIOChannel_autoptr-desc (bs:pointer GIOChannel-desc))
(define-fh-pointer-type GIOChannel_autoptr GIOChannel_autoptr-desc)

;; typedef GKeyFile *GKeyFile_autoptr;
(define GKeyFile_autoptr-desc (bs:pointer GKeyFile-desc))
(define-fh-pointer-type GKeyFile_autoptr GKeyFile_autoptr-desc)

;; typedef GList *GList_autoptr;
(define GList_autoptr-desc (bs:pointer GList-desc))
(define-fh-pointer-type GList_autoptr GList_autoptr-desc)

;; typedef GArray *GArray_autoptr;
(define GArray_autoptr-desc (bs:pointer GArray-desc))
(define-fh-pointer-type GArray_autoptr GArray_autoptr-desc)

;; typedef GPtrArray *GPtrArray_autoptr;
(define GPtrArray_autoptr-desc (bs:pointer GPtrArray-desc))
(define-fh-pointer-type GPtrArray_autoptr GPtrArray_autoptr-desc)

;; typedef GByteArray *GByteArray_autoptr;
(define GByteArray_autoptr-desc (bs:pointer GByteArray-desc))
(define-fh-pointer-type GByteArray_autoptr GByteArray_autoptr-desc)

;; typedef GMainContext *GMainContext_autoptr;
(define GMainContext_autoptr-desc (bs:pointer GMainContext-desc))
(define-fh-pointer-type GMainContext_autoptr GMainContext_autoptr-desc)

;; typedef GMainLoop *GMainLoop_autoptr;
(define GMainLoop_autoptr-desc (bs:pointer GMainLoop-desc))
(define-fh-pointer-type GMainLoop_autoptr GMainLoop_autoptr-desc)

;; typedef GSource *GSource_autoptr;
(define GSource_autoptr-desc (bs:pointer GSource-desc))
(define-fh-pointer-type GSource_autoptr GSource_autoptr-desc)

;; typedef GMappedFile *GMappedFile_autoptr;
(define GMappedFile_autoptr-desc (bs:pointer GMappedFile-desc))
(define-fh-pointer-type GMappedFile_autoptr GMappedFile_autoptr-desc)

;; typedef GMarkupParseContext *GMarkupParseContext_autoptr;
(define GMarkupParseContext_autoptr-desc (bs:pointer GMarkupParseContext-desc))
(define-fh-pointer-type GMarkupParseContext_autoptr GMarkupParseContext_autoptr-desc)

;; typedef GNode *GNode_autoptr;
(define GNode_autoptr-desc (bs:pointer GNode-desc))
(define-fh-pointer-type GNode_autoptr GNode_autoptr-desc)

;; typedef GOptionContext *GOptionContext_autoptr;
(define GOptionContext_autoptr-desc (bs:pointer GOptionContext-desc))
(define-fh-pointer-type GOptionContext_autoptr GOptionContext_autoptr-desc)

;; typedef GOptionGroup *GOptionGroup_autoptr;
(define GOptionGroup_autoptr-desc (bs:pointer GOptionGroup-desc))
(define-fh-pointer-type GOptionGroup_autoptr GOptionGroup_autoptr-desc)

;; typedef GPatternSpec *GPatternSpec_autoptr;
(define GPatternSpec_autoptr-desc (bs:pointer GPatternSpec-desc))
(define-fh-pointer-type GPatternSpec_autoptr GPatternSpec_autoptr-desc)

;; typedef GQueue *GQueue_autoptr;
(define GQueue_autoptr-desc (bs:pointer GQueue-desc))
(define-fh-pointer-type GQueue_autoptr GQueue_autoptr-desc)

;; typedef GRand *GRand_autoptr;
(define GRand_autoptr-desc (bs:pointer GRand-desc))
(define-fh-pointer-type GRand_autoptr GRand_autoptr-desc)

;; typedef GRegex *GRegex_autoptr;
(define GRegex_autoptr-desc (bs:pointer GRegex-desc))
(define-fh-pointer-type GRegex_autoptr GRegex_autoptr-desc)

;; typedef GMatchInfo *GMatchInfo_autoptr;
(define GMatchInfo_autoptr-desc (bs:pointer GMatchInfo-desc))
(define-fh-pointer-type GMatchInfo_autoptr GMatchInfo_autoptr-desc)

;; typedef GScanner *GScanner_autoptr;
(define GScanner_autoptr-desc (bs:pointer GScanner-desc))
(define-fh-pointer-type GScanner_autoptr GScanner_autoptr-desc)

;; typedef GSequence *GSequence_autoptr;
(define GSequence_autoptr-desc (bs:pointer GSequence-desc))
(define-fh-pointer-type GSequence_autoptr GSequence_autoptr-desc)

;; typedef GSList *GSList_autoptr;
(define GSList_autoptr-desc (bs:pointer GSList-desc))
(define-fh-pointer-type GSList_autoptr GSList_autoptr-desc)

;; typedef GString *GString_autoptr;
(define GString_autoptr-desc (bs:pointer GString-desc))
(define-fh-pointer-type GString_autoptr GString_autoptr-desc)

;; typedef GStringChunk *GStringChunk_autoptr;
(define GStringChunk_autoptr-desc (bs:pointer GStringChunk-desc))
(define-fh-pointer-type GStringChunk_autoptr GStringChunk_autoptr-desc)

;; typedef GThread *GThread_autoptr;
(define GThread_autoptr-desc (bs:pointer GThread-desc))
(define-fh-pointer-type GThread_autoptr GThread_autoptr-desc)

;; typedef GMutexLocker *GMutexLocker_autoptr;
(define GMutexLocker_autoptr-desc (bs:pointer GMutexLocker-desc))
(define-fh-pointer-type GMutexLocker_autoptr GMutexLocker_autoptr-desc)

;; typedef GTimer *GTimer_autoptr;
(define GTimer_autoptr-desc (bs:pointer GTimer-desc))
(define-fh-pointer-type GTimer_autoptr GTimer_autoptr-desc)

;; typedef GTimeZone *GTimeZone_autoptr;
(define GTimeZone_autoptr-desc (bs:pointer GTimeZone-desc))
(define-fh-pointer-type GTimeZone_autoptr GTimeZone_autoptr-desc)

;; typedef GTree *GTree_autoptr;
(define GTree_autoptr-desc (bs:pointer GTree-desc))
(define-fh-pointer-type GTree_autoptr GTree_autoptr-desc)

;; typedef GVariant *GVariant_autoptr;
(define GVariant_autoptr-desc (bs:pointer GVariant-desc))
(define-fh-pointer-type GVariant_autoptr GVariant_autoptr-desc)

;; typedef GVariantBuilder *GVariantBuilder_autoptr;
(define GVariantBuilder_autoptr-desc (bs:pointer GVariantBuilder-desc))
(define-fh-pointer-type GVariantBuilder_autoptr GVariantBuilder_autoptr-desc)

;; typedef GVariantIter *GVariantIter_autoptr;
(define GVariantIter_autoptr-desc (bs:pointer GVariantIter-desc))
(define-fh-pointer-type GVariantIter_autoptr GVariantIter_autoptr-desc)

;; typedef GVariantDict *GVariantDict_autoptr;
(define GVariantDict_autoptr-desc (bs:pointer GVariantDict-desc))
(define-fh-pointer-type GVariantDict_autoptr GVariantDict_autoptr-desc)

;; typedef GVariantType *GVariantType_autoptr;
(define GVariantType_autoptr-desc (bs:pointer GVariantType-desc))
(define-fh-pointer-type GVariantType_autoptr GVariantType_autoptr-desc)

;; access to enum symbols and #define'd constants:
(define glib-symbol-val
  (let ((sym-tab
          '((_CLOCK_REALTIME . 0)
            (_CLOCK_MONOTONIC . 6)
            (_CLOCK_MONOTONIC_RAW . 4)
            (_CLOCK_MONOTONIC_RAW_APPROX . 5)
            (_CLOCK_UPTIME_RAW . 8)
            (_CLOCK_UPTIME_RAW_APPROX . 9)
            (_CLOCK_PROCESS_CPUTIME_ID . 12)
            (_CLOCK_THREAD_CPUTIME_ID . 16)
            (G_USER_DIRECTORY_DESKTOP . 0)
            (G_USER_DIRECTORY_DOCUMENTS . 1)
            (G_USER_DIRECTORY_DOWNLOAD . 2)
            (G_USER_DIRECTORY_MUSIC . 3)
            (G_USER_DIRECTORY_PICTURES . 4)
            (G_USER_DIRECTORY_PUBLIC_SHARE . 5)
            (G_USER_DIRECTORY_TEMPLATES . 6)
            (G_USER_DIRECTORY_VIDEOS . 7)
            (G_USER_N_DIRECTORIES . 8)
            (G_FORMAT_SIZE_DEFAULT . 0)
            (G_FORMAT_SIZE_LONG_FORMAT . 1)
            (G_FORMAT_SIZE_IEC_UNITS . 2)
            (G_THREAD_ERROR_AGAIN . 0)
            (G_ONCE_STATUS_NOTCALLED . 0)
            (G_ONCE_STATUS_PROGRESS . 1)
            (G_ONCE_STATUS_READY . 2)
            (G_BOOKMARK_FILE_ERROR_INVALID_URI . 0)
            (G_BOOKMARK_FILE_ERROR_INVALID_VALUE . 1)
            (G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED . 2)
            (G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND . 3)
            (G_BOOKMARK_FILE_ERROR_READ . 4)
            (G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING . 5)
            (G_BOOKMARK_FILE_ERROR_WRITE . 6)
            (G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND . 7)
            (G_CHECKSUM_MD5 . 0)
            (G_CHECKSUM_SHA1 . 1)
            (G_CHECKSUM_SHA256 . 2)
            (G_CHECKSUM_SHA512 . 3)
            (G_CHECKSUM_SHA384 . 4)
            (G_CONVERT_ERROR_NO_CONVERSION . 0)
            (G_CONVERT_ERROR_ILLEGAL_SEQUENCE . 1)
            (G_CONVERT_ERROR_FAILED . 2)
            (G_CONVERT_ERROR_PARTIAL_INPUT . 3)
            (G_CONVERT_ERROR_BAD_URI . 4)
            (G_CONVERT_ERROR_NOT_ABSOLUTE_PATH . 5)
            (G_CONVERT_ERROR_NO_MEMORY . 6)
            (G_DATE_DAY . 0)
            (G_DATE_MONTH . 1)
            (G_DATE_YEAR . 2)
            (G_DATE_BAD_WEEKDAY . 0)
            (G_DATE_MONDAY . 1)
            (G_DATE_TUESDAY . 2)
            (G_DATE_WEDNESDAY . 3)
            (G_DATE_THURSDAY . 4)
            (G_DATE_FRIDAY . 5)
            (G_DATE_SATURDAY . 6)
            (G_DATE_SUNDAY . 7)
            (G_DATE_BAD_MONTH . 0)
            (G_DATE_JANUARY . 1)
            (G_DATE_FEBRUARY . 2)
            (G_DATE_MARCH . 3)
            (G_DATE_APRIL . 4)
            (G_DATE_MAY . 5)
            (G_DATE_JUNE . 6)
            (G_DATE_JULY . 7)
            (G_DATE_AUGUST . 8)
            (G_DATE_SEPTEMBER . 9)
            (G_DATE_OCTOBER . 10)
            (G_DATE_NOVEMBER . 11)
            (G_DATE_DECEMBER . 12)
            (G_TIME_TYPE_STANDARD . 0)
            (G_TIME_TYPE_DAYLIGHT . 1)
            (G_TIME_TYPE_UNIVERSAL . 2)
            (G_FILE_ERROR_EXIST . 0)
            (G_FILE_ERROR_ISDIR . 1)
            (G_FILE_ERROR_ACCES . 2)
            (G_FILE_ERROR_NAMETOOLONG . 3)
            (G_FILE_ERROR_NOENT . 4)
            (G_FILE_ERROR_NOTDIR . 5)
            (G_FILE_ERROR_NXIO . 6)
            (G_FILE_ERROR_NODEV . 7)
            (G_FILE_ERROR_ROFS . 8)
            (G_FILE_ERROR_TXTBSY . 9)
            (G_FILE_ERROR_FAULT . 10)
            (G_FILE_ERROR_LOOP . 11)
            (G_FILE_ERROR_NOSPC . 12)
            (G_FILE_ERROR_NOMEM . 13)
            (G_FILE_ERROR_MFILE . 14)
            (G_FILE_ERROR_NFILE . 15)
            (G_FILE_ERROR_BADF . 16)
            (G_FILE_ERROR_INVAL . 17)
            (G_FILE_ERROR_PIPE . 18)
            (G_FILE_ERROR_AGAIN . 19)
            (G_FILE_ERROR_INTR . 20)
            (G_FILE_ERROR_IO . 21)
            (G_FILE_ERROR_PERM . 22)
            (G_FILE_ERROR_NOSYS . 23)
            (G_FILE_ERROR_FAILED . 24)
            (G_FILE_TEST_IS_REGULAR . 1)
            (G_FILE_TEST_IS_SYMLINK . 2)
            (G_FILE_TEST_IS_DIR . 4)
            (G_FILE_TEST_IS_EXECUTABLE . 8)
            (G_FILE_TEST_EXISTS . 16)
            (G_TRAVERSE_LEAVES . 1)
            (G_TRAVERSE_NON_LEAVES . 2)
            (G_TRAVERSE_ALL . 3)
            (G_TRAVERSE_MASK . 3)
            (G_TRAVERSE_LEAFS . 1)
            (G_TRAVERSE_NON_LEAFS . 2)
            (G_IN_ORDER . 0)
            (G_PRE_ORDER . 1)
            (G_POST_ORDER . 2)
            (G_LEVEL_ORDER . 3)
            (G_HOOK_FLAG_ACTIVE . 1)
            (G_HOOK_FLAG_IN_CALL . 2)
            (G_HOOK_FLAG_MASK . 15)
            (G_IO_IN . 1)
            (G_IO_OUT . 4)
            (G_IO_PRI . 2)
            (G_IO_ERR . 8)
            (G_IO_HUP . 16)
            (G_IO_NVAL . 32)
            (G_UNICODE_CONTROL . 0)
            (G_UNICODE_FORMAT . 1)
            (G_UNICODE_UNASSIGNED . 2)
            (G_UNICODE_PRIVATE_USE . 3)
            (G_UNICODE_SURROGATE . 4)
            (G_UNICODE_LOWERCASE_LETTER . 5)
            (G_UNICODE_MODIFIER_LETTER . 6)
            (G_UNICODE_OTHER_LETTER . 7)
            (G_UNICODE_TITLECASE_LETTER . 8)
            (G_UNICODE_UPPERCASE_LETTER . 9)
            (G_UNICODE_SPACING_MARK . 10)
            (G_UNICODE_ENCLOSING_MARK . 11)
            (G_UNICODE_NON_SPACING_MARK . 12)
            (G_UNICODE_DECIMAL_NUMBER . 13)
            (G_UNICODE_LETTER_NUMBER . 14)
            (G_UNICODE_OTHER_NUMBER . 15)
            (G_UNICODE_CONNECT_PUNCTUATION . 16)
            (G_UNICODE_DASH_PUNCTUATION . 17)
            (G_UNICODE_CLOSE_PUNCTUATION . 18)
            (G_UNICODE_FINAL_PUNCTUATION . 19)
            (G_UNICODE_INITIAL_PUNCTUATION . 20)
            (G_UNICODE_OTHER_PUNCTUATION . 21)
            (G_UNICODE_OPEN_PUNCTUATION . 22)
            (G_UNICODE_CURRENCY_SYMBOL . 23)
            (G_UNICODE_MODIFIER_SYMBOL . 24)
            (G_UNICODE_MATH_SYMBOL . 25)
            (G_UNICODE_OTHER_SYMBOL . 26)
            (G_UNICODE_LINE_SEPARATOR . 27)
            (G_UNICODE_PARAGRAPH_SEPARATOR . 28)
            (G_UNICODE_SPACE_SEPARATOR . 29)
            (G_UNICODE_BREAK_MANDATORY . 0)
            (G_UNICODE_BREAK_CARRIAGE_RETURN . 1)
            (G_UNICODE_BREAK_LINE_FEED . 2)
            (G_UNICODE_BREAK_COMBINING_MARK . 3)
            (G_UNICODE_BREAK_SURROGATE . 4)
            (G_UNICODE_BREAK_ZERO_WIDTH_SPACE . 5)
            (G_UNICODE_BREAK_INSEPARABLE . 6)
            (G_UNICODE_BREAK_NON_BREAKING_GLUE . 7)
            (G_UNICODE_BREAK_CONTINGENT . 8)
            (G_UNICODE_BREAK_SPACE . 9)
            (G_UNICODE_BREAK_AFTER . 10)
            (G_UNICODE_BREAK_BEFORE . 11)
            (G_UNICODE_BREAK_BEFORE_AND_AFTER . 12)
            (G_UNICODE_BREAK_HYPHEN . 13)
            (G_UNICODE_BREAK_NON_STARTER . 14)
            (G_UNICODE_BREAK_OPEN_PUNCTUATION . 15)
            (G_UNICODE_BREAK_CLOSE_PUNCTUATION . 16)
            (G_UNICODE_BREAK_QUOTATION . 17)
            (G_UNICODE_BREAK_EXCLAMATION . 18)
            (G_UNICODE_BREAK_IDEOGRAPHIC . 19)
            (G_UNICODE_BREAK_NUMERIC . 20)
            (G_UNICODE_BREAK_INFIX_SEPARATOR . 21)
            (G_UNICODE_BREAK_SYMBOL . 22)
            (G_UNICODE_BREAK_ALPHABETIC . 23)
            (G_UNICODE_BREAK_PREFIX . 24)
            (G_UNICODE_BREAK_POSTFIX . 25)
            (G_UNICODE_BREAK_COMPLEX_CONTEXT . 26)
            (G_UNICODE_BREAK_AMBIGUOUS . 27)
            (G_UNICODE_BREAK_UNKNOWN . 28)
            (G_UNICODE_BREAK_NEXT_LINE . 29)
            (G_UNICODE_BREAK_WORD_JOINER . 30)
            (G_UNICODE_BREAK_HANGUL_L_JAMO . 31)
            (G_UNICODE_BREAK_HANGUL_V_JAMO . 32)
            (G_UNICODE_BREAK_HANGUL_T_JAMO . 33)
            (G_UNICODE_BREAK_HANGUL_LV_SYLLABLE . 34)
            (G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE . 35)
            (G_UNICODE_BREAK_CLOSE_PARANTHESIS . 36)
            (G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER
              .
              37)
            (G_UNICODE_BREAK_HEBREW_LETTER . 38)
            (G_UNICODE_BREAK_REGIONAL_INDICATOR . 39)
            (G_UNICODE_BREAK_EMOJI_BASE . 40)
            (G_UNICODE_BREAK_EMOJI_MODIFIER . 41)
            (G_UNICODE_BREAK_ZERO_WIDTH_JOINER . 42)
            (G_UNICODE_SCRIPT_INVALID_CODE . -1)
            (G_UNICODE_SCRIPT_COMMON . 0)
            (G_UNICODE_SCRIPT_INHERITED . 1)
            (G_UNICODE_SCRIPT_ARABIC . 2)
            (G_UNICODE_SCRIPT_ARMENIAN . 3)
            (G_UNICODE_SCRIPT_BENGALI . 4)
            (G_UNICODE_SCRIPT_BOPOMOFO . 5)
            (G_UNICODE_SCRIPT_CHEROKEE . 6)
            (G_UNICODE_SCRIPT_COPTIC . 7)
            (G_UNICODE_SCRIPT_CYRILLIC . 8)
            (G_UNICODE_SCRIPT_DESERET . 9)
            (G_UNICODE_SCRIPT_DEVANAGARI . 10)
            (G_UNICODE_SCRIPT_ETHIOPIC . 11)
            (G_UNICODE_SCRIPT_GEORGIAN . 12)
            (G_UNICODE_SCRIPT_GOTHIC . 13)
            (G_UNICODE_SCRIPT_GREEK . 14)
            (G_UNICODE_SCRIPT_GUJARATI . 15)
            (G_UNICODE_SCRIPT_GURMUKHI . 16)
            (G_UNICODE_SCRIPT_HAN . 17)
            (G_UNICODE_SCRIPT_HANGUL . 18)
            (G_UNICODE_SCRIPT_HEBREW . 19)
            (G_UNICODE_SCRIPT_HIRAGANA . 20)
            (G_UNICODE_SCRIPT_KANNADA . 21)
            (G_UNICODE_SCRIPT_KATAKANA . 22)
            (G_UNICODE_SCRIPT_KHMER . 23)
            (G_UNICODE_SCRIPT_LAO . 24)
            (G_UNICODE_SCRIPT_LATIN . 25)
            (G_UNICODE_SCRIPT_MALAYALAM . 26)
            (G_UNICODE_SCRIPT_MONGOLIAN . 27)
            (G_UNICODE_SCRIPT_MYANMAR . 28)
            (G_UNICODE_SCRIPT_OGHAM . 29)
            (G_UNICODE_SCRIPT_OLD_ITALIC . 30)
            (G_UNICODE_SCRIPT_ORIYA . 31)
            (G_UNICODE_SCRIPT_RUNIC . 32)
            (G_UNICODE_SCRIPT_SINHALA . 33)
            (G_UNICODE_SCRIPT_SYRIAC . 34)
            (G_UNICODE_SCRIPT_TAMIL . 35)
            (G_UNICODE_SCRIPT_TELUGU . 36)
            (G_UNICODE_SCRIPT_THAANA . 37)
            (G_UNICODE_SCRIPT_THAI . 38)
            (G_UNICODE_SCRIPT_TIBETAN . 39)
            (G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL . 40)
            (G_UNICODE_SCRIPT_YI . 41)
            (G_UNICODE_SCRIPT_TAGALOG . 42)
            (G_UNICODE_SCRIPT_HANUNOO . 43)
            (G_UNICODE_SCRIPT_BUHID . 44)
            (G_UNICODE_SCRIPT_TAGBANWA . 45)
            (G_UNICODE_SCRIPT_BRAILLE . 46)
            (G_UNICODE_SCRIPT_CYPRIOT . 47)
            (G_UNICODE_SCRIPT_LIMBU . 48)
            (G_UNICODE_SCRIPT_OSMANYA . 49)
            (G_UNICODE_SCRIPT_SHAVIAN . 50)
            (G_UNICODE_SCRIPT_LINEAR_B . 51)
            (G_UNICODE_SCRIPT_TAI_LE . 52)
            (G_UNICODE_SCRIPT_UGARITIC . 53)
            (G_UNICODE_SCRIPT_NEW_TAI_LUE . 54)
            (G_UNICODE_SCRIPT_BUGINESE . 55)
            (G_UNICODE_SCRIPT_GLAGOLITIC . 56)
            (G_UNICODE_SCRIPT_TIFINAGH . 57)
            (G_UNICODE_SCRIPT_SYLOTI_NAGRI . 58)
            (G_UNICODE_SCRIPT_OLD_PERSIAN . 59)
            (G_UNICODE_SCRIPT_KHAROSHTHI . 60)
            (G_UNICODE_SCRIPT_UNKNOWN . 61)
            (G_UNICODE_SCRIPT_BALINESE . 62)
            (G_UNICODE_SCRIPT_CUNEIFORM . 63)
            (G_UNICODE_SCRIPT_PHOENICIAN . 64)
            (G_UNICODE_SCRIPT_PHAGS_PA . 65)
            (G_UNICODE_SCRIPT_NKO . 66)
            (G_UNICODE_SCRIPT_KAYAH_LI . 67)
            (G_UNICODE_SCRIPT_LEPCHA . 68)
            (G_UNICODE_SCRIPT_REJANG . 69)
            (G_UNICODE_SCRIPT_SUNDANESE . 70)
            (G_UNICODE_SCRIPT_SAURASHTRA . 71)
            (G_UNICODE_SCRIPT_CHAM . 72)
            (G_UNICODE_SCRIPT_OL_CHIKI . 73)
            (G_UNICODE_SCRIPT_VAI . 74)
            (G_UNICODE_SCRIPT_CARIAN . 75)
            (G_UNICODE_SCRIPT_LYCIAN . 76)
            (G_UNICODE_SCRIPT_LYDIAN . 77)
            (G_UNICODE_SCRIPT_AVESTAN . 78)
            (G_UNICODE_SCRIPT_BAMUM . 79)
            (G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS . 80)
            (G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC . 81)
            (G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI . 82)
            (G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN . 83)
            (G_UNICODE_SCRIPT_JAVANESE . 84)
            (G_UNICODE_SCRIPT_KAITHI . 85)
            (G_UNICODE_SCRIPT_LISU . 86)
            (G_UNICODE_SCRIPT_MEETEI_MAYEK . 87)
            (G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN . 88)
            (G_UNICODE_SCRIPT_OLD_TURKIC . 89)
            (G_UNICODE_SCRIPT_SAMARITAN . 90)
            (G_UNICODE_SCRIPT_TAI_THAM . 91)
            (G_UNICODE_SCRIPT_TAI_VIET . 92)
            (G_UNICODE_SCRIPT_BATAK . 93)
            (G_UNICODE_SCRIPT_BRAHMI . 94)
            (G_UNICODE_SCRIPT_MANDAIC . 95)
            (G_UNICODE_SCRIPT_CHAKMA . 96)
            (G_UNICODE_SCRIPT_MEROITIC_CURSIVE . 97)
            (G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS . 98)
            (G_UNICODE_SCRIPT_MIAO . 99)
            (G_UNICODE_SCRIPT_SHARADA . 100)
            (G_UNICODE_SCRIPT_SORA_SOMPENG . 101)
            (G_UNICODE_SCRIPT_TAKRI . 102)
            (G_UNICODE_SCRIPT_BASSA_VAH . 103)
            (G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN . 104)
            (G_UNICODE_SCRIPT_DUPLOYAN . 105)
            (G_UNICODE_SCRIPT_ELBASAN . 106)
            (G_UNICODE_SCRIPT_GRANTHA . 107)
            (G_UNICODE_SCRIPT_KHOJKI . 108)
            (G_UNICODE_SCRIPT_KHUDAWADI . 109)
            (G_UNICODE_SCRIPT_LINEAR_A . 110)
            (G_UNICODE_SCRIPT_MAHAJANI . 111)
            (G_UNICODE_SCRIPT_MANICHAEAN . 112)
            (G_UNICODE_SCRIPT_MENDE_KIKAKUI . 113)
            (G_UNICODE_SCRIPT_MODI . 114)
            (G_UNICODE_SCRIPT_MRO . 115)
            (G_UNICODE_SCRIPT_NABATAEAN . 116)
            (G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN . 117)
            (G_UNICODE_SCRIPT_OLD_PERMIC . 118)
            (G_UNICODE_SCRIPT_PAHAWH_HMONG . 119)
            (G_UNICODE_SCRIPT_PALMYRENE . 120)
            (G_UNICODE_SCRIPT_PAU_CIN_HAU . 121)
            (G_UNICODE_SCRIPT_PSALTER_PAHLAVI . 122)
            (G_UNICODE_SCRIPT_SIDDHAM . 123)
            (G_UNICODE_SCRIPT_TIRHUTA . 124)
            (G_UNICODE_SCRIPT_WARANG_CITI . 125)
            (G_UNICODE_SCRIPT_AHOM . 126)
            (G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS . 127)
            (G_UNICODE_SCRIPT_HATRAN . 128)
            (G_UNICODE_SCRIPT_MULTANI . 129)
            (G_UNICODE_SCRIPT_OLD_HUNGARIAN . 130)
            (G_UNICODE_SCRIPT_SIGNWRITING . 131)
            (G_UNICODE_SCRIPT_ADLAM . 132)
            (G_UNICODE_SCRIPT_BHAIKSUKI . 133)
            (G_UNICODE_SCRIPT_MARCHEN . 134)
            (G_UNICODE_SCRIPT_NEWA . 135)
            (G_UNICODE_SCRIPT_OSAGE . 136)
            (G_UNICODE_SCRIPT_TANGUT . 137)
            (G_NORMALIZE_DEFAULT . 0)
            (G_NORMALIZE_NFD . 0)
            (G_NORMALIZE_DEFAULT_COMPOSE . 1)
            (G_NORMALIZE_NFC . 1)
            (G_NORMALIZE_ALL . 2)
            (G_NORMALIZE_NFKD . 2)
            (G_NORMALIZE_ALL_COMPOSE . 3)
            (G_NORMALIZE_NFKC . 3)
            (G_IO_ERROR_NONE . 0)
            (G_IO_ERROR_AGAIN . 1)
            (G_IO_ERROR_INVAL . 2)
            (G_IO_ERROR_UNKNOWN . 3)
            (G_IO_CHANNEL_ERROR_FBIG . 0)
            (G_IO_CHANNEL_ERROR_INVAL . 1)
            (G_IO_CHANNEL_ERROR_IO . 2)
            (G_IO_CHANNEL_ERROR_ISDIR . 3)
            (G_IO_CHANNEL_ERROR_NOSPC . 4)
            (G_IO_CHANNEL_ERROR_NXIO . 5)
            (G_IO_CHANNEL_ERROR_OVERFLOW . 6)
            (G_IO_CHANNEL_ERROR_PIPE . 7)
            (G_IO_CHANNEL_ERROR_FAILED . 8)
            (G_IO_STATUS_ERROR . 0)
            (G_IO_STATUS_NORMAL . 1)
            (G_IO_STATUS_EOF . 2)
            (G_IO_STATUS_AGAIN . 3)
            (G_SEEK_CUR . 0)
            (G_SEEK_SET . 1)
            (G_SEEK_END . 2)
            (G_IO_FLAG_APPEND . 1)
            (G_IO_FLAG_NONBLOCK . 2)
            (G_IO_FLAG_IS_READABLE . 4)
            (G_IO_FLAG_IS_WRITABLE . 8)
            (G_IO_FLAG_IS_WRITEABLE . 8)
            (G_IO_FLAG_IS_SEEKABLE . 16)
            (G_IO_FLAG_MASK . 31)
            (G_IO_FLAG_GET_MASK . 31)
            (G_IO_FLAG_SET_MASK . 3)
            (G_KEY_FILE_ERROR_UNKNOWN_ENCODING . 0)
            (G_KEY_FILE_ERROR_PARSE . 1)
            (G_KEY_FILE_ERROR_NOT_FOUND . 2)
            (G_KEY_FILE_ERROR_KEY_NOT_FOUND . 3)
            (G_KEY_FILE_ERROR_GROUP_NOT_FOUND . 4)
            (G_KEY_FILE_ERROR_INVALID_VALUE . 5)
            (G_KEY_FILE_NONE . 0)
            (G_KEY_FILE_KEEP_COMMENTS . 1)
            (G_KEY_FILE_KEEP_TRANSLATIONS . 2)
            (G_MARKUP_ERROR_BAD_UTF8 . 0)
            (G_MARKUP_ERROR_EMPTY . 1)
            (G_MARKUP_ERROR_PARSE . 2)
            (G_MARKUP_ERROR_UNKNOWN_ELEMENT . 3)
            (G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE . 4)
            (G_MARKUP_ERROR_INVALID_CONTENT . 5)
            (G_MARKUP_ERROR_MISSING_ATTRIBUTE . 6)
            (G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG . 1)
            (G_MARKUP_TREAT_CDATA_AS_TEXT . 2)
            (G_MARKUP_PREFIX_ERROR_POSITION . 4)
            (G_MARKUP_IGNORE_QUALIFIED . 8)
            (G_MARKUP_COLLECT_INVALID . 0)
            (G_MARKUP_COLLECT_STRING . 1)
            (G_MARKUP_COLLECT_STRDUP . 2)
            (G_MARKUP_COLLECT_BOOLEAN . 3)
            (G_MARKUP_COLLECT_TRISTATE . 4)
            (G_MARKUP_COLLECT_OPTIONAL . 65536)
            (G_VARIANT_CLASS_BOOLEAN . 98)
            (G_VARIANT_CLASS_BYTE . 121)
            (G_VARIANT_CLASS_INT16 . 110)
            (G_VARIANT_CLASS_UINT16 . 113)
            (G_VARIANT_CLASS_INT32 . 105)
            (G_VARIANT_CLASS_UINT32 . 117)
            (G_VARIANT_CLASS_INT64 . 120)
            (G_VARIANT_CLASS_UINT64 . 116)
            (G_VARIANT_CLASS_HANDLE . 104)
            (G_VARIANT_CLASS_DOUBLE . 100)
            (G_VARIANT_CLASS_STRING . 115)
            (G_VARIANT_CLASS_OBJECT_PATH . 111)
            (G_VARIANT_CLASS_SIGNATURE . 103)
            (G_VARIANT_CLASS_VARIANT . 118)
            (G_VARIANT_CLASS_MAYBE . 109)
            (G_VARIANT_CLASS_ARRAY . 97)
            (G_VARIANT_CLASS_TUPLE . 40)
            (G_VARIANT_CLASS_DICT_ENTRY . 123)
            (G_VARIANT_PARSE_ERROR_FAILED . 0)
            (G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED . 1)
            (G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE . 2)
            (G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED
              .
              3)
            (G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END . 4)
            (G_VARIANT_PARSE_ERROR_INVALID_CHARACTER . 5)
            (G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING . 6)
            (G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH . 7)
            (G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE . 8)
            (G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING . 9)
            (G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE . 10)
            (G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE . 11)
            (G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG . 12)
            (G_VARIANT_PARSE_ERROR_TYPE_ERROR . 13)
            (G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN . 14)
            (G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD . 15)
            (G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT
              .
              16)
            (G_VARIANT_PARSE_ERROR_VALUE_EXPECTED . 17)
            (G_LOG_FLAG_RECURSION . 1)
            (G_LOG_FLAG_FATAL . 2)
            (G_LOG_LEVEL_ERROR . 4)
            (G_LOG_LEVEL_CRITICAL . 8)
            (G_LOG_LEVEL_WARNING . 16)
            (G_LOG_LEVEL_MESSAGE . 32)
            (G_LOG_LEVEL_INFO . 64)
            (G_LOG_LEVEL_DEBUG . 128)
            (G_LOG_LEVEL_MASK . -4)
            (G_LOG_WRITER_HANDLED . 1)
            (G_LOG_WRITER_UNHANDLED . 0)
            (G_OPTION_FLAG_NONE . 0)
            (G_OPTION_FLAG_HIDDEN . 1)
            (G_OPTION_FLAG_IN_MAIN . 2)
            (G_OPTION_FLAG_REVERSE . 4)
            (G_OPTION_FLAG_NO_ARG . 8)
            (G_OPTION_FLAG_FILENAME . 16)
            (G_OPTION_FLAG_OPTIONAL_ARG . 32)
            (G_OPTION_FLAG_NOALIAS . 64)
            (G_OPTION_ARG_NONE . 0)
            (G_OPTION_ARG_STRING . 1)
            (G_OPTION_ARG_INT . 2)
            (G_OPTION_ARG_CALLBACK . 3)
            (G_OPTION_ARG_FILENAME . 4)
            (G_OPTION_ARG_STRING_ARRAY . 5)
            (G_OPTION_ARG_FILENAME_ARRAY . 6)
            (G_OPTION_ARG_DOUBLE . 7)
            (G_OPTION_ARG_INT64 . 8)
            (G_OPTION_ERROR_UNKNOWN_OPTION . 0)
            (G_OPTION_ERROR_BAD_VALUE . 1)
            (G_OPTION_ERROR_FAILED . 2)
            (G_REGEX_ERROR_COMPILE . 0)
            (G_REGEX_ERROR_OPTIMIZE . 1)
            (G_REGEX_ERROR_REPLACE . 2)
            (G_REGEX_ERROR_MATCH . 3)
            (G_REGEX_ERROR_INTERNAL . 4)
            (G_REGEX_ERROR_STRAY_BACKSLASH . 101)
            (G_REGEX_ERROR_MISSING_CONTROL_CHAR . 102)
            (G_REGEX_ERROR_UNRECOGNIZED_ESCAPE . 103)
            (G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER . 104)
            (G_REGEX_ERROR_QUANTIFIER_TOO_BIG . 105)
            (G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS
              .
              106)
            (G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS
              .
              107)
            (G_REGEX_ERROR_RANGE_OUT_OF_ORDER . 108)
            (G_REGEX_ERROR_NOTHING_TO_REPEAT . 109)
            (G_REGEX_ERROR_UNRECOGNIZED_CHARACTER . 112)
            (G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS
              .
              113)
            (G_REGEX_ERROR_UNMATCHED_PARENTHESIS . 114)
            (G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE
              .
              115)
            (G_REGEX_ERROR_UNTERMINATED_COMMENT . 118)
            (G_REGEX_ERROR_EXPRESSION_TOO_LARGE . 120)
            (G_REGEX_ERROR_MEMORY_ERROR . 121)
            (G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND . 125)
            (G_REGEX_ERROR_MALFORMED_CONDITION . 126)
            (G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES
              .
              127)
            (G_REGEX_ERROR_ASSERTION_EXPECTED . 128)
            (G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME . 130)
            (G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED
              .
              131)
            (G_REGEX_ERROR_HEX_CODE_TOO_LARGE . 134)
            (G_REGEX_ERROR_INVALID_CONDITION . 135)
            (G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND
              .
              136)
            (G_REGEX_ERROR_INFINITE_LOOP . 140)
            (G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR
              .
              142)
            (G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME . 143)
            (G_REGEX_ERROR_MALFORMED_PROPERTY . 146)
            (G_REGEX_ERROR_UNKNOWN_PROPERTY . 147)
            (G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG . 148)
            (G_REGEX_ERROR_TOO_MANY_SUBPATTERNS . 149)
            (G_REGEX_ERROR_INVALID_OCTAL_VALUE . 151)
            (G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE . 154)
            (G_REGEX_ERROR_DEFINE_REPETION . 155)
            (G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS
              .
              156)
            (G_REGEX_ERROR_MISSING_BACK_REFERENCE . 157)
            (G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE . 158)
            (G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN
              .
              159)
            (G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB
              .
              160)
            (G_REGEX_ERROR_NUMBER_TOO_BIG . 161)
            (G_REGEX_ERROR_MISSING_SUBPATTERN_NAME . 162)
            (G_REGEX_ERROR_MISSING_DIGIT . 163)
            (G_REGEX_ERROR_INVALID_DATA_CHARACTER . 164)
            (G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME . 165)
            (G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED
              .
              166)
            (G_REGEX_ERROR_INVALID_CONTROL_CHAR . 168)
            (G_REGEX_ERROR_MISSING_NAME . 169)
            (G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS . 171)
            (G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES . 172)
            (G_REGEX_ERROR_NAME_TOO_LONG . 175)
            (G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE . 176)
            (G_REGEX_CASELESS . 1)
            (G_REGEX_MULTILINE . 2)
            (G_REGEX_DOTALL . 4)
            (G_REGEX_EXTENDED . 8)
            (G_REGEX_ANCHORED . 16)
            (G_REGEX_DOLLAR_ENDONLY . 32)
            (G_REGEX_UNGREEDY . 512)
            (G_REGEX_RAW . 2048)
            (G_REGEX_NO_AUTO_CAPTURE . 4096)
            (G_REGEX_OPTIMIZE . 8192)
            (G_REGEX_FIRSTLINE . 262144)
            (G_REGEX_DUPNAMES . 524288)
            (G_REGEX_NEWLINE_CR . 1048576)
            (G_REGEX_NEWLINE_LF . 2097152)
            (G_REGEX_NEWLINE_CRLF . 3145728)
            (G_REGEX_NEWLINE_ANYCRLF . 5242880)
            (G_REGEX_BSR_ANYCRLF . 8388608)
            (G_REGEX_JAVASCRIPT_COMPAT . 33554432)
            (G_REGEX_MATCH_ANCHORED . 16)
            (G_REGEX_MATCH_NOTBOL . 128)
            (G_REGEX_MATCH_NOTEOL . 256)
            (G_REGEX_MATCH_NOTEMPTY . 1024)
            (G_REGEX_MATCH_PARTIAL . 32768)
            (G_REGEX_MATCH_NEWLINE_CR . 1048576)
            (G_REGEX_MATCH_NEWLINE_LF . 2097152)
            (G_REGEX_MATCH_NEWLINE_CRLF . 3145728)
            (G_REGEX_MATCH_NEWLINE_ANY . 4194304)
            (G_REGEX_MATCH_NEWLINE_ANYCRLF . 5242880)
            (G_REGEX_MATCH_BSR_ANYCRLF . 8388608)
            (G_REGEX_MATCH_BSR_ANY . 16777216)
            (G_REGEX_MATCH_PARTIAL_SOFT . 32768)
            (G_REGEX_MATCH_PARTIAL_HARD . 134217728)
            (G_REGEX_MATCH_NOTEMPTY_ATSTART . 268435456)
            (G_ERR_UNKNOWN . 0)
            (G_ERR_UNEXP_EOF . 1)
            (G_ERR_UNEXP_EOF_IN_STRING . 2)
            (G_ERR_UNEXP_EOF_IN_COMMENT . 3)
            (G_ERR_NON_DIGIT_IN_CONST . 4)
            (G_ERR_DIGIT_RADIX . 5)
            (G_ERR_FLOAT_RADIX . 6)
            (G_ERR_FLOAT_MALFORMED . 7)
            (G_TOKEN_EOF . 0)
            (G_TOKEN_LEFT_PAREN . 40)
            (G_TOKEN_RIGHT_PAREN . 41)
            (G_TOKEN_LEFT_CURLY . 123)
            (G_TOKEN_RIGHT_CURLY . 125)
            (G_TOKEN_LEFT_BRACE . 91)
            (G_TOKEN_RIGHT_BRACE . 93)
            (G_TOKEN_EQUAL_SIGN . 61)
            (G_TOKEN_COMMA . 44)
            (G_TOKEN_NONE . 256)
            (G_TOKEN_ERROR . 257)
            (G_TOKEN_CHAR . 258)
            (G_TOKEN_BINARY . 259)
            (G_TOKEN_OCTAL . 260)
            (G_TOKEN_INT . 261)
            (G_TOKEN_HEX . 262)
            (G_TOKEN_FLOAT . 263)
            (G_TOKEN_STRING . 264)
            (G_TOKEN_SYMBOL . 265)
            (G_TOKEN_IDENTIFIER . 266)
            (G_TOKEN_IDENTIFIER_NULL . 267)
            (G_TOKEN_COMMENT_SINGLE . 268)
            (G_TOKEN_COMMENT_MULTI . 269)
            (G_TOKEN_LAST . 270)
            (G_SHELL_ERROR_BAD_QUOTING . 0)
            (G_SHELL_ERROR_EMPTY_STRING . 1)
            (G_SHELL_ERROR_FAILED . 2)
            (G_SLICE_CONFIG_ALWAYS_MALLOC . 1)
            (G_SLICE_CONFIG_BYPASS_MAGAZINES . 2)
            (G_SLICE_CONFIG_WORKING_SET_MSECS . 3)
            (G_SLICE_CONFIG_COLOR_INCREMENT . 4)
            (G_SLICE_CONFIG_CHUNK_SIZES . 5)
            (G_SLICE_CONFIG_CONTENTION_COUNTER . 6)
            (G_SPAWN_ERROR_FORK . 0)
            (G_SPAWN_ERROR_READ . 1)
            (G_SPAWN_ERROR_CHDIR . 2)
            (G_SPAWN_ERROR_ACCES . 3)
            (G_SPAWN_ERROR_PERM . 4)
            (G_SPAWN_ERROR_TOO_BIG . 5)
            (G_SPAWN_ERROR_2BIG . 5)
            (G_SPAWN_ERROR_NOEXEC . 6)
            (G_SPAWN_ERROR_NAMETOOLONG . 7)
            (G_SPAWN_ERROR_NOENT . 8)
            (G_SPAWN_ERROR_NOMEM . 9)
            (G_SPAWN_ERROR_NOTDIR . 10)
            (G_SPAWN_ERROR_LOOP . 11)
            (G_SPAWN_ERROR_TXTBUSY . 12)
            (G_SPAWN_ERROR_IO . 13)
            (G_SPAWN_ERROR_NFILE . 14)
            (G_SPAWN_ERROR_MFILE . 15)
            (G_SPAWN_ERROR_INVAL . 16)
            (G_SPAWN_ERROR_ISDIR . 17)
            (G_SPAWN_ERROR_LIBBAD . 18)
            (G_SPAWN_ERROR_FAILED . 19)
            (G_SPAWN_DEFAULT . 0)
            (G_SPAWN_LEAVE_DESCRIPTORS_OPEN . 1)
            (G_SPAWN_DO_NOT_REAP_CHILD . 2)
            (G_SPAWN_SEARCH_PATH . 4)
            (G_SPAWN_STDOUT_TO_DEV_NULL . 8)
            (G_SPAWN_STDERR_TO_DEV_NULL . 16)
            (G_SPAWN_CHILD_INHERITS_STDIN . 32)
            (G_SPAWN_FILE_AND_ARGV_ZERO . 64)
            (G_SPAWN_SEARCH_PATH_FROM_ENVP . 128)
            (G_SPAWN_CLOEXEC_PIPES . 256)
            (G_ASCII_ALNUM . 1)
            (G_ASCII_ALPHA . 2)
            (G_ASCII_CNTRL . 4)
            (G_ASCII_DIGIT . 8)
            (G_ASCII_GRAPH . 16)
            (G_ASCII_LOWER . 32)
            (G_ASCII_PRINT . 64)
            (G_ASCII_PUNCT . 128)
            (G_ASCII_SPACE . 256)
            (G_ASCII_UPPER . 512)
            (G_ASCII_XDIGIT . 1024)
            (G_TEST_TRAP_SILENCE_STDOUT . 128)
            (G_TEST_TRAP_SILENCE_STDERR . 256)
            (G_TEST_TRAP_INHERIT_STDIN . 512)
            (G_TEST_SUBPROCESS_INHERIT_STDIN . 1)
            (G_TEST_SUBPROCESS_INHERIT_STDOUT . 2)
            (G_TEST_SUBPROCESS_INHERIT_STDERR . 4)
            (G_TEST_LOG_NONE . 0)
            (G_TEST_LOG_ERROR . 1)
            (G_TEST_LOG_START_BINARY . 2)
            (G_TEST_LOG_LIST_CASE . 3)
            (G_TEST_LOG_SKIP_CASE . 4)
            (G_TEST_LOG_START_CASE . 5)
            (G_TEST_LOG_STOP_CASE . 6)
            (G_TEST_LOG_MIN_RESULT . 7)
            (G_TEST_LOG_MAX_RESULT . 8)
            (G_TEST_LOG_MESSAGE . 9)
            (G_TEST_LOG_START_SUITE . 10)
            (G_TEST_LOG_STOP_SUITE . 11)
            (G_TEST_DIST . 0)
            (G_TEST_BUILT . 1)
            (G_THREAD_PRIORITY_LOW . 0)
            (G_THREAD_PRIORITY_NORMAL . 1)
            (G_THREAD_PRIORITY_HIGH . 2)
            (G_THREAD_PRIORITY_URGENT . 3)
            (QOS_CLASS_USER_INTERACTIVE . 33)
            (QOS_CLASS_USER_INITIATED . 25)
            (QOS_CLASS_DEFAULT . 21)
            (QOS_CLASS_UTILITY . 17)
            (QOS_CLASS_BACKGROUND . 9)
            (QOS_CLASS_UNSPECIFIED . 0)
            (G_LITTLE_ENDIAN . 1234)
            (G_BIG_ENDIAN . 4321)
            (G_PDP_ENDIAN . 3412)
            (G_DATALIST_FLAGS_MASK . 3)
            (G_DIR_SEPARATOR_S . "/")
            (G_SEARCHPATH_SEPARATOR_S . ":")
            (G_MEM_ALIGN . 8)
            (G_PRIORITY_HIGH . -100)
            (G_PRIORITY_DEFAULT . 0)
            (G_PRIORITY_HIGH_IDLE . 100)
            (G_PRIORITY_DEFAULT_IDLE . 200)
            (G_PRIORITY_LOW . 300)
            (G_UNICODE_COMBINING_MARK . 10)
            (G_UNICHAR_MAX_DECOMPOSITION_LENGTH . 18)
            (G_KEY_FILE_DESKTOP_GROUP . "Desktop Entry")
            (G_KEY_FILE_DESKTOP_KEY_TYPE . "Type")
            (G_KEY_FILE_DESKTOP_KEY_VERSION . "Version")
            (G_KEY_FILE_DESKTOP_KEY_NAME . "Name")
            (G_KEY_FILE_DESKTOP_KEY_GENERIC_NAME
              .
              "GenericName")
            (G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY . "NoDisplay")
            (G_KEY_FILE_DESKTOP_KEY_COMMENT . "Comment")
            (G_KEY_FILE_DESKTOP_KEY_ICON . "Icon")
            (G_KEY_FILE_DESKTOP_KEY_HIDDEN . "Hidden")
            (G_KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN
              .
              "OnlyShowIn")
            (G_KEY_FILE_DESKTOP_KEY_NOT_SHOW_IN
              .
              "NotShowIn")
            (G_KEY_FILE_DESKTOP_KEY_TRY_EXEC . "TryExec")
            (G_KEY_FILE_DESKTOP_KEY_EXEC . "Exec")
            (G_KEY_FILE_DESKTOP_KEY_PATH . "Path")
            (G_KEY_FILE_DESKTOP_KEY_TERMINAL . "Terminal")
            (G_KEY_FILE_DESKTOP_KEY_MIME_TYPE . "MimeType")
            (G_KEY_FILE_DESKTOP_KEY_CATEGORIES
              .
              "Categories")
            (G_KEY_FILE_DESKTOP_KEY_STARTUP_NOTIFY
              .
              "StartupNotify")
            (G_KEY_FILE_DESKTOP_KEY_STARTUP_WM_CLASS
              .
              "StartupWMClass")
            (G_KEY_FILE_DESKTOP_KEY_URL . "URL")
            (G_KEY_FILE_DESKTOP_KEY_DBUS_ACTIVATABLE
              .
              "DBusActivatable")
            (G_KEY_FILE_DESKTOP_KEY_ACTIONS . "Actions")
            (G_KEY_FILE_DESKTOP_TYPE_APPLICATION
              .
              "Application")
            (G_KEY_FILE_DESKTOP_TYPE_LINK . "Link")
            (G_KEY_FILE_DESKTOP_TYPE_DIRECTORY . "Directory")
            (G_OPTION_REMAINING . "")
            (G_CSET_A_2_Z . "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
            (G_CSET_a_2_z . "abcdefghijklmnopqrstuvwxyz")
            (G_CSET_DIGITS . "0123456789")
            (G_CSET_LATINC
              .
              "ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝÞ")
            (G_CSET_LATINS
              .
              "ßàáâãäåæçèéêëìíîïðñòóôõöøùúûüýþÿ")
            (G_STR_DELIMITERS . "_-|> <.")
            (G_USEC_PER_SEC . 1000000)
            (G_URI_RESERVED_CHARS_GENERIC_DELIMITERS
              .
              ":/?#[]@")
            (G_URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS
              .
              "!$&'()*+,;=")
            (G_URI_RESERVED_CHARS_ALLOWED_IN_PATH_ELEMENT
              .
              "!$&'()*+,;=:@")
            (G_URI_RESERVED_CHARS_ALLOWED_IN_PATH
              .
              "!$&'()*+,;=:@/")
            (G_URI_RESERVED_CHARS_ALLOWED_IN_USERINFO
              .
              "!$&'()*+,;=:")
            (G_ALLOC_ONLY . 1)
            (G_ALLOC_AND_FREE . 2)
            (G_ALLOCATOR_LIST . 1)
            (G_ALLOCATOR_SLIST . 2)
            (G_ALLOCATOR_NODE . 3))))
    (lambda (k) (assq-ref sym-tab k))))
(export glib-symbol-val)

(define (unwrap-enum obj)
  (cond ((number? obj) obj)
        ((symbol? obj) (glib-symbol-val obj))
        ((fh-object? obj) (struct-ref obj 0))
        (else (error "type mismatch"))))

(define glib-types
  '("gfloat" "gdouble" "gpointer" "gconstpointer" (union . "_GDoubleIEEE754"
    ) "GDoubleIEEE754" (union . "_GFloatIEEE754") "GFloatIEEE754" "GTimeVal" (
    struct . "_GTimeVal") "GBytes" "GArray" "GByteArray" "GPtrArray" (struct 
    . "_GArray") (struct . "_GByteArray") (struct . "_GPtrArray") "GError" (
    struct . "_GError") "GDebugKey" (struct . "_GDebugKey") "GThread" (union 
    . "_GMutex") "GMutex" "GRecMutex" "GRWLock" "GCond" "GPrivate" "GOnce" (
    struct . "_GRWLock") (struct . "_GCond") (struct . "_GRecMutex") (struct 
    . "_GPrivate") (struct . "_GOnce") (pointer . "GMutexLocker") 
    "GAsyncQueue" "GBookmarkFile" "GChecksum" "GData" "GDate" (struct . 
    "_GDate") "GTimeZone" "GDateTime" "GDir" "GMemVTable" (struct . 
    "_GMemVTable") "GNode" (struct . "_GNode") "GList" (struct . "_GList") 
    "GHashTable" "GHashTableIter" (struct . "_GHashTableIter") "GHmac" "GHook"
    "GHookList" (struct . "_GHookList") (struct . "_GHook") "GPollFD" (struct
    . "_GPollFD") "GSList" (struct . "_GSList") "GMainContext" "GMainLoop" 
    "GSource" "GSourcePrivate" "GSourceCallbackFuncs" "GSourceFuncs" (struct 
    . "_GSource") (struct . "_GSourceCallbackFuncs") (struct . "_GSourceFuncs"
    ) "GString" (struct . "_GString") "GIOChannel" "GIOFuncs" (struct . 
    "_GIOChannel") (struct . "_GIOFuncs") "GKeyFile" "GMappedFile" 
    "GMarkupParseContext" "GMarkupParser" (struct . "_GMarkupParser") 
    "GVariantType" "GVariant" "GVariantIter" (struct . "_GVariantIter") 
    "GVariantBuilder" (struct . "_GVariantBuilder") "GVariantDict" (struct . 
    "_GVariantDict") "GLogField" (struct . "_GLogField") "GOptionContext" 
    "GOptionGroup" "GOptionEntry" (struct . "_GOptionEntry") "GPatternSpec" 
    "GQueue" (struct . "_GQueue") "GRand" "GRegex" "GMatchInfo" "GScanner" 
    "GScannerConfig" (union . "_GTokenValue") "GTokenValue" (struct . 
    "_GScannerConfig") (struct . "_GScanner") "GSequence" "GSequenceIter" 
    "GStrv" "GStringChunk" "GTestCase" "GTestSuite" "GTestConfig" 
    "GTestLogMsg" "GTestLogBuffer" "GThreadPool" (struct . "_GThreadPool") 
    "GTimer" "GTrashStack" (struct . "_GTrashStack") "GTree" "GAllocator" 
    "GMemChunk" "GCache" "GCompletion" (struct . "_GCompletion") "GRelation" 
    "GTuples" (struct . "_GTuples") (struct . "_GThread") "GThreadFunctions" (
    struct . "_GThreadFunctions") "GStaticMutex" "GStaticRecMutex" (struct . 
    "_GStaticRecMutex") "GStaticRWLock" (struct . "_GStaticRWLock") 
    "GStaticPrivate" (struct . "_GStaticPrivate") "GAsyncQueue_autoptr" 
    "GBookmarkFile_autoptr" "GBytes_autoptr" "GChecksum_autoptr" 
    "GDateTime_autoptr" "GDir_autoptr" "GError_autoptr" "GHashTable_autoptr" 
    "GHmac_autoptr" "GIOChannel_autoptr" "GKeyFile_autoptr" "GList_autoptr" 
    "GArray_autoptr" "GPtrArray_autoptr" "GByteArray_autoptr" 
    "GMainContext_autoptr" "GMainLoop_autoptr" "GSource_autoptr" 
    "GMappedFile_autoptr" "GMarkupParseContext_autoptr" "GNode_autoptr" 
    "GOptionContext_autoptr" "GOptionGroup_autoptr" "GPatternSpec_autoptr" 
    "GQueue_autoptr" "GRand_autoptr" "GRegex_autoptr" "GMatchInfo_autoptr" 
    "GScanner_autoptr" "GSequence_autoptr" "GSList_autoptr" "GString_autoptr" 
    "GStringChunk_autoptr" "GThread_autoptr" "GMutexLocker_autoptr" 
    "GTimer_autoptr" "GTimeZone_autoptr" "GTree_autoptr" "GVariant_autoptr" 
    "GVariantBuilder_autoptr" "GVariantIter_autoptr" "GVariantDict_autoptr" 
    "GVariantType_autoptr"))
;;(export glibtypes)

(define gpointer*-desc
  (bs:pointer gpointer-desc))

(export gpointer*-desc)

(define-fh-pointer-type gpointer* gpointer*-desc)

(define gdouble*-desc (bs:pointer double))

(export gdouble*-desc)

(define-fh-pointer-type gdouble* gdouble*-desc)

;; --- last line ---
