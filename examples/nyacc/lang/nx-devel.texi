\input texinfo.tex
@setfilename nx-devel.info
@settitle Developing NYACC Extension Languages

@headings off
@everyfooting @| @thispage @|

@node Top
@top Developing NYACC Extension Languages
@format
Matt Wette
July 2018
@end format

@heading ideas

In JS lexer, maybe double-newline should be ';'.  So in JS, we can parse
@example
TryStatement
  : Try stmts Catch stmts Finally stmts
  | Try stmts Catch stmts [';']
@end example

Rule: all N-languages should allow @code{#! ... !#} as a comment.
and #L to end of line as a comment.

Note: Guile reads language files with encoding always set to UTF-8.

Note: Guile assumes reader/compiler will return EOF on end of input.

Note: Extensions should allow identifiers to start with `$'.

Note: If language functions have special variables the convention is
to pass via keyword aruments.  For example, in javacript all functions
accept the @code{#:this} keyword.  (I should add @code{#:nargin} etc.
to matlab.)

Question: Should associative arrays be indexed by symbols or strings?

@heading Read, Parse and Compile

A language may have two or three phases to get to lower level.
The first is parsing which reads text and turns into the languages own
intermediate form, typically for one the language compilers.  There
may be an additional step using a parser, which converts output from
the reader into something for the compiler.  Tree-IL works this way:
it has an intermediate text form which can be generated using scheme
list expressions and binary form using scheme records.

@subheading Compiling a File 

Define a joint is
@enumerate
@item javascript to tree-il
@item tree-il to cps
@item cps to bytecode
@end enumerate

The signature is
@example
compile exp env0 opts => exp env2 env1
@end example
for a chain of joints, compile-file will run the reader to get an
expression then iterate on the elements of the joint, providing
env1 as continuation to env0 in the next iteration.
On iteration of the next expression env0 is env?

Say the compilers are @code{comp:jvs->til} and @code{comp:til->byt}.
(We will ignore options for now.)  Let's pretend that cps is the joint
(even though tree-il is a possible joint).  We use ``mid'' to
designate the joint.  Then the program that generate a bytecode file is
@lisp
(let*-values
  ((jvs-c0) (jvs-def-env))
  ;;
  ((til-x1 til-e1 jvs-c1) (comp:jvs->til (read-jvs port jvs-c0) jvs-c0))
  ((cps-x1 cps-e1 til-c1) (comp:til->cps til-x1 til-e1))
  ;;
  ((til-x2 til-e2 jvs-c2) (comp:jvs->til (read-jvs port jvs-c1) jvs-c1))
  ((cps-x2 cps-e2 til-c2) (comp:til->cps til-x2 til-e2))
  ;;
  ((exps) (cps-joiner (list cps-x1 cps-x2) cps-e2)
  ((byt byt-e5 bytcps-c1) (comp:cps->byt exps cps-e2))
@end lisp
This seems to say that a compiler can use it's own env but needs to
pass out an env that can be used by lower levels.

Note that if the top-level language is a joint, then the compiler
will just read expressions, combine them and then send to the compiler
in one shot.

@subheading Compiling a File

@heading Common Procedures

@deffn {Procedure} lookup name dict => (lexical ...)|(toplevel ...)|(@@@@ ...)
where @var{name} is a string and @var{dict} is an a-list dictionary
@end deffn

For langauges that generate automatic definitions (e.g., by
assignment) our technique is to top wrap top-level statements in
a TIL @code{seq}-string to define variables if needed. Here is TIL code:
@lisp
(let (var) (,var) ((call (toplevel module-local-variable)
		         (call (toplevel current-module))
		         (const ,sym)))
  (if (lexical var ,var) (void) (define ,sym (void))))
@end lisp
where @code{sym} is the symbol for which we want a toplevel slot
assigned. The routine to generate this is called
@code{make-toplevel-defcheck} and the routine which wraps a toplevel
TIL expression with symbols appearing in our symbol table is called
@code{add-topdefs}.  Right now this is in @file{matlab/compile-tree-il.scm}

@deffn {Procedure} compile-tree-il exp env opts => exp env cenv
On input @var{exp} is the SXML from our reader, @var{env} is ``an
environment'', and @var{opts} is a keyword list of options.  The procedure
returns three values: the compiled expression, the corresponding environment
for the target for the compiled language, and a continuation environment
for the next source tree.
@end deffn

@subheading Looping

In @code{fD} we add lexical variable for the break and continue prompt tags:
@lisp
 ((for . ,rest)
  (values tree '() (add-lexicals "break" "continue" (push-scope
  dict))))
@end lisp



@heading Modules

@subheading @file{system/base/compile}) 
In the procedure @code{read-and-compile} which iterates on
@code{read-and-parse} to read one expression at a time to
@enumerate
@item read-and-parse env port cenv => exp
@item 
@end enumerate

We refer to ``from'' as ``top'' and ``to'' as ``bottom''.  For our
example, javascript is at the top and bytecode is at the bottom.

If the language spec defines a parser then read, is followed by parse.

find-language-joint:
This finds the highest level language that provides a means for joining
expressions, and called this the ``joint.''  The reader will parse
and compile one expression at a time to the joint, combine
expressions, then compile the sequence to the bottom.

We use reader-parser to refer to reader or reader, followed by parser,
if the parser exists.

language spec fields:
@table
@item reader
@code{reader port env -> exp} reads from port and generates an expression
@item parser
@code{parser env -> env} converts reader expression to input for
compiler; an example is tree-il which has ``external form'' that can
be pretty-printed and ``internal form'' which is a record tree
@item joiner
@code{joiner exp-list -> exp} joins a list of expressions into a
single expression.  In Scheme: (exp ...) -> (begin exp exp exp) so
the joiner is @code{(cons 'begin exps)}.
@end table

On EOF the reader-parser should return 

Signatures
@example
reader port cenv -> exp
parser exp -> exp
compiler 
@end example


@bye
