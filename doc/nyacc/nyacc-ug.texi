\input texinfo.tex
@setfilename nyacc-ug.info
@settitle Not Yet Another Compiler Compiler!

@copying
Copyright (C) 2015,2016 -- Matthew R. Wette.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included with the distribution as COPYING.DOC.
@end copying

@macro nyacc
@sc{NYACC}@ 
@end macro

@clear skip

@dircategory The Algorithmic Language Scheme
@direntry
* NYACC User Guide: (nyacc).    The NYACC user's guide.
@end direntry

@titlepage
@title Not Yet Another Compiler-Compiler!
@subtitle A LALR(1) Parser Generator Implemented in Guile
@author Matt Wette
@end titlepage

@ifnottex
@node Top, Demonstration, (dir), (dir)
@top NYACC User's Guide
@end ifnottex

@menu
* Demonstration::
* Parsing::
* Translation::
* Administrative::
* TODOs::
* References::
@end menu


@node Demonstration,, Parsing, Top
@chapter Demonstration

WARNING: This manual is work in progress.

A LALR(1) parser is a pushdown automata for parsing computer languages.
In this tool the automata, along with its auxiliary parameters
(e.g., actions), is called a @emph{machine}.  The grammar is called 
the @emph{specification}.  The program that processes, driven by the 
machine, input token to generate a final output, or error, is 
the @emph{parser}.

@section A Simple Batch Calculator

A simplest way to introduce working with @nyacc is to work through
an example.  Consider the following contents of the file @file{calc1.scm}
in the distributed directory @code{examples/nyacc/lang/calc/}:
@example
(add-to-load-path "../../../../module")

(use-modules (nyacc lalr))
(use-modules (nyacc lex))
(use-modules (nyacc parse))

(define spec
  (lalr-spec
   (prec< (left "+" "-") (left "*" "/"))
   (start expr)
   (grammar
    (expr
     (expr "+" expr ($$ (+ $1 $3)))
     (expr "-" expr ($$ (- $1 $3)))
     (expr "*" expr ($$ (* $1 $3)))
     (expr "/" expr ($$ (/ $1 $3)))
     ($fixed ($$ (string->number $1)))
     ($float ($$ (string->number $1)))
     ("(" expr ")" ($$ $2))))))

(define mach (make-lalr-machine spec))
(define raw-parser (make-lalr-parser mach))
(define gen-lexer (make-lexer-generator (lalr-match-table mach)))

(define (calc1-eval str)
  (with-input-from-string str
    (lambda () (raw-parser (gen-lexer)))))

(define (calc1-demo string)
  (simple-format #t "~A => ~A\n" string (calc1-eval string)))

(demo "2 + 2")
@end example
Here is an explanation of the above code:
@enumerate
@item
The relevent modules are imported using Guile's @code{use-modules} syntax.
@item
The syntax form @code{lalr-spec} is used to generate a (canonical)
specification from the grammar and options provided in the form.
@item
The @code{prec<} directive indicates that 
the tokens appearing in the sequence of associativity directives
should be interpreted in increasing order of precedence.  The
associativity statements @code{left} indicate that the tokens have left
associativity.  So, in this grammar @code{+}, @code{-}, @code{*}, and
@code{/} are left associative, @code{*} and @code{/} have equal
precedence, @code{+} and @code{-} have equal precedence, but @code{*}
and @code{/} have higher precedence than @code{+} and @code{-}.
@item
The @code{start} directive indicates which left-hand symbol in the
grammar is the starting symbol for the grammar.
@item
The @code{grammar} directive is used to specify the production rules.
In the example above one left-hand side is associated with multiple
right hand sides.  But this is not required.
@itemize
@item
Multiple right-hand sides can be written for a single left-hand side.  
@item
Non-terminals are indicated using symbols (e.g., @code{expr}).
@item
Terminals are indicated using constants or reserved symbols.
Constants take the form of string literals (e.g.,@code{"+"}),
character literals (e.g., @code{#\+}), or quoted symbols
(e.g., @code{'+}).  In this example, reserved symbols used as
terminals are @code{$fixed} and @code{$float}.
Note that tokens or terminals to not need to be declared as in bison
or the Guile lalr module.
@item
The reserved symbols @code{$fixed} and @code{$float} indicate an
unsigned integer and floating point number, respectively.  The 
@nyacc procedures for generating lexical analyzers will emit this token
when the corresponding numbers are detected in the input.  In general,
symbols starting with @code{$} are reserved by @nyacc.
@item
Within the right-hand side specification a @code{$$} form is used to
specify an action associated with the rule.  Ordinarily, the action
appears as the last element of a right-hand side, but mid-rule
actions are possible.  Inside the @code{$$} form, the variables
@code{$1}, @code{$2}, etc.@  refer to the symantic value of the
corresponding item in the rule.
@item
The expression returned by @code{lalr-spec} is an association list;
you can peek at the internals with Guile.
@end itemize
@item
The data structures comprising the automaton (aka machine) is
generated using the procedure @code{make-lalr-machine}.  This routine
does the bulk of the processing to produce an LALR(1) automata.  The
value returned by this procedure is also an associative list.
@item
Generating a usable parser procedure requires a few steps.  The first is
to create a raw parser:
@example
(define raw-parser (make-lalr-parser mach)))
@end example
Note that @code{raw-parser} is a thunk: a procedure of no arguments.
This code generates a parser (procedure) from the machine and the
match table.  The match table is the handshake between the lexical
analyzer and the parser for encoding tokens.  In this example the
match table is symbol based, but there is an option to hash these
symbols into integers.  @xref{Hashing and Compacting}
@item
The next task is to create a generator for lexical analyzers.  This is
performed as follows: 
@example
(define gen-lexer (make-lexer-generator (lalr-match-table mach)))
@end example
We create a generator here because a lexical analyzer may require
internal state (e.g., line number, mode).  The generator is
constructed from the @dfn{match table} provided by the machine.  The
procedure @code{make-lexer-generator} is imported from the module
@code{(nyacc lex)}.  Optional arguments to @code{make-lexer-generator}
allow the user to specify custom readers for identifiers, comments,
numbers, etc.  @xref{lex}
@item
The actual parser/evaluator we use calls the raw parser with a
lexical analyser created from the generator.
@example
(define (calc1-eval str)
  (with-input-from-string str
    (lambda () (raw-parser (gen-lexer)))))
@end example
The lexical analyzer reads code from @code{(current-input-port)} so we
set up the environment using @code{with-input-from-string}. 
@xref{Input and Output,,,guile}
@item 
And now we can run it:
@example
(calc1-eval "1 + 1") => 2
@end example
@end enumerate

If we execute the example file above we should get the following:
@example
$ guile calc1.scm
2 + 2 => 4
$
@end example


@section An Interactive Calculator

If one uses the above code to make an interactive parser it will get
stuck, requiring multiple return keystrokes to get output.  If you
replace @code{make-lalr-parser} with @code{make-lalr-ia-parser} then
you get an interactive parser.  See the example @file{calc2.scm} in the
same directory.  (Note: If you look at the @nyacc parse module you
will see that the baser parser is quite a bit cleaner than the
ia-parser, hence the motivation to provide both, at least for now.)
Here is an interactive calculator.  Note that it uses mid-rule actions
and other features not discussed above.  Details are in the sequel.

@example
(use-modules (nyacc lalr))
(use-modules (nyacc lex))
(use-modules (nyacc parse))

(define (next) (newline) (display "> ") (force-output))

(define calc2-spec
  (lalr-spec
   (prec< (left "+" "-") (left "*" "/"))
   (start stmt-list)
   (grammar
    (stmt-list
     (stmt)
     (stmt-list stmt))
    (stmt
     (expr ($$ (display $1) (next)) "\n"))
    (expr
     ($empty)
     (expr "+" expr ($$ (+ $1 $3)))
     (expr "-" expr ($$ (- $1 $3)))
     (expr "*" expr ($$ (* $1 $3)))
     (expr "/" expr ($$ (/ $1 $3)))
     ($fixed ($$ (string->number $1)))
     ($float ($$ (string->number $1)))
     ("(" expr ")" ($$ $2))))))

(define calc2-mach (make-lalr-machine calc2-spec))
(define match-table (assq-ref calc2-mach 'mtab))
(define parse (make-lalr-ia-parser calc2-mach))
(define gen-lexer
  (make-lexer-generator match-table #:space-chars " \t"))

(next)
(parse (gen-lexer))
@end example

@section Generating a Language to run in Guile

One cool feature of Guile is that it provides a backend infrastructure
for evaluation of multiple languages.   
The files @file{parser.scm}, @file{compiler.scm} in the
@file{nyacc/lang/calc} directory and @file{spec.scm} in the
@file{language/calc} directory implement our calculator in Guile.  To
execute the calculator as follows:
@example
$ cd examples
$ guile -L ../module -L .
...
scheme@@(guile-user)> ,L calc
...
Happy hacking with calc!  To switch back, type `,L scheme'.
calc@@(guile-user)> 1 + 1
2
calc@@(guile-user)> 
@end example
Our evaluator uses SXML as the intermediate representation between the
parser and compiler (to tree-il).  See also the example in the
@file{examples/nyacc/lang/javascript} directory.

@section Running with the Debugger

You can run with debugging on.  In @file{calc1.scm} one can see a
modified version of @code{calc1-eval} which will print out debugging info:
@example
(define (calc1-eval str)
  (with-input-from-string str
    (lambda () (raw-parser (gen-lexer) #:debug #t))))
@end example
@noindent
To make use of this info you probably want to generate an output file
as describe in Section @ref{Human Readable Output}.


@c ==================================
@page @c for proofreading
@node Parsing
@chapter Parsing

Most of the syntax and procecures for generating skelton parsers
exported from the module @code{(nyacc lalr)}.  Other modules include
@table @asis
@item (lalr lex)
This is a module providing procedures for generating lexical analyzers.
@item (lalr util)
This is a module providing utilities used by the other modules.
@end table


@section The Grammar Specification
@anchor{Specification}

The syntax for generating specifications is @code{lalr-spec}.  As
mentioned in the  previous chapter, the syntax generates an
association list, or @dfn{a-list}. 

@deffn {Syntax} lalr-spec grammar => a-list
This routine reads a grammar in a scheme-like syntax and returns an a-list.
The returned a-list is normally used as an input for
@code{make-lalr-machine}.  The syntax is of the form
@example
(lalr-spec (@var{directive} @dots{}) @dots{})
@end example
The order of the directives does not matter, but typically the
@code{grammar} directive occurs last.
@end deffn

The directives are
@table @code
@item notice
bla
@item reserve
This is a list of tokens which do not appear in the grammar but should
be added to the match table. 
@item prec< prec>
these psecific pre
@item expect
This is the expected number of shift-reduce conflicts to occur.
@item start
This specifies the top-level starting non-terminal.
@item grammar
the grammar see below
@end table

Notably the grammar will have rhs arguments decorated with type (e.g.,
@code{(terminal . #\,)}).

Each production rule in the grammar will be of the form
@code{(lhs rhs1 rhs2 ...)} where each element of the RHS is one of
@itemize
@item @code{('terminal . atom)}
@item @code{('non-terminal . symbol)}
@item @code{('action . (ref narg guts)}
@item @code{('proxy . production-rule)}
@end itemize
Currently, the number of arguments for items is computed in the routine
@code{process-grammar}.



We have (experimental) convenience macros:
@example
($? foo bar baz) => ``foo bar baz'' occurs never or once
($* foo bar baz) => ``foo bar baz'' occurs zero or more times
($+ foo bar baz) => ``foo bar baz'' occurs one or more times
@end example
@noindent
However, these have hardcoded actions and are considered to be,
in current form, unattractive for practical use.

Todo: discuss
@itemize
@item
reserved symbols (e.g., @code{$fixed}, @code{$ident}, @code{$empty})
@item
Strings of length one are equivalent to the corresponding character.
@item
@code{(pp-lalr-grammar calc-spec)}
@item
@code{(pp-lalr-machine calc-mach)}
@item
@code{(define calc-mach (compact-mach calc-mach))}
@item
@code{(define calc-mach (hashify-Machine calc-mach))}
@item
The specification for @code{expr} could have been expressed using
@example
  (expr (expr "+" expr ($$ (+ $1 $3))))
  (expr (expr "-" expr ($$ (- $1 $3))))
  (expr (expr "*" expr ($$ (* $1 $3))))
  (expr (expr #\/ expr ($$ (/ $1 $3))))
  (expr ('$fx ($$ (string->number $1))))
@end example
@item
rule-base precedence
@item
multiple precedence statements so that some items can be unordered
@example
(prec< "then" "else")
(prec< "t1" "t2" "t3" "t4" "t5")
=> ((t1 . t2) (t2 . t3) (t3 . t4) (t4 . t5) (then . else))
@end example
@end itemize

@section Other Directives

@example
(expect 1)
@end example

@example
(notice "Copyright (C) 2017 John Doe")
@end example

@example
(reserve "abc" "def")
@end example

@section Recovery from Syntax Errors

The grammar specification allows the user to handle some syntax
errors.  This allows parsing to continue.  The behavior is similar
to parser generators like @emph{yacc} or @emph{bison}.  The following
production rule-list allows the user to trap an error.
@example
(line
  ("\n")
  (exp "\n")
  ($error "\n"))
@end example
@noindent
If the current input token does not match the grammar, then the parser
will skip input tokens until a @code{"\n"} is read.  The default
behavior is to generate an error message: @emph{"syntax error"}.
To provide a user-defined handler just add an action for the rule:
@example
(line
  ("\n")
  (exp "\n")
  ($error "\n" ($$ (format #t "line error\n"))))
@end example
@noindent
Note that if the action is not at the end of the rule then the default
recovery action (@emph{"syntax error"}) will be executed.


@section The Lex Module
@anchor{lex}

The @nyacc @code{lex} module provide routines for constructing
lexical analyzers.  The intension is to provide routines to make
construction easy, not necessarily the most efficient.

@section The Match Table
In some parser generators one declares terminals in the grammar file
and the generator will provide an include file providing the list of
terminals along with the associated ``hash codes''.  In @nyacc the
terminals are detected in the grammar as non-identifiers: strings
(e.g., @code{"for"}), symbols (e.g., @code{'$ident}) or characters
(e.g., @code{#\+}).   The machine generation phase of the parser 
generates a match table which is an a-list of these objects along with
the token code.  These codes are what the lexical analyzer should return.
BLA Bla bla.  So in the end we have
@itemize
@item
The user specifies the grammar with terminals in natural form
(e.g., @code{"for"}).
@item
The parser generator internalizes these to symbols or integers, and generates
an a-list, the match table,  of (natural form, internal form).
@item
The programmer provides the match table to the procedure that builds 
a lexical analyzer generator (e.g., @code{make-lexer-generator}).
@item
The lexical analyzer uses this table to associate strings in the input
with entries in the match table.   In the case of keywords the keys will
appear as strings (e.g., @code{for}), whereas in the case of special items,
processed in the lexical analyzer by readers (e.g., @code{read-num}), the
keys will be symbols (e.g., @code{'$fl}).
@item
The lexical analyzer returns pairs in the form (internal form, natural form)
to the parser.  Note the reflexive behavior of the lexical analyzer.  It
was built with pairs of the form (natural form, internal form) and returns
pairs of the form (internal form, natural form).
@end itemize

Now one item need to be dealt with and that is the token value for the 
default.  It should be @code{-1} or @code{'$default}. WORK ON THIS.


@section Parsing a Sublanguage of a Specification

Say you have a @nyacc specification @code{cspec} for the C language
and you want to generate a machine for parsing C expressions.  You can
go this via 
@example
(define cxspec (restart-spec cspec 'expression))
(define cxmach (make-lalr-machine cxspec))
@end example



@section The Parser-Lex'er Interface

To be documented.

@example
typedef int foo_t;
foo_t x;
@end example

@section Parser Tables

Note that generating a parser requires a machine argument.  It is
possible to export the machine to a pair of files and later regenerate
enough info to create a parser from the tables saved in the machine.

For example, Tables can be generated 
@example
(write-lalr-actions calc1-mach "calc1-act.scm")
(write-lalr-tables calc1-mach "calc1-tab.scm")
@end example

Then, without reference to the original specification or need to
run @code{make-lalr-machine}, you can ...
@example
(include "calc1-tab.scm")
... code for parser ...
(include "calc1-act.scm")
@end example

Check some of the examples in the @nyacc distribution.

@section Hashing and Compacting
@anchor{Hashing and Compacting}

The procedure @code{compact-machine} will compact the parse tables.
That is, if multiple tokens generate the same transition, then these
will be combined into a single @emph{default} transition.
Ordinarily @nyacc will expect symbols to be emitted from the lexical
analyzer.  To use integers instead, use the procedure
@code{hashify-machine}.  One can, of course, use both procedures:
@example
(define calc-mach
  (compact-machine
   (hashify-machine
     (make-lalr-machine calc-spec))))
@end example       
     
@section Exporting Parsers
@nyacc provides routines for exporting @nyacc grammar
specifications to other LALR parser generators.

The Bison exporter uses the following rules:
@itemize
@item
Terminals expressed as strings which look like C identifiers are
converted to symbols of all capitals.  For example @code{"for"} is
converted to @code{FOR}.
@item
Strings which are not like C identifiers and are of length 1 are
converted to characters.  For example, @code{"+"} is converted to @code{'+'}.
@item
Characters are converted to C characters.
For example, @code{#\!} is converted to @code{'!'}.
@item
Multi-character strings that do not look like identifiers are
converted to symbols of the form @code{ChSeq_@i{i}_@i{j}_@i{k}} where
@i{i}, @i{j} and @i{k} are decimal representations of the character
code.  For example @code{"+="} is converted to @code{ChSeq_43_61}.
@item
Terminals expressed as symbols are converted as-is but @code{$} and @code{-}
are replaced with @code{_}.
@end itemize

TODO: Export to Bison xml format.

The Guile exporter uses the following rules: TBD.

@section Debugging


@subsection Human Readable Output
@anchor{Human Readable Output}

You can generate text files which provide human-readable forms of
the grammar specification and resulting automaton, akin to what you
might get with bison using the `-r' flag.
@example
(with-output-to-file "calc1.out"
  (lambda ()
    (pp-lalr-grammar calc1-mach)
    (pp-lalr-machine calc1-mach)))
@end example

The above code will generate something that looks like 
@example
0 $start => stmt-list
1 stmt-list =>
2 stmt-list => stmt-list $P1 stmt
3 $P1 =>
4 stmt => "\n"
g5 stmt => expr "\n"
6 expr => expr "+" expr
7 expr => expr "-" expr
8 expr => expr "*" expr
9 expr => expr "/" expr
10 expr => "*" '$error
11 expr => '$fixed
12 expr => '$float
13 expr => "(" expr ")"

0:	$start => . stmt-list
	stmt-list => .
	stmt-list => . stmt-list $P1 stmt
		stmt-list => shift 1
		'$end => reduce 1
		"(" => reduce 1
		'$float => reduce 1
		'$fixed => reduce 1
		"*" => reduce 1
		"\n" => reduce 1

1:	stmt-list => stmt-list . $P1 stmt
	$P1 => .
	$start => stmt-list .
		$P1 => shift 2
		"(" => reduce 3
		'$float => reduce 3
		'$fixed => reduce 3
		"*" => reduce 3
		"\n" => reduce 3
		'$end => accept 0

...

21:	expr => expr . "/" expr
	expr => expr . "*" expr
	expr => expr . "-" expr
	expr => expr . "+" expr
	expr => expr "+" expr .
		"+" => reduce 6
		"-" => reduce 6
		"*" => shift 13
		"/" => shift 14
		"\n" => reduce 6
		")" => reduce 6
		["+" => shift 11] REMOVED by associativity
		["-" => shift 12] REMOVED by associativity
		["*" => reduce 6] REMOVED by precedence
		["/" => reduce 6] REMOVED by precedence

@end example

@c ==================================
@node Translation
@chapter Translation

@c attributed grammars

Under @samp{examples/nyacc} are utilities for translating languages
along with some samples.  The approach that is used here is to parse
languages into a SXML based parse tree and use the SXML modules in
Guile to translate.  We have built a javascript to tree-il translater
which means that one can execute javascript at the Guile command line:
@example
scheme@@(guile-user)> ,L javascript
need to complete
@end example

@section Tagged-Lists
In actions in @nyacc can use our tagged-lists to build the trees.
For example, building a statement list for a program might go like this:
@example
  (program
   (stmt-list ($$ `(program ,(tl->list $1))))
   (...))
  (stmt-list
   (stmt ($$ (make-tl 'stmt-list $1)))
   (stmt-list stmt ($$ (tl-append $1 $2))))
@end example

@section Working with SXML Based Parse Trees
To work with the trees described in the last section use
@example
(sx-ref tree 1)
(sx-attr tree)
(sx-attr-ref tree 'item)
(sx-tail tree 2)
@end example

@section Example: Converting Javascript to Tree-IL

This illustrates translation with @code{foldts*-values} and
@code{sxml-match}. 


@node Administrative
@chapter Administrative Notes

@section Installation
Installation instructions are included in the top-level file
@file{README} of the source distribution.

@section Reporting Bugs
Bug reporting will be dealt with once the package is place on a 
publically accessible source repository.

@section The Free Documentation License
The Free Documentation License is included in the Guile Reference
Manual.  It is included with the @nyacc source as the file 
COPYING.DOC.

@node TODOs
@chapter TODOs, Notes, Ideas
Todo/Notes/Ideas:
@table @asis
@item 16
add error handling (lalr-spec will now return #f for fatal error)
@item 3
support other target languages:
(write-lalr-parser pgen "foo.py" #:lang 'python)
@item 6
export functions to allow user to control the flow
i.e., something like: (parse-1 state) => state
@item 9
macros - gotta be scheme macros but how to deal with other stuff
(macro ($? val ...) () (val ...))
(macro ($* val ...) () (_ val ...))
(macro ($+ val ...) (val ...) (_ val ...))
idea: use $0 for LHS
@item 10
support semantic forms: (1) attribute grammars, (2) translational
semantics, (3) operational semantics, (4) denotational semantics
@item 13
add ($abort) and ($accept)
@item 18
keep resolved shift/reduce conflicts for pp-lalr-machine
(now have rat-v -- removed action table -- in mach, need to add to pp)
@item 19
add a location stack to the parser/lexer
@item 22
write parser file generator (working prototype)
@item 25
think
@item 26
Fix lexical analyzer to return tval, sval pairs using @code{cons-source} 
instead of @code{cons}.  This will then allow support of location info.
@end table


@node References
@chapter References

@table @asis
@item [DB]
Aho, A.V., Sethi, R., and Ullman, J. D., ``Compilers: Principles,
Techniques and Tools,'' Addison-Wesley, 1985 (aka the Dragon Book)
@item [DP]
DeRemer, F., and Pennello, T., ``Efficient Computation of LALR(1)
Look-Ahead Sets.'' ACM Trans. Prog. Lang. and Systems, Vol. 4, No. 4.,
Oct. 1982, pp. 615-649.
@item [RPC]
R. P. Corbett, ``Static Semantics and Compiler Error Recovery,''
Ph.D. Thesis, UC Berkeley, 1985.
@end table


@c Old Stuff, to be removed
@ifset skip
In the DB an item is used to refer to the position in a production and
the position with associated lookaheads that give the possible set of
terminals that can generate a reduction when the item is a candidate for
reduction (i.e., the dot appears at the end of the p-rule). In this
report we use the terms @emph{item} for the position and @emph{la-item}
for the position and associated lookaheads.  An example of an la-item
is as follows:
@example
A => B . C D, e/f/g
@end example
@noindent
where @code{e/f/g} is a tuple of terminals which can appear at
@example
A => B C D ., e/f/g
@end example
@noindent
We denote an item in the code using a cons with the index of the p-rule
in the car and the index of the right-hand side symbol after the dot
in the cdr.  The end of p-rule will be denoted with index @code{-1}.
So if the rule @samp{A=>BCD} appears as index 7, then the above would
be item @code{(7 . 1)} or la-item @code{((7 . 1) e f g)}.
@end ifset

@bye
@c --- last line
