\input texinfo.tex
@setfilename nyacc-hg.info
@settitle NYACC Hacker's Guide

@copying
Copyright (C) 2015 -- Matthew R. Wette.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included with the distribution as COPYING.DOC.
@end copying

@clear skip

@titlepage
@title NYACC Hacker's Guide
@author Matt Wette
@end titlepage

@ifnottex
@node Top, Habits, (dir), (dir)
@top Habits
@end ifnottex

@menu
* Habits::
@end menu

@node Habits
@chapter Habits

This chapter explains some of my programming habits.  I hope it helps
to relieve the head-scratching.

@section Modifying Compound Data Types

In general I do not use @code{set-car!} or @code{set-cdr!}.  I do use
@code{vector-set!} and @code{hashq-set!}

@section A-Lists Versus Hash Tables

In general I prefer a-lists over hash tables in Scheme because a-lists
are Scheme-like.  To update an entry in an alist I will just paste
the new entry on the front.  For example,
@example
(let ((al '((foo . 1) (bar . 2) (baz . 3))))
  ...
  (acons 'bar 99 al))
@end example
@noindent
If the values of the a-list are lists and I want to add something to the
list I just use cons, as in the following:
@example
(let ((al '((foo 1) (bar 2) (baz 3))))
  ...
  (acons 'bar (cons 99 (assq-ref al 'bar)) al)
@end example
@noindent
This modification costs just two cons cells.

@section Iteration
For iteration I usually use @emph{named-let} and often in concert with
 @emph{cond}.  The order of variable declarations in my named-let are
the result variable, followed
by iteration variables in order of slowest to fastest modification.  
In the cond I usually evaluate in the order fastest to slowest modification.
Consider the following C code fragment:
@example
res = 0;
for (i = 0; i < ni, i++) @{
  res += 100*i;
  for (j = 0; j < nj, j++) @{
    res += 10*j;
    for (k = 0; k < nk, k++) @{
      res += k;
    @}
  @}
@}
@end example
@noindent
In Scheme, I would express this as
@example
(let iter ((res 0) (i 0) (j 0) (k 0))
  (cond
   ((< k nk) (iter (+ res k) i j (1+ k)))
   ((< j nj) (iter (+ res (* 10 j)) i (1+ j) 0))
   ((< i ni) (iter (+ res (* 100 i)) (1+ i) 0 0))
   (else res)))
@end example
@c @noindent

@section The Free Documentation License
The Free Documentation License is included in the Guile Reference
Manual.  It is included with the @sc{nyacc} source as COPYING.DOC.

@bye
@c --- last line
