nyacc/lang/c99/

Copyright (C) 2015,2016,2019,2020 Matthew R. Wette

Copying and distribution of this file, with or without modification,
are permitted in any medium without royalty provided the copyright
notice and this notice are preserved.  This file is offered as-is,
without any warranty.

manifest:

cpp.scm		C preprocessor using tables
		includes: cpp-act.scm,cpp-tab.scm
cppmach.scm	CPP expression grammer, machine and act/tab file generation

mach.scm	C grammer, machine and act/tab file generation
		depends: cpp.scm

parser.scm	C file parser, C expression parser
		includes: c99-act.scm, c99-tab.scm, c99x-act.scm, c99-tab.scm,
		          body.scm
		depends: cpp.scm

body.scm	included in parser.scm

cxmach.scm	parse constant expressions

cxeval.scm	evaluate constant expressions

pprint.scm	C pretty printer, from SXML output of above parsers

util.scm	utilities merge, remove trees from included files

munge.scm	utilities to process information in trees

munge-base.scm	workhorse for munge, typeref expansion, udecl->mdecl

ffi-help.scm	generate FFI api code from C headers

mach.d/
  cpp-act.scm	cpp expression parser actions, generated from cppmach.scm
  cpp-tab.scm	cpp expression parser tables, generated from cppmach.scm

  c99-act.scm	parser actions, generated from mach.scm
  c99-tab.scm	parser tables, generated from mach.scm

  c99x-act.scm	expression parser actions, generated from mach.scm
  c99x-tab.scm	expression parser tables, generated from mach.scm

  c99cx-act.scm	constant expression parser actions, generated from cxmach.scm
  c99cx-tab.scm	constant expression parser tables, generated from cxmach.scm

NOTES:

The standard says:
 "For two qualified types to be compatible, both shall have the identically
  qualified version of a compatible type; the order of type qualifiers within
  a list of specifiers or qualifiers does not affect the specified type."

=== Thinking about bytestructures: =============================================

I am reworking bytestructures.  I'd like to preserve what Taylan has done
but I want more crisp definition of what gets returned.  bs-ref '* gives int.
I need to add desc-equal? (see issue #2 in scm-bs repo).  I also want to add
support for multiple architectures.  There will be a parameter *arch* used.

* manifest
  cdata-ref => cdata always
  cdata-set! many => undefined
  cdata-val => think about this
  cdata-type
  cdata-unwrap val => (values bv ix ct)
  ctype-type type => struct union ... f64 f32 i32 u32 ...
  ctype-eqv? a b => #t|#f
  ctype-size => int | #f (#f if size is dynamic, i.e., pointer/array deref)
  ctype-alignment => int

* extras?
  ctype->gtype (guile type)
    + bytevector maps, plus array => array, struct => record, but not union
      cstring => string

* use cases:
  1 copy string to/from buffer
  2 make struct w/ values (macro or lambda?)

@@@ HERE @@@
* layouts:
  <cdata>: bv ix ct (bytevector offset ctype)
  <ctype>: ?name ?setter ?getter ?unwrapper

(cdata-ref obj . sels) ;; sels are selectors

(ctype-sel ct ix sel) -> (values ct ix)
(ctype-sel* ct ix . sels) -> 


* Currently bytestructure-ref is a macro, this is problematic for other
  languages implemented in guile
* use (descriptor-index <desc> sym sym ...) => offset descriptor
   or (descriptor-index <desc> sym sym ...) => offset getter setter
* and what does getter do? copy or share? 
  + (bs-ref obj index) => /shared if object, or val if xxx
  + (bs-val obj index) -> value
  + (bs-set! obj index value) :
      (bs-set! obj ix0 ix1 ... val) == (bs-set! (bs-ref obj ix0) ix1 ... value)
  + but what about pointer? be the same and require de-ref via '*,
    : can't automatically deref because '* => obj or '* vector of obj
  + cstrings? : thinking not mutable
  
does bs:struct currently keep as meta a list of (name desc)

type => ($ <type> 'int bits signed?) | ($ <type> 'flt bits #t)
        | ??? ($ <type> 'ptr bits #f)

($ <desc> size align setter wrapper setter meta)

(unwrap bs) => (bv ix desc)

bs-getter:
    (bv, os, desc, ix) => (bv, os, desc)
bs-setter:
    (bv, os, desc) ==[copy]==> 
    value

bs-val: (bv, os, desc) -> prim | (bv, os, desc)

cdt:struct vs bs:struct

fh-ref -> bs
fh-set! bs
fh-val -> copy

(with-arch arch
  (bs:struct xxx))

fh-type: desc bv ix

need: type-equal? foo-desc (bs:struct 'abc 'def)

function cast
type cast 